<!--
  Archive Metadata
  URL: https://www.thewrap.com/juliet-broadway-review-max-martin-jukebox-musical/
  Outlet: TheWrap
  Critic: Robert Hofler
  Show: and-juliet-2022
  FetchMethod: scrapingbee
  Archived: 2026-02-02T08:26:52.436Z
-->
<!DOCTYPE html><html lang="en-US"><head><script type="text/javascript" async="" src="https://cdn.id5-sync.com/api/1.0/id5PrebidModule.js"></script>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="robots" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1">
	<style>img:is([sizes="auto" i], [sizes^="auto," i]) { contain-intrinsic-size: 3000px 1500px }</style>
	
	<!-- This site is optimized with the Yoast SEO Premium plugin v25.9 (Yoast SEO v25.9) - https://yoast.com/wordpress/plugins/seo/ -->
	<link rel="canonical" href="https://www.thewrap.com/juliet-broadway-review-max-martin-jukebox-musical/">
	<meta property="og:locale" content="en_US">
	<meta property="og:type" content="article">
	<meta property="og:title" content="'&amp; Juliet' Broadway Review: Max Martin Jukebox Musical Retools the Bard to a Pop Beat">
	<meta property="og:description" content="David West Read book reimagines Shakespeare as a sexist hack">
	<meta property="og:url" content="https://www.thewrap.com/juliet-broadway-review-max-martin-jukebox-musical/">
	<meta property="og:site_name" content="TheWrap">
	<meta property="article:published_time" content="2022-11-18T03:00:00+00:00">
	<meta property="og:image" content="https://i0.wp.com/www.thewrap.com/wp-content/uploads/2022/11/juliet.jpg?fit=1200%2C675&amp;quality=89&amp;ssl=1">
	<meta property="og:image:width" content="1200">
	<meta property="og:image:height" content="675">
	<meta property="og:image:type" content="image/jpeg">
	<meta name="author" content="By Robert Hofler">
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:label1" content="Written by">
	<meta name="twitter:data1" content="By Robert Hofler">
	<meta name="twitter:label2" content="Est. reading time">
	<meta name="twitter:data2" content="4 minutes">
	<script async="" type="text/javascript" src="//ads.pubmatic.com/AdServer/js/pwt/156500/13793/pwt.js"></script><script async="" src="https://www.googletagmanager.com/gtm.js?id=GTM-WM35TFR"></script><script type="application/ld+json" class="yoast-schema-graph">{"@context":"https://schema.org","@graph":[{"@type":"Article","@id":"https://www.thewrap.com/juliet-broadway-review-max-martin-jukebox-musical/#article","isPartOf":{"@id":"https://www.thewrap.com/juliet-broadway-review-max-martin-jukebox-musical/"},"author":[{"@id":"https://www.thewrap.com/#/schema/person/c6b1e3ef63e5d9fda130d8283f111434"}],"headline":"&#8216;&#038; Juliet&#8217; Broadway Review: Max Martin Jukebox Musical Retools the Bard to a Pop Beat","datePublished":"2022-11-18T03:00:00+00:00","mainEntityOfPage":{"@id":"https://www.thewrap.com/juliet-broadway-review-max-martin-jukebox-musical/"},"wordCount":740,"publisher":{"@id":"https://www.thewrap.com/#organization"},"image":{"@id":"https://www.thewrap.com/juliet-broadway-review-max-martin-jukebox-musical/#primaryimage"},"thumbnailUrl":"https://i0.wp.com/www.thewrap.com/wp-content/uploads/2022/11/juliet.jpg?fit=1200%2C675&quality=89&ssl=1","keywords":["Broadway","reviews"],"articleSection":["Theater"],"inLanguage":"en-US"},{"@type":"WebPage","@id":"https://www.thewrap.com/juliet-broadway-review-max-martin-jukebox-musical/","url":"https://www.thewrap.com/juliet-broadway-review-max-martin-jukebox-musical/","name":"'& Juliet' Broadway Review: Max Martin Jukebox Musical Retools the Bard to a Pop Beat - TheWrap","isPartOf":{"@id":"https://www.thewrap.com/#website"},"primaryImageOfPage":{"@id":"https://www.thewrap.com/juliet-broadway-review-max-martin-jukebox-musical/#primaryimage"},"image":{"@id":"https://www.thewrap.com/juliet-broadway-review-max-martin-jukebox-musical/#primaryimage"},"thumbnailUrl":"https://i0.wp.com/www.thewrap.com/wp-content/uploads/2022/11/juliet.jpg?fit=1200%2C675&quality=89&ssl=1","datePublished":"2022-11-18T03:00:00+00:00","breadcrumb":{"@id":"https://www.thewrap.com/juliet-broadway-review-max-martin-jukebox-musical/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://www.thewrap.com/juliet-broadway-review-max-martin-jukebox-musical/"]}]},{"@type":"ImageObject","inLanguage":"en-US","@id":"https://www.thewrap.com/juliet-broadway-review-max-martin-jukebox-musical/#primaryimage","url":"https://i0.wp.com/www.thewrap.com/wp-content/uploads/2022/11/juliet.jpg?fit=1200%2C675&quality=89&ssl=1","contentUrl":"https://i0.wp.com/www.thewrap.com/wp-content/uploads/2022/11/juliet.jpg?fit=1200%2C675&quality=89&ssl=1","width":1200,"height":675,"caption":"Lorna Courtney in \"& Juliet\" (Photo: Matthew Murphy)"},{"@type":"BreadcrumbList","@id":"https://www.thewrap.com/juliet-broadway-review-max-martin-jukebox-musical/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https://www.thewrap.com/"},{"@type":"ListItem","position":2,"name":"Creative Content","item":"https://www.thewrap.com/creative-content/"},{"@type":"ListItem","position":3,"name":"Theater","item":"https://www.thewrap.com/creative-content/theater/"},{"@type":"ListItem","position":4,"name":"&#8216;&#038; Juliet&#8217; Broadway Review: Max Martin Jukebox Musical Retools the Bard to a Pop Beat"}]},{"@type":"WebSite","@id":"https://www.thewrap.com/#website","url":"https://www.thewrap.com/","name":"TheWrap","description":"Your trusted source for breaking entertainment news, film reviews, TV updates and Hollywood insights. Stay informed with the latest entertainment headlines and analysis from TheWrap.","publisher":{"@id":"https://www.thewrap.com/#organization"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https://www.thewrap.com/?s={search_term_string}"},"query-input":{"@type":"PropertyValueSpecification","valueRequired":true,"valueName":"search_term_string"}}],"inLanguage":"en-US"},{"@type":"Organization","@id":"https://www.thewrap.com/#organization","name":"TheWrap","url":"https://www.thewrap.com/","logo":{"@type":"ImageObject","inLanguage":"en-US","@id":"https://www.thewrap.com/#/schema/logo/image/","url":"https://i0.wp.com/www.thewrap.com/wp-content/uploads/2022/07/pro-content.jpg?fit=180%2C22&quality=89&ssl=1","contentUrl":"https://i0.wp.com/www.thewrap.com/wp-content/uploads/2022/07/pro-content.jpg?fit=180%2C22&quality=89&ssl=1","width":180,"height":22,"caption":"TheWrap"},"image":{"@id":"https://www.thewrap.com/#/schema/logo/image/"}},{"@type":"Person","@id":"https://www.thewrap.com/#/schema/person/c6b1e3ef63e5d9fda130d8283f111434","name":"By Robert Hofler"},{"@type":"Person","@id":"https://www.thewrap.com/#/schema/person/c6b1e3ef63e5d9fda130d8283f111434","name":"By Robert Hofler"}]}</script>
	<!-- / Yoast SEO Premium plugin. -->


<title>'&amp; Juliet' Broadway Review: Max Martin Jukebox Musical Retools the Bard to a Pop Beat - TheWrap</title>
<link rel="dns-prefetch" href="//www.google.com">
<link rel="dns-prefetch" href="//www.thewrap.com">
<link rel="dns-prefetch" href="//htlbid.com">
<link rel="dns-prefetch" href="//cdn.sophi.io">
<link rel="dns-prefetch" href="//s.ntv.io">
<link rel="dns-prefetch" href="//assets.zephr.com">
<link rel="dns-prefetch" href="//use.typekit.net">
<link rel="preconnect" href="//i0.wp.com">
<link href="https://use.typekit.net" rel="preconnect">
<link rel="alternate" type="application/rss+xml" title="TheWrap » Feed" href="https://www.thewrap.com/feed/">
<link rel="alternate" type="application/rss+xml" title="TheWrap » Comments Feed" href="https://www.thewrap.com/comments/feed/">
<link rel="preload" href="https://use.typekit.net/icl0tmu.css?ver=1.0.0" class="wp-asset-manager the-wrap-typekit" as="style" media="all" type="text/css"><script>
window._wpemojiSettings = {"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/15.1.0\/72x72\/","ext":".png","svgUrl":"https:\/\/s.w.org\/images\/core\/emoji\/15.1.0\/svg\/","svgExt":".svg","source":{"concatemoji":"https:\/\/www.thewrap.com\/wp-includes\/js\/wp-emoji-release.min.js?ver=6.8"}};
/*! This file is auto-generated */
!function(i,n){var o,s,e;function c(e){try{var t={supportTests:e,timestamp:(new Date).valueOf()};sessionStorage.setItem(o,JSON.stringify(t))}catch(e){}}function p(e,t,n){e.clearRect(0,0,e.canvas.width,e.canvas.height),e.fillText(t,0,0);var t=new Uint32Array(e.getImageData(0,0,e.canvas.width,e.canvas.height).data),r=(e.clearRect(0,0,e.canvas.width,e.canvas.height),e.fillText(n,0,0),new Uint32Array(e.getImageData(0,0,e.canvas.width,e.canvas.height).data));return t.every(function(e,t){return e===r[t]})}function u(e,t,n){switch(t){case"flag":return n(e,"\ud83c\udff3\ufe0f\u200d\u26a7\ufe0f","\ud83c\udff3\ufe0f\u200b\u26a7\ufe0f")?!1:!n(e,"\ud83c\uddfa\ud83c\uddf3","\ud83c\uddfa\u200b\ud83c\uddf3")&&!n(e,"\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc65\udb40\udc6e\udb40\udc67\udb40\udc7f","\ud83c\udff4\u200b\udb40\udc67\u200b\udb40\udc62\u200b\udb40\udc65\u200b\udb40\udc6e\u200b\udb40\udc67\u200b\udb40\udc7f");case"emoji":return!n(e,"\ud83d\udc26\u200d\ud83d\udd25","\ud83d\udc26\u200b\ud83d\udd25")}return!1}function f(e,t,n){var r="undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?new OffscreenCanvas(300,150):i.createElement("canvas"),a=r.getContext("2d",{willReadFrequently:!0}),o=(a.textBaseline="top",a.font="600 32px Arial",{});return e.forEach(function(e){o[e]=t(a,e,n)}),o}function t(e){var t=i.createElement("script");t.src=e,t.defer=!0,i.head.appendChild(t)}"undefined"!=typeof Promise&&(o="wpEmojiSettingsSupports",s=["flag","emoji"],n.supports={everything:!0,everythingExceptFlag:!0},e=new Promise(function(e){i.addEventListener("DOMContentLoaded",e,{once:!0})}),new Promise(function(t){var n=function(){try{var e=JSON.parse(sessionStorage.getItem(o));if("object"==typeof e&&"number"==typeof e.timestamp&&(new Date).valueOf()<e.timestamp+604800&&"object"==typeof e.supportTests)return e.supportTests}catch(e){}return null}();if(!n){if("undefined"!=typeof Worker&&"undefined"!=typeof OffscreenCanvas&&"undefined"!=typeof URL&&URL.createObjectURL&&"undefined"!=typeof Blob)try{var e="postMessage("+f.toString()+"("+[JSON.stringify(s),u.toString(),p.toString()].join(",")+"));",r=new Blob([e],{type:"text/javascript"}),a=new Worker(URL.createObjectURL(r),{name:"wpTestEmojiSupports"});return void(a.onmessage=function(e){c(n=e.data),a.terminate(),t(n)})}catch(e){}c(n=f(s,u,p))}t(n)}).then(function(e){for(var t in e)n.supports[t]=e[t],n.supports.everything=n.supports.everything&&n.supports[t],"flag"!==t&&(n.supports.everythingExceptFlag=n.supports.everythingExceptFlag&&n.supports[t]);n.supports.everythingExceptFlag=n.supports.everythingExceptFlag&&!n.supports.flag,n.DOMReady=!1,n.readyCallback=function(){n.DOMReady=!0}}).then(function(){return e}).then(function(){var e;n.supports.everything||(n.readyCallback(),(e=n.source||{}).concatemoji?t(e.concatemoji):e.wpemoji&&e.twemoji&&(t(e.twemoji),t(e.wpemoji)))}))}((window,document),window._wpemojiSettings);
</script>
<style id="the-wrap-ad-style-inline-css">
.entry-content>.wp-block-the-wrap-ad{margin-block:2rem}

</style>
<style id="the-wrap-ad-styles-inline-css">
.wp-block-the-wrap-ad [data-google-query-id]{margin-block:2rem}.wp-block-the-wrap-ad [data-google-query-id] [style*="display: none"]{margin-block:unset}.feature-has-ad-sidebar .wp-block-the-wrap-ad [data-google-query-id]{margin-block:unset}.wp-block-the-wrap-ad [data-sticky] [data-google-query-id]{margin-block:unset}.wp-block-the-wrap-ad.yad-skin-ad-left [data-google-query-id],.wp-block-the-wrap-ad.yad-skin-ad-right [data-google-query-id]{margin-block:unset}@media(min-width: 1200px){.wp-block-the-wrap-ad.yad-skin-ad-top{min-height:9.625rem}}@media(max-width: 770px){.wp-block-the-wrap-ad.yad-mob-banner-ad-b{margin-block:1rem;min-height:3.125rem}.wp-block-the-wrap-ad.yad-mob-banner-ad-b [data-google-query-id]{margin-block:unset}}@media(max-width: 770px){.wp-block-the-wrap-ad[class^=yad-mob-box-ad]{min-height:3.125rem}}@media(min-width: 771px){.wp-block-the-wrap-ad[class^=yad-dsk-box-ad]{min-height:15.625rem}}.sidebar-area>.wp-block-the-wrap-ad{margin-block:unset}@media(min-width: 64rem){.sidebar-area>.wp-block-the-wrap-ad:first-child [data-google-query-id]{margin-block-start:unset}}.wp-block-the-wrap-ad.yad-wrapstyle-dsk-banner-ad-b,.wp-block-the-wrap-ad.yad-wrapstyle-dsk-banner-ad-c,.wp-block-the-wrap-ad.yad-wrapstyle-dsk-banner-ad-d,.wp-block-the-wrap-ad.yad-wrapstyle-dsk-banner-ad-e{max-width:none}.sidebar-area .wp-block-the-wrap-ad:last-child{position:sticky;top:calc(var(--adminbar-height) + 2rem)}.full-width-template .wp-block-the-wrap-ad--inline,.page-template-template-magazine .container--entry-content>.wp-block-the-wrap-ad--inline{left:50%;margin-left:-50vw !important;margin-right:-50vw !important;max-width:none;position:relative;right:50%;width:100vw}

/*# sourceMappingURL=ad.min.css.map*/
</style>
<style id="yoast-seo-breadcrumbs-styles-inline-css">
.entry-header .yoast-breadcrumbs,.wp-block-the-wrap-article-header-full .yoast-breadcrumbs{font-size:.875rem;font-weight:400;line-height:1.2142857143;color:#5a6875;font-family:var(--wp--preset--font-family--libre-franklin);margin-block-end:.875rem}.entry-header .yoast-breadcrumbs a,.wp-block-the-wrap-article-header-full .yoast-breadcrumbs a{margin:0 .375rem;text-decoration:none}.entry-header .yoast-breadcrumbs a:hover,.entry-header .yoast-breadcrumbs a:focus,.wp-block-the-wrap-article-header-full .yoast-breadcrumbs a:hover,.wp-block-the-wrap-article-header-full .yoast-breadcrumbs a:focus{text-decoration:underline}

/*# sourceMappingURL=breadcrumbs.min.css.map*/
</style>
<style id="wp-block-post-title-inline-css">
.wp-block-post-title{box-sizing:border-box;word-break:break-word}.wp-block-post-title :where(a){display:inline-block;font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;text-decoration:inherit}
</style>
<style id="core-post-title-styles-inline-css">
h1.wp-block-post-title{--heading-font-family: var(--wp--preset--font-family--ivy-display);--heading-font-weight: 700;font-family:var(--heading-font-family, var(--wp--preset--font-family--ivy-text));font-weight:var(--heading-font-weight, 400);font-size:clamp(2rem,5vw,3rem);letter-spacing:-0.5px;line-height:1.15}.entry-header h1.wp-block-post-title{margin-bottom:.5rem}@media(min-width: 64rem){.entry-header h1.wp-block-post-title{margin-bottom:1rem}}.container>h1.wp-block-post-title{margin-inline:auto}.container--content>h1.wp-block-post-title{max-width:var(--content-max)}.wp-block-post-title:not(h1){font-size:1.125rem;font-weight:600;line-height:1.3333333333}@media(min-width: 64rem){.wp-block-post-title:not(h1){font-size:1.3125rem;font-weight:600;line-height:1.2380952381}.ad-skin-1000-active .wp-block-post-title:not(h1){font-size:1.125rem;font-weight:600;line-height:1.3333333333}}.wp-block-post-title:not(h1) a{text-decoration:none;color:inherit}.wp-block-post-title:not(h1) a:hover,.wp-block-post-title:not(h1) a:focus{text-decoration:underline}.wp-block-post-title--profile-header{font-size:2rem;font-weight:700;line-height:1.125;font-family:var(--wp--preset--font-family--ivy-display);letter-spacing:-0.5px}@media(min-width: 48rem){.wp-block-post-title--profile-header{font-size:3rem;font-weight:700;line-height:1.0833333333;font-family:var(--wp--preset--font-family--ivy-display)}}

/*# sourceMappingURL=post-title.min.css.map*/
</style>
<style id="the-wrap-subhed-style-inline-css">


</style>
<style id="the-wrap-subhed-styles-inline-css">
div.wp-block-the-wrap-subhed,p.wp-block-the-wrap-subhed{font-size:1.25rem;line-height:1.3;font-family:var(--wp--preset--font-family--ivy-text);font-weight:100;letter-spacing:-0.5px}@media(min-width: 64rem){div.wp-block-the-wrap-subhed,p.wp-block-the-wrap-subhed{font-size:1.5rem;line-height:1.25}}

/*# sourceMappingURL=subhed.min.css.map*/
</style>
<style id="wp-block-post-author-inline-css">
.wp-block-post-author{box-sizing:border-box;display:flex;flex-wrap:wrap}.wp-block-post-author__byline{font-size:.5em;margin-bottom:0;margin-top:0;width:100%}.wp-block-post-author__avatar{margin-right:1em}.wp-block-post-author__bio{font-size:.7em;margin-bottom:.7em}.wp-block-post-author__content{flex-basis:0;flex-grow:1}.wp-block-post-author__name{margin:0}
</style>
<link rel="stylesheet" id="core-post-author-styles-css" href="https://www.thewrap.com/wp-content/themes/the-wrap/client/build/css/blocks/core/post-author.min.css?ver=cbeb0300c7e0bacf5961" media="all">
<style id="wp-block-post-date-inline-css">
.wp-block-post-date{box-sizing:border-box}
</style>
<style id="core-post-date-styles-inline-css">
.wp-block-post-date{font-size:.75rem;line-height:1.25;font-family:var(--wp--preset--font-family--libre-franklin);letter-spacing:-0.13px}.wp-block-post:first-child .post-item--top-feature .wp-block-post-date{line-height:1.875rem}.wp-block-post-date--latest-news{color:#5a6875;font-weight:600}.wp-block-post-date--entry-header{font-size:.875rem;line-height:1.8571428571;color:#5a6875}@media(min-width: 48rem){.wp-block-post-date--entry-header{color:#20262f}}

/*# sourceMappingURL=post-date.min.css.map*/
</style>
<style id="the-wrap-social-link-style-inline-css">
.wp-block-the-wrap-social-link svg{max-width:30px}

</style>
<style id="wp-block-group-inline-css">
.wp-block-group{box-sizing:border-box}:where(.wp-block-group.wp-block-group-is-layout-constrained){position:relative}
</style>
<style id="core-group-styles-inline-css">
.wp-block-group{gap:var(--block-vertical-rhythm)}.wp-block-group>*+*{margin-block:var(--block-vertical-rhythm, 1.25rem)}.wp-block-group>*+*:last-child{margin-block-end:unset}.wp-block-group>*:last-child{margin-bottom:0}.wrapstyle-video{--heading-font-family: var(--wp--preset--font-family--ivy-display);font-family:var(--wp--preset--font-family--libre-franklin);max-width:var(--site-max);padding:4.5rem 0}@media(min-width(md)){.wrapstyle-video{padding:4.5rem 1.25rem}}.wrapstyle-video.alignwide{max-width:var(--site-max)}.wrapstyle-video .wrapstyle-video__heading{font-size:5.375rem;line-height:1;margin-bottom:2.5rem}.wrapstyle-video .wrapstyle-video__content{padding:var(--block-vertical-rhythm) 0}.wrapstyle-video .wp-block-columns .wp-block-column.wrapstyle-video__embed{flex-basis:55.085%}.wrapstyle-video .wp-block-columns .wp-block-column.wrapstyle-video__content{flex-basis:44.915%}.wrapstyle-video .wrapstyle-video__eyebrow{text-decoration:none;font-size:.75rem;line-height:1.25;color:#c50000;text-transform:uppercase}.wrapstyle-video .wrapstyle-video__title{font-size:3rem;line-height:1.0833333333}.wrapstyle-video .wrapstyle-video__description{font-size:1.25rem;font-weight:100}.wrapstyle-video .wrapstyle-video__link{font-size:1.0625rem;line-height:1.4117647059;color:inherit;-webkit-text-decoration-color:#c50000;text-decoration-color:#c50000;text-underline-offset:.375rem}.wrapstyle-video .wrapstyle-video__link:hover,.wrapstyle-video .wrapstyle-video__link:focus{-webkit-text-decoration-color:#c50000;text-decoration-color:#c50000}

/*# sourceMappingURL=group.min.css.map*/
</style>
<style id="wp-block-post-featured-image-inline-css">
.wp-block-post-featured-image{margin-left:0;margin-right:0}.wp-block-post-featured-image a{display:block;height:100%}.wp-block-post-featured-image :where(img){box-sizing:border-box;height:auto;max-width:100%;vertical-align:bottom;width:100%}.wp-block-post-featured-image.alignfull img,.wp-block-post-featured-image.alignwide img{width:100%}.wp-block-post-featured-image .wp-block-post-featured-image__overlay.has-background-dim{background-color:#000;inset:0;position:absolute}.wp-block-post-featured-image{position:relative}.wp-block-post-featured-image .wp-block-post-featured-image__overlay.has-background-gradient{background-color:initial}.wp-block-post-featured-image .wp-block-post-featured-image__overlay.has-background-dim-0{opacity:0}.wp-block-post-featured-image .wp-block-post-featured-image__overlay.has-background-dim-10{opacity:.1}.wp-block-post-featured-image .wp-block-post-featured-image__overlay.has-background-dim-20{opacity:.2}.wp-block-post-featured-image .wp-block-post-featured-image__overlay.has-background-dim-30{opacity:.3}.wp-block-post-featured-image .wp-block-post-featured-image__overlay.has-background-dim-40{opacity:.4}.wp-block-post-featured-image .wp-block-post-featured-image__overlay.has-background-dim-50{opacity:.5}.wp-block-post-featured-image .wp-block-post-featured-image__overlay.has-background-dim-60{opacity:.6}.wp-block-post-featured-image .wp-block-post-featured-image__overlay.has-background-dim-70{opacity:.7}.wp-block-post-featured-image .wp-block-post-featured-image__overlay.has-background-dim-80{opacity:.8}.wp-block-post-featured-image .wp-block-post-featured-image__overlay.has-background-dim-90{opacity:.9}.wp-block-post-featured-image .wp-block-post-featured-image__overlay.has-background-dim-100{opacity:1}.wp-block-post-featured-image:where(.alignleft,.alignright){width:100%}
</style>
<style id="core-post-featured-image-styles-inline-css">
.wp-block-post-featured-image.is-style-rounded img{border:2px solid #f8f9fa;border-radius:9999px;box-shadow:0 3.2px 3.2px -1.6px rgba(24,39,75,.08),0 1.6px 2.4px -1.6px rgba(24,39,75,.12)}.wp-block-post-featured-image.alignfull{max-width:none}.wp-block-post-featured-image.alignfull figcaption{padding-inline:var(--site-edge)}.wp-block-the-wrap-article-header-full .wp-block-post-featured-image.alignfull{width:100%}.wp-block-post-featured-image--profile-header{height:6.875rem;width:6.875rem}@media(min-width: 48rem){.wp-block-post-featured-image--profile-header{height:9.5rem;width:9.5rem}}.wp-block-post-featured-image.has-pro-badge{position:relative}.wp-block-post-featured-image.has-pro-badge>figure{margin:0}.wp-block-post-featured-image.has-icon-play{align-self:start;display:grid}.wp-block-post-featured-image.has-icon-play figure,.wp-block-post-featured-image.has-icon-play .post-featured-image__play-icon{grid-column:1;grid-row:1}.wp-block-post-featured-image.has-icon-play .post-featured-image__play-icon{align-self:center;color:#fff;justify-self:center}@media(min-width: 48rem){.wp-block-post-featured-image.has-icon-play .post-featured-image__play-icon{height:auto;width:4.1875rem}}.wp-block-post-featured-image.has-icon-play figure{margin:0}.wp-block-post-featured-image--video{align-items:center;aspect-ratio:16/9;display:flex;justify-content:center;width:100%}.wp-block-post-featured-image--video iframe{aspect-ratio:16/9;height:auto;width:100%}

/*# sourceMappingURL=post-featured-image.min.css.map*/
</style>
<style id="wp-block-paragraph-inline-css">
.is-small-text{font-size:.875em}.is-regular-text{font-size:1em}.is-large-text{font-size:2.25em}.is-larger-text{font-size:3em}.has-drop-cap:not(:focus):first-letter{float:left;font-size:8.4em;font-style:normal;font-weight:100;line-height:.68;margin:.05em .1em 0 0;text-transform:uppercase}body.rtl .has-drop-cap:not(:focus):first-letter{float:none;margin-left:.1em}p.has-drop-cap.has-background{overflow:hidden}:root :where(p.has-background){padding:1.25em 2.375em}:where(p.has-text-color:not(.has-link-color)) a{color:inherit}p.has-text-align-left[style*="writing-mode:vertical-lr"],p.has-text-align-right[style*="writing-mode:vertical-rl"]{rotate:180deg}
</style>
<style id="the-wrap-read-more-style-inline-css">
.the-wrap-read-more__container{align-items:center;display:flex;flex-direction:row-reverse;gap:.75rem;justify-content:space-between}

</style>
<style id="the-wrap-read-more-styles-inline-css">
.wp-block-the-wrap-read-more{--block-vertical-rhythm: 2rem}@media(min-width: 48rem){.wp-block-the-wrap-read-more{--block-vertical-rhythm: 3rem}}.the-wrap-read-more__container{background-color:#f7f7f7;padding:.625rem}@media(min-width: 48rem){.the-wrap-read-more__container{padding:1rem}}.the-wrap-read-more__image{flex:0 0 8.75rem}@media(min-width: 48rem){.the-wrap-read-more__image{flex-basis:10.5rem}}.the-wrap-read-more__headline{font-size:1.125rem;font-weight:700;line-height:1.3333333333;font-family:var(--wp--preset--font-family--ivy-display)}@media(min-width: 48rem){.the-wrap-read-more__headline{font-size:1.5rem;line-height:1.3333333333}}.the-wrap-read-more__headline a{text-decoration:none}.the-wrap-read-more__headline strong{font-size:.75rem;font-weight:600;line-height:1.1666666667;color:#c50000;font-family:var(--wp--preset--font-family--libre-franklin);text-transform:uppercase}@media(min-width: 48rem){.the-wrap-read-more__headline strong{font-size:.875rem;font-weight:600;line-height:1.1428571429}}

/*# sourceMappingURL=read-more.min.css.map*/
</style>
<link rel="stylesheet" id="wp-block-image-css" href="https://www.thewrap.com/wp-includes/blocks/image/style.min.css?ver=6.8" media="all">
<style id="core-image-styles-inline-css">
.wp-block-image>a{display:block}.wp-block-image.is-style-rounded img{border:2px solid #f8f9fa;border-radius:9999px;box-shadow:0 3.2px 3.2px -1.6px rgba(24,39,75,.08),0 1.6px 2.4px -1.6px rgba(24,39,75,.12)}@media(min-width: 30rem){.wp-block-image.alignleft,.wp-block-image.alignright{max-width:calc(50% - var(--site-gap))}}.wp-block-image.alignfull figcaption{padding-inline:var(--site-edge)}

/*# sourceMappingURL=image.min.css.map*/
</style>
<style id="wp-block-post-content-inline-css">
.wp-block-post-content{display:flow-root}
</style>
<link rel="stylesheet" id="newsletter-builder-signup-form-styles-css" href="https://www.thewrap.com/wp-content/themes/the-wrap/client/build/css/blocks/newsletter-builder/signup-form.min.css?ver=4a2c2e85220c50dc04a3" media="all">
<style id="the-wrap-author-bios-style-inline-css">
.wp-block-the-wrap-author-bios__entry{align-items:center;display:flex;flex-wrap:wrap;gap:.75rem}.wp-block-the-wrap-author-bios__entry+.wp-block-the-wrap-author-bios__entry{margin-top:2rem}.wp-block-the-wrap-author-bios__entry-excerpt{flex-basis:100%}

</style>
<style id="the-wrap-author-bios-styles-inline-css">
.wp-block-the-wrap-author-bios{border-top:1px solid #dcdfe4;margin-block:2rem;padding-top:2rem}.wp-block-the-wrap-author-bios__entry-avatar{display:var(--display-no-mobile, block);margin-bottom:0}.wp-block-the-wrap-author-bios__entry-avatar img{border:2px solid #f8f9fa;border-radius:9999px;box-shadow:0 3.2px 3.2px -1.6px rgba(24,39,75,.08),0 1.6px 2.4px -1.6px rgba(24,39,75,.12)}.wp-block-the-wrap-author-bios__entry-name{font-size:2rem;font-weight:700;line-height:1.125;font-family:var(--wp--preset--font-family--ivy-display)}.wp-block-the-wrap-author-bios__entry-name a{text-decoration:none}.wp-block-the-wrap-author-bios__entry-name a:hover{text-decoration:underline}.wp-block-the-wrap-author-bios__entry-excerpt{font-size:.9375rem;line-height:1.4666666667}

/*# sourceMappingURL=author-bios.min.css.map*/
</style>
<style id="the-wrap-connatix-styles-inline-css">
@media(min-width: 768px){.wp-block-the-wrap-connatix--right-rail{aspect-ratio:16/9}}@media(max-width: 767px){.wp-block-the-wrap-connatix--below-article{aspect-ratio:16/9}}

/*# sourceMappingURL=connatix.min.css.map*/
</style>
<style id="the-wrap-taboola-styles-inline-css">
.container--taboola{display:block;margin-top:2rem}.container--taboola #taboola-below-article-thumbnails{max-width:var(--content-max)}.container--taboola #taboola-below-article-thumbnails[data-feed-main-container-id=taboola-below-article-thumbnails].tbl-feed-full-width{margin-inline:auto}

/*# sourceMappingURL=taboola.min.css.map*/
</style>
<style id="wp-block-post-template-inline-css">
.wp-block-post-template{box-sizing:border-box;list-style:none;margin-bottom:0;margin-top:0;max-width:100%;padding:0}.wp-block-post-template.is-flex-container{display:flex;flex-direction:row;flex-wrap:wrap;gap:1.25em}.wp-block-post-template.is-flex-container>li{margin:0;width:100%}@media (min-width:600px){.wp-block-post-template.is-flex-container.is-flex-container.columns-2>li{width:calc(50% - .625em)}.wp-block-post-template.is-flex-container.is-flex-container.columns-3>li{width:calc(33.33333% - .83333em)}.wp-block-post-template.is-flex-container.is-flex-container.columns-4>li{width:calc(25% - .9375em)}.wp-block-post-template.is-flex-container.is-flex-container.columns-5>li{width:calc(20% - 1em)}.wp-block-post-template.is-flex-container.is-flex-container.columns-6>li{width:calc(16.66667% - 1.04167em)}}@media (max-width:600px){.wp-block-post-template-is-layout-grid.wp-block-post-template-is-layout-grid.wp-block-post-template-is-layout-grid.wp-block-post-template-is-layout-grid{grid-template-columns:1fr}}.wp-block-post-template-is-layout-constrained>li>.alignright,.wp-block-post-template-is-layout-flow>li>.alignright{float:right;margin-inline-end:0;margin-inline-start:2em}.wp-block-post-template-is-layout-constrained>li>.alignleft,.wp-block-post-template-is-layout-flow>li>.alignleft{float:left;margin-inline-end:2em;margin-inline-start:0}.wp-block-post-template-is-layout-constrained>li>.aligncenter,.wp-block-post-template-is-layout-flow>li>.aligncenter{margin-inline-end:auto;margin-inline-start:auto}
</style>
<style id="wp-block-heading-inline-css">
h1.has-background,h2.has-background,h3.has-background,h4.has-background,h5.has-background,h6.has-background{padding:1.25em 2.375em}h1.has-text-align-left[style*=writing-mode]:where([style*=vertical-lr]),h1.has-text-align-right[style*=writing-mode]:where([style*=vertical-rl]),h2.has-text-align-left[style*=writing-mode]:where([style*=vertical-lr]),h2.has-text-align-right[style*=writing-mode]:where([style*=vertical-rl]),h3.has-text-align-left[style*=writing-mode]:where([style*=vertical-lr]),h3.has-text-align-right[style*=writing-mode]:where([style*=vertical-rl]),h4.has-text-align-left[style*=writing-mode]:where([style*=vertical-lr]),h4.has-text-align-right[style*=writing-mode]:where([style*=vertical-rl]),h5.has-text-align-left[style*=writing-mode]:where([style*=vertical-lr]),h5.has-text-align-right[style*=writing-mode]:where([style*=vertical-rl]),h6.has-text-align-left[style*=writing-mode]:where([style*=vertical-lr]),h6.has-text-align-right[style*=writing-mode]:where([style*=vertical-rl]){rotate:180deg}
</style>
<link rel="stylesheet" id="wp-block-comments-css" href="https://www.thewrap.com/wp-includes/blocks/comments/style.min.css?ver=6.8" media="all">
<style id="core-comments-styles-inline-css">
.wp-block-comments{--block-vertical-rhythm: 2rem;margin-block:2rem}.wp-block-comments>*+*{margin-block:var(--block-vertical-rhythm, 1.25rem)}.wp-block-comments>*+*:last-child{margin-block-end:unset}

/*# sourceMappingURL=comments.min.css.map*/
</style>
<style id="the-wrap-collapsed-comments-styles-inline-css">
.wp-block-the-wrap-collapsed-comments{margin-block-start:2.5rem}.wp-block-the-wrap-collapsed-comments .wp-block-comments--hidden{display:none}

/*# sourceMappingURL=collapsed-comments.min.css.map*/
</style>
<style id="the-wrap-footer-menu-styles-inline-css">
.wp-block-the-wrap-footer-menu{border:1px solid #515151}@media(min-width: 48rem){.wp-block-the-wrap-footer-menu{border:unset}}.footer-menu__heading{font-size:.875rem;font-weight:700;line-height:1.7142857143;font-family:var(--wp--preset--font-family--libre-franklin);letter-spacing:.2px;text-transform:uppercase}@media(min-width: 48rem){.footer-menu__heading{margin-bottom:.375rem}}@media(max-width: 47.9375rem){.footer-menu__toggle{align-items:center;background-color:#fff;color:#1d1d1f;display:flex;justify-content:space-between;padding:1rem;width:100%}}.footer-menu__toggle-icon{color:#c50000}@media(prefers-reduced-motion: no-preference){.footer-menu__toggle-icon{transition:all 150ms ease-in-out}}[aria-expanded=true]>.footer-menu__toggle-icon{transform:rotate(180deg)}@media(min-width: 48rem){.footer-menu__toggle-icon{display:none}}.footer-menu__menu{font-size:.875rem;line-height:1.7142857143;font-family:var(--wp--preset--font-family--libre-franklin)}@media(max-width: 47.9375rem){.footer-menu__menu{background-color:#fff;color:#1d1d1f;padding:0 1rem 1rem}.footer-menu__menu[aria-hidden=true]{display:none}}.footer-menu__menu .menu__link{font-size:.875rem;line-height:1.7142857143;display:inline-block;padding-block:.375rem;text-decoration:none}.footer-menu__menu .menu__link:hover{text-decoration:underline}

/*# sourceMappingURL=footer-menu.min.css.map*/
</style>
<link rel="stylesheet" id="the-wrap-ybid-css" href="https://htlbid.com/v3/thewrap.com/ybid.css?ver=1.0.0" media="all">
<style id="wp-emoji-styles-inline-css">

	img.wp-smiley, img.emoji {
		display: inline !important;
		border: none !important;
		box-shadow: none !important;
		height: 1em !important;
		width: 1em !important;
		margin: 0 0.07em !important;
		vertical-align: -0.1em !important;
		background: none !important;
		padding: 0 !important;
	}
</style>
<link rel="stylesheet" id="wp-block-library-css" href="https://www.thewrap.com/wp-includes/css/dist/block-library/common.min.css?ver=6.8" media="all">
<style id="global-styles-inline-css">
:root{--wp--preset--aspect-ratio--square: 1;--wp--preset--aspect-ratio--4-3: 4/3;--wp--preset--aspect-ratio--3-4: 3/4;--wp--preset--aspect-ratio--3-2: 3/2;--wp--preset--aspect-ratio--2-3: 2/3;--wp--preset--aspect-ratio--16-9: 16/9;--wp--preset--aspect-ratio--9-16: 9/16;--wp--preset--color--black: #1D1D1F;--wp--preset--color--cyan-bluish-gray: #abb8c3;--wp--preset--color--white: #FFFFFF;--wp--preset--color--pale-pink: #f78da7;--wp--preset--color--vivid-red: #cf2e2e;--wp--preset--color--luminous-vivid-orange: #ff6900;--wp--preset--color--luminous-vivid-amber: #fcb900;--wp--preset--color--light-green-cyan: #7bdcb5;--wp--preset--color--vivid-green-cyan: #00d084;--wp--preset--color--pale-cyan-blue: #8ed1fc;--wp--preset--color--vivid-cyan-blue: #0693e3;--wp--preset--color--vivid-purple: #9b51e0;--wp--preset--color--true-black: #000000;--wp--preset--color--gray: #F2F5F7;--wp--preset--color--gray-light: #BDC6CE;--wp--preset--color--gray-dark: #3D4550;--wp--preset--color--red: #DA0A0A;--wp--preset--color--ruby: #721C24;--wp--preset--color--blue: #00A8EA;--wp--preset--color--link: #C50000;--wp--preset--gradient--vivid-cyan-blue-to-vivid-purple: linear-gradient(135deg,rgba(6,147,227,1) 0%,rgb(155,81,224) 100%);--wp--preset--gradient--light-green-cyan-to-vivid-green-cyan: linear-gradient(135deg,rgb(122,220,180) 0%,rgb(0,208,130) 100%);--wp--preset--gradient--luminous-vivid-amber-to-luminous-vivid-orange: linear-gradient(135deg,rgba(252,185,0,1) 0%,rgba(255,105,0,1) 100%);--wp--preset--gradient--luminous-vivid-orange-to-vivid-red: linear-gradient(135deg,rgba(255,105,0,1) 0%,rgb(207,46,46) 100%);--wp--preset--gradient--very-light-gray-to-cyan-bluish-gray: linear-gradient(135deg,rgb(238,238,238) 0%,rgb(169,184,195) 100%);--wp--preset--gradient--cool-to-warm-spectrum: linear-gradient(135deg,rgb(74,234,220) 0%,rgb(151,120,209) 20%,rgb(207,42,186) 40%,rgb(238,44,130) 60%,rgb(251,105,98) 80%,rgb(254,248,76) 100%);--wp--preset--gradient--blush-light-purple: linear-gradient(135deg,rgb(255,206,236) 0%,rgb(152,150,240) 100%);--wp--preset--gradient--blush-bordeaux: linear-gradient(135deg,rgb(254,205,165) 0%,rgb(254,45,45) 50%,rgb(107,0,62) 100%);--wp--preset--gradient--luminous-dusk: linear-gradient(135deg,rgb(255,203,112) 0%,rgb(199,81,192) 50%,rgb(65,88,208) 100%);--wp--preset--gradient--pale-ocean: linear-gradient(135deg,rgb(255,245,203) 0%,rgb(182,227,212) 50%,rgb(51,167,181) 100%);--wp--preset--gradient--electric-grass: linear-gradient(135deg,rgb(202,248,128) 0%,rgb(113,206,126) 100%);--wp--preset--gradient--midnight: linear-gradient(135deg,rgb(2,3,129) 0%,rgb(40,116,252) 100%);--wp--preset--font-size--small: 13px;--wp--preset--font-size--medium: 20px;--wp--preset--font-size--large: 36px;--wp--preset--font-size--x-large: 42px;--wp--preset--font-family--ivy-display: ivypresto-display, 'Libre Baskerville', Georgia, Times, 'Times New Roman', serif;--wp--preset--font-family--ivy-text: ivypresto-text, Georgia, Times, 'Times New Roman', serif;--wp--preset--font-family--libre-franklin: libre-franklin, Helvetica, Arial, sans-serif;--wp--preset--font-family--system-serif: Georgia, Times, 'Times New Roman', serif;--wp--preset--font-family--system-sans-serif: Helvetica, 'Helvetica Neue', -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;--wp--preset--spacing--20: 0.44rem;--wp--preset--spacing--30: 0.67rem;--wp--preset--spacing--40: 1rem;--wp--preset--spacing--50: 1.5rem;--wp--preset--spacing--60: 2.25rem;--wp--preset--spacing--70: 3.38rem;--wp--preset--spacing--80: 5.06rem;--wp--preset--shadow--natural: 6px 6px 9px rgba(0, 0, 0, 0.2);--wp--preset--shadow--deep: 12px 12px 50px rgba(0, 0, 0, 0.4);--wp--preset--shadow--sharp: 6px 6px 0px rgba(0, 0, 0, 0.2);--wp--preset--shadow--outlined: 6px 6px 0px -3px rgba(255, 255, 255, 1), 6px 6px rgba(0, 0, 0, 1);--wp--preset--shadow--crisp: 6px 6px 0px rgba(0, 0, 0, 1);}:root { --wp--style--global--content-size: 652px;--wp--style--global--wide-size: var(--tw--block-wide); }:where(body) { margin: 0; }.wp-site-blocks { padding-top: var(--wp--style--root--padding-top); padding-bottom: var(--wp--style--root--padding-bottom); }.has-global-padding { padding-right: var(--wp--style--root--padding-right); padding-left: var(--wp--style--root--padding-left); }.has-global-padding > .alignfull { margin-right: calc(var(--wp--style--root--padding-right) * -1); margin-left: calc(var(--wp--style--root--padding-left) * -1); }.has-global-padding :where(:not(.alignfull.is-layout-flow) > .has-global-padding:not(.wp-block-block, .alignfull)) { padding-right: 0; padding-left: 0; }.has-global-padding :where(:not(.alignfull.is-layout-flow) > .has-global-padding:not(.wp-block-block, .alignfull)) > .alignfull { margin-left: 0; margin-right: 0; }.wp-site-blocks > .alignleft { float: left; margin-right: 2em; }.wp-site-blocks > .alignright { float: right; margin-left: 2em; }.wp-site-blocks > .aligncenter { justify-content: center; margin-left: auto; margin-right: auto; }:where(.is-layout-flex){gap: 0.5em;}:where(.is-layout-grid){gap: 0.5em;}.is-layout-flow > .alignleft{float: left;margin-inline-start: 0;margin-inline-end: 2em;}.is-layout-flow > .alignright{float: right;margin-inline-start: 2em;margin-inline-end: 0;}.is-layout-flow > .aligncenter{margin-left: auto !important;margin-right: auto !important;}.is-layout-constrained > .alignleft{float: left;margin-inline-start: 0;margin-inline-end: 2em;}.is-layout-constrained > .alignright{float: right;margin-inline-start: 2em;margin-inline-end: 0;}.is-layout-constrained > .aligncenter{margin-left: auto !important;margin-right: auto !important;}.is-layout-constrained > :where(:not(.alignleft):not(.alignright):not(.alignfull)){max-width: var(--wp--style--global--content-size);margin-left: auto !important;margin-right: auto !important;}.is-layout-constrained > .alignwide{max-width: var(--wp--style--global--wide-size);}body .is-layout-flex{display: flex;}.is-layout-flex{flex-wrap: wrap;align-items: center;}.is-layout-flex > :is(*, div){margin: 0;}body .is-layout-grid{display: grid;}.is-layout-grid > :is(*, div){margin: 0;}body{--wp--style--root--padding-top: 0px;--wp--style--root--padding-right: var(--site-edge);--wp--style--root--padding-bottom: 0px;--wp--style--root--padding-left: var(--site-edge);}a:where(:not(.wp-element-button)){text-decoration: underline;}:root :where(.wp-element-button, .wp-block-button__link){background-color: #32373c;border-width: 0;color: #fff;font-family: inherit;font-size: inherit;line-height: inherit;padding: calc(0.667em + 2px) calc(1.333em + 2px);text-decoration: none;}.has-black-color{color: var(--wp--preset--color--black) !important;}.has-cyan-bluish-gray-color{color: var(--wp--preset--color--cyan-bluish-gray) !important;}.has-white-color{color: var(--wp--preset--color--white) !important;}.has-pale-pink-color{color: var(--wp--preset--color--pale-pink) !important;}.has-vivid-red-color{color: var(--wp--preset--color--vivid-red) !important;}.has-luminous-vivid-orange-color{color: var(--wp--preset--color--luminous-vivid-orange) !important;}.has-luminous-vivid-amber-color{color: var(--wp--preset--color--luminous-vivid-amber) !important;}.has-light-green-cyan-color{color: var(--wp--preset--color--light-green-cyan) !important;}.has-vivid-green-cyan-color{color: var(--wp--preset--color--vivid-green-cyan) !important;}.has-pale-cyan-blue-color{color: var(--wp--preset--color--pale-cyan-blue) !important;}.has-vivid-cyan-blue-color{color: var(--wp--preset--color--vivid-cyan-blue) !important;}.has-vivid-purple-color{color: var(--wp--preset--color--vivid-purple) !important;}.has-true-black-color{color: var(--wp--preset--color--true-black) !important;}.has-gray-color{color: var(--wp--preset--color--gray) !important;}.has-gray-light-color{color: var(--wp--preset--color--gray-light) !important;}.has-gray-dark-color{color: var(--wp--preset--color--gray-dark) !important;}.has-red-color{color: var(--wp--preset--color--red) !important;}.has-ruby-color{color: var(--wp--preset--color--ruby) !important;}.has-blue-color{color: var(--wp--preset--color--blue) !important;}.has-link-color{color: var(--wp--preset--color--link) !important;}.has-black-background-color{background-color: var(--wp--preset--color--black) !important;}.has-cyan-bluish-gray-background-color{background-color: var(--wp--preset--color--cyan-bluish-gray) !important;}.has-white-background-color{background-color: var(--wp--preset--color--white) !important;}.has-pale-pink-background-color{background-color: var(--wp--preset--color--pale-pink) !important;}.has-vivid-red-background-color{background-color: var(--wp--preset--color--vivid-red) !important;}.has-luminous-vivid-orange-background-color{background-color: var(--wp--preset--color--luminous-vivid-orange) !important;}.has-luminous-vivid-amber-background-color{background-color: var(--wp--preset--color--luminous-vivid-amber) !important;}.has-light-green-cyan-background-color{background-color: var(--wp--preset--color--light-green-cyan) !important;}.has-vivid-green-cyan-background-color{background-color: var(--wp--preset--color--vivid-green-cyan) !important;}.has-pale-cyan-blue-background-color{background-color: var(--wp--preset--color--pale-cyan-blue) !important;}.has-vivid-cyan-blue-background-color{background-color: var(--wp--preset--color--vivid-cyan-blue) !important;}.has-vivid-purple-background-color{background-color: var(--wp--preset--color--vivid-purple) !important;}.has-true-black-background-color{background-color: var(--wp--preset--color--true-black) !important;}.has-gray-background-color{background-color: var(--wp--preset--color--gray) !important;}.has-gray-light-background-color{background-color: var(--wp--preset--color--gray-light) !important;}.has-gray-dark-background-color{background-color: var(--wp--preset--color--gray-dark) !important;}.has-red-background-color{background-color: var(--wp--preset--color--red) !important;}.has-ruby-background-color{background-color: var(--wp--preset--color--ruby) !important;}.has-blue-background-color{background-color: var(--wp--preset--color--blue) !important;}.has-link-background-color{background-color: var(--wp--preset--color--link) !important;}.has-black-border-color{border-color: var(--wp--preset--color--black) !important;}.has-cyan-bluish-gray-border-color{border-color: var(--wp--preset--color--cyan-bluish-gray) !important;}.has-white-border-color{border-color: var(--wp--preset--color--white) !important;}.has-pale-pink-border-color{border-color: var(--wp--preset--color--pale-pink) !important;}.has-vivid-red-border-color{border-color: var(--wp--preset--color--vivid-red) !important;}.has-luminous-vivid-orange-border-color{border-color: var(--wp--preset--color--luminous-vivid-orange) !important;}.has-luminous-vivid-amber-border-color{border-color: var(--wp--preset--color--luminous-vivid-amber) !important;}.has-light-green-cyan-border-color{border-color: var(--wp--preset--color--light-green-cyan) !important;}.has-vivid-green-cyan-border-color{border-color: var(--wp--preset--color--vivid-green-cyan) !important;}.has-pale-cyan-blue-border-color{border-color: var(--wp--preset--color--pale-cyan-blue) !important;}.has-vivid-cyan-blue-border-color{border-color: var(--wp--preset--color--vivid-cyan-blue) !important;}.has-vivid-purple-border-color{border-color: var(--wp--preset--color--vivid-purple) !important;}.has-true-black-border-color{border-color: var(--wp--preset--color--true-black) !important;}.has-gray-border-color{border-color: var(--wp--preset--color--gray) !important;}.has-gray-light-border-color{border-color: var(--wp--preset--color--gray-light) !important;}.has-gray-dark-border-color{border-color: var(--wp--preset--color--gray-dark) !important;}.has-red-border-color{border-color: var(--wp--preset--color--red) !important;}.has-ruby-border-color{border-color: var(--wp--preset--color--ruby) !important;}.has-blue-border-color{border-color: var(--wp--preset--color--blue) !important;}.has-link-border-color{border-color: var(--wp--preset--color--link) !important;}.has-vivid-cyan-blue-to-vivid-purple-gradient-background{background: var(--wp--preset--gradient--vivid-cyan-blue-to-vivid-purple) !important;}.has-light-green-cyan-to-vivid-green-cyan-gradient-background{background: var(--wp--preset--gradient--light-green-cyan-to-vivid-green-cyan) !important;}.has-luminous-vivid-amber-to-luminous-vivid-orange-gradient-background{background: var(--wp--preset--gradient--luminous-vivid-amber-to-luminous-vivid-orange) !important;}.has-luminous-vivid-orange-to-vivid-red-gradient-background{background: var(--wp--preset--gradient--luminous-vivid-orange-to-vivid-red) !important;}.has-very-light-gray-to-cyan-bluish-gray-gradient-background{background: var(--wp--preset--gradient--very-light-gray-to-cyan-bluish-gray) !important;}.has-cool-to-warm-spectrum-gradient-background{background: var(--wp--preset--gradient--cool-to-warm-spectrum) !important;}.has-blush-light-purple-gradient-background{background: var(--wp--preset--gradient--blush-light-purple) !important;}.has-blush-bordeaux-gradient-background{background: var(--wp--preset--gradient--blush-bordeaux) !important;}.has-luminous-dusk-gradient-background{background: var(--wp--preset--gradient--luminous-dusk) !important;}.has-pale-ocean-gradient-background{background: var(--wp--preset--gradient--pale-ocean) !important;}.has-electric-grass-gradient-background{background: var(--wp--preset--gradient--electric-grass) !important;}.has-midnight-gradient-background{background: var(--wp--preset--gradient--midnight) !important;}.has-small-font-size{font-size: var(--wp--preset--font-size--small) !important;}.has-medium-font-size{font-size: var(--wp--preset--font-size--medium) !important;}.has-large-font-size{font-size: var(--wp--preset--font-size--large) !important;}.has-x-large-font-size{font-size: var(--wp--preset--font-size--x-large) !important;}.has-ivy-display-font-family{font-family: var(--wp--preset--font-family--ivy-display) !important;}.has-ivy-text-font-family{font-family: var(--wp--preset--font-family--ivy-text) !important;}.has-libre-franklin-font-family{font-family: var(--wp--preset--font-family--libre-franklin) !important;}.has-system-serif-font-family{font-family: var(--wp--preset--font-family--system-serif) !important;}.has-system-sans-serif-font-family{font-family: var(--wp--preset--font-family--system-sans-serif) !important;}
:where(.wp-block-post-template.is-layout-flex){gap: 1.25em;}:where(.wp-block-post-template.is-layout-grid){gap: 1.25em;}
:root :where(p){font-size: 1.125rem;line-height: 1.875rem;}
</style>
<style id="core-block-supports-inline-css">
.wp-container-core-group-is-layout-76ea2f42{justify-content:flex-start;}
</style>
<style id="wp-block-template-skip-link-inline-css">

		.skip-link.screen-reader-text {
			border: 0;
			clip-path: inset(50%);
			height: 1px;
			margin: -1px;
			overflow: hidden;
			padding: 0;
			position: absolute !important;
			width: 1px;
			word-wrap: normal !important;
		}

		.skip-link.screen-reader-text:focus {
			background-color: #eee;
			clip-path: none;
			color: #444;
			display: block;
			font-size: 1em;
			height: auto;
			left: 5px;
			line-height: normal;
			padding: 15px 23px 14px;
			text-decoration: none;
			top: 5px;
			width: auto;
			z-index: 100000;
		}
</style>
<link rel="stylesheet" id="the-wrap-typekit-css" href="https://use.typekit.net/icl0tmu.css?ver=1.0.0" media="all">
<link rel="stylesheet" id="the-wrap-global-css" href="https://www.thewrap.com/wp-content/themes/the-wrap/client/build/css/global.min.css?ver=3d3b505432471be0961a" media="all">
<link rel="stylesheet" id="the-wrap-article-css" href="https://www.thewrap.com/wp-content/themes/the-wrap/client/build/css/article.min.css?ver=ae2229508ef0412090d1" media="all">
<link rel="stylesheet" id="the-wrap-lazy-render-css" href="https://www.thewrap.com/wp-content/themes/the-wrap/client/build/css/lazy-render.min.css?ver=ab296160acb19c4e2697" media="all">
<script id="newsletter-builder-signup-form-view-script-js-extra">
var newsletterBuilderSignupForm = {"nonce":"b3b5f80261"};
</script>
<script src="https://www.thewrap.com/wp-content/plugins/newsletter-builder/build/signup-form/view.js?ver=27ef4abd79534e443eeb" id="newsletter-builder-signup-form-view-script-js" defer="" data-wp-strategy="defer"></script>
<script src="https://www.thewrap.com/wp-content/plugins/the-wrap/build/connatix/view.js?ver=412f6cfd68a4fe77ab36" id="the-wrap-connatix-view-script-js" defer="" data-wp-strategy="defer"></script>
<script src="https://www.thewrap.com/wp-content/plugins/the-wrap/build/collapsed-comments/view.js?ver=73d0ab22245c80cad3cc" id="the-wrap-collapsed-comments-view-script-js" defer="" data-wp-strategy="defer"></script>
<script src="https://htlbid.com/v3/thewrap.com/ybid.js?ver=1.0.0" id="the-wrap-ybid-js" async="" data-wp-strategy="async"></script>
<script src="https://s.ntv.io/serve/load.js?ver=6.8" id="the-wrap-nativo-js" async="" data-wp-strategy="async"></script>
<script id="the-wrap-zephr-browser-js-before">
			let thewrap_token = document.cookie.split("; ").find((row) => row.startsWith("wtid_token"))?.split("=")[1];
			let thewrap_token_custom_data = typeof thewrap_token === "string" && thewrap_token !== "" ? {tokenValidated:"true"} : {};
			
</script>
<script src="https://assets.zephr.com/zephr-browser/1.9.1/zephr-browser.umd.js?ver=1.9.1" id="the-wrap-zephr-browser-js"></script>
<script id="the-wrap-zephr-browser-js-after">
			let thewrap_zephr_custom_data={"postType":"post","articleTags":["broadway","reviews-2"],"articleCategories":["theater"],"articleSection":"theater"};
			document.addEventListener("DOMContentLoaded", (event) => {
				if (typeof thewrap_sophi_decision_data === "object") {
					Object.assign(thewrap_zephr_custom_data, thewrap_sophi_decision_data);
				}
				if (typeof thewrap_token_custom_data === "object") {
					Object.assign(thewrap_zephr_custom_data, thewrap_token_custom_data);
				}
				if (typeof thewrap_zephr_custom_data !== "object" || !thewrap_zephr_custom_data.postType) {
					zephrBrowser.run();
				} else {
					zephrBrowser.run({
						customData: thewrap_zephr_custom_data
					});
				}
			});
			

			document.addEventListener("load", (event) => {
				if (
					typeof Zephr.accessDetails.authenticated !== "undefined"
					&& Zephr.accessDetails.authenticated
				) {
					let thewrap_expiry = new Date();
					thewrap_expiry.setTime(thewrap_expiry.getTime() + (7 * 24 * 60 * 60 * 1000)); // One week.
					document.cookie = "thewrap_registered_user=true; Expires=" + thewrap_expiry;
				}
			});
			
</script>
<link rel="https://api.w.org/" href="https://www.thewrap.com/wp-json/"><link rel="alternate" title="JSON" type="application/json" href="https://www.thewrap.com/wp-json/wp/v2/posts/7172154"><link rel="EditURI" type="application/rsd+xml" title="RSD" href="https://www.thewrap.com/xmlrpc.php?rsd">
<meta name="generator" content="WordPress 6.8">
<link rel="alternate" title="oEmbed (JSON)" type="application/json+oembed" href="https://www.thewrap.com/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fwww.thewrap.com%2Fjuliet-broadway-review-max-martin-jukebox-musical%2F">
<link rel="alternate" title="oEmbed (XML)" type="text/xml+oembed" href="https://www.thewrap.com/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fwww.thewrap.com%2Fjuliet-broadway-review-max-martin-jukebox-musical%2F&amp;format=xml">
<script>
	window.dataLayer = window.dataLayer || [];
	window.dataLayer.push({"author":"by-robert-hofler","tags":"broadway reviews-2","template":"Article page","dateCreated":"2022-11-17T19:00:00-08:00","dateLastModified":"2022-11-17T15:03:36Z","isGallery":"0","postId":"7172154"});
</script>

<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer',"GTM-WM35TFR");</script>
<!-- End Google Tag Manager -->
<meta name="article-tags" content="broadway, reviews-2">
<meta name="article-section" content="theater">
<meta name="article-categories" content="theater">

<script>
	! function(n) {
		if (!window.cnx) {
			window.cnx = {}, window.cnx.cmd = [];
			var t = n.createElement("iframe");
			t.src = 'javascript:false';
			t.display = "none", t.onload = function() {
				var n = t.contentWindow.document,
					c = n.createElement("script");
				c.src = "//cd.connatix.com/connatix.player.js?cid=8759484e-bb96-415e-9d33-167af5d155f0", c.setAttribute("async", "1"), c.setAttribute("type", "text/javascript"), n.body.appendChild(c)
			}, n.head.appendChild(t)
		}
	}(document);
</script><iframe src="javascript:false"></iframe>
<style class="wp-fonts-local">
@font-face{font-family:libre-franklin;font-style:normal;font-weight:100 900;font-display:fallback;src:url('https://www.thewrap.com/wp-content/themes/the-wrap/assets/fonts/LibreFranklin-VariableFont_wght.woff2') format('woff2');font-stretch:normal;}
@font-face{font-family:libre-franklin;font-style:italic;font-weight:100 900;font-display:fallback;src:url('https://www.thewrap.com/wp-content/themes/the-wrap/assets/fonts/LibreFranklin-Italic-VariableFont_wght.woff2') format('woff2');font-stretch:normal;}
</style>
<link rel="icon" href="https://i0.wp.com/www.thewrap.com/wp-content/uploads/2024/05/the_wrap_symbol_black_bkg.png?fit=32%2C32&amp;quality=80&amp;ssl=1" sizes="32x32">
<link rel="icon" href="https://i0.wp.com/www.thewrap.com/wp-content/uploads/2024/05/the_wrap_symbol_black_bkg.png?fit=192%2C192&amp;quality=80&amp;ssl=1" sizes="192x192">
<link rel="apple-touch-icon" href="https://i0.wp.com/www.thewrap.com/wp-content/uploads/2024/05/the_wrap_symbol_black_bkg.png?fit=180%2C180&amp;quality=80&amp;ssl=1">
<meta name="msapplication-TileImage" content="https://i0.wp.com/www.thewrap.com/wp-content/uploads/2024/05/the_wrap_symbol_black_bkg.png?fit=270%2C270&amp;quality=80&amp;ssl=1">

<script>
	window.ybid = window.ybid || {};
	ybid.cmd = ybid.cmd || [];
	ybid.cmd.push(function () {
		ybid.layout("universal");
					ybid.setTargeting("Category", ["theater"]);
						ybid.setTargeting("Page-Type", "single");
						ybid.setTargeting("Path", "/juliet-broadway-review-max-martin-jukebox-musical/");
						ybid.setTargeting("Post-Author", "Robert Hofler");
						ybid.setTargeting("Post-Type", "post");
						ybid.setTargeting("PostID", "7172154");
						ybid.setTargeting("Tag", ["broadway","reviews-2"]);
						ybid.setTargeting("is_testing", "no");
						ybid.setTargeting("testmode", "");
				});
</script>
<script src="https://securepubads.g.doubleclick.net/tag/js/gpt.js" async=""></script><style type="text/css">/* Fix for adhesion offset when 1x1 is served */
div.y-ad > div.y-ad-gpt > div { 
  width: fit-content !important; 
}
</style><script src="//ads.pubmatic.com/AdServer/js/pwt/158370/4934/pwt.js" async=""></script><script src="https://c.amazon-adsystem.com/aax2/apstag.js" async=""></script><style>                      .htmx-indicator{opacity:0}                      .htmx-request .htmx-indicator{opacity:1; transition: opacity 200ms ease-in;}                      .htmx-request.htmx-indicator{opacity:1; transition: opacity 200ms ease-in;}                    </style><script async="" defer="" src="https://agent.intentiq.com/Agent/GA/UniversalID-Sync/IIQUniversalID-sync.js" id="ntv_iiq_script"></script><script type="text/javascript" src="https://jadserve.postrelease.com/t?ntv_mvi=&amp;us_privacy=1---&amp;ntv_url=https%253A%252F%252Fwww.thewrap.com%252Fjuliet-broadway-review-max-martin-jukebox-musical%252F"></script><script src="https://d15kdpgjg3unno.cloudfront.net/oPS.js?cid=86" async=""></script><script type="text/javascript" src="https://widgets.outbrain.com/outbrain.js" id="NTV_OutbrainJS"></script><script type="text/javascript" src="https://cdn.binsiad.com/ins-ag/ins-ag.min.js?e=1" charset="UTF-8" async="true" id="ins-tag" data-as="teads"></script><script type="text/javascript" src="https://mv.outbrain.com/Multivac/api/platforms?contentUrl=https%3A%2F%2Fwww.thewrap.com%2Fjuliet-broadway-review-max-martin-jukebox-musical%2F&amp;idx=0&amp;rand=40420&amp;widgetJSId=JS_1&amp;va=true&amp;format=vjapi&amp;settings=true&amp;recs=true&amp;key=NATIV2E687KJ12FAMMNHDF091&amp;tch=0&amp;adblck=0&amp;abwl=0&amp;obRecsAbtestVars=1550:5795&amp;wdr-attribution-src=1&amp;activeTab=true&amp;clientType=23&amp;clientVer=4d83fbc5b74_2026-01-26&amp;devMem=8&amp;scrOri=l&amp;hwc=4&amp;ttfb=344&amp;bandwidth=1.4&amp;netQ=3g&amp;ccnsnt=true&amp;version=4d83fbc5b74_2026-01-26&amp;sig=vMeq1tU5&amp;apv=false&amp;osLang=en-US&amp;winW=1920&amp;winH=993&amp;scrW=800&amp;scrH=600&amp;dpr=1&amp;secured=true&amp;cmpStat=0&amp;ccpa=1---&amp;ccpaStat=1&amp;ogn=https%3A%2F%2Fwww.thewrap.com%2Fjuliet-broadway-review-max-martin-jukebox-musical%2F&amp;pubcid=3c8485b9-a855-42e4-b6d8-c386b3002c15&amp;iiq=6a348c7a-1e21-4de9-b319-85b98b33665c" charset="UTF-8" async=""></script></head>

<body class="wp-singular post-template-default single single-post postid-7172154 single-format-standard wp-custom-logo wp-embed-responsive wp-theme-the-wrap">
<svg xmlns="http://www.w3.org/2000/svg" focusable="false" height="0" role="none" style="left:-9999px;overflow:hidden;position:absolute" viewBox="0 0 0 0" width="0"><symbol id="am-symbol-youtube-play-dark" viewBox="0 0 234.6667 165.3333"><g transform="matrix(1.3333333 0 0 -1.3333333 0 165.3333)"><g transform="scale(.1)"><path d="M700 358.313v523.375l460-261.7zm1023.22 688.057c-20.24 76.22-79.88 136.24-155.6 156.61C1430.37 1240 880 1240 880 1240s-550.367 0-687.621-37.02c-75.723-20.37-135.3634-80.39-155.6017-156.61C0 908.227 0 620 0 620s0-288.223 36.7773-426.371C57.0156 117.41 116.656 57.3906 192.379 37.0117 329.633 0 880 0 880 0s550.37 0 687.62 37.0117c75.72 20.3789 135.36 80.3983 155.6 156.6173C1760 331.777 1760 620 1760 620s0 288.227-36.78 426.37" fill="#fff" fill-opacity="1" fill-rule="nonzero" stroke="none"></path></g></g></symbol><symbol id="am-symbol-logo" viewBox="0 0 726 109"><path d="M725.52 81.53h-25.91v27.18h25.91V81.53Z" fill="#D2232A"></path><path d="M647.95 52.46V14.85h15.96c11.69 0 17.38 7.27 17.38 18.49 0 11.22-5.37 19.12-16.91 19.12h-16.43Zm-25.12 56.25h25.12V66.68h20.54c23.07 0 37.45-11.85 37.45-34.13S691.08 0 667.54 0h-44.71v108.71Zm-79.79-39.18 17.85-49.93 17.22 49.93h-35.08.01Zm-31.6 39.18h18.17l9.64-25.6h42.66l9.32 25.6h25.6L578.43 0h-28.44l-38.55 108.7v.01Zm-72.84-58.3V14.38h18.17c12.32 0 17.54 6.16 17.54 17.85 0 11.69-5.69 18.17-18.33 18.17H438.6v.01Zm-24.65 58.3h24.65V64.79h12.32l28.28 43.92h27.81l-31.28-46.29c13.75-4.27 23.54-14.22 23.54-30.49 0-19.43-13.11-31.92-36.81-31.92h-48.51v108.7Zm-133.19 0h31.28l17.7-76.95 18.17 76.95h31.28L407.32 0h-20.54l-21.17 88.01L343.8 0h-23.23L299.4 88.64 279.02 0h-26.23l27.97 108.7v.01Zm-101.12 0h68.1v-3.79h-58.62V53.41h53.72v-3.79h-53.72V3.79h56.72V0h-66.2v108.71Zm-19.28 0h9.32V0h-9.32v49.45H96.84V0h-9.32v108.7h9.32V53.24h63.52v55.47Zm-125.92 0h9.48V3.79h34.44V0H0v3.79h34.44v104.92Z" fill="#000"></path></symbol><symbol id="am-symbol-pro-logo" viewBox="0 0 269 40"><g clip-path="url(#wrap-pro-logo-a)">
    <path d="M173.371 39.326h3.314v-17.08h9.102c7.809 0 13.033-3.145 13.033-10.955 0-7.247-5.056-10.617-12.752-10.617h-12.697v38.652Zm3.314-18.428V2.022h9.102c6.517 0 9.494 3.595 9.494 9.382 0 5.562-2.697 9.494-9.213 9.494h-9.383Zm26.124 18.428h3.371V20.955h8.371l12.247 18.37h3.989l-12.472-18.483c5.899-.618 10.057-3.764 10.057-10 0-7.416-5.001-10.168-11.63-10.168h-13.933v38.652Zm3.371-19.776V2.022h9.775c5.956 0 8.99 3.033 8.99 8.82 0 5.843-3.428 8.708-9.439 8.708h-9.326ZM249.944 40c11.405 0 18.484-8.933 18.484-20 0-11.012-7.079-20-18.484-20-11.461 0-18.483 8.988-18.483 20 0 11.067 7.022 20 18.483 20Zm0-1.349C240.45 38.651 235 30.336 235 20c0-10.338 5.506-18.652 14.944-18.652 9.382 0 14.944 8.314 14.944 18.652 0 10.337-5.506 18.651-14.944 18.651Z" fill="#000"></path>
    <path d="M158.877 39.325h9.213v-9.663h-9.213v9.663Z" fill="#D2232A"></path>
    <path d="M9.944 39.326h11.123l6.293-27.36 6.46 27.36h11.124l10-38.652h-7.303l-7.528 31.292L32.36.674h-8.259L16.573 32.19 9.326.674H0l9.944 38.652Zm47.36 0h8.764V23.707h4.382l10.056 15.619h9.888L79.27 22.864c4.888-1.516 8.371-5.055 8.371-10.842 0-6.91-4.663-11.348-13.09-11.348H57.303v38.652Zm8.764-20.731V5.785h6.46c4.383 0 6.236 2.192 6.236 6.35 0 4.1-2.022 6.46-6.516 6.46h-6.18Zm25.898 20.73h6.46l3.428-9.1h15.169l3.314 9.1h9.102L115.787.675h-10.113L91.966 39.326Zm11.236-13.932 6.349-17.753 6.123 17.753h-12.472Zm28.371 13.933h8.933V24.382h7.303c8.202 0 13.315-4.214 13.315-12.136 0-7.528-5.281-11.572-13.652-11.572h-15.899v38.652Zm8.933-20V5.953h5.674c4.157 0 6.18 2.585 6.18 6.574 0 4.045-1.911 6.797-6.012 6.797h-5.842Z" fill="#000"></path>
  </g><defs>
    <clipPath id="wrap-pro-logo-a">
      <path d="M0 0h268.425v40H0z" fill="#fff"></path>
    </clipPath>
  </defs></symbol><symbol id="am-symbol-search" viewBox="0 0 17 17"><path d="m16.5822 14.5846-3.2867-3.2513c.8985-1.34629 1.3214-2.95425 1.2015-4.56842-.12-1.61416-.7759-3.14196-1.8635-4.34068-1.0877-1.19873-2.5447-1.999636-4.13962-2.275492-1.59493-.275855-3.23631-.010839-4.66339.752948-1.42707.763784-2.558 1.982544-3.213124 3.462654-.6551219 1.48011-.796867 3.13669-.402716 4.70659.39415 1.5699 1.30159 2.9631 2.57817 3.9582 1.27657.9951 2.84907 1.5351 4.46768 1.5342 1.4365.0015 2.8404-.4278 4.0304-1.2325l3.2938 3.2938c.2654.2638.6245.4119.9987.4119.3743 0 .7333-.1481.9988-.4119.1371-.1322.2461-.2906.3206-.4659.0745-.1752.1129-.3637.1129-.5541 0-.1905-.0384-.3789-.1129-.5542-.0745-.1752-.1835-.3337-.3206-.4658zm-9.3217-12.45961c1.01539 0 2.00799.30101 2.8524.86498.8443.56398 1.5025 1.3656 1.8914 2.30356.3889.93797.491 1.97016.2935 2.96614-.1976.99598-.686 1.91103-1.4035 2.62953s-1.63188 1.2081-2.62759 1.4071c-.99571.1989-2.02804.0982-2.96654-.2894s-1.74103-1.0447-2.30617-1.8883c-.56513-.84354-.86751-1.83572-.86891-2.85111 0-1.36265.54082-2.66959 1.5037-3.63379.96287-.96421 2.26907-1.50683 3.63171-1.50871z" fill="currentColor"></path></symbol><symbol id="am-symbol-menu" viewBox="0 0 32 32"><path d="m16 .336426c-3.1645 0-6.25793.938384-8.88912 2.696484-2.63118 1.7581-4.68194 4.25696-5.89295 7.18059-1.21099742 2.9236-1.527851 6.1407-.910487 9.2444.617363 3.1037 2.141217 5.9546 4.378857 8.1922 2.23764 2.2377 5.08857 3.7615 8.1923 4.3789 3.1037.6174 6.3207.3005 9.2443-.9105 2.9237-1.211 5.4225-3.2618 7.1806-5.893 1.7581-2.6311 2.6965-5.7246 2.6965-8.8891 0-4.2434-1.6857-8.3131-4.6863-11.31368s-7.0702-4.686294-11.3137-4.686294zm-6 19.999974h12c.3536 0 .6928.1405.9428.3905.2501.2501.3905.5892.3905.9429 0 .3536-.1404.6927-.3905.9428-.25.25-.5892.3905-.9428.3905h-12c-.35361 0-.69275-.1405-.9428-.3905-.25005-.2501-.39053-.5892-.39053-.9428 0-.3537.14048-.6928.39053-.9429.25005-.25.58919-.3905.9428-.3905zm-1.33333-4c0-.3536.14048-.6927.39053-.9428.25005-.25.58919-.3905.9428-.3905h12c.3536 0 .6928.1405.9428.3905.2501.2501.3905.5892.3905.9428s-.1404.6928-.3905.9428c-.25.2501-.5892.3906-.9428.3906h-12c-.35361 0-.69275-.1405-.9428-.3906-.25005-.25-.39053-.5892-.39053-.9428zm13.33333-4h-12c-.35361 0-.69275-.1405-.9428-.3905s-.39053-.5892-.39053-.9428.14048-.6928.39053-.9428c.25005-.25006.58919-.39054.9428-.39054h12c.3536 0 .6928.14048.9428.39054.2501.25.3905.5892.3905.9428s-.1404.6928-.3905.9428c-.25.25-.5892.3905-.9428.3905z" fill="#1d1d1f"></path></symbol><symbol id="am-symbol-menu-search" viewBox="0 0 42 24"><path d="M3 4h18v2H3zm0 7h12v2H3zm0 7h18v2H3z" fill="#000"></path><path d="m39.563 19.062-3.529-3.528m0 0a6.5 6.5 0 1 0-9.191-9.192 6.5 6.5 0 0 0 9.191 9.192" fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.031"></path></symbol><symbol id="am-symbol-close" viewBox="0 0 32 32"><path d="m19.0668 16.6378c-.0319-.0299-.0573-.0661-.0747-.1062-.0173-.0401-.0263-.0834-.0263-.1271s.009-.087.0263-.1271c.0174-.0402.0428-.0763.0747-.1062l12.3467-12.36005c.187-.18478.3356-.40486.4369-.64747.1014-.24261.1536-.50293.1536-.76586s-.0522-.52325-.1536-.76586c-.1013-.24261-.2499-.46269-.4369-.647473-.3767-.371307-.8844-.579458-1.4133-.579458-.529 0-1.0367.208151-1.4134.579458l-12.3466 12.346713c-.0311.0322-.0684.0579-.1097.0754-.0412.0175-.0855.0266-.1303.0266-.0449 0-.0892-.0091-.1304-.0266-.0413-.0175-.0786-.0432-.1096-.0754l-12.34671-12.346713c-.37671-.371307-.8844-.579458-1.41334-.579458-.52893 0-1.036627.208151-1.413331.579458-.187053.184783-.335565.404863-.436926.647473-.1013616.24261-.15355511.50293-.15355511.76586s.05219351.52325.15355511.76586c.101361.24261.249873.46269.436926.64747l12.346681 12.36005c.0319.0299.0573.066.0747.1062.0173.0401.0263.0834.0263.1271s-.009.087-.0263.1271c-.0174.0401-.0428.0763-.0747.1062l-12.346681 12.3467c-.187053.1848-.335565.4048-.436926.6475-.1013616.2426-.15355511.5029-.15355511.7658 0 .263.05219351.5233.15355511.7659.101361.2426.249873.4627.436926.6475.376704.3713.884401.5794 1.413331.5794.52894 0 1.03663-.2081 1.41334-.5794l12.34671-12.3467c.031-.0323.0683-.0579.1096-.0755.0412-.0175.0855-.0265.1304-.0265.0448 0 .0891.009.1303.0265.0413.0176.0786.0432.1097.0755l12.3466 12.3467c.3767.3713.8844.5794 1.4134.5794.5289 0 1.0366-.2081 1.4133-.5794.187-.1848.3356-.4049.4369-.6475.1014-.2426.1536-.5029.1536-.7659 0-.2629-.0522-.5232-.1536-.7658-.1013-.2427-.2499-.4627-.4369-.6475z" fill="#000"></path></symbol><symbol id="am-symbol-chevron-down" viewBox="0 0 14 9"><path d="M7.02003 8.33643C6.64184 8.33643 6.31768 8.17672 6.10157 7.91055L0.752907 1.94822C0.374719 1.52234 0.428746 0.883516 0.860961 0.564105C1.29318 0.244695 1.88747 0.244695 2.26566 0.670575L6.91197 5.88761C6.966 5.94085 7.02003 5.94085 7.12808 5.88761L11.7744 0.670576C12.1526 0.244695 12.8009 0.244695 13.1791 0.617341C13.5573 0.989986 13.6113 1.57557 13.2871 2.00145L7.99251 7.96378C7.72238 8.17672 7.39822 8.33643 7.02003 8.33643Z" fill="currentColor"></path></symbol><symbol id="am-symbol-account" viewBox="0 0 20 20"><clipPath id="account-a"><path d="m0 0h20v20h-20z"></path></clipPath><g clip-path="url(#account-a)"><path d="m10 0c-1.97781 0-3.91121.58649-5.5557 1.6853-1.64449 1.09882-2.92621 2.6606-3.683091 4.48787-.75687614 1.82726-.95491 3.83793-.569057 5.77773.385852 1.9398 1.338258 3.7216 2.736788 5.1202 1.39852 1.3985 3.18035 2.3509 5.12016 2.7368 1.93981.3858 3.9505.1878 5.7777-.5691 1.8273-.7569 3.3891-2.0386 4.4879-3.6831s1.6853-3.5779 1.6853-5.5557c0-2.65216-1.0536-5.1957-2.9289-7.07107-1.8754-1.87536-4.4189-2.92893-7.0711-2.92893zm0 2.08333c1.503-.00081 2.9751.42669 4.2438 1.23242 1.2688.80572 2.2817 1.95632 2.92 3.31699.6384 1.36068.8758 2.87509.6844 4.36586-.1913 1.4907-.8035 2.8961-1.7649 4.0514-.0586.0695-.1381.1183-.2266.1393s-.1814.0131-.265-.0226c-.7334-.3334-1.625-.6584-2.6334-1.0334l-.625-.225c-.1083-.0416-.2083-.225-.2666-.4666-.0593-.2125-.0758-.4345-.0487-.6534.0272-.2189.0976-.4302.207-.6216.8917-.9834 1.4417-2.0334 1.4417-4.25003.0436-.50294-.0195-1.00941-.1853-1.48624s-.4304-.91326-.7766-1.28069c-.3462-.36742-.7661-.65755-1.2322-.85138-.4661-.19384-.968-.28699-1.4726-.27336-.50463-.01363-1.00645.07952-1.47258.27336-.46613.19383-.88604.48396-1.23222.85138-.34619.36743-.61083.80386-.77659 1.28069s-.22889.9833-.18527 1.48624c0 2.21663.55 3.27503 1.44166 4.25003.10944.1914.17979.4027.20697.6216s.01065.4409-.04863.6534c-.05834.2416-.15834.425-.26667.4666l-.625.2584c-1.00833.375-1.9.7-2.63333 1.0333-.08365.0357-.17656.0437-.26506.0227s-.16793-.0699-.22661-.1394c-.9716-1.1546-1.59255-2.5632-1.78954-4.0593-.197-1.49617.03818-3.01745.67778-4.38426s1.65691-2.52209 2.93183-3.32945c1.27492-.80737 2.75422-1.2331 4.26326-1.22696z" fill="#000"></path></g></symbol><symbol id="am-symbol-email-outline" viewBox="0 0 20 16"><path d="M0 16V0h20v16zm10-7L2 4v10h16V4zm0-2 8-5H2zM2 4V2v12z" fill="currentColor"></path></symbol><symbol id="am-symbol-facebook" viewBox="0 0 19 33"><path d="m18.1865 10.02c-.0617-.07031-.1375-.12681-.2225-.16587-.085-.03905-.1773-.05978-.2708-.06084h-5.0267v-1.88c0-.37333.08-.8.68-.8h4c.088.00579.1762-.00931.2573-.04407s.1528-.08818.2094-.15593c.06-.05913.1074-.12976.1395-.20765.032-.07789.0481-.16145.0471-.24568v-5.33333c0-.176813-.0702-.346383-.1952-.471407s-.2946-.195262-.4714-.195262h-5.7734c-6.39996 0-6.8933 5.466669-6.8933 7.133329v2.2h-3.33333c-.17681 0-.34638.07024-.471404.19527-.125024.12504-.195262.29464-.195262.47144v5.3333c0 .1768.070238.3464.195262.4714s.294594.1953.471404.1953h3.33333v15.3333c0 .1768.07024.3464.19527.4714.12502.125.29459.1953.4714.1953h6.66663c.1768 0 .3464-.0703.4714-.1953.1251-.125.1953-.2946.1953-.4714v-15.3333h4.4667c.1658.0008.326-.0602.4493-.1712.1233-.1109.2008-.2638.2173-.4288l.5467-5.3334c.0121-.091.004-.1835-.0236-.2711-.0277-.0876-.0742-.168-.1364-.2355z" fill="currentColor"></path></symbol><symbol id="am-symbol-twitter" viewBox="0 0 32 27"><path d="m31.0932 6.04653c.0949-.07886.166-.1825.2055-.29938.0395-.11689.0457-.24243.0181-.36267-.0276-.12023-.0881-.23044-.1747-.31835-.0865-.08791-.1958-.15009-.3155-.1796l-1.0534-.25333c-.097-.02439-.1871-.07073-.2634-.13546s-.1367-.14611-.1766-.23787c-.0426-.08955-.0648-.18749-.0648-.28667s.0222-.19712.0648-.28667l.6-1.18666c.0571-.11618.079-.24645.0633-.37492-.0158-.12846-.0686-.24956-.152-.34852s-.1938-.17151-.3177-.20878c-.124-.03727-.2561-.03766-.3802-.00112l-2.6667.74667c-.0982.02708-.2015.03031-.3012.00944s-.193-.06525-.2721-.12944c-.9905-.74285-2.1683-1.195209-3.4013-1.306396-1.2331-.111186-2.4728.123196-3.5802.676876-1.1073.55369-2.0387 1.40481-2.6895 2.45798-.6509 1.05317-.9957 2.26679-.9957 3.50487v.48c.0006.0819-.029.16114-.0831.22262s-.1289.10089-.2102.11072c-3.7467.44-7.33338-1.46667-11.20004-5.92-.08155-.09626-.18873-.1674-.3091-.20516s-.24899-.0406-.3709-.00818c-.11614.04882-.21569.13017-.28666.23425-.07097.10409-.11033.22648-.11334.35242-.54034 2.19333-.32423 4.50485.61333 6.56.02918.05311.04448.11273.04448.17333s-.0153.12022-.04448.17334c-.03586.05301-.08679.09404-.14621.11781s-.1246.02918-.18712.01552l-1.50667-.29333c-.1066-.01447-.2151-.00392-.31693.03079-.10182.03471-.194166.09264-.269735.16921-.07271.07745-.126262.17086-.156363.27273-.030101.1019-.035913.2094-.01697.3139.115118 1.0233.458898 2.0076 1.005888 2.88.547.8724 1.2832 1.6106 2.15411 2.16.05217.0316.09468.0769.12289.131s.04105.1148.03711.1757c-.00065.0632-.02.1247-.05559.1769s-.08584.0927-.14441.1164l-.72.28c-.17051.0747-.30467.2137-.37333.3867-.03594.0843-.05447.175-.05447.2667 0 .0916.01853.1823.05447.2666.39079.8551.98314 1.6027 1.72626 2.1786s1.61484.963 2.5404 1.1281c.06581.0196.12463.0577.16952.1097.04488.0519.07397.1157.08382.1836.00659.0714-.00911.1431-.04492.2051-.03582.0621-.09.1116-.15508.1416-1.80613.7396-3.74172 1.1113-5.69334 1.0933-.17681-.0353-.360423.001-.510452.101s-.254181.2556-.289543.4324.000962.3604.100981.5104c.100019.1501.255541.2542.432354.2896 3.39484 1.6163 7.09419 2.4934 10.85334 2.5733 3.3057.0488 6.5524-.8788 9.3333-2.6667 2.2887-1.5249 4.1637-3.5932 5.4574-6.02 1.2937-2.4269 1.9657-5.1365 1.956-7.88663v-1.16c-.0001-.09697.0213-.19275.0628-.28039.0416-.08763.1021-.16493.1772-.22628z" fill="currentColor"></path></symbol><symbol id="am-symbol-instagram" viewBox="0 0 32 33"><g fill="currentColor"><path d="m24.6667.459961h-17.33337c-1.94383.003525-3.80705.777269-5.18155 2.151779-1.374507 1.3745-2.14825535 3.23772-2.15178 5.18155v17.33331c.00352465 1.9439.777273 3.8071 2.15178 5.1816 1.3745 1.3745 3.23772 2.1482 5.18155 2.1518h17.33337c1.9438-.0036 3.807-.7773 5.1815-2.1518s2.1483-3.2377 2.1518-5.1816v-17.33331c-.0035-1.94383-.7773-3.80705-2.1518-5.18155-1.3745-1.37451-3.2377-2.148254-5.1815-2.151779zm2 21.333339c0 1.4145-.5619 2.771-1.5621 3.7712s-2.3568 1.5621-3.7713 1.5621h-10.6666c-1.41452 0-2.77108-.5619-3.77127-1.5621s-1.5621-2.3567-1.5621-3.7712v-10.6667c0-1.41446.56191-2.77101 1.5621-3.77121 1.00019-1.00019 2.35675-1.5621 3.77127-1.5621h10.6666c1.4145 0 2.7711.56191 3.7713 1.5621 1.0002 1.0002 1.5621 2.35675 1.5621 3.77121z"></path><path d="m15.9998 21.7934c2.9456 0 5.3334-2.3878 5.3334-5.3334 0-2.9455-2.3878-5.3333-5.3334-5.3333-2.9455 0-5.3333 2.3878-5.3333 5.3333 0 2.9456 2.3878 5.3334 5.3333 5.3334z"></path><path d="m22.6668 11.1266c.7364 0 1.3334-.5969 1.3334-1.33331 0-.73638-.597-1.33333-1.3334-1.33333s-1.3333.59695-1.3333 1.33333c0 .73641.5969 1.33331 1.3333 1.33331z"></path></g></symbol><symbol id="am-symbol-youtube" viewBox="0 0 32 23"><path d="m26.7467.126709h-21.49337c-1.38683.020651-2.71107.580756-3.69182 1.561511-.980754.98075-1.5408589 2.30499-1.56151 3.69182v12.15996c.0206511 1.3869.580756 2.7111 1.56151 3.6919.98075.9807 2.30499 1.5408 3.69182 1.5615h21.49337c1.3868-.0207 2.711-.5808 3.6918-1.5615.9807-.9808 1.5408-2.305 1.5615-3.6919v-12.15996c-.0207-1.38683-.5808-2.71107-1.5615-3.69182-.9808-.980755-2.305-1.54086-3.6918-1.561511zm-4.6934 11.333291-9.0266 5.8134c-.1055.0731-.2317.1105-.36.1066-.1117.0006-.2218-.0269-.32-.08-.1043-.0586-.1913-.1437-.2522-.2467-.0608-.103-.0934-.2203-.0945-.3399v-11.54669c.0011-.11964.0337-.23689.0945-.33989.0609-.10301.1479-.18813.2522-.24678.1024-.06242.22-.09544.34-.09544.1199 0 .2375.03302.34.09544l9.0266 5.77336c.0936.0604.1705.1433.2238.2412.0533.0978.0812.2074.0812.3188s-.0279.221-.0812.3188-.1302.1807-.2238.2412z" fill="currentColor"></path></symbol><symbol id="am-symbol-linkedin" viewBox="0 0 14 14"><g fill="currentColor"><path d="m3.33302 4.6665h-2.666678c-.184095 0-.333334.14924-.333334.33334v8.66666c0 .1841.149239.3334.333334.3334h2.666678c.18409 0 .33333-.1493.33333-.3334v-8.66666c0-.1841-.14924-.33334-.33333-.33334z"></path><path d="m1.98636 3.33329c.33019.00264.65373-.09285.92956-.27438.27583-.18152.49153-.44089.61972-.74519s.16311-.63982.10031-.964c-.06279-.32418-.22047-.622396-.45302-.85682s-.52949-.3944882-.85315-.4598852-.65945-.03317918-.96478.0925662c-.30532.125745-.566408.33935-.750141.613715-.183733.274364-.281827.597124-.281838.927324-.000877.218.041192.43403.123806.63577.082614.20173.204154.38522.357681.53999.153527.15476.336032.27777.537102.362.20107.08424.41676.12804.63475.12891z"></path><path d="m11.3334 14h2c.0884 0 .1732-.0351.2357-.0976s.0976-.1473.0976-.2357v-5.60003c0-2.51334-1.42-3.73335-3.4067-3.73335-.39339-.014-.78535.05472-1.15053.20171-.36519.14699-.69545.36899-.96946.65163-.03724.04043-.08634.06801-.14024.07879-.0539.01079-.10983.0042-.15976-.01879-.0504-.01883-.09393-.05246-.12487-.09649-.03093-.04402-.04783-.09638-.04846-.15018 0-.0884-.03512-.17319-.09763-.2357-.06252-.06251-.1473-.09763-.23571-.09763h-2.00001c-.0884 0-.17319.03512-.2357.09763s-.09763.1473-.09763.2357v8.66671c0 .0884.03512.1732.09763.2357s.1473.0976.2357.0976h2.00001c.08841 0 .17319-.0351.23571-.0976.06251-.0625.09763-.1473.09763-.2357v-5.00003c0-.44203.17559-.86595.48815-1.17851.31257-.31257.73649-.48816 1.17852-.48816s.86595.17559 1.17855.48816c.3125.31256.4881.73648.4881 1.17851v5.00003c0 .0884.0351.1732.0977.2357.0625.0625.1473.0976.2357.0976z"></path></g></symbol><symbol id="am-symbol-email" viewBox="0 0 14 10"><g fill="currentColor"><path d="m13.9358 1.401c-.0173-.01154-.0376-.0177-.0583-.0177-.0208 0-.0411.00616-.0584.0177l-5.68745 5.68748c-.14833.14885-.32475.26675-.51902.34686-.19426.08012-.40251.12084-.61264.11981-.4256-.00084-.83394-.16836-1.1375-.46667l-5.681657-5.66415c-.017267-.01154-.037567-.0177-.058333-.0177-.020767 0-.0410667.00616-.0583335.0177-.0161238.00636-.0304219.01661-.0416184.02985-.0111964.01323-.01894289.02903-.0225481.04598v6.99999c0 .30942.122916.60616.341708.82495.218792.2188.515538.34171.824952.34171h11.66664c.3094 0 .6062-.12291.825-.34171.2188-.21879.3417-.51553.3417-.82495v-6.99999c.0005-.02106-.0054-.04177-.0168-.05946-.0115-.01768-.028-.03152-.0474-.0397z"></path><path d="m6.48052 6.49348c.13827.13435.32346.2095.51625.2095.19278 0 .37798-.07515.51625-.2095l5.65248-5.652485c.038-.038261.0647-.086325.0771-.138847.0123-.052522.0099-.107442-.0071-.158652-.0642-.21-.245-.21-.4025-.21h-11.66664c-.16333 0-.33833 0-.402497.21-.016991.05121-.019444.10613-.007086.158652s.039043.100586.077086.138847z"></path></g></symbol></svg>
		
			
				
					
							<div class="yad-oop-ad-a wp-block-the-wrap-ad"></div>
	
					
				
			
		
		
<!-- Google Tag Manager (noscript) -->
<noscript>
	<iframe
		src="https://www.googletagmanager.com/ns.html?id=GTM-WM35TFR"
		height="0"
		width="0"
		style="display:none;visibility:hidden"
	></iframe>
</noscript>
<!-- End Google Tag Manager (noscript) -->

<a class="skip-link screen-reader-text" id="wp-skip-link" href="#main">Skip to content</a><div class="wp-site-blocks"><div id="page" class="site">
	<a class="skip-link" href="#content">Skip to content</a>

	<div class="site-header-ad-wrapper">
		
			
				
					
							<div class="yad-skin-ad-left wp-block-the-wrap-ad"></div>
	
							<div class="yad-skin-ad-right wp-block-the-wrap-ad"></div>
	
					
				
			
		
	</div>

	<div class="site-header-ad-wrapper">
		
			

			
				
					

					
							<div class="yad-skin-ad-top wp-block-the-wrap-ad"></div>
	
					
				
			
		
	</div>

	<header id="masthead" class="site-header">
		<div class="site-header__sticky-wrapper" data-component="sticky-header">
			<div class="site-header__brand-bar container container--site">
				<div class="site-header__brand-bar-inner">
					
						
					

					<div class="site-header__group-1">
						<button aria-label="Menu" aria-controls="mega-menu-wrapper" class="site-header__menu-button site-header__menu-button--open" data-component="menu-button">
							<svg aria-hidden="true" focusable="false" width="42" height="24"><use href="#am-symbol-menu-search"></use></svg>
							<span class="site-header__menu-button-text">Menu</span>
						</button>

						<button aria-label="Close" class="site-header__menu-button site-header__menu-button--close">
							<svg aria-hidden="true" focusable="false" width="18" height="18"><use href="#am-symbol-close"></use></svg>
							<span class="site-header__menu-button-text">Close</span>
						</button>

						<a href="https://www.thewrap.com/newsletters/" class="site-header__newsletters">
							<svg aria-hidden="true" focusable="false" width="20" height="16"><use href="#am-symbol-email-outline"></use></svg>
							Newsletters
						</a>
					</div>

					<a href="/" aria-label="TheWrap home" rel="home" class="site-header__logo-link">
						<svg aria-hidden="true" focusable="false" width="279.74" height="42" class="site-header__logo"><use href="#am-symbol-logo"></use></svg>
					</a>

					<div class="site-header__group-2">
						
					<div class="site-header__log-in">
							<a href="/join-pro/" class="site-header__subscribe">Subscribe</a>
						</div><a class="site-header__zephr-login" href="/login" target="_blank">
    Sign In
</a></div>

					<div class="site-header__mega-menu" id="mega-menu-wrapper" aria-hidden="true" role="dialog" aria-modal="true">
						<div class="site-header__search" id="menu-search-wrapper">
							
<form method="GET" action="https://www.thewrap.com/" role="search" class="search-form" aria-label="Search Form">
	<div class="search-form__container">
		<div class="search-form__input-wrapper">
			<label for="search-form-1" class="screen-reader-text">
				Search The Wrap			</label>

			<input type="search" id="search-form-1" class="search-form__input" placeholder="Search news and topics" value="" name="s">

			<span class="search-form__decoration-icon">
				<svg aria-hidden="true" focusable="false" width="25" height="25"><use href="#am-symbol-search"></use></svg>			</span>
		</div>

		<button type="submit" class="search-form__submit">
			<span class="search-form__submit-label">Search</span>
			<svg aria-hidden="true" focusable="false" width="17" height="17" class="search-form__submit-icon"><use href="#am-symbol-search"></use></svg>		</button>
	</div>
</form>

						</div>

						<nav aria-label="Main" class="site-header__primary-navigation wp-block-the-wrap-nav-menu">
	<h2 id="header-primary-nav-heading" class="screen-reader-only">
		Main	</h2>

	<ul aria-labelledby="header-primary-nav-heading" role="list" id="menu-header-primary" class="header-primary-menu"><li id="menu-item-7941543" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children menu-item-7941543 menu__item header-primary-menu__item menu__item--has-children header-primary-menu__item--has-children"><a href="https://www.thewrap.com/media-platforms/tv/" id="menu-link-2" class="menu__link header-primary-menu__link">TV</a>
<ul id="header-primary-menu-submenu-7941543" role="list" class="sub-menu menu__submenu header-primary-menu__submenu">
	<li id="menu-item-7941544" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941544 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/media-platforms/tv/" id="menu-link-3" class="menu__submenu-link header-primary-menu__submenu-link">TV News</a></li>
	<li id="menu-item-7941545" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-7941545 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/tag/ratings/" id="menu-link-4" class="menu__submenu-link header-primary-menu__submenu-link">Ratings</a></li>
	<li id="menu-item-7941546" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941546 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/media-platforms/streaming/" id="menu-link-5" class="menu__submenu-link header-primary-menu__submenu-link">Streaming</a></li>
	<li id="menu-item-7941547" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941547 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/media-platforms/journalism/" id="menu-link-6" class="menu__submenu-link header-primary-menu__submenu-link">Media News</a></li>
	<li id="menu-item-7941549" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-7941549 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/tag/tv-reviews/" id="menu-link-7" class="menu__submenu-link header-primary-menu__submenu-link">Reviews</a></li>
</ul>
</li>
<li id="menu-item-7941550" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children menu-item-7941550 menu__item header-primary-menu__item menu__item--has-children header-primary-menu__item--has-children"><a href="https://www.thewrap.com/creative-content/movies/" id="menu-link-8" class="menu__link header-primary-menu__link">Movies</a>
<ul id="header-primary-menu-submenu-7941550" role="list" class="sub-menu menu__submenu header-primary-menu__submenu">
	<li id="menu-item-7941553" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941553 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/creative-content/movies/" id="menu-link-9" class="menu__submenu-link header-primary-menu__submenu-link">Movie News</a></li>
	<li id="menu-item-7941554" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941554 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/industry-news/box-office/" id="menu-link-10" class="menu__submenu-link header-primary-menu__submenu-link">Box Office</a></li>
	<li id="menu-item-7941555" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941555 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/creative-content/reviews/" id="menu-link-11" class="menu__submenu-link header-primary-menu__submenu-link">Reviews</a></li>
	<li id="menu-item-7941557" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-7941557 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/tag/sundance/" id="menu-link-12" class="menu__submenu-link header-primary-menu__submenu-link">Sundance</a></li>
	<li id="menu-item-7941558" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-7941558 menu__submenu-item header-primary-menu__submenu-item"><a href="https://thewrap.com/tag/cannes-film-festival/" id="menu-link-13" class="menu__submenu-link header-primary-menu__submenu-link">Cannes</a></li>
	<li id="menu-item-7941559" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-7941559 menu__submenu-item header-primary-menu__submenu-item"><a href="https://thewrap.com/tag/venice-film-festival/" id="menu-link-14" class="menu__submenu-link header-primary-menu__submenu-link">Venice Film Festival</a></li>
	<li id="menu-item-7941560" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-7941560 menu__submenu-item header-primary-menu__submenu-item"><a href="https://thewrap.com/tag/tiff/" id="menu-link-15" class="menu__submenu-link header-primary-menu__submenu-link">Toronto Film Festival</a></li>
</ul>
</li>
<li id="menu-item-7941563" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children menu-item-7941563 menu__item header-primary-menu__item menu__item--has-children header-primary-menu__item--has-children"><a href="https://www.thewrap.com/industry-news/awards/" id="menu-link-16" class="menu__link header-primary-menu__link">Awards</a>
<ul id="header-primary-menu-submenu-7941563" role="list" class="sub-menu menu__submenu header-primary-menu__submenu">
	<li id="menu-item-7941564" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-7941564 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/awards-tracker/" id="menu-link-17" class="menu__submenu-link header-primary-menu__submenu-link">Awards Tracker</a></li>
	<li id="menu-item-7941565" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941565 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/industry-news/awards/" id="menu-link-18" class="menu__submenu-link header-primary-menu__submenu-link">Awards Coverage</a></li>
	<li id="menu-item-7941566" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-7941566 menu__submenu-item header-primary-menu__submenu-item"><a href="https://thewrap.com/tag/oscars/" id="menu-link-19" class="menu__submenu-link header-primary-menu__submenu-link">Oscars</a></li>
	<li id="menu-item-7941567" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-7941567 menu__submenu-item header-primary-menu__submenu-item"><a href="https://thewrap.com/tag/emmys/" id="menu-link-20" class="menu__submenu-link header-primary-menu__submenu-link">Emmys</a></li>
	<li id="menu-item-7941568" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-7941568 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/oscarwrap/" id="menu-link-21" class="menu__submenu-link header-primary-menu__submenu-link">TheWrap Magazine</a></li>
</ul>
</li>
<li id="menu-item-7941570" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-has-children menu-item-7941570 menu__item header-primary-menu__item menu__item--has-children header-primary-menu__item--has-children"><a href="https://www.thewrap.com/members-hub/" id="menu-link-22" class="menu__link header-primary-menu__link">Industry</a>
<ul id="header-primary-menu-submenu-7941570" role="list" class="sub-menu menu__submenu header-primary-menu__submenu">
	<li id="menu-item-7941571" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-7941571 menu__submenu-item header-primary-menu__submenu-item"><a href="https://thewrap.com/tag/ai/" id="menu-link-23" class="menu__submenu-link header-primary-menu__submenu-link">AI</a></li>
	<li id="menu-item-7941572" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941572 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/industry-news/deals-ma/" id="menu-link-24" class="menu__submenu-link header-primary-menu__submenu-link">Deals &amp; M&amp;A</a></li>
	<li id="menu-item-7941573" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941573 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/commentary-analysis/data-analysis/" id="menu-link-25" class="menu__submenu-link header-primary-menu__submenu-link">Data Analysis</a></li>
	<li id="menu-item-7941574" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-7941574 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/industry-news/business/" id="menu-link-26" class="menu__submenu-link header-primary-menu__submenu-link">Earnings Coverage</a></li>
	<li id="menu-item-7941575" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-7941575 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/what-to-watch/" id="menu-link-27" class="menu__submenu-link header-primary-menu__submenu-link">Streaming Charts</a></li>
	<li id="menu-item-7941576" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941576 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/industry-news/tech/" id="menu-link-28" class="menu__submenu-link header-primary-menu__submenu-link">Tech</a></li>
	<li id="menu-item-7941577" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-7941577 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/thegrill-2025-panels-videos/" id="menu-link-29" class="menu__submenu-link header-primary-menu__submenu-link">The Grill</a></li>
	<li id="menu-item-7941580" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-7941580 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/tag/game-on-series-2/" id="menu-link-30" class="menu__submenu-link header-primary-menu__submenu-link">Game On: A Wrap Sports Series</a></li>
</ul>
</li>
<li id="menu-item-7941584" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children menu-item-7941584 menu__item header-primary-menu__item menu__item--has-children header-primary-menu__item--has-children"><a href="https://www.thewrap.com/commentary-analysis/columns/" id="menu-link-31" class="menu__link header-primary-menu__link">Columns</a>
<ul id="header-primary-menu-submenu-7941584" role="list" class="sub-menu menu__submenu header-primary-menu__submenu">
	<li id="menu-item-7941586" class="menu-item menu-item-type-taxonomy menu-item-object-tw_column menu-item-7941586 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/column/waxword/" id="menu-link-32" class="menu__submenu-link header-primary-menu__submenu-link">WaxWord</a></li>
	<li id="menu-item-7941587" class="menu-item menu-item-type-taxonomy menu-item-object-tw_column menu-item-7941587 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/column/steve-pond/" id="menu-link-33" class="menu__submenu-link header-primary-menu__submenu-link">Steve Pond</a></li>
	<li id="menu-item-7941588" class="menu-item menu-item-type-taxonomy menu-item-object-tw_column menu-item-7941588 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/column/the-media-front/" id="menu-link-34" class="menu__submenu-link header-primary-menu__submenu-link">The Media Front</a></li>
	<li id="menu-item-7941589" class="menu-item menu-item-type-taxonomy menu-item-object-tw_column menu-item-7941589 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/column/inside-the-ratings/" id="menu-link-35" class="menu__submenu-link header-primary-menu__submenu-link">Inside the Ratings</a></li>
	<li id="menu-item-7941590" class="menu-item menu-item-type-taxonomy menu-item-object-tw_column menu-item-7941590 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/column/creatorverse/" id="menu-link-36" class="menu__submenu-link header-primary-menu__submenu-link">Creatorverse</a></li>
</ul>
</li>
<li id="menu-item-7941592" class="menu-item menu-item-type-taxonomy menu-item-object-tw_column menu-item-has-children menu-item-7941592 menu__item header-primary-menu__item menu__item--has-children header-primary-menu__item--has-children"><a href="https://www.thewrap.com/column/wrapstyle/" id="menu-link-37" class="menu__link header-primary-menu__link">WrapStyle</a>
<ul id="header-primary-menu-submenu-7941592" role="list" class="sub-menu menu__submenu header-primary-menu__submenu">
	<li id="menu-item-7941593" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941593 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/culture-lifestyle/fashion/" id="menu-link-38" class="menu__submenu-link header-primary-menu__submenu-link">Fashion</a></li>
	<li id="menu-item-7941594" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941594 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/culture-lifestyle/culture/" id="menu-link-39" class="menu__submenu-link header-primary-menu__submenu-link">Culture</a></li>
	<li id="menu-item-7941595" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-7941595 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/thewrapbook-art-of-television-2025/" id="menu-link-40" class="menu__submenu-link header-primary-menu__submenu-link">TheWrapBook Vol. 4: The Art of Television 2025</a></li>
	<li id="menu-item-7941596" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-7941596 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/the-wrapbook-art-of-cinema-issue-3/" id="menu-link-41" class="menu__submenu-link header-primary-menu__submenu-link">TheWrapBook Vol. 3: The Art of Cinema</a></li>
	<li id="menu-item-7941598" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-7941598 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/the-wrapbook-tv-issue/" id="menu-link-42" class="menu__submenu-link header-primary-menu__submenu-link">TheWrapBook Vol. 2: The Art of Television 2024</a></li>
	<li id="menu-item-7941600" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-7941600 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/the-wrapbook-the-art-of-cinema-2023/" id="menu-link-43" class="menu__submenu-link header-primary-menu__submenu-link">TheWrapBook Vol. 1: The Art of Cinema</a></li>
</ul>
</li>
<li id="menu-item-7941601" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-has-children menu-item-7941601 menu__item header-primary-menu__item menu__item--has-children header-primary-menu__item--has-children"><a href="https://www.thewrap.com/" id="menu-link-44" class="menu__link header-primary-menu__link">Topics</a>
<ul id="header-primary-menu-submenu-7941601" role="list" class="sub-menu menu__submenu header-primary-menu__submenu">
	<li id="menu-item-7941603" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941603 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/media-platforms/politics/" id="menu-link-45" class="menu__submenu-link header-primary-menu__submenu-link">Politics</a></li>
	<li id="menu-item-7941604" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941604 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/creative-content/music/" id="menu-link-46" class="menu__submenu-link header-primary-menu__submenu-link">Music</a></li>
	<li id="menu-item-7941606" class="menu-item menu-item-type-taxonomy menu-item-object-category current-post-ancestor current-menu-parent current-post-parent menu-item-7941606 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/creative-content/theater/" id="menu-link-47" class="menu__submenu-link header-primary-menu__submenu-link">Theater</a></li>
	<li id="menu-item-7941607" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941607 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/industry-news/labor-unions/" id="menu-link-48" class="menu__submenu-link header-primary-menu__submenu-link">Labor &amp; Unions</a></li>
	<li id="menu-item-7941608" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-7941608 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/tag/podcasts/" id="menu-link-49" class="menu__submenu-link header-primary-menu__submenu-link">Podcasts</a></li>
	<li id="menu-item-7941611" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941611 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/culture-lifestyle/sports/" id="menu-link-50" class="menu__submenu-link header-primary-menu__submenu-link">Sports</a></li>
</ul>
</li>
<li id="menu-item-7941614" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children menu-item-7941614 menu__item header-primary-menu__item menu__item--has-children header-primary-menu__item--has-children"><a href="https://www.thewrap.com/multimedia/" id="menu-link-51" class="menu__link header-primary-menu__link">Multimedia</a>
<ul id="header-primary-menu-submenu-7941614" role="list" class="sub-menu menu__submenu header-primary-menu__submenu">
	<li id="menu-item-7941616" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941616 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/multimedia/videos/" id="menu-link-52" class="menu__submenu-link header-primary-menu__submenu-link">Videos</a></li>
	<li id="menu-item-7941618" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941618 menu__submenu-item header-primary-menu__submenu-item"><a href="https://www.thewrap.com/multimedia/photos/" id="menu-link-53" class="menu__submenu-link header-primary-menu__submenu-link">Photos</a></li>
</ul>
</li>
<li id="menu-item-7941620" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941620 menu__item header-primary-menu__item"><a href="https://www.thewrap.com/creative-content/what-to-watch/" id="menu-link-54" class="menu__link header-primary-menu__link">What to Watch</a></li>
<li id="menu-item-7941621" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-7941621 menu__item header-primary-menu__item"><a href="https://www.thewrap.com/newsletters/" id="menu-link-55" class="menu__link header-primary-menu__link">Newsletters</a></li>
</ul></nav>


						<div class="site-header__mega-menu-cta">
							
						<div class="zephr-mobile-logout">
								<a href="/join-pro/" class="site-header__subscribe">Subscribe</a>
							</div></div>

						<div class="site-header__social-profiles wp-block-template-part"><nav id="socials-navigation" aria-label="Social Media" class="social-profiles">
	<h2 class="screen-reader-text">Follow Us</h2>

	<ul role="list" class="social-profiles__social-accounts">
		<li><a href="https://www.facebook.com/thewrap" class="wp-block-the-wrap-social-profile">
	<span class="screen-reader-text">Visit The Wrap on facebook</span>
	<svg aria-hidden="true" focusable="false" width="18.42" height="32"><use href="#am-symbol-facebook"></use></svg></a>
</li>
		<li><a href="https://www.twitter.com/thewrap" class="wp-block-the-wrap-social-profile">
	<span class="screen-reader-text">Visit The Wrap on twitter</span>
	<svg aria-hidden="true" focusable="false" width="29.62" height="25"><use href="#am-symbol-twitter"></use></svg></a>
</li>
		<li><a href="https://www.instagram.com/thewrap" class="wp-block-the-wrap-social-profile">
	<span class="screen-reader-text">Visit The Wrap on instagram</span>
	<svg aria-hidden="true" focusable="false" width="31.03" height="32"><use href="#am-symbol-instagram"></use></svg></a>
</li>
		<li><a href="https://www.youtube.com/thewrap" class="wp-block-the-wrap-social-profile">
	<span class="screen-reader-text">Visit The Wrap on youtube</span>
	<svg aria-hidden="true" focusable="false" width="32" height="23"><use href="#am-symbol-youtube"></use></svg></a>
</li>
	</ul>
</nav>
</div>
					</div>
				</div>
			</div>
		</div>

		<nav aria-label="Top Categories" class="site-header__menu-bar container container--site wp-block-the-wrap-nav-menu">
	<h2 id="header-secondary-nav-heading" class="screen-reader-only">
		Top Categories	</h2>

	<ul aria-labelledby="header-secondary-nav-heading" role="list" id="menu-header-secondary" class="header-secondary-menu"><li id="menu-item-7941627" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941627 menu__item header-secondary-menu__item"><a href="https://www.thewrap.com/media-platforms/tv/" id="menu-link-56" class="menu__link header-secondary-menu__link">TV</a></li>
<li id="menu-item-7941628" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941628 menu__item header-secondary-menu__item"><a href="https://www.thewrap.com/creative-content/movies/" id="menu-link-57" class="menu__link header-secondary-menu__link">Movies</a></li>
<li id="menu-item-7941629" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941629 menu__item header-secondary-menu__item"><a href="https://www.thewrap.com/industry-news/awards/" id="menu-link-58" class="menu__link header-secondary-menu__link">Awards</a></li>
<li id="menu-item-7941631" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-7941631 menu__item header-secondary-menu__item"><a href="https://www.thewrap.com/members-hub/" id="menu-link-59" class="menu__link header-secondary-menu__link">WrapPRO</a></li>
<li id="menu-item-7941633" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-7941633 menu__item header-secondary-menu__item"><a href="https://www.thewrap.com/wrapstyle/" id="menu-link-60" class="menu__link header-secondary-menu__link">WrapStyle</a></li>
<li id="menu-item-7941634" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-7941634 menu__item header-secondary-menu__item"><a href="https://www.thewrap.com/what-to-watch/" id="menu-link-61" class="menu__link header-secondary-menu__link">What to Watch</a></li>
<li id="menu-item-7941635" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941635 menu__item header-secondary-menu__item"><a href="https://www.thewrap.com/commentary-analysis/columns/" id="menu-link-62" class="menu__link header-secondary-menu__link">Columns</a></li>
<li id="menu-item-7941636" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941636 menu__item header-secondary-menu__item"><a href="https://www.thewrap.com/industry-news/tech/" id="menu-link-63" class="menu__link header-secondary-menu__link">AI &amp; Tech</a></li>
<li id="menu-item-7941637" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941637 menu__item header-secondary-menu__item"><a href="https://www.thewrap.com/industry-news/business/" id="menu-link-64" class="menu__link header-secondary-menu__link">Business</a></li>
<li id="menu-item-7941639" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941639 menu__item header-secondary-menu__item"><a href="https://www.thewrap.com/media-platforms/" id="menu-link-65" class="menu__link header-secondary-menu__link">Media</a></li>
<li id="menu-item-7941640" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-7941640 menu__item header-secondary-menu__item"><a href="https://www.thewrap.com/multimedia/videos/" id="menu-link-66" class="menu__link header-secondary-menu__link">Video</a></li>
</ul></nav>


		<div class="site-header__nav-stripe-wrapper">
			<div class="container container--site site-header__nav-stripe">
				
					
				
			</div>
		</div>

		<div class="zephr_banner"></div>
	</header>

	<div id="content" class="site-content container">
		
			
				
					
							<div class="yad-mob-banner-ad-b wp-block-the-wrap-ad"></div>
	

							<div class="yad-dsk-banner-ad-g wp-block-the-wrap-ad"></div>
	
					
				

			
		

		<div id="primary" class="content-area">
			<main id="main" class="site-main">

<article>
	<header class="entry-header entry-header--single container container--content has-global-padding">
		<div class="yoast-breadcrumbs"><span><span><a href="https://www.thewrap.com/">Home</a></span> &gt; <span><a href="https://www.thewrap.com/creative-content/">Creative Content</a></span> &gt; <span><a href="https://www.thewrap.com/creative-content/theater/">Theater</a></span></span></div>

		<h1 class="wp-block-post-title">‘&amp; Juliet’ Broadway Review: Max Martin Jukebox Musical Retools the Bard to a Pop Beat</h1>

		
			

			
				
			
		

		
			
						<p class="wp-block-the-wrap-subhed">David West Read book reimagines Shakespeare as a sexist hack</p>
		
			
		

		<div class="entry-info wp-block-template-part"><div style="" class="wp-block-post-author" id=""><span>By Robert Hofler</span></div>

<div class="wp-block-post-date"><time datetime="2022-11-17T19:00:00-08:00">November 17, 2022 @ 7:00 PM</time></div>


<div class="wp-block-group entry-info__social is-content-justification-left is-layout-flex wp-container-core-group-is-layout-76ea2f42 wp-block-group-is-layout-flex" style="gap: 0.5rem 0;">
    <div class="wp-block-template-part">
	
		<nav aria-label="Social Media" class="social-share">
			<h2 id="social-share-nav-heading" class="screen-reader-only">Share on Social Media</h2>

			<ul role="list" aria-labelledby="social-share-nav-heading" class="social-share__social-accounts">
				<li><a href="https://www.facebook.com/sharer.php?u%20=%20https://www.thewrap.com/juliet-broadway-review-max-martin-jukebox-musical/" class="wp-block-the-wrap-social-link">
	<svg aria-hidden="true" focusable="false" width="8.06" height="14"><use href="#am-symbol-facebook"></use></svg>	<span class="screen-reader-text">Share on Facebook</span>
</a>
</li>
				<li><a href="https://twitter.com/share?url%20=%20https://www.thewrap.com/juliet-broadway-review-max-martin-jukebox-musical/" class="wp-block-the-wrap-social-link">
	<svg aria-hidden="true" focusable="false" width="14" height="11.81"><use href="#am-symbol-twitter"></use></svg>	<span class="screen-reader-text">Share on X (formerly Twitter)</span>
</a>
</li>
				<li><a href="https://www.linkedin.com/shareArticle?mini%20=%20true&amp;url%20=%20https://www.thewrap.com/juliet-broadway-review-max-martin-jukebox-musical/" class="wp-block-the-wrap-social-link">
	<svg aria-hidden="true" focusable="false" width="14" height="14"><use href="#am-symbol-linkedin"></use></svg>	<span class="screen-reader-text">Share on LinkedIn</span>
</a>
</li>
				<li><a href="mailto:?body%20=%20https://www.thewrap.com/juliet-broadway-review-max-martin-jukebox-musical/&amp;subject%20=%20‘&amp;%20Juliet’%20Broadway%20Review:%20Max%20Martin%20Jukebox%20Musical%20Retools%20the%20Bard%20to%20a%20Pop%20Beat" class="wp-block-the-wrap-social-link">
	<svg aria-hidden="true" focusable="false" width="14" height="10"><use href="#am-symbol-email"></use></svg>	<span class="screen-reader-text">Share on Email</span>
</a>
</li>
			</ul>
		</nav>
	

	
	

</div>

    
</div>

</div>

		

		<figure class="wp-block-post-featured-image"><img width="990" height="557" src="https://i0.wp.com/www.thewrap.com/wp-content/uploads/2022/11/juliet.jpg?fit=990%2C557&amp;quality=89&amp;ssl=1" class="attachment-the-wrap-theme-content-max size-the-wrap-theme-content-max wp-post-image" alt="&amp; juliet" style="object-fit:cover;" decoding="async" fetchpriority="high" srcset="https://i0.wp.com/www.thewrap.com/wp-content/uploads/2022/11/juliet.jpg?w=1200&amp;quality=89&amp;ssl=1 1200w, https://i0.wp.com/www.thewrap.com/wp-content/uploads/2022/11/juliet.jpg?resize=300%2C169&amp;quality=89&amp;ssl=1 300w, https://i0.wp.com/www.thewrap.com/wp-content/uploads/2022/11/juliet.jpg?resize=1024%2C576&amp;quality=89&amp;ssl=1 1024w, https://i0.wp.com/www.thewrap.com/wp-content/uploads/2022/11/juliet.jpg?resize=768%2C432&amp;quality=89&amp;ssl=1 768w, https://i0.wp.com/www.thewrap.com/wp-content/uploads/2022/11/juliet.jpg?resize=298%2C168&amp;quality=89&amp;ssl=1 298w, https://i0.wp.com/www.thewrap.com/wp-content/uploads/2022/11/juliet.jpg?resize=936%2C527&amp;quality=89&amp;ssl=1 936w" sizes="(max-width: 990px) 100vw, 990px" data-portal-copyright="TheWrap" data-has-syndication-rights="1"><figcaption>Lorna Courtney in "&amp; Juliet" (Photo: Matthew Murphy)</figcaption></figure>
	</header>

	<div class="content-wrapper--with-more-from">
		<div class="content-wrapper content-wrapper--has-sidebar content-wrapper--content-max">
			<div class="content-area">
				

				<div style="position: relative;"><div class="entry-content container container--entry-content wp-block-post-content is-layout-flow wp-block-post-content-is-layout-flow"> <p>For aficionados of the poster art at Joe Allen restaurant, there is now the Broadway kitsch of seeing Paulo Szot play the very senior member of a boy band in “&amp; Juliet.” This jukebox musical opened Thursday at Broadway’s Stephen Sondheim Theatre after a run on London’s West End.</p> <p>Szot, an erstwhile star of the Metropolitan Opera, won a Tony for playing Emile de Becque in “South Pacific, and he successfully recycles his French accent from that 2008 revival to play the father of Juliet’s love interest in this new musical with a book by David West Read and hit...
</p><div style="position: absolute; height: 100%; width: 100%; bottom: 0px; background-image: linear-gradient(0deg, rgb(255, 255, 255) 0%, rgba(255, 255, 255, 0) 100%);"></div></div></div><style>.zephr-form-progress-bar.svelte-19rlx92{width:100%;border:0;border-radius:20px;margin-top:10px}.zephr-form-progress-bar.svelte-19rlx92::-webkit-progress-bar{background-color:var(--zephr-color-background-tinted);border:0;border-radius:20px}.zephr-form-progress-bar.svelte-19rlx92::-webkit-progress-value{background-color:var(--zephr-color-text-tinted);border:0;border-radius:20px}.zephr-progress-bar-step.svelte-19rlx92{margin:auto;color:var(--zephr-color-text-tinted);font-size:var(--zf-subtext-fontSize);font-family:var(--zf-root-fontFamily);cursor:pointer}.zephr-progress-bar-step.svelte-19rlx92:first-child{margin-left:0}.zephr-progress-bar-step.svelte-19rlx92:last-child{margin-right:0}.zephr-progress-bar-step.disabled.svelte-19rlx92{cursor:default}
.zephr-form-button-top-margin.svelte-gd8hr6{margin-top:20px}.zephr-form-button.svelte-gd8hr6{padding:0 20px;text-decoration:none;text-transform:capitalize;border-radius:calc(var(--zephr-button-borderRadius) * 1px);font-size:var(--zf-button-fontSize);font-weight:normal;cursor:pointer;border-style:solid;border-width:calc(var(--zephr-button-borderWidth) * 1px);border-color:var(--zephr-color-action-tinted);transition:backdrop-filter 0.2s, background-color 0.2s;display:flex;justify-content:center;align-items:center;width:100%;background-color:var(--zephr-color-action-main);color:var(--zf-button-color);position:relative;overflow:hidden;font-family:var(--zf-root-fontFamily)}.zephr-form-button.svelte-gd8hr6:hover{background-color:var(--zephr-color-action-tinted);border-color:var(--zephr-color-action-tinted)}.zephr-form-button.svelte-gd8hr6:disabled{background-color:var(--zephr-color-background-tinted);border-color:var(--zephr-color-background-tinted)}.zephr-form-button.svelte-gd8hr6:disabled:hover{background-color:var(--zephr-color-background-tinted);border-color:var(--zephr-color-background-tinted)}.zephr-form-button.inputHeight.svelte-gd8hr6{height:calc(var(--zephr-input-height) * 1px)}.zephr-form-button.svelte-gd8hr6:not(inputHeight){height:calc(var(--zephr-button-height) * 1px)}.zephr-form-button.aside.svelte-gd8hr6{width:auto;margin-left:10px}
.payment-option-wrapper.svelte-hcxnnv>input[type="radio"].svelte-hcxnnv{display:none}.payment-option-wrapper.svelte-hcxnnv.svelte-hcxnnv{display:flex;flex:1 0 28%;width:100%}.payment-option-wrapper.svelte-hcxnnv.svelte-hcxnnv:only-child{max-width:325px}.box-container.svelte-hcxnnv.svelte-hcxnnv{display:flex;flex-direction:column;flex:1 1 0;width:0;text-align:center}.inner-box.svelte-hcxnnv.svelte-hcxnnv{border:var(--zf-payment-options-border);border-radius:var(--zf-payment-options-borderRadius);background-color:var(--zf-payment-options-bgColor);height:100%;display:flex;flex-direction:column}.box-container.highlighted.svelte-hcxnnv .inner-box.svelte-hcxnnv{border-top-left-radius:0;border-top-right-radius:0}.box-container.svelte-hcxnnv .box-content.svelte-hcxnnv{flex-grow:1;padding:30px 20px;margin:0 10px;overflow:hidden}.box-container.svelte-hcxnnv .styled-box-content.svelte-hcxnnv{color:var(--zephr-color-text-main);font-family:var(--zf-root-fontFamily)}
  .box-container .styled-box-content h1,
  .box-container .styled-box-content h2,
  .box-container .styled-box-content h3,
  .box-container .styled-box-content p,
  .box-container .styled-box-content span
   {color:var(--zephr-color-text-main);font-family:var(--zf-root-fontFamily)}.payment-options-container .box-container .styled-box-content button{color:#fff;background-color:var(--zephr-color-action-main);border-width:calc(var(--zephr-button-borderWidth) * 1px);border-color:var(--zephr-color-action-tinted);border-radius:calc(var(--zephr-button-borderRadius) * 1px);font-size:var(--zf-button-fontSize)}.payment-options-container .box-container .styled-box-content button:hover{background-color:var(--zephr-color-action-tinted);border-color:var(--zephr-color-action-tinted)}.payment-options-container .box-container .box-content img{max-width:210px;height:auto}.box-top.svelte-hcxnnv.svelte-hcxnnv{height:40px}.box-container.highlighted.svelte-hcxnnv .box-top.svelte-hcxnnv{color:var(--zf-payment-options-highlighted-color);background-color:var(--zf-payment-options-highlighted-bgColor);position:relative;border:var(--zf-payment-options-border);border-bottom-width:0;border-radius:var(--zf-payment-options-borderRadius);border-bottom-left-radius:0;border-bottom-right-radius:0;display:flex;justify-content:center;align-items:center}.box-container.highlighted.svelte-hcxnnv .box-top .box-top-text.svelte-hcxnnv{font-weight:bold}.box-container.svelte-hcxnnv .box-bottom.svelte-hcxnnv{min-height:60px;display:flex;flex-direction:column;align-items:center;padding:20px 0 30px;margin:0 30px}.button-sub-text.svelte-hcxnnv.svelte-hcxnnv{margin-top:10px}
.payment-options-container.svelte-tqlhky{flex-wrap:wrap;font-size:var(--zf-payment-options-fontSize);width:100%;color:var(--zf-payment-options-color);line-height:18px;padding:31px 0 20px;display:grid;justify-content:space-evenly;justify-items:center;grid-template-columns:repeat(auto-fit, minmax(300px, 1fr));gap:13px}@media(max-width: 340px){.payment-options-container.svelte-tqlhky{grid-template-columns:repeat(auto-fit, minmax(280px, 1fr))}}
.zephr-form-error-message-min-height.svelte-1ko2lqj{min-height:1.1em}.zephr-form-error-message.svelte-1ko2lqj{color:var(--zephr-color-warning-main);font-size:var(--zf-subtext-fontSize);margin-top:0.5em;position:relative;margin-left:1.2em;margin-right:1.2em}
.zephr-form-input-inner-container.svelte-88cmol{position:relative}.zephr-form-input-full-width.svelte-88cmol{width:100%}.zephr-form-input.svelte-88cmol{width:100%;display:block;height:calc(var(--zephr-input-height) * 1px);padding-left:8px;font-size:var(--zf-input-fontSize);border:calc(var(--zephr-input-borderWidth) * 1px) solid
      var(--zephr-input-borderColor);border-radius:calc(var(--zephr-input-borderRadius) * 1px);transition:border-color 0.25s ease, box-shadow 0.25s ease;outline:0;color:var(--zephr-color-text-main);background-color:var(--zf-input-bgColor);font-family:var(--zf-root-fontFamily)}.zephr-form-input.svelte-88cmol::placeholder{color:var(--zephr-color-background-tinted);font-family:var(--zf-root-fontFamily)}.zephr-form-input-checkbox.svelte-88cmol{width:auto;height:auto;margin:8px 5px 0 0;float:left}.zephr-form-input-radio.svelte-88cmol{position:absolute;opacity:0;cursor:pointer;height:0;width:0}.zephr-form-input-color[type="color"].svelte-88cmol{width:50px;padding:0;border-radius:50%}.zephr-form-input-color[type="color"].svelte-88cmol::-webkit-color-swatch{border:none;border-radius:50%;padding:0}.zephr-form-input-color[type="color"].svelte-88cmol::-webkit-color-swatch-wrapper{border:none;border-radius:50%;padding:0}.zephr-form-input.disabled.svelte-88cmol,.zephr-form-input.disabled.svelte-88cmol:hover{border:calc(var(--zephr-input-borderWidth) * 1px) solid
      var(--zephr-input-borderColor);background-color:var(--zephr-color-background-tinted)}.zephr-form-input.error.svelte-88cmol{border:1px solid var(--zephr-color-warning-main)}
.zephr-form-input-label.svelte-yaw4yg.svelte-yaw4yg{margin-top:10px;display:block;line-height:30px;font-size:var(--zf-subtext-fontSize);color:var(--zephr-color-text-tinted);font-family:var(--zf-root-fontFamily)}.zephr-form-input-label.svelte-yaw4yg.svelte-yaw4yg:first-child{margin-top:0}.zephr-form-input-label.svelte-yaw4yg span.svelte-yaw4yg{display:block}
.svelte-fa-base{height:1em;overflow:visible;transform-origin:center;vertical-align:-0.125em}.svelte-fa-fw{text-align:center;width:1.25em}.svelte-fa-pull-left.svelte-f5ydbn{float:left}.svelte-fa-pull-right.svelte-f5ydbn{float:right}.svelte-fa-size-lg.svelte-f5ydbn{font-size:1.33333em;line-height:0.75em;vertical-align:-0.225em}.svelte-fa-size-sm.svelte-f5ydbn{font-size:0.875em}.svelte-fa-size-xs.svelte-f5ydbn{font-size:0.75em}.spin.svelte-f5ydbn{animation:svelte-f5ydbn-spin 2s 0s infinite linear}.pulse.svelte-f5ydbn{animation:svelte-f5ydbn-spin 1s infinite steps(8)}@keyframes svelte-f5ydbn-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
.svelte-fa-layers.svelte-ff6okk{display:inline-block;position:relative}.svelte-fa-layers.svelte-ff6okk .svelte-fa{position:absolute;bottom:0;left:0;right:0;top:0;margin:auto;text-align:center}.svelte-fa-layers.svelte-ff6okk .svelte-fa-layers-text{position:absolute;top:50%;left:50%;transform:translate(-50%, -50%)}.svelte-fa-layers.svelte-ff6okk .svelte-fa-layers-text span{display:inline-block}.svelte-fa-pull-left.svelte-ff6okk{float:left}.svelte-fa-pull-right.svelte-ff6okk{float:right}.svelte-fa-size-lg.svelte-ff6okk{font-size:1.33333em;line-height:0.75em;vertical-align:-0.225em}.svelte-fa-size-sm.svelte-ff6okk{font-size:0.875em}.svelte-fa-size-xs.svelte-ff6okk{font-size:0.75em}
.container.svelte-1j4jgwv{display:inline-block;height:auto}.svelte-fa-size-lg.svelte-1j4jgwv{font-size:1.33333em;line-height:0.75em;vertical-align:-0.225em}.svelte-fa-size-sm.svelte-1j4jgwv{font-size:0.875em}.svelte-fa-size-xs.svelte-1j4jgwv{font-size:0.75em}
.zephr-form-password-match.svelte-tsrdk3.svelte-tsrdk3{margin:20px 0;justify-content:center}.zephr-form-password-match.svelte-tsrdk3 ul.svelte-tsrdk3{padding-left:0;margin:0}.zephr-form-password-requirement.svelte-tsrdk3.svelte-tsrdk3{display:flex;align-items:center;color:var(--zephr-color-text-tinted);font-size:var(--zf-subtext-fontSize);min-height:20px;font-family:var(--zf-root-fontFamily)}.zephr-form-password-requirement-icon.svelte-tsrdk3.svelte-tsrdk3{margin-right:10px;font-size:15px}
.zephr-form-password-progress.svelte-1bpbne4.svelte-1bpbne4{display:flex;margin-top:10px}.zephr-form-password-bar.svelte-1bpbne4.svelte-1bpbne4{width:100%;height:4px;border-radius:2px}.zephr-form-password-bar.svelte-1bpbne4.svelte-1bpbne4:not(:first-child){margin-left:8px}.zephr-form-password-requirements.svelte-1bpbne4.svelte-1bpbne4{margin:20px 0;justify-content:center}.zephr-form-password-requirements.svelte-1bpbne4 ul.svelte-1bpbne4{padding-left:0;margin:0}.zephr-form-password-requirement.svelte-1bpbne4.svelte-1bpbne4{display:flex;align-items:center;color:var(--zephr-color-text-tinted);font-size:var(--zf-subtext-fontSize);min-height:20px;font-family:var(--zf-root-fontFamily)}.zephr-form-password-requirement-icon.svelte-1bpbne4.svelte-1bpbne4{margin-right:10px;font-size:15px}
.apple-pay-button{display:inline-block;-webkit-appearance:-apple-pay-button;-apple-pay-button-type:pay;width:440px;max-width:100%;height:45px;margin-top:20px}.apple-pay-button-black{-apple-pay-button-style:black}#google-pay-button.svelte-1drqjgk{width:440px;max-width:100%;height:45px;margin-top:20px}
#braintree-dropin-container.svelte-w52z2j{margin-top:1em;margin-bottom:1em}
.stripe-element.svelte-1bi6tmz{margin-top:2em;margin-bottom:1em;border:calc(var(--zephr-input-borderWidth) * 1px) solid
      var(--zephr-input-borderColor);border-radius:calc(var(--zephr-input-borderRadius) * 1px);padding:1em}.stripe-element.svelte-1bi6tmz iframe:focus{outline:none !important}
#stripe-mobile-pay-button.svelte-12ehv8b{width:440px;max-width:100%;height:45px;margin-top:20px}
.spinner-container.svelte-1c5ov4v{text-align:center;padding:2em}
#zuora_payment.svelte-1vnsk3p{margin-top:1em;margin-bottom:1em}.zuora-disabled-iframe-container.svelte-1vnsk3p .z_hppm_iframe{pointer-events:none;opacity:0.3}.zuora-dynamic-form-disabled.svelte-1vnsk3p{pointer-events:none;opacity:0.3}.spinner-overlay.svelte-1vnsk3p{width:100%;height:100%;position:absolute;top:0;left:0;display:flex;align-items:center;justify-content:center}.form-wrapper.svelte-1vnsk3p{position:relative}
#payment-element.svelte-1ejcgdg{margin-top:1em;margin-bottom:1em;border:calc(var(--zephr-input-borderWidth) * 1px) solid
            var(--zephr-input-borderColor);border-radius:calc(var(--zephr-input-borderRadius) * 1px);padding:1em}
.zephr-form-checkbox.svelte-ud4i0a.svelte-ud4i0a.svelte-ud4i0a{position:absolute;opacity:0;cursor:pointer;height:0;width:0}.zephr-form-checkbox-label.svelte-ud4i0a.svelte-ud4i0a.svelte-ud4i0a{display:flex;align-items:center;font-family:var(--zf-root-fontFamily)}.zephr-form-checkmark.svelte-ud4i0a.svelte-ud4i0a.svelte-ud4i0a{position:relative;box-sizing:border-box;height:23px;width:23px;background-color:#fff;border:calc(var(--zephr-input-borderWidth) * 1px) solid
      var(--zephr-input-borderColor);border-radius:6px;margin-right:12px;cursor:pointer}.zephr-form-checkmark.checked.svelte-ud4i0a.svelte-ud4i0a.svelte-ud4i0a{border-color:var(--zephr-color-action-main)}.zephr-form-checkmark.checked.svelte-ud4i0a.svelte-ud4i0a.svelte-ud4i0a:after{content:"";position:absolute;width:6px;height:13px;border:solid var(--zephr-color-action-main);border-width:0 2px 2px 0;transform:rotate(45deg);top:3px;left:8px;box-sizing:border-box}.zephr-form-checkmark.disabled.svelte-ud4i0a.svelte-ud4i0a.svelte-ud4i0a{border:calc(var(--zephr-input-borderWidth) * 1px) solid
      var(--zephr-color-background-tinted)}.zephr-form-checkmark.disabled.checked.svelte-ud4i0a.svelte-ud4i0a.svelte-ud4i0a:after{border:solid var(--zephr-color-background-tinted);border-width:0 2px 2px 0}.zephr-form-checkmark.error.svelte-ud4i0a.svelte-ud4i0a.svelte-ud4i0a{border:calc(var(--zephr-input-borderWidth) * 1px) solid
      var(--zephr-color-warning-main)}.zephr-form-checkbox.svelte-ud4i0a:focus-visible+.zephr-form-checkbox-label.svelte-ud4i0a>.zephr-form-checkmark.svelte-ud4i0a{outline:2px solid var(--zephr-color-action-main);outline-color:-webkit-focus-ring-color}
.zephr-form-payment-auto-renew-toggle.svelte-1yfwddr{margin:10px 0;font-size:var(--zf-font-size-base);font-family:var(--zf-root-fontFamily)}
.check-image.svelte-w5z6iw{height:1.2em;vertical-align:middle;margin-right:0.5em}.zephr-form-success-message.svelte-w5z6iw{color:var(--zephr-color-text-main);display:inline-block}
.zephr-form-verification-resend-link-container.svelte-1yj9ceh{margin-bottom:2em}.zephr-form-verification-resend-link.svelte-1yj9ceh,.zephr-form-verification-resend-text.svelte-1yj9ceh{float:right;position:absolute;padding-right:2px;padding-top:0.5em;padding-left:0.5em;font-size:var(--zf-subtext-fontSize);right:0}.zephr-form-verification-resend-link.svelte-1yj9ceh{cursor:pointer;color:var(--zf-link-color)}
.zephr-form-custom-text.svelte-3sd7s2{margin-top:1em;margin-bottom:1em;color:var(--zephr-color-text-main)}
.zephr-form-input-radio.svelte-1cbmaif.svelte-1cbmaif.svelte-1cbmaif{position:absolute;opacity:0;cursor:pointer;height:0;width:0}.zephr-form-radio-label.svelte-1cbmaif.svelte-1cbmaif.svelte-1cbmaif{display:flex;align-items:center;font-family:var(--zf-root-fontFamily)}.zephr-form-radio-dot.svelte-1cbmaif.svelte-1cbmaif.svelte-1cbmaif{display:block;position:relative;box-sizing:border-box;height:23px;width:23px;background-color:#fff;border:1px solid #ebebeb;border-radius:50%;margin-right:12px;cursor:pointer}.checked.svelte-1cbmaif.svelte-1cbmaif.svelte-1cbmaif{border-color:var(--zephr-color-action-main)}.checked.svelte-1cbmaif.svelte-1cbmaif.svelte-1cbmaif:after{content:"";position:absolute;width:17px;height:17px;background:var(--zephr-color-action-main);border-radius:50%;top:2px;left:2px}.disabled.checked.svelte-1cbmaif.svelte-1cbmaif.svelte-1cbmaif:after{background:var(--zephr-color-background-tinted)}.error.svelte-1cbmaif.svelte-1cbmaif.svelte-1cbmaif{border:1px solid var(--zephr-color-warning-main)}.zephr-form-input-radio.svelte-1cbmaif:focus-visible+.zephr-form-radio-label.svelte-1cbmaif>.zephr-form-radio-dot.svelte-1cbmaif{outline:2px solid var(--zephr-color-action-main);outline-color:-webkit-focus-ring-color}
.zephr-form-input-error-text.svelte-wlae04{color:var(--zephr-color-warning-main);font-family:var(--zf-root-fontFamily)}.zephr-form-input-select.svelte-wlae04{display:block;appearance:auto;width:100%;height:calc(var(--zephr-input-height) * 1px);font-size:var(--zf-input-fontSize);font-family:var(--zf-root-fontFamily);border:calc(var(--zephr-input-borderWidth) * 1px) solid
      var(--zephr-input-borderColor);border-radius:calc(var(--zephr-input-borderRadius) * 1px);transition:border-color 0.25s ease, box-shadow 0.25s ease;outline:0;color:var(--zephr-color-text-main);background-color:var(--zf-input-bgColor);padding:10px}.zephr-form-input-select.unselected.svelte-wlae04{color:var(--zephr-color-background-tinted)}.zephr-form-input-select.error.svelte-wlae04{border-color:var(--zephr-color-warning-main)}.zephr-form-input-textarea.svelte-wlae04{display:block;min-height:calc(var(--zephr-input-height) * 1px);min-width:100%;max-width:100%;background-color:var(--zf-input-bgColor);border:calc(var(--zephr-input-borderWidth) * 1px) solid var(--zephr-input-borderColor);border-radius:calc(var(--zephr-input-borderRadius) * 1px);transition:border-color 0.25s ease, box-shadow 0.25s ease;color:var(--zephr-color-text-main);font-size:var(--zf-input-fontSize);font-weight:300;padding:16px 8px;font-family:var(--zf-root-fontFamily);outline:0}.zephr-form-input-textarea.svelte-wlae04::placeholder{color:var(--zephr-color-background-tinted);font-family:var(--zf-root-fontFamily)}.zephr-form-input-slider-output.svelte-wlae04{margin:13px 0 0 10px}
.zephr-form-link.svelte-14vxk2u{margin:10px 0;color:var(--zf-link-color);text-decoration:underline;cursor:pointer;font-family:var(--zf-root-fontFamily)}.zephr-form-link-disabled.svelte-14vxk2u{color:var(--zephr-color-text-main);cursor:not-allowed;text-decoration:none}.zephr-form-link-no-underline.svelte-14vxk2u{text-decoration:none}
.zephr-form-reset-link-container.svelte-49aomy{min-height:2.5em}.zephr-form-link-message.svelte-49aomy{margin:10px 0 10px 20px;font-family:var(--zf-root-fontFamily)}
.zephr-form-reset-link-container.svelte-49aomy{min-height:2.5em}.zephr-form-link-message.svelte-49aomy{margin:10px 0 10px 20px;font-family:var(--zf-root-fontFamily)}
.zephr-form-google-icon.svelte-aktnoc{width:20px}
.zephr-form-social-sign-in.svelte-1e2xtn4{align-items:center}.zephr-form-social-sign-in-button.svelte-1e2xtn4{width:100%;min-height:55px;padding:15px;color:#000;background-color:#fff;box-shadow:0 0 5px rgba(0, 0, 0, 0.3);border-radius:10px;font-size:17px;display:flex;align-items:center;cursor:pointer;margin-top:20px;font-family:var(--zf-root-fontFamily)}.zephr-form-social-sign-in-button.svelte-1e2xtn4:hover{background-color:#fafafa}.zephr-form-social-sign-in-icon.svelte-1e2xtn4{display:flex;justify-content:center;margin-right:30px;width:25px}
.zephr-form-promo-input-container.svelte-xf8v79{flex:0.6}.zephr-form-promo-activate-line.svelte-xf8v79{display:flex;cursor:pointer;min-height:calc(var(--zephr-input-height) * 1px);margin:1em 1.2em;font-size:var(--zf-payment-summary-fontSize);line-height:calc(var(--zephr-input-height) * 1px);color:var(--zf-link-color)}.zephr-form-promo-line.svelte-xf8v79{display:flex;min-height:calc(var(--zephr-input-height) * 1px);margin:1em 1.2em}.zephr-form-addon-line.svelte-xf8v79{display:flex;padding-top:1em;padding-bottom:1em;margin-left:1.2em}.zephr-form-summary-prorate-disclaimer.svelte-xf8v79{padding-top:0.25em;padding-left:1em;color:var(--zephr-color-text-tinted)}.zephr-form-summary-charge-description.svelte-xf8v79{color:var(--zephr-color-text-tinted)}.zephr-form-charge-line.svelte-xf8v79{display:flex;padding-top:1em;margin-left:1.2em;padding-left:1em}.zephr-form-summary-line-right.svelte-xf8v79{margin-left:auto;margin-right:1.5em;text-align:right}.zephr-form-summary-line-left.svelte-xf8v79{margin-left:10px}.zephr-form-summary-promo-middle.svelte-xf8v79{position:relative;top:calc(var(--zephr-input-height) * 0.5px)}.zephr-form-summary.svelte-xf8v79{border:var(--zf-payment-summary-border);border-radius:var(--zf-payment-summary-borderRadius);padding-top:1em;padding-bottom:1em;font-size:var(--zf-payment-summary-fontSize);margin-top:1.5em;margin-bottom:1.5em;color:var(--zf-payment-summary-color);background-color:var(--zf-payment-summary-bgColor)}.zephr-form-summary.svelte-xf8v79:first-child{margin-top:0}.zephr-form-summary-title.svelte-xf8v79{margin-bottom:1em;margin-left:1.2em}.zephr-form-summary-price-line.svelte-xf8v79{font-weight:bold;padding-left:1em;padding-top:1em}.zephr-form-summary-line.svelte-xf8v79{display:flex}.zephr-form-summary-price-line-upper.svelte-xf8v79{border-top:var(--zf-payment-summary-border);margin-top:1em}.zephr-form-summary-line-title.svelte-xf8v79{flex:0 0 65%;margin-left:1.2em}.zephr-form-summary-line-price.svelte-xf8v79{flex:1;text-align:right;margin-right:1.5em}.zephr-form-discount-line.svelte-xf8v79{display:flex;justify-content:space-between;margin:0.5em 0;margin-left:1.2em}
.zephr-form-divider-container.svelte-1jhhsfx{display:flex;align-items:center;justify-content:center;margin:1.5em 0}.zephr-form-divider-line.svelte-1jhhsfx{height:1px;width:50%;margin:0 5px;background-color:var(--zephr-color-text-tinted)}.zephr-form-divider-line-complete.svelte-1jhhsfx{height:1px;width:100%;margin:0 5px;background-color:var(--zephr-color-text-tinted)}.zephr-form-divider-text.svelte-1jhhsfx{margin:0 12px;color:var(--zephr-color-text-main);font-size:var(--zf-info-fontSize);font-family:var(--zf-root-fontFamily);white-space:nowrap}
.zephr-form-login-link.svelte-1jmemom.svelte-1jmemom{margin-top:1em;margin-bottom:1em;text-align:center}.zephr-form-login-link.svelte-1jmemom>a.svelte-1jmemom{color:var(--zf-link-color);margin-left:0.25em}
.zephr-form-account-code-container.svelte-1hhep92{margin-top:1.5em}
.zephr-form-invitation-container.svelte-1qkv7d3{border:1px solid;margin:1.5em 0;padding:20px;color:var(--zephr-color-text-main)}.zephr-form-invitation-title.svelte-1qkv7d3{margin-bottom:20px;font-weight:bold;font-family:var(--zf-root-fontFamily)}.zephr-form-invitation-email.svelte-1qkv7d3{display:flex;align-items:center}.zephr-form-invitation-input-container.svelte-1qkv7d3{flex-grow:1}.zephr-form-invitation-success-message.svelte-1qkv7d3{margin-top:0.5em}
.subscription-option-product-label{margin-bottom:5px;margin-top:0}.subscription-option-wrapper.svelte-1gr56ov{display:flex;flex:1 0 28%;width:100%;max-width:400px}.subscription-option-wrapper.svelte-1gr56ov:only-child{max-width:325px}.subscription-option-box{display:flex;flex-direction:column;flex:1 1 0;width:0}.info-row.svelte-1gr56ov{margin-top:7px;margin-bottom:7px}.info-label.svelte-1gr56ov{display:inline;margin-right:10px}.info.svelte-1gr56ov{display:inline}hr.svelte-1gr56ov{border-width:1px 0px 0px;margin:5px 5px;border-color:var(--zephr-color-background-tinted)}.inner-box.svelte-1gr56ov{border:var(--zf-payment-options-border);border-radius:var(--zf-payment-options-borderRadius);background-color:var(--zf-payment-options-bgColor);height:100%;display:flex;flex-direction:column;flex-grow:1;padding:20px 20px;margin:0 10px;overflow:hidden}.change-disabled-label.svelte-1gr56ov{margin-top:15px}
.subscription-options-container.svelte-bnxnvq{flex-wrap:wrap;font-size:var(--zf-payment-options-fontSize);width:100%;color:var(--zf-payment-options-color);line-height:18px;padding:31px 0 20px;display:grid;justify-content:space-evenly;justify-items:center;grid-template-columns:repeat(auto-fit, minmax(300px, 1fr));gap:13px}@media(max-width: 340px){.subscription-options-container.svelte-bnxnvq{grid-template-columns:repeat(auto-fit, minmax(280px, 1fr))}}
.subscription-list-item.svelte-1qhs7yc{font-family:var(--zephr-typography-body-font), var(--zephr-typography-body-fallbackFont);color:var(--zephr-color-text-main)}hr.svelte-1qhs7yc{border-width:1px 0px 0px;margin:20px 0px;border-color:var(--zephr-color-background-tinted)}.inactive.svelte-1qhs7yc{text-decoration:line-through}h3.svelte-1qhs7yc{margin:0 0 20px}.inner-box.svelte-1qhs7yc{display:flex;flex-direction:column;flex-grow:1;padding:30px 20px;margin:0 10px;overflow:hidden;min-width:300px}.gift-pill.svelte-1qhs7yc{display:inline-block;background-color:var(--zephr-color-background-tinted);color:var(--zephr-color-text-main);font-size:0.75rem;font-weight:600;padding:3px 8px;border-radius:12px;margin-left:8px;vertical-align:middle}
.zephr-form-tablink.svelte-py0ruk{display:flex;align-items:center;cursor:pointer;justify-content:space-between;text-decoration:none;color:var(--zephr-color-text-main);font-weight:590;padding:var(--zf-list-subscriptions-section-padding);border-bottom:1px solid var(--zephr-color-background-tinted)}.zephr-form-tablink.svelte-py0ruk:hover{text-decoration:underline}.zephr-form-tablink.svelte-py0ruk:last-child{border-bottom:none
  }
.zephr-subscription-list-box-item.svelte-xxnasy.svelte-xxnasy{font-family:var(--zephr-typography-body-font),
      var(--zephr-typography-body-fallbackFont);color:var(--zephr-color-text-main);max-width:var(--zf-list-subscriptions-container-maxWidth);border-radius:var(--zf-list-subscriptions-container-borderRadius);border:var(--zf-list-subscriptions-container-border);padding:var(--zf-list-subscriptions-container-padding)}.zephr-inner-box.svelte-xxnasy.svelte-xxnasy{display:flex;flex-direction:column;flex-grow:1}.zephr-box-item-information.svelte-xxnasy.svelte-xxnasy{font-size:var(--zf-list-subscriptions-info-fontSize);color:var(--zephr-color-text-tinted);margin-top:8px}.zephr-section.svelte-xxnasy.svelte-xxnasy{padding:var(--zf-list-subscriptions-section-padding);border-bottom:1px solid var(--zephr-color-background-tinted);gap:8px}.zephr-section.svelte-xxnasy.svelte-xxnasy:first-child{padding-top:0;border-bottom:none}.zephr-section.svelte-xxnasy.svelte-xxnasy:last-child{border-bottom:none}.zephr-section.svelte-xxnasy span.svelte-xxnasy{font-weight:590}.zephr-section.svelte-xxnasy h2.svelte-xxnasy{margin:0}.gift-pill.svelte-xxnasy.svelte-xxnasy{display:inline-block;background-color:var(--zephr-color-background-tinted);color:var(--zephr-color-text-main);font-size:0.75rem;font-weight:600;padding:3px 8px;border-radius:12px;margin-left:8px;vertical-align:middle}.auto-renew-toggle-container.svelte-xxnasy.svelte-xxnasy{display:flex;align-items:center;gap:8px}.updating-indicator.svelte-xxnasy.svelte-xxnasy{font-size:0.85rem;color:var(--zephr-color-text-tinted);font-style:italic}.status-message.svelte-xxnasy.svelte-xxnasy{margin-top:8px;font-size:0.85rem}.status-message.success.svelte-xxnasy.svelte-xxnasy{color:#28a745}.status-message.error.svelte-xxnasy.svelte-xxnasy{color:#dc3545}
.subscriptions-list-container.svelte-ldb1rq{margin-top:40px;display:flex;flex-direction:column;gap:40px}
.past-subscriptions-link-wrapper.svelte-zpa2t{margin:10px 0}
.event-link-wrapper{margin-top:10px}.float-right.svelte-3cxpfz{float:right;margin-top:calc(var(--zephr-input-height) * -1px + 5px)}
.bold-label.svelte-nx4w5y label{font-weight:bold}.read-only-input.svelte-nx4w5y{border:none;background:none;color:#333;cursor:default;outline:none;flex-grow:1;margin-right:10px;margin-top:15px}.zephr-form-relative-container.svelte-nx4w5y{display:flex;align-items:center;justify-content:space-between;width:100%}.update-link{white-space:nowrap;text-decoration:none;font-size:0.75em}
.bold-label.svelte-nx4w5y label{font-weight:bold}.read-only-input.svelte-nx4w5y{border:none;background:none;color:#333;cursor:default;outline:none;flex-grow:1;margin-right:10px;margin-top:15px}.zephr-form-relative-container.svelte-nx4w5y{display:flex;align-items:center;justify-content:space-between;width:100%}.update-link{white-space:nowrap;text-decoration:none;font-size:0.75em}
.zephr-form-ro-attribute{display:flex;align-items:center;height:50px;justify-content:flex-start}.zephr-form-ro-attribute-label{margin-right:10px;&:after {
      content: ": ";
    }}
hr.svelte-jmotet{border-width:1px 0px 0px;margin:20px 0px;border-color:var(--zephr-color-background-tinted)}.session-container.svelte-jmotet{padding:15px;display:flex;flex-direction:column}.device-title.svelte-jmotet{font-weight:bold;font-size:1.2em;margin-bottom:10px}.current-device.svelte-jmotet{color:#777;font-size:0.9em;margin-left:10px}.login-time.svelte-jmotet,.browser.svelte-jmotet,.country.svelte-jmotet{margin-bottom:10px;font-size:0.9em}
.sign-out-all.svelte-1ogdv39{color:#0073e6;cursor:pointer;font-size:1em;margin:20px 0;text-align:center}.sign-out-all.svelte-1ogdv39:hover{text-decoration:underline}
.table.svelte-7sscau.svelte-7sscau{display:grid;grid-template-columns:0.7fr 1.4fr 1fr 0.6fr}.table-head.svelte-7sscau.svelte-7sscau{display:contents}.table-row.svelte-7sscau.svelte-7sscau{display:contents}.table-head.svelte-7sscau>div.svelte-7sscau{font-size:13px;padding:13px 10px 10px;border-bottom:1px solid var(--zephr-color-background-tinted)}.table-row.svelte-7sscau>div.svelte-7sscau{font-size:var(--zf-info-fontSize);height:60px;padding:0 10px;border-bottom:1px solid var(--zephr-color-background-tinted);display:flex;align-items:center}.table-head.svelte-7sscau>div.svelte-7sscau:first-child,.table-row.svelte-7sscau>div.svelte-7sscau:first-child{padding-left:0}.table-head.svelte-7sscau>div.svelte-7sscau:last-child,.table-row.svelte-7sscau>div.svelte-7sscau:last-child{padding-right:0}.taxes.svelte-7sscau.svelte-7sscau{color:var(--zephr-color-background-tinted);white-space:pre;font-size:small}
.zephr-form-button-group.svelte-5uv9ua{display:flex;flex-direction:row;gap:12px;margin-top:20px}.zephr-form-back-button.svelte-5uv9ua{padding:0 20px;border-radius:calc(var(--zephr-button-borderRadius) * 1px);border-style:solid;border-width:calc(var(--zephr-button-borderWidth) * 1px);border-color:var(--zephr-color-action-main);display:flex;justify-content:center;align-items:center;width:100%;background-color:var(--zephr-color-action-main);color:var(--zf-button-color);cursor:pointer}.zephr-form-continue-button.svelte-5uv9ua{padding:0 20px;border-radius:calc(var(--zephr-button-borderRadius) * 1px);border-style:solid;border-width:calc(var(--zephr-button-borderWidth) * 1px);border-color:var(--zephr-color-action-main);display:flex;justify-content:center;align-items:center;width:100%;background-color:var(--zf-button-color);color:var(--zephr-color-action-main);cursor:pointer}.zephr-form-back-button.svelte-5uv9ua:hover{background-color:var(--zephr-color-action-tinted);border-color:var(--zephr-color-action-tinted)}.zephr-form-continue-button.svelte-5uv9ua:hover{background-color:var(--zephr-color-action-tinted);border-color:var(--zephr-color-action-tinted);color:var(--zf-button-color)}.zephr-form-back-button.svelte-5uv9ua:not(inputHeight){height:calc(var(--zephr-button-height) * 1px)}.zephr-form-continue-button.svelte-5uv9ua:not(inputHeight){height:calc(var(--zephr-button-height) * 1px)}
.zephr-form-button.svelte-1uaz0r{padding:0 20px;text-decoration:none;text-transform:capitalize;border-radius:calc(var(--zephr-button-borderRadius) * 1px);font-size:var(--zf-button-fontSize);font-weight:normal;cursor:pointer;border-style:solid;border-width:calc(var(--zephr-button-borderWidth) * 1px);border-color:var(--zephr-color-action-tinted);transition:backdrop-filter 0.2s, background-color 0.2s;display:flex;justify-content:center;align-items:center;width:100%;background-color:var(--zephr-color-action-main);color:var(--zf-button-color);position:relative;overflow:hidden;font-family:var(--zf-root-fontFamily);height:calc(var(--zephr-button-height) * 1px)}.zephr-form-button.svelte-1uaz0r:hover{background-color:var(--zephr-color-action-tinted);border-color:var(--zephr-color-action-tinted);color:var(--zf-button-color)}.zephr-form-button-top-margin.svelte-1uaz0r{margin-top:20px}
.recipient-name-section.svelte-hvl7z2{margin-top:1rem;margin-bottom:1rem}.field.svelte-hvl7z2{margin-bottom:0.5rem}label.svelte-hvl7z2{display:block;margin-bottom:0.5rem;color:var(--zephr-color-text-tinted);font-family:var(--zf-root-fontFamily)}input.svelte-hvl7z2{width:100%;padding:0.5rem;border:calc(var(--zephr-input-borderWidth) * 1px) solid var(--zephr-input-borderColor);border-radius:calc(var(--zephr-input-borderRadius) * 1px);background-color:var(--zf-input-bgColor);color:var(--zephr-color-text-main);font-family:var(--zf-root-fontFamily)}input.svelte-hvl7z2::placeholder{color:var(--zephr-color-background-tinted);font-family:var(--zf-root-fontFamily)}input.svelte-hvl7z2:focus{outline:none;border-color:var(--zephr-color-action-main)}.error.svelte-hvl7z2{border-color:var(--zephr-color-warning-main) !important}.error-text.svelte-hvl7z2{color:var(--zephr-color-warning-main);font-size:0.875em;margin-top:0.25rem;font-family:var(--zf-root-fontFamily)}
.recipient-email-section.svelte-1odylgp{margin-bottom:1rem}.field.svelte-1odylgp{margin-bottom:0.5rem}label.svelte-1odylgp{display:block;margin-bottom:0.5rem;color:var(--zephr-color-text-tinted);font-family:var(--zf-root-fontFamily)}input.svelte-1odylgp{width:100%;padding:0.5rem;border:calc(var(--zephr-input-borderWidth) * 1px) solid var(--zephr-input-borderColor);border-radius:calc(var(--zephr-input-borderRadius) * 1px);background-color:var(--zf-input-bgColor);color:var(--zephr-color-text-main);font-family:var(--zf-root-fontFamily)}input.svelte-1odylgp::placeholder{color:var(--zephr-color-background-tinted);font-family:var(--zf-root-fontFamily)}input.svelte-1odylgp:focus{outline:none;border-color:var(--zephr-color-action-main)}.error.svelte-1odylgp{border-color:var(--zephr-color-warning-main) !important}.error-text.svelte-1odylgp{color:var(--zephr-color-warning-main);font-size:0.875em;margin-top:0.25rem;font-family:var(--zf-root-fontFamily)}
.recipient-address-section.svelte-iu0vdb{margin-bottom:1rem}.address-main-label.svelte-iu0vdb{display:block;margin-bottom:0.75rem;color:var(--zephr-color-text-tinted);font-family:var(--zf-root-fontFamily);font-weight:600}.address-fields.svelte-iu0vdb{display:grid;grid-template-columns:repeat(2, 1fr);gap:1rem}.full-width.svelte-iu0vdb{grid-column:1 / -1}.field.svelte-iu0vdb{margin-bottom:0.5rem}label.svelte-iu0vdb{display:block;margin-bottom:0.5rem;color:var(--zephr-color-text-tinted);font-family:var(--zf-root-fontFamily)}input.svelte-iu0vdb{width:100%;padding:0.5rem;border:calc(var(--zephr-input-borderWidth) * 1px) solid var(--zephr-input-borderColor);border-radius:calc(var(--zephr-input-borderRadius) * 1px);background-color:var(--zf-input-bgColor);color:var(--zephr-color-text-main);font-family:var(--zf-root-fontFamily)}input.svelte-iu0vdb::placeholder{color:var(--zephr-color-background-tinted);font-family:var(--zf-root-fontFamily)}input.svelte-iu0vdb:focus{outline:none;border-color:var(--zephr-color-action-main)}.error-text.svelte-iu0vdb{color:var(--zephr-color-warning-main);font-size:0.875em;margin-top:0.25rem;font-family:var(--zf-root-fontFamily)}@media(max-width: 640px){.address-fields.svelte-iu0vdb{grid-template-columns:1fr}}
.recipient-message-section.svelte-h6tpk7{margin-top:1rem;margin-bottom:1rem}.field.svelte-h6tpk7{margin-bottom:0.5rem}label.svelte-h6tpk7{display:block;margin-bottom:0.5rem;color:var(--zephr-color-text-tinted);font-family:var(--zf-root-fontFamily)}textarea.svelte-h6tpk7{width:100%;min-height:100px;resize:vertical;padding:0.5rem;border:calc(var(--zephr-input-borderWidth) * 1px) solid var(--zephr-input-borderColor);border-radius:calc(var(--zephr-input-borderRadius) * 1px);background-color:var(--zf-input-bgColor);color:var(--zephr-color-text-main);font-family:var(--zf-root-fontFamily)}textarea.svelte-h6tpk7::placeholder{color:var(--zephr-color-background-tinted);font-family:var(--zf-root-fontFamily)}textarea.svelte-h6tpk7:focus{outline:none;border-color:var(--zephr-color-action-main)}
.zephr-form-input-wrapper.svelte-764k6k{display:flex;flex-direction:column;margin-bottom:16px;width:100%}label.svelte-764k6k{margin-bottom:8px;font-weight:500}input.svelte-764k6k{padding:12px;border-radius:var(--input-border-radius, 4px);border:var(--input-border-width, 1px) solid var(--input-border-color, #ccc);font-size:16px;height:var(--input-height, 50px);box-sizing:border-box}input.svelte-764k6k:focus{outline:none;border-color:var(--color-action-main, #006EDB)}input.error.svelte-764k6k{border-color:var(--color-warning-main, #D90B00)}.error-message.svelte-764k6k{color:var(--color-warning-main, #D90B00);font-size:14px;margin-top:4px}.required.svelte-764k6k{color:var(--color-warning-main, #D90B00)}
.zephr-gift-list-box-item.svelte-srvimy.svelte-srvimy{margin-bottom:1.5rem;font-family:var(--zephr-typography-body-font), var(--zephr-typography-body-fallbackFont);color:var(--zephr-color-text-main);max-width:var(--zf-list-subscriptions-container-maxWidth);border-radius:var(--zf-list-subscriptions-container-borderRadius);border:var(--zf-list-subscriptions-container-border);padding:var(--zf-list-subscriptions-container-padding);position:relative;overflow:hidden;background-color:white}.zephr-inner-box.svelte-srvimy.svelte-srvimy{display:flex;flex-direction:column;flex-grow:1;padding-top:20px}.zephr-banner-top.svelte-srvimy.svelte-srvimy{background-color:black;color:white;padding:5px 1.5rem;width:100%;font-size:0.875rem;text-align:center;position:absolute;top:0;left:0;right:0}.zephr-header-section.svelte-srvimy.svelte-srvimy{position:relative}.zephr-status-pill.svelte-srvimy.svelte-srvimy{position:absolute;top:0;right:0;display:inline-block;padding:4px 12px;border-radius:16px;font-size:0.75rem;font-weight:500;color:white;background-color:black}.zephr-section.svelte-srvimy.svelte-srvimy{padding:var(--zf-list-subscriptions-section-padding);gap:8px}.zephr-section.svelte-srvimy.svelte-srvimy:first-child{padding-top:0}.zephr-section.svelte-srvimy span.svelte-srvimy{font-weight:590;display:block;margin-bottom:0.25rem}.zephr-box-item-information.svelte-srvimy.svelte-srvimy{font-size:var(--zf-list-subscriptions-info-fontSize);color:var(--zephr-color-text-tinted);margin-top:8px}
.subscriptions-list-container.svelte-ldb1rq{margin-top:40px;display:flex;flex-direction:column;gap:40px}
.zephr-form-gift-toggle.svelte-93167f{margin:10px 0;font-size:var(--zf-font-size-base);font-family:var(--zf-root-fontFamily)}
.zephr-form-gift-future-date-toggle.svelte-c9nudz{margin:10px 0;font-size:var(--zf-font-size-base);font-family:var(--zf-root-fontFamily)}.zephr-form-gift-future-date-toggle-description.svelte-c9nudz{margin:5px 0 0 0;font-size:var(--zf-font-size-small, 14px);color:var(--zf-color-text-secondary, #666);line-height:1.4}
.zephr-form-gift-future-date-input.svelte-1vykgtl{margin:10px 0;font-size:var(--zf-font-size-base);font-family:var(--zf-root-fontFamily)}.zephr-form-gift-future-date-input-description.svelte-1vykgtl{margin:5px 0 0 0;font-size:var(--zf-font-size-small, 14px);color:var(--zf-color-text-secondary, #666);line-height:1.4}
.suspend-resume-subscription-section.svelte-1hog2jr{margin-top:1rem;margin-bottom:1rem}.field.svelte-1hog2jr{margin-bottom:0.5rem}label.svelte-1hog2jr{display:block;margin-bottom:0.5rem;color:var(--zephr-color-text-tinted);font-family:var(--zf-root-fontFamily)}input.svelte-1hog2jr{width:100%;padding:0.5rem;border:calc(var(--zephr-input-borderWidth) * 1px) solid var(--zephr-input-borderColor);border-radius:calc(var(--zephr-input-borderRadius) * 1px);background-color:var(--zf-input-bgColor);color:var(--zephr-color-text-main);font-family:var(--zf-root-fontFamily)}input.svelte-1hog2jr::placeholder{color:var(--zephr-color-background-tinted);font-family:var(--zf-root-fontFamily)}input.svelte-1hog2jr:focus{outline:none;border-color:var(--zephr-color-action-main)}.error.svelte-1hog2jr{border-color:var(--zephr-color-warning-main) !important}.error-text.svelte-1hog2jr{color:var(--zephr-color-warning-main);font-size:0.875em;margin-top:0.25rem;font-family:var(--zf-root-fontFamily)}
.subscription-custom-fields-update.svelte-t6s0pv{max-width:600px;margin:0 auto;padding:1rem}.title.svelte-t6s0pv{font-size:1.5rem;font-weight:600;margin-bottom:0.5rem;color:var(--text-color, #333)}.description.svelte-t6s0pv{color:var(--text-secondary, #666);margin-bottom:1rem;line-height:1.5}.subscription-info.svelte-t6s0pv{background:var(--background-light, #f8f9fa);padding:0.75rem;border-radius:4px;margin-bottom:1rem;border:1px solid var(--border-color, #e0e0e0)}.custom-fields-form.svelte-t6s0pv{display:flex;flex-direction:column;gap:1.5rem}.field-group.svelte-t6s0pv{display:flex;flex-direction:column;gap:0.25rem;padding:1rem;background:var(--background-light, #f8f9fa);border-radius:4px;border:1px solid var(--border-color, #e0e0e0)}.textarea-input.svelte-t6s0pv{min-height:80px;padding:0.75rem;border:1px solid var(--border-color, #ccc);border-radius:4px;font-family:inherit;font-size:1rem;resize:vertical;transition:border-color 0.2s}.textarea-input.svelte-t6s0pv:focus{outline:none;border-color:var(--primary-color, #007bff);box-shadow:0 0 0 2px var(--primary-color-alpha, rgba(0, 123, 255, 0.25))}.textarea-input.error.svelte-t6s0pv{border-color:var(--error-color, #dc3545)}.textarea-input.svelte-t6s0pv:disabled{background-color:var(--background-disabled, #f5f5f5);cursor:not-allowed}.error-message.svelte-t6s0pv{margin-top:0.5rem}.success-message.svelte-t6s0pv{padding:0.75rem;background:var(--success-background, #d4edda);border:1px solid var(--success-border, #c3e6cb);border-radius:4px;margin-top:0.5rem}.success-text.svelte-t6s0pv{color:var(--success-color, #155724);margin:0}.button-group.svelte-t6s0pv{display:flex;gap:0.75rem;margin-top:1rem}.submit-button.svelte-t6s0pv,.cancel-button.svelte-t6s0pv{padding:0.75rem 1.5rem;border:none;border-radius:4px;font-size:1rem;font-weight:500;cursor:pointer;transition:all 0.2s;display:flex;align-items:center;gap:0.5rem}.submit-button.svelte-t6s0pv{background:var(--primary-color, #007bff);color:white}.submit-button.svelte-t6s0pv:hover:not(:disabled){background:var(--primary-color-hover, #0056b3)}.submit-button.svelte-t6s0pv:disabled{background:var(--background-disabled, #6c757d);cursor:not-allowed}.cancel-button.svelte-t6s0pv{background:var(--secondary-color, #6c757d);color:white}.cancel-button.svelte-t6s0pv:hover:not(:disabled){background:var(--secondary-color-hover, #545b62)}.cancel-button.svelte-t6s0pv:disabled{opacity:0.6;cursor:not-allowed}
.subscription-custom-fields-container.svelte-uox0m2{padding:0;max-width:800px;margin:0 auto}.form-title.svelte-uox0m2{font-size:1.75rem;font-weight:700;margin:0 0 16px 0;color:var(--zephr-color-text-main)}.form-description.svelte-uox0m2{font-size:1rem;margin:0 0 32px 0;color:var(--zephr-color-text-tinted);line-height:1.5}.custom-fields-form.svelte-uox0m2{display:flex;flex-direction:column;gap:16px}.field-item.svelte-uox0m2{display:flex;flex-direction:column;gap:8px;padding:16px;background-color:var(--zephr-color-background-main);border:1px solid var(--zephr-color-background-tinted);border-radius:8px;transition:all 0.2s ease}.field-item.svelte-uox0m2:focus-within{border-color:var(--zephr-color-action-main);box-shadow:0 0 0 2px rgba(66, 153, 225, 0.1)}.field-label.svelte-uox0m2{font-weight:600;font-size:0.9rem;color:var(--zephr-color-text-main);display:flex;align-items:center;gap:8px}.field-input.svelte-uox0m2{padding:12px 16px;border:2px solid var(--zephr-color-background-tinted);border-radius:8px;font-size:1rem;transition:all 0.2s ease;background-color:var(--zephr-color-background-main)}.field-input.svelte-uox0m2:focus{outline:none;border-color:var(--zephr-color-action-main);box-shadow:0 0 0 3px rgba(66, 153, 225, 0.1)}.field-input.svelte-uox0m2:disabled{background-color:#f5f5f5;color:#666;cursor:not-allowed}.success-message.svelte-uox0m2{background-color:#d4edda;border:1px solid #c3e6cb;color:#155724;padding:12px 16px;border-radius:8px;margin:16px 0;font-weight:500;display:flex;align-items:center;gap:8px}.error-message.svelte-uox0m2{background-color:#f8d7da;border:1px solid #f5c6cb;color:#721c24;padding:12px 16px;border-radius:8px;margin:16px 0;font-weight:500;display:flex;align-items:center;gap:8px}.form-actions.svelte-uox0m2{margin-top:32px;padding-top:24px;border-top:1px solid var(--zephr-color-background-tinted);text-align:center;display:flex;justify-content:center;gap:16px}.submit-button.svelte-uox0m2{background:linear-gradient(135deg, var(--zephr-color-action-main) 0%, var(--zephr-color-action-tinted) 100%);color:white;border:none;padding:16px 32px;border-radius:8px;font-size:1rem;font-weight:600;cursor:pointer;transition:all 0.2s ease;min-width:160px}.submit-button.svelte-uox0m2:hover:not(:disabled){transform:translateY(-2px);box-shadow:0 4px 8px rgba(0, 0, 0, 0.2)}.submit-button.svelte-uox0m2:disabled{opacity:0.6;cursor:not-allowed;transform:none}.simple-field-group.svelte-uox0m2{margin-bottom:24px;display:flex;flex-direction:column;gap:16px}.loading.svelte-uox0m2{text-align:center;padding:40px 20px;color:var(--zephr-color-text-tinted);font-size:1.1rem;background-color:var(--zephr-color-background-tinted);border-radius:8px}
.bill-to-contact-section.svelte-z564ap{margin-top:1rem;margin-bottom:1rem}.field.svelte-z564ap{margin-bottom:0.5rem}label.svelte-z564ap{display:block;margin-bottom:0.5rem;color:var(--zephr-color-text-tinted);font-family:var(--zf-root-fontFamily)}input.svelte-z564ap,select.svelte-z564ap{width:100%;padding:0.5rem;border:calc(var(--zephr-input-borderWidth) * 1px) solid
      var(--zephr-input-borderColor);border-radius:calc(var(--zephr-input-borderRadius) * 1px);background-color:var(--zf-input-bgColor);color:var(--zephr-color-text-main);font-family:var(--zf-root-fontFamily)}input.svelte-z564ap::placeholder{color:var(--zephr-color-background-tinted);font-family:var(--zf-root-fontFamily)}input.svelte-z564ap:focus{outline:none;border-color:var(--zephr-color-action-main)}.error.svelte-z564ap{border-color:var(--zephr-color-warning-main) !important}.error-text.svelte-z564ap{color:var(--zephr-color-warning-main);font-size:0.875em;margin-top:0.25rem;font-family:var(--zf-root-fontFamily)}
.zephr-form-max-width{max-width:var(--zf-container-maxWidth);margin:auto}.zephr-form-content.svelte-j7lu48{padding:var(--zf-container-padding);background-color:var(--zf-container-bgColor);border:var(--zf-container-border);border-radius:var(--zf-container-borderRadius)}.zephr-payment-options-content.svelte-j7lu48{background-color:transparent;border:none;border-radius:0}.close-button-container.svelte-j7lu48{text-align:right;width:100%;margin-bottom:15px}.close-button.svelte-j7lu48{cursor:pointer;display:inline;padding:7px;min-width:32px;min-height:32px;border-radius:16px;margin:1px}.loading-placeholder.svelte-j7lu48{display:flex;justify-content:center;align-items:center;min-height:200px}
.zephr-form{--zf-root-fontSize:16px;--zf-root-fontFamily:var(--zephr-typography-body-font), var(--zephr-typography-body-fallbackFont);--zf-container-maxWidth:440px;--zf-container-padding:20px;--zf-container-margin:20px auto;--zf-container-border:none;--zf-container-borderRadius:calc(var(--zephr-input-borderRadius) * 1px);--zf-container-color:var(--zephr-color-text-main);--zf-container-bgColor:var(--zephr-color-background-main, transparent);--zf-info-fontSize:14px;--zf-subtext-fontSize:12px;--zf-link-color:#6ba5e9;--zf-input-fontSize:var(--zf-root-fontSize);--zf-input-bgColor:var(--zephr-color-background-main, transparent);--zf-button-fontSize:calc(var(--zephr-button-fontSize, 16) * 1px);--zf-button-color:#fff;--zf-password-valid-color:#7bcb7f;--zf-password-invalid-color:#c4c4c4;--zf-payment-options-fontSize:var(--zf-subtext-fontSize);--zf-payment-options-color:var(--zephr-color-text-main);--zf-payment-options-bgColor:var(--zf-container-bgColor);--zf-payment-options-border:calc(var(--zephr-input-borderWidth) * 1px) solid var(--zephr-input-borderColor);--zf-payment-options-borderRadius:calc(var(--zephr-input-borderRadius) * 1px);--zf-payment-options-highlighted-color:var(--zephr-color-text-main);--zf-payment-options-highlighted-bgColor:var(--zephr-color-accent-main);--zf-payment-summary-fontSize:var(--zf-subtext-fontSize);--zf-payment-summary-color:var(--zephr-color-text-main);--zf-payment-summary-bgColor:var(--zf-input-bgColor);--zf-payment-summary-border:calc(var(--zephr-input-borderWidth) * 1px) solid var(--zephr-input-borderColor);--zf-payment-summary-borderRadius:calc(var(--zephr-input-borderRadius) * 1px);--zf-list-subscriptions-container-maxWidth:630px;--zf-list-subscriptions-container-padding:24px;--zf-list-subscriptions-section-padding:16px 0px;--zf-list-subscriptions-container-border:calc(var(--zephr-input-borderWidth) * 1px) solid var(--zephr-input-borderColor);--zf-list-subscriptions-container-borderRadius:calc(var(--zephr-input-borderRadius) * 1px);--zf-list-subscriptions-info-fontSize:var(--zf-info-fontSize)}.zephr-form.svelte-789zog{color:var(--zf-container-color);margin:var(--zf-container-margin);font-size:var(--zf-root-fontSize);font-family:var(--zf-root-fontFamily)}.zephr-form *{box-sizing:border-box}:where(.zephr-form) button{text-transform:unset;overflow:visible;font-family:var(--zf-root-fontFamily, unset);font-size:var(--zf-root-fontSize, unset);line-height:unset;margin:unset;padding:unset;border:unset;background:unset;&:hover, &:focus-visible {
            border: unset;
            background: unset;
        }}.zephr-form-disabled-div{pointer-events:none;opacity:0.8}.zephr-form-relative-container{position:relative}.zephr-form-flex-container{display:flex}.zephr-form-input-inner-button{cursor:pointer;position:absolute;top:50%;transform:translateY(-50%);right:5px;padding:10px 5px}.zephr-form-input-inner-text{color:var(--zephr-color-text-main);font-size:var(--zf-subtext-fontSize);font-weight:bold;font-family:var(--zf-root-fontFamily)}
</style>
                        
                        <style></style>
                        <div id="zephr-form-JbWRHt" class="zephr-form-container">
                        <div id="zephr-payment-form-root" class="zephr-form zephr-payment-form svelte-789zog" style="--zephr-button-borderRadius: 0;
--zephr-button-borderWidth: 0;
--zephr-button-fontSize: 16;
--zephr-button-fontWeight: normal;
--zephr-button-height: 50;
--zephr-color-accent-main: #dcdfe4;
--zephr-color-accent-tinted: #bfc4ce;
--zephr-color-action-main: #da0a0a;
--zephr-color-action-tinted: #f52222;
--zephr-color-background-main: #FFFFFF;
--zephr-color-background-tinted: #b3b3b3;
--zephr-color-text-main: #000000;
--zephr-color-text-tinted: #333333;
--zephr-color-warning-main: #D90B00;
--zephr-color-warning-tinted: #ff190d;
--zephr-input-borderColor: #333333;
--zephr-input-borderRadius: 0;
--zephr-input-borderWidth: 1;
--zephr-input-height: 50;
--zephr-typography-title-fallbackFont: serif;
--zephr-typography-title-font: IvyPresto Text;
--zephr-typography-body-fallbackFont: sans-serif;
--zephr-typography-body-font: Libre Franklin"><div style="max-height: 10000px; overflow: unset;"> <div><form class="zephr-form-content svelte-j7lu48 zephr-payment-options-content"> <div>
        <style>.zephr-radio-payment-options-page {
  --zephr-radio-payment-options-page-line-color: var(--zephr-color-text-main);
  --zephr-radio-payment-options-page-line-font-size: 18px;

  --zephr-radio-payment-options-page-title-font-size: 24px;
  --zephr-radio-payment-options-page-title-text-align: center;

  --zephr-radio-payment-options-page-wrapper-background: var(--zephr-color-background-main);
  --zephr-radio-payment-options-page-wrapper-border: 1px solid var(--zephr-color-background-tinted);
  --zephr-radio-payment-options-page-wrapper-border-radius: 5px;

  --zephr-radio-payment-option-price-color: var(--zephr-color-text-main);
  --zephr-radio-payment-option-price-font-size: 16px;

  --zephr-radio-payment-options-description-color: var(--zephr-color-text-main);
  --zephr-radio-payment-options-description-font-size: 12px;

  --zephr-radio-payment-option-price-description-color: var(--zephr-color-text-main);
  --zephr-radio-payment-option-price-description-font-size: 12px;

  --zephr-radio-payment-options-button-background: var(--zephr-color-action-main);
  --zephr-radio-payment-options-button-color: var(--zephr-color-background-main);
  --zephr-radio-payment-options-button-hover-background: var(--zephr-color-action-tinted);
  --zephr-radio-payment-options-button-hover-color: var(--zephr-color-action-tinted);
  --zephr-radio-payment-options-button-font-size: 12px;
  --zephr-radio-payment-options-button-width: 100%;
  --zephr-radio-payment-options-button-height: calc(var(--zephr-button-height) * 1px);

  --zephr-radio-plan-group-description-color: var(--zephr-color-text-tinted);
  --zephr-radio-plan-group-description-font-size: 10px;
  --zephr-radio-plan-group-description-max-width: 492px;

  --zephr-radio-plan-group-terms-color: var(--zephr-color-text-tinted);
  --zephr-radio-plan-group-terms-text-align: center;
  --zephr-radio-plan-group-terms-font-size: 12px;

  --zephr-radio-payment-options-page-link-color: #2E6CD4;
  --zephr-radio-payment-options-page-link-font-size: 12px;
}

  .zephr-radio-payment-options-page {
    display: flex;
    flex-direction: column;
    gap: 32px;
    font-family: var(--zephr-typography-body-font),  var(--zephr-typography-body-fallbackFont);
  }
  .zephr-radio-payment-options-page-line {
    text-align: center;
    color: var(--zephr-radio-payment-options-page-line-color);
  }
  .zephr-radio-payment-options-page-line h2 {
    font-size: var(--zephr-radio-payment-options-page-line-font-size);
    font-weight: 400;
    margin: 0px;
  }
  .zephr-radio-payment-options-page-title {
    font-size: var(--zephr-radio-payment-options-page-title-font-size);
    font-weight: 400;
    margin: 0px;
    color: var(--zephr-color-text-main);
    text-align: var(--zephr-radio-payment-options-page-title-text-align);
    font-style: normal;
    font-weight: 400;
    line-height: 100%;
  }
  .zephr-radio-payment-options-page-wrapper {
    display: flex;
    padding: 30px;
    flex-direction: column;
    align-items: center;
    gap: 32px;
    border-radius: var(--zephr-radio-payment-options-page-wrapper-border-radius);
    border: var(--zephr-radio-payment-options-page-wrapper-border);
    background: var(--zephr-radio-payment-options-page-wrapper-background);
    align-self: center;
  }

  .zephr-radio-payment-options-wrapper {
    display: flex;
    justify-content: center;
    align-items: flex-start;
    gap: 20px;
  }
  .zephr-radio-payment-options-selector-wrapper {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 24px;
  }
  .zephr-radio-payment-options-description-wrapper {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 16px;
  }
  .zephr-radio-payment-option-wrapper {
    display: flex;
    justify-content: center;
    align-items: flex-start;
    gap: 8px;
  }
  .zephr-radio-payment-option-description-wrapper {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 8px;
    max-width: 220px;
  }
  .zephr-radio-payment-option-title {
    color: var(--zephr-color-text-main);
    font-size: 18px;
    font-style: normal;
    font-weight: 510;
    line-height: 100%;
  }
  .zephr-radio-payment-option-price {
    color: var(--zephr-radio-payment-option-price-color);
    font-family: SF Pro;
    font-size: var(--zephr-radio-payment-option-price-font-size);
    font-style: normal;
    font-weight: 400;
    line-height: 100%;
  }
  .zephr-radio-payment-option-price-description {
    color: var(--zephr-radio-payment-option-price-description-color);
    font-size: var(--zephr-radio-payment-option-price-description-font-size);
    font-style: normal;
    font-weight: 400;
    line-height: 100%;
  }
  .zephr-radio-payment-options-description-line {
    display: flex;
    max-width: 220px;
    align-items: flex-start;
    gap: 8px;
  }
  .zephr-payment-option-description-icon {
    stroke-width: 2px;
    stroke: var(--zephr-color-action-main);
  }
  .zephr-radio-payment-options-description {
    color: var(--zephr-radio-payment-options-description-color);
    font-size: var(--zephr-radio-payment-options-description-font-size);
    font-style: normal;
    font-weight: 400;
    line-height: 100%;
    padding-right: 8px;
  }
  .zephr-radio-payment-options-button {
    max-width: 492px;
    padding: 10px 28px;
    background: var(--zephr-radio-payment-options-button-background);
    border-radius: calc(var(--zephr-input-borderRadius) * 1px);
    border-style: solid;
    border-width: calc(var(--zephr-button-borderWidth) * 1px);
    border-color: var(--zephr-color-action-tinted);
    font-size: var(--zephr-radio-payment-options-button-font-size);
    font-style: normal;
    font-weight: 510;
    text-align: center;
    color: var(--zephr-radio-payment-options-button-color);
    cursor: pointer;
    width: var(--zephr-radio-payment-options-button-width);
    height: var(--zephr-radio-payment-options-button-height);
    font-family: var(--zephr-typography-body-font),
      var(--zephr-typography-body-fallbackFont);
  }
  .zephr-radio-payment-options-button:hover {
    background-color: var(--zephr-radio-payment-options-button-hover-background);
    border-color: var(--zephr-radio-payment-options-button-hover-color);
  }
  .zephr-radio-plan-group-description {
    color: var(--zephr-radio-plan-group-description-color);
    font-size: var(--zephr-radio-plan-group-description-font-size);
    text-align: center;
    font-style: normal;
    font-weight: 400;
    line-height: 138.3%;
    max-width: var(--zephr-radio-plan-group-description-max-width);
  }
  .zephr-radio-plan-group-terms {
    color: var(--zephr-radio-plan-group-terms-color);
    text-align: var(--zephr-radio-plan-group-terms-text-align);
    font-size: var(--zephr-radio-plan-group-terms-font-size);
    font-style: normal;
    font-weight: 400;
    line-height: 100%;
  }
  .zephr-radio-payment-options-page-footer {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
  }
  .zephr-radio-payment-options-page-login-line {
    display: flex;
    justify-content: center;
    align-items: flex-start;
    gap: 4px;
  }
  .zephr-radio-payment-options-page-link {
    color: var(--zephr-radio-payment-options-page-link-color);
    font-size: var(--zephr-radio-payment-options-page-link-font-size);
    font-style: normal;
    font-weight: 400;
    line-height: 100%;
  }
  /* NYT-style Welcome Offer visual treatment */
.zephr-welcome-offer-header {
  text-align: center;
  margin-bottom: -12px;
  margin-top: 8px;
}

.zephr-welcome-offer-header .label {
  font-size: 14px;
  font-weight: 600;
  letter-spacing: 0.5px;
  text-transform: uppercase;
  color: #333333;
}

.zephr-welcome-offer-header .price-line {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 8px;
  font-family: Georgia, serif;
  font-size: 28px;
  font-weight: 600;
  margin-top: 4px;
  color: #1A1A1A;
}

.zephr-welcome-offer-header .old-price {
  text-decoration: line-through;
  color: #999999;
  font-size: 22px;
  font-weight: 400;
}
.zephr-welcome-offer-header .price-line {
  margin-bottom: 10px;  /* adjust to taste: 8px, 12px, 16px */
}
.zephr-welcome-offer-header s {
  color: #888;        /* light gray */
  text-decoration-color: #888;  /* ensure the line is gray too */
}
/* Header wrapper */
.zephr-welcome-offer-header {
  text-align: center;
  margin: 0 auto 2px auto;
}

/* Top line: "Cyber Sale – Save 75%" (3x bigger & with red 'Save 75%') */
.zephr-welcome-offer-header .cyber-line {
  font-size: 1.1rem;          /* ~3x typical body text */
  font-weight: 600;
  line-height: 1;
}

/* Make just "Save 75%" red */
.zephr-welcome-offer-header .savings-red {
  color: #88;             /* your brand red */
}

/* $1/week – 3x bigger */
.zephr-welcome-offer-header .price-line .new-price {
        color: #c20000 !important;
  display: inline-block;
  margin-top: 3px;
  font-size: 3.2rem;          /* ~3x original */
  font-weight: 700;
}

/* Subline: NOW $199 (strike) $52 for 12 months */
.zephr-welcome-offer-header .subline {
  margin-top: 4px;
  font-size: 1.1rem;
  font-weight: 500;
}

/* Optional: gray old price */
.zephr-welcome-offer-header .subline s {
  color: #999999;
  text-decoration-color: #999999;
  margin: 0 2px;
}
.zephr-radio-payment-option-price-description {
  color: var(--zephr-radio-payment-option-price-description-color);
  font-size: var(--zephr-radio-payment-option-price-description-font-size);
  font-style: italic; /* ← change this */
  font-weight: 400;
  line-height: 100%;
}
.zephr-radio-payment-option-price-description {
  font-style: italic;
  opacity: 0.85;
}

.zephr-welcome-offer-header 
.zephr-radio-payment-option-price {
  font-style: italic;
  font-weight: 400;
}

.zephr-radio-payment-option-price {
  font-style: normal;
}
/* FIX: restore native radio rendering in test/live where global CSS resets inputs */
.zephr-radio-payment-options-page input[type="radio"]{
  -webkit-appearance: radio !important;
  appearance: auto !important;

  /* override common “hide input” patterns */
  display: inline-block !important;
  opacity: 1 !important;
  visibility: visible !important;
  position: static !important;
  clip: auto !important;
  clip-path: none !important;

  /* ensure it has a box to render */
  width: 16px !important;
  height: 16px !important;
  margin-right: 10px !important;
}

/* Optional: keeps alignment clean if your label is flex/inline */
.zephr-radio-payment-options-page .zephr-radio-payment-options-page-option,
.zephr-radio-payment-options-page label{
  align-items: flex-start;
}
/* Enlarge entire footer line: "Already a subscriber? Login" */
.zephr-radio-payment-options-page-login-line {
  font-size: 16px;        /* increase whole line */
  line-height: 1.4;
}

/* Ensure the Login link inherits the same size */
.zephr-radio-payment-options-page-login-line
  .zephr-radio-payment-options-page-link {
  font-size: inherit;
}
/* Make the entire "Already a subscriber? Login" line bigger */
.zephr-radio-payment-options-page .zephr-radio-payment-options-page-login-line{
  font-size: 23px !important;
  line-height: 1.4 !important;
}

/* Force the non-link text to match (covers span/p/div wrappers) */
.zephr-radio-payment-options-page .zephr-radio-payment-options-page-login-line span,
.zephr-radio-payment-options-page .zephr-radio-payment-options-page-login-line p,
.zephr-radio-payment-options-page .zephr-radio-payment-options-page-login-line div{
  font-size: 23px !important;
  line-height: 1.4 !important;
}

/* Keep link aligned + same size */
.zephr-radio-payment-options-page .zephr-radio-payment-options-page-login-line
  .zephr-radio-payment-options-page-link{
  font-size: 23px !important;
}</style>
        <div class="zephr-radio-payment-options-page">

  <div class="zephr-welcome-offer-header">
    <div class="label cyber-line">
      ALL ACCESS – <span class="savings-red">14 Day Trial </span>
    </div>

    <div class="price-line">
      <span class="new-price">Try for $1</span>
    </div>

    <div class="label subline">
    
    </div>
  </div>


  <div class="zephr-radio-payment-options-page">
  <div class="zephr-radio-payment-options-page-wrapper">
      <h2 class="zephr-radio-payment-options-page-title">Start for $1 – Select a Plan</h2>
    <div class="zephr-radio-payment-options-wrapper">
      <div class="zephr-radio-payment-options-selector-wrapper">
        <div class="zephr-radio-payment-option-wrapper">
          <input type="radio" id="ZXXm3P" name="radio-payment-option" checked="" value="ZXXm3P">
          <div class="zephr-radio-payment-option-description-wrapper">
            <label for="ZXXm3P" class="zephr-radio-payment-option-title">Annual (Most Popular)</label>
              <span class="zephr-radio-payment-option-price">$3.83/week (billed annually)</span>
          </div>
        </div>
        <div class="zephr-radio-payment-option-wrapper">
          <input type="radio" id="MXQT8U" name="radio-payment-option" value="MXQT8U" onchange="window.Zephr.forms['grueh'].setState({ selectedOption: 'MXQT8U' });">
          <div class="zephr-radio-payment-option-description-wrapper">
            <label for="MXQT8U" class="zephr-radio-payment-option-title">Monthly</label>
              <span class="zephr-radio-payment-option-price">$6.25/week (billed monthly)</span>
          </div>
        </div>
      </div>
      <div class="zephr-radio-payment-options-description-wrapper">
        <div class="zephr-radio-payment-options-description-line">
          <svg xmlns="http://www.w3.org/2000/svg" width="12" height="10" viewBox="0 0 12 10" fill="none">
            <path class="zephr-payment-option-description-icon" d="M1 4.85738L4.09524 7.95261L11 1.04785"></path>
          </svg>
          <span class="zephr-radio-payment-options-description">Unlimited access to TheWrap</span>
        </div>
        <div class="zephr-radio-payment-options-description-line">
          <svg xmlns="http://www.w3.org/2000/svg" width="12" height="10" viewBox="0 0 12 10" fill="none">
            <path class="zephr-payment-option-description-icon" d="M1 4.85738L4.09524 7.95261L11 1.04785"></path>
          </svg>
          <span class="zephr-radio-payment-options-description">Data insights &amp; deep-dive features</span>
        </div>
        <div class="zephr-radio-payment-options-description-line">
          <svg xmlns="http://www.w3.org/2000/svg" width="12" height="10" viewBox="0 0 12 10" fill="none">
            <path class="zephr-payment-option-description-icon" d="M1 4.85738L4.09524 7.95261L11 1.04785"></path>
          </svg>
          <span class="zephr-radio-payment-options-description">Weekly PRO newsletters</span>
        </div>
        <div class="zephr-radio-payment-options-description-line">
          <svg xmlns="http://www.w3.org/2000/svg" width="12" height="10" viewBox="0 0 12 10" fill="none">
            <path class="zephr-payment-option-description-icon" d="M1 4.85738L4.09524 7.95261L11 1.04785"></path>
          </svg>
          <span class="zephr-radio-payment-options-description">Exclusive videos &amp; analysis</span>
        </div>
        <div class="zephr-radio-payment-options-description-line">
          <svg xmlns="http://www.w3.org/2000/svg" width="12" height="10" viewBox="0 0 12 10" fill="none">
            <path class="zephr-payment-option-description-icon" d="M1 4.85738L4.09524 7.95261L11 1.04785"></path>
          </svg>
          <span class="zephr-radio-payment-options-description">Invite-only member events</span>
        </div>
      </div>
    </div>
    <button class="zephr-radio-payment-options-button" onclick="window.Zephr.forms['grueh'].selectPaymentOption('wrappro-digital-print', 'ZXXm3P');">
      Continue with card
    </button>
    <span class="zephr-radio-plan-group-description">$1 for 14 days, then $4/week (billed annually at $199) or $6.25/week (billed every 4 weeks at $24.99). Plans renew automatically. Cancel anytime during your 14-day trial to avoid full-plan charges.</span>
  </div>
  <div class="zephr-radio-payment-options-page-footer">
    <div class="zephr-radio-payment-options-page-login-line">
        <span class="zephr-radio-plan-group-terms">Already a subscriber?</span>
        <a class="zephr-radio-payment-options-page-link" href="https://www.thewrap.com/login"><span>Login</span></a><a>
    </a></div><a>
  </a></div><a>
  </a></div><a>

        </a></div></div> </form></div> </div></div></div>
                        <script data-cmp-ab="2">(function () {
	'use strict';

	/** @returns {void} */
	function noop() {}

	/**
	 * @template T
	 * @template S
	 * @param {T} tar
	 * @param {S} src
	 * @returns {T & S}
	 */
	function assign(tar, src) {
		// @ts-ignore
		for (const k in src) tar[k] = src[k];
		return /** @type {T & S} */ (tar);
	}

	function run(fn) {
		return fn();
	}

	function blank_object() {
		return Object.create(null);
	}

	/**
	 * @param {Function[]} fns
	 * @returns {void}
	 */
	function run_all(fns) {
		fns.forEach(run);
	}

	/**
	 * @param {any} thing
	 * @returns {thing is Function}
	 */
	function is_function(thing) {
		return typeof thing === 'function';
	}

	/** @returns {boolean} */
	function safe_not_equal(a, b) {
		return a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';
	}

	let src_url_equal_anchor;

	/**
	 * @param {string} element_src
	 * @param {string} url
	 * @returns {boolean}
	 */
	function src_url_equal(element_src, url) {
		if (element_src === url) return true;
		if (!src_url_equal_anchor) {
			src_url_equal_anchor = document.createElement('a');
		}
		// This is actually faster than doing URL(..).href
		src_url_equal_anchor.href = url;
		return element_src === src_url_equal_anchor.href;
	}

	/** @returns {boolean} */
	function is_empty(obj) {
		return Object.keys(obj).length === 0;
	}

	function create_slot(definition, ctx, $$scope, fn) {
		if (definition) {
			const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
			return definition[0](slot_ctx);
		}
	}

	function get_slot_context(definition, ctx, $$scope, fn) {
		return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
	}

	function get_slot_changes(definition, $$scope, dirty, fn) {
		if (definition[2] && fn) {
			const lets = definition[2](fn(dirty));
			if ($$scope.dirty === undefined) {
				return lets;
			}
			if (typeof lets === 'object') {
				const merged = [];
				const len = Math.max($$scope.dirty.length, lets.length);
				for (let i = 0; i < len; i += 1) {
					merged[i] = $$scope.dirty[i] | lets[i];
				}
				return merged;
			}
			return $$scope.dirty | lets;
		}
		return $$scope.dirty;
	}

	/** @returns {void} */
	function update_slot_base(
		slot,
		slot_definition,
		ctx,
		$$scope,
		slot_changes,
		get_slot_context_fn
	) {
		if (slot_changes) {
			const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
			slot.p(slot_context, slot_changes);
		}
	}

	/** @returns {any[] | -1} */
	function get_all_dirty_from_scope($$scope) {
		if ($$scope.ctx.length > 32) {
			const dirty = [];
			const length = $$scope.ctx.length / 32;
			for (let i = 0; i < length; i++) {
				dirty[i] = -1;
			}
			return dirty;
		}
		return -1;
	}

	function null_to_empty(value) {
		return value == null ? '' : value;
	}

	function action_destroyer(action_result) {
		return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
	}

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @returns {void}
	 */
	function append(target, node) {
		target.appendChild(node);
	}

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @param {Node} [anchor]
	 * @returns {void}
	 */
	function insert(target, node, anchor) {
		target.insertBefore(node, anchor || null);
	}

	/**
	 * @param {Node} node
	 * @returns {void}
	 */
	function detach(node) {
		if (node.parentNode) {
			node.parentNode.removeChild(node);
		}
	}

	/**
	 * @returns {void} */
	function destroy_each(iterations, detaching) {
		for (let i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) iterations[i].d(detaching);
		}
	}

	/**
	 * @template {keyof HTMLElementTagNameMap} K
	 * @param {K} name
	 * @returns {HTMLElementTagNameMap[K]}
	 */
	function element(name) {
		return document.createElement(name);
	}

	/**
	 * @template {keyof SVGElementTagNameMap} K
	 * @param {K} name
	 * @returns {SVGElement}
	 */
	function svg_element(name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	}

	/**
	 * @param {string} data
	 * @returns {Text}
	 */
	function text(data) {
		return document.createTextNode(data);
	}

	/**
	 * @returns {Text} */
	function space() {
		return text(' ');
	}

	/**
	 * @returns {Text} */
	function empty() {
		return text('');
	}

	/**
	 * @param {EventTarget} node
	 * @param {string} event
	 * @param {EventListenerOrEventListenerObject} handler
	 * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]
	 * @returns {() => void}
	 */
	function listen(node, event, handler, options) {
		node.addEventListener(event, handler, options);
		return () => node.removeEventListener(event, handler, options);
	}

	/**
	 * @returns {(event: any) => any} */
	function prevent_default(fn) {
		return function (event) {
			event.preventDefault();
			// @ts-ignore
			return fn.call(this, event);
		};
	}

	/**
	 * @returns {(event: any) => void} */
	function self(fn) {
		return function (event) {
			// @ts-ignore
			if (event.target === this) fn.call(this, event);
		};
	}

	/**
	 * @param {Element} node
	 * @param {string} attribute
	 * @param {string} [value]
	 * @returns {void}
	 */
	function attr(node, attribute, value) {
		if (value == null) node.removeAttribute(attribute);
		else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
	}
	/**
	 * List of attributes that should always be set through the attr method,
	 * because updating them through the property setter doesn't work reliably.
	 * In the example of `width`/`height`, the problem is that the setter only
	 * accepts numeric values, but the attribute can also be set to a string like `50%`.
	 * If this list becomes too big, rethink this approach.
	 */
	const always_set_through_set_attribute = ['width', 'height'];

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {{ [x: string]: string }} attributes
	 * @returns {void}
	 */
	function set_attributes(node, attributes) {
		// @ts-ignore
		const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
		for (const key in attributes) {
			if (attributes[key] == null) {
				node.removeAttribute(key);
			} else if (key === 'style') {
				node.style.cssText = attributes[key];
			} else if (key === '__value') {
				/** @type {any} */ (node).value = node[key] = attributes[key];
			} else if (
				descriptors[key] &&
				descriptors[key].set &&
				always_set_through_set_attribute.indexOf(key) === -1
			) {
				node[key] = attributes[key];
			} else {
				attr(node, key, attributes[key]);
			}
		}
	}

	/**
	 * @param {Element} element
	 * @returns {ChildNode[]}
	 */
	function children(element) {
		return Array.from(element.childNodes);
	}

	/**
	 * @param {Text} text
	 * @param {unknown} data
	 * @returns {void}
	 */
	function set_data(text, data) {
		data = '' + data;
		if (text.data === data) return;
		text.data = /** @type {string} */ (data);
	}

	/**
	 * @returns {void} */
	function set_input_value(input, value) {
		input.value = value == null ? '' : value;
	}

	/**
	 * @returns {void} */
	function set_style(node, key, value, important) {
		if (value == null) {
			node.style.removeProperty(key);
		} else {
			node.style.setProperty(key, value, important ? 'important' : '');
		}
	}

	/**
	 * @returns {void} */
	function select_option(select, value, mounting) {
		for (let i = 0; i < select.options.length; i += 1) {
			const option = select.options[i];
			if (option.__value === value) {
				option.selected = true;
				return;
			}
		}
		if (!mounting || value !== undefined) {
			select.selectedIndex = -1; // no option should be selected
		}
	}

	/**
	 * @returns {void} */
	function toggle_class(element, name, toggle) {
		// The `!!` is required because an `undefined` flag means flipping the current state.
		element.classList.toggle(name, !!toggle);
	}

	/**
	 * @template T
	 * @param {string} type
	 * @param {T} [detail]
	 * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]
	 * @returns {CustomEvent<T>}
	 */
	function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
		return new CustomEvent(type, { detail, bubbles, cancelable });
	}

	function construct_svelte_component(component, props) {
		return new component(props);
	}

	/**
	 * @typedef {Node & {
	 * 	claim_order?: number;
	 * 	hydrate_init?: true;
	 * 	actual_end_child?: NodeEx;
	 * 	childNodes: NodeListOf<NodeEx>;
	 * }} NodeEx
	 */

	/** @typedef {ChildNode & NodeEx} ChildNodeEx */

	/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */

	/**
	 * @typedef {ChildNodeEx[] & {
	 * 	claim_info?: {
	 * 		last_index: number;
	 * 		total_claimed: number;
	 * 	};
	 * }} ChildNodeArray
	 */

	let current_component;

	/** @returns {void} */
	function set_current_component(component) {
		current_component = component;
	}

	function get_current_component() {
		if (!current_component) throw new Error('Function called outside component initialization');
		return current_component;
	}

	/**
	 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
	 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
	 * it can be called from an external module).
	 *
	 * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
	 *
	 * `onMount` does not run inside a [server-side component](https://svelte.dev/docs#run-time-server-side-component-api).
	 *
	 * https://svelte.dev/docs/svelte#onmount
	 * @template T
	 * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn
	 * @returns {void}
	 */
	function onMount(fn) {
		get_current_component().$$.on_mount.push(fn);
	}

	/**
	 * Schedules a callback to run immediately after the component has been updated.
	 *
	 * The first time the callback runs will be after the initial `onMount`
	 *
	 * https://svelte.dev/docs/svelte#afterupdate
	 * @param {() => any} fn
	 * @returns {void}
	 */
	function afterUpdate(fn) {
		get_current_component().$$.after_update.push(fn);
	}

	/**
	 * Schedules a callback to run immediately before the component is unmounted.
	 *
	 * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
	 * only one that runs inside a server-side component.
	 *
	 * https://svelte.dev/docs/svelte#ondestroy
	 * @param {() => any} fn
	 * @returns {void}
	 */
	function onDestroy(fn) {
		get_current_component().$$.on_destroy.push(fn);
	}

	/**
	 * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs#template-syntax-component-directives-on-eventname).
	 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
	 *
	 * Component events created with `createEventDispatcher` create a
	 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
	 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
	 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
	 * property and can contain any type of data.
	 *
	 * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:
	 * ```ts
	 * const dispatch = createEventDispatcher<{
	 *  loaded: never; // does not take a detail argument
	 *  change: string; // takes a detail argument of type string, which is required
	 *  optional: number | null; // takes an optional detail argument of type number
	 * }>();
	 * ```
	 *
	 * https://svelte.dev/docs/svelte#createeventdispatcher
	 * @template {Record<string, any>} [EventMap=any]
	 * @returns {import('./public.js').EventDispatcher<EventMap>}
	 */
	function createEventDispatcher() {
		const component = get_current_component();
		return (type, detail, { cancelable = false } = {}) => {
			const callbacks = component.$$.callbacks[type];
			if (callbacks) {
				// TODO are there situations where events could be dispatched
				// in a server (non-DOM) environment?
				const event = custom_event(/** @type {string} */ (type), detail, { cancelable });
				callbacks.slice().forEach((fn) => {
					fn.call(component, event);
				});
				return !event.defaultPrevented;
			}
			return true;
		};
	}

	const dirty_components = [];
	const binding_callbacks = [];

	let render_callbacks = [];

	const flush_callbacks = [];

	const resolved_promise = /* @__PURE__ */ Promise.resolve();

	let update_scheduled = false;

	/** @returns {void} */
	function schedule_update() {
		if (!update_scheduled) {
			update_scheduled = true;
			resolved_promise.then(flush);
		}
	}

	/** @returns {void} */
	function add_render_callback(fn) {
		render_callbacks.push(fn);
	}

	// flush() calls callbacks in this order:
	// 1. All beforeUpdate callbacks, in order: parents before children
	// 2. All bind:this callbacks, in reverse order: children before parents.
	// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
	//    for afterUpdates called during the initial onMount, which are called in
	//    reverse order: children before parents.
	// Since callbacks might update component values, which could trigger another
	// call to flush(), the following steps guard against this:
	// 1. During beforeUpdate, any updated components will be added to the
	//    dirty_components array and will cause a reentrant call to flush(). Because
	//    the flush index is kept outside the function, the reentrant call will pick
	//    up where the earlier call left off and go through all dirty components. The
	//    current_component value is saved and restored so that the reentrant call will
	//    not interfere with the "parent" flush() call.
	// 2. bind:this callbacks cannot trigger new flush() calls.
	// 3. During afterUpdate, any updated components will NOT have their afterUpdate
	//    callback called a second time; the seen_callbacks set, outside the flush()
	//    function, guarantees this behavior.
	const seen_callbacks = new Set();

	let flushidx = 0; // Do *not* move this inside the flush() function

	/** @returns {void} */
	function flush() {
		// Do not reenter flush while dirty components are updated, as this can
		// result in an infinite loop. Instead, let the inner flush handle it.
		// Reentrancy is ok afterwards for bindings etc.
		if (flushidx !== 0) {
			return;
		}
		const saved_component = current_component;
		do {
			// first, call beforeUpdate functions
			// and update components
			try {
				while (flushidx < dirty_components.length) {
					const component = dirty_components[flushidx];
					flushidx++;
					set_current_component(component);
					update(component.$$);
				}
			} catch (e) {
				// reset dirty state to not end up in a deadlocked state and then rethrow
				dirty_components.length = 0;
				flushidx = 0;
				throw e;
			}
			set_current_component(null);
			dirty_components.length = 0;
			flushidx = 0;
			while (binding_callbacks.length) binding_callbacks.pop()();
			// then, once components are updated, call
			// afterUpdate functions. This may cause
			// subsequent updates...
			for (let i = 0; i < render_callbacks.length; i += 1) {
				const callback = render_callbacks[i];
				if (!seen_callbacks.has(callback)) {
					// ...so guard against infinite loops
					seen_callbacks.add(callback);
					callback();
				}
			}
			render_callbacks.length = 0;
		} while (dirty_components.length);
		while (flush_callbacks.length) {
			flush_callbacks.pop()();
		}
		update_scheduled = false;
		seen_callbacks.clear();
		set_current_component(saved_component);
	}

	/** @returns {void} */
	function update($$) {
		if ($$.fragment !== null) {
			$$.update();
			run_all($$.before_update);
			const dirty = $$.dirty;
			$$.dirty = [-1];
			$$.fragment && $$.fragment.p($$.ctx, dirty);
			$$.after_update.forEach(add_render_callback);
		}
	}

	/**
	 * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
	 * @param {Function[]} fns
	 * @returns {void}
	 */
	function flush_render_callbacks(fns) {
		const filtered = [];
		const targets = [];
		render_callbacks.forEach((c) => (fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c)));
		targets.forEach((c) => c());
		render_callbacks = filtered;
	}

	const outroing = new Set();

	/**
	 * @type {Outro}
	 */
	let outros;

	/**
	 * @returns {void} */
	function group_outros() {
		outros = {
			r: 0,
			c: [],
			p: outros // parent group
		};
	}

	/**
	 * @returns {void} */
	function check_outros() {
		if (!outros.r) {
			run_all(outros.c);
		}
		outros = outros.p;
	}

	/**
	 * @param {import('./private.js').Fragment} block
	 * @param {0 | 1} [local]
	 * @returns {void}
	 */
	function transition_in(block, local) {
		if (block && block.i) {
			outroing.delete(block);
			block.i(local);
		}
	}

	/**
	 * @param {import('./private.js').Fragment} block
	 * @param {0 | 1} local
	 * @param {0 | 1} [detach]
	 * @param {() => void} [callback]
	 * @returns {void}
	 */
	function transition_out(block, local, detach, callback) {
		if (block && block.o) {
			if (outroing.has(block)) return;
			outroing.add(block);
			outros.c.push(() => {
				outroing.delete(block);
				if (callback) {
					if (detach) block.d(1);
					callback();
				}
			});
			block.o(local);
		} else if (callback) {
			callback();
		}
	}

	/** @typedef {1} INTRO */
	/** @typedef {0} OUTRO */
	/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */
	/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */

	/**
	 * @typedef {Object} Outro
	 * @property {number} r
	 * @property {Function[]} c
	 * @property {Object} p
	 */

	/**
	 * @typedef {Object} PendingProgram
	 * @property {number} start
	 * @property {INTRO|OUTRO} b
	 * @property {Outro} [group]
	 */

	/**
	 * @typedef {Object} Program
	 * @property {number} a
	 * @property {INTRO|OUTRO} b
	 * @property {1|-1} d
	 * @property {number} duration
	 * @property {number} start
	 * @property {number} end
	 * @property {Outro} [group]
	 */

	// general each functions:

	function ensure_array_like(array_like_or_iterator) {
		return array_like_or_iterator?.length !== undefined
			? array_like_or_iterator
			: Array.from(array_like_or_iterator);
	}

	/** @returns {{}} */
	function get_spread_update(levels, updates) {
		const update = {};
		const to_null_out = {};
		const accounted_for = { $$scope: 1 };
		let i = levels.length;
		while (i--) {
			const o = levels[i];
			const n = updates[i];
			if (n) {
				for (const key in o) {
					if (!(key in n)) to_null_out[key] = 1;
				}
				for (const key in n) {
					if (!accounted_for[key]) {
						update[key] = n[key];
						accounted_for[key] = 1;
					}
				}
				levels[i] = n;
			} else {
				for (const key in o) {
					accounted_for[key] = 1;
				}
			}
		}
		for (const key in to_null_out) {
			if (!(key in update)) update[key] = undefined;
		}
		return update;
	}

	function get_spread_object(spread_props) {
		return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
	}

	/** @returns {void} */
	function create_component(block) {
		block && block.c();
	}

	/** @returns {void} */
	function mount_component(component, target, anchor) {
		const { fragment, after_update } = component.$$;
		fragment && fragment.m(target, anchor);
		// onMount happens before the initial afterUpdate
		add_render_callback(() => {
			const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
			// if the component was destroyed immediately
			// it will update the `$$.on_destroy` reference to `null`.
			// the destructured on_destroy may still reference to the old array
			if (component.$$.on_destroy) {
				component.$$.on_destroy.push(...new_on_destroy);
			} else {
				// Edge case - component was destroyed immediately,
				// most likely as a result of a binding initialising
				run_all(new_on_destroy);
			}
			component.$$.on_mount = [];
		});
		after_update.forEach(add_render_callback);
	}

	/** @returns {void} */
	function destroy_component(component, detaching) {
		const $$ = component.$$;
		if ($$.fragment !== null) {
			flush_render_callbacks($$.after_update);
			run_all($$.on_destroy);
			$$.fragment && $$.fragment.d(detaching);
			// TODO null out other refs, including component.$$ (but need to
			// preserve final state?)
			$$.on_destroy = $$.fragment = null;
			$$.ctx = [];
		}
	}

	/** @returns {void} */
	function make_dirty(component, i) {
		if (component.$$.dirty[0] === -1) {
			dirty_components.push(component);
			schedule_update();
			component.$$.dirty.fill(0);
		}
		component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;
	}

	// TODO: Document the other params
	/**
	 * @param {SvelteComponent} component
	 * @param {import('./public.js').ComponentConstructorOptions} options
	 *
	 * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.
	 * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.
	 * This will be the `add_css` function from the compiled component.
	 *
	 * @returns {void}
	 */
	function init(
		component,
		options,
		instance,
		create_fragment,
		not_equal,
		props,
		append_styles = null,
		dirty = [-1]
	) {
		const parent_component = current_component;
		set_current_component(component);
		/** @type {import('./private.js').T$$} */
		const $$ = (component.$$ = {
			fragment: null,
			ctx: [],
			// state
			props,
			update: noop,
			not_equal,
			bound: blank_object(),
			// lifecycle
			on_mount: [],
			on_destroy: [],
			on_disconnect: [],
			before_update: [],
			after_update: [],
			context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
			// everything else
			callbacks: blank_object(),
			dirty,
			skip_bound: false,
			root: options.target || parent_component.$$.root
		});
		append_styles && append_styles($$.root);
		let ready = false;
		$$.ctx = instance
			? instance(component, options.props || {}, (i, ret, ...rest) => {
					const value = rest.length ? rest[0] : ret;
					if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {
						if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
						if (ready) make_dirty(component, i);
					}
					return ret;
			  })
			: [];
		$$.update();
		ready = true;
		run_all($$.before_update);
		// `false` as a special case of no DOM component
		$$.fragment = create_fragment ? create_fragment($$.ctx) : false;
		if (options.target) {
			if (options.hydrate) {
				// TODO: what is the correct type here?
				// @ts-expect-error
				const nodes = children(options.target);
				$$.fragment && $$.fragment.l(nodes);
				nodes.forEach(detach);
			} else {
				// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
				$$.fragment && $$.fragment.c();
			}
			if (options.intro) transition_in(component.$$.fragment);
			mount_component(component, options.target, options.anchor);
			flush();
		}
		set_current_component(parent_component);
	}

	/**
	 * Base class for Svelte components. Used when dev=false.
	 *
	 * @template {Record<string, any>} [Props=any]
	 * @template {Record<string, any>} [Events=any]
	 */
	class SvelteComponent {
		/**
		 * ### PRIVATE API
		 *
		 * Do not use, may change at any time
		 *
		 * @type {any}
		 */
		$$ = undefined;
		/**
		 * ### PRIVATE API
		 *
		 * Do not use, may change at any time
		 *
		 * @type {any}
		 */
		$$set = undefined;

		/** @returns {void} */
		$destroy() {
			destroy_component(this, 1);
			this.$destroy = noop;
		}

		/**
		 * @template {Extract<keyof Events, string>} K
		 * @param {K} type
		 * @param {((e: Events[K]) => void) | null | undefined} callback
		 * @returns {() => void}
		 */
		$on(type, callback) {
			if (!is_function(callback)) {
				return noop;
			}
			const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
			callbacks.push(callback);
			return () => {
				const index = callbacks.indexOf(callback);
				if (index !== -1) callbacks.splice(index, 1);
			};
		}

		/**
		 * @param {Partial<Props>} props
		 * @returns {void}
		 */
		$set(props) {
			if (this.$$set && !is_empty(props)) {
				this.$$.skip_bound = true;
				this.$$set(props);
				this.$$.skip_bound = false;
			}
		}
	}

	/**
	 * @typedef {Object} CustomElementPropDefinition
	 * @property {string} [attribute]
	 * @property {boolean} [reflect]
	 * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]
	 */

	// generated during release, do not modify

	const PUBLIC_VERSION = '4';

	if (typeof window !== 'undefined')
		// @ts-ignore
		(window.__svelte || (window.__svelte = { v: new Set() })).v.add(PUBLIC_VERSION);

	// Some height larger than whats resonable expected,
	// but not so large as to infulence the transition time
	const TRANSITION_OPEN_HEIGHT = '700px';
	// Absolute max height
	const MAX_OPEN_HEIGHT = '10000px';
	const CLOSED_HEIGHT = '0px';
	const DURATION_MS = 500;
	function accordion(node, isOpen) {
	    let currentState = isOpen;
	    node.style.maxHeight = isOpen ? MAX_OPEN_HEIGHT : CLOSED_HEIGHT;
	    node.style.overflow = isOpen ? "unset" : "hidden";
	    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
	    const animationsDisabled = mediaQuery.matches;
	    if (animationsDisabled) {
	        node.style.display = isOpen ? 'unset' : 'none';
	    }
	    return {
	        update(isOpen) {
	            if (animationsDisabled) {
	                node.style.display = isOpen ? 'unset' : 'none';
	                return;
	            }
	            if (isOpen === currentState) {
	                return;
	            }
	            currentState = isOpen;
	            const toHeight = isOpen ? TRANSITION_OPEN_HEIGHT : CLOSED_HEIGHT;
	            const fromHeight = isOpen ? CLOSED_HEIGHT : TRANSITION_OPEN_HEIGHT;
	            node.animate([
	                {
	                    maxHeight: fromHeight,
	                    overflow: 'hidden'
	                },
	                {
	                    maxHeight: toHeight,
	                    overflow: 'hidden'
	                },
	            ], {
	                duration: DURATION_MS,
	                fill: 'both',
	            }).addEventListener("finish", () => {
	                // After the opening transition, unset the max height so if it's larger than OPEN_HEIGHT the content
	                // will be shown, but via a quick jump
	                if (!isOpen) {
	                    return;
	                }
	                node.animate([
	                    {
	                        maxHeight: toHeight,
	                        overflow: 'hidden'
	                    },
	                    {
	                        maxHeight: MAX_OPEN_HEIGHT,
	                        overflow: 'hidden'
	                    },
	                ], {
	                    duration: 100,
	                    fill: 'both',
	                });
	            });
	        }
	    };
	}

	const elementTypes = {
	    PROGRESS_BAR: 'progress_bar',
	    PAYMENT_OPTION_SELECTION: 'payment_option_selection',
	    PASSWORD: 'password',
	    VERIFICATION_CODE: 'otp_code',
	    BUTTON: 'button',
	    PAYMENT: 'payment',
	    PAYMENT_PRE_LOADER: 'payment-pre-loader',
	    EMAIL_ADDRESS: 'email_address',
	    SUCCESS_MESSAGE: 'success_message',
	    TEXT: 'text',
	    USER_ATTRIBUTE: 'user_attribute',
	    RESET_PASSWORD_LINK: 'link',
	    RESEND_LOGIN_LINK: 'resend_login_link',
	    SOCIAL_SIGNIN: 'social_sign_in',
	    PAYMENT_SUMMARY: 'payment_summary',
	    DIVIDER: 'divider',
	    LOGIN_LINK: 'show_login_link',
	    ACCOUNT_MEMBERSHIP_CODE: 'account_code',
	    MOBILE_PAYMENT: 'mobile_payment',
	    INVITATION: 'invitation',
	    TEMPLATE_COMPONENT: 'template_component',
	    SUBSCRIPTION_SELECT: 'subscription_select',
	    EVENT_LINK: 'event_link',
	    SUBSCRIPTIONS_LIST: 'subscriptions_list',
	    PAST_SUBSCRIPTIONS_LINK: 'past_subscriptions_link',
	    BILLING_HISTORY: 'billing_history',
	    CHNAGE_PAYMENT_METHOD_BUTTON: 'change_payment_method_button',
	    READ_ONLY_EMAIL_ADDRESS: 'read_only_email_address',
	    READ_ONLY_PASSWORD: 'read_only_password',
	    READ_ONLY_USER_ATTRIBUTE: 'read_only_user_attribute',
	    CHNAGE_PAYMENT_METHOD: 'change_payment_method',
	    DEVICES_SESSIONS_LIST: 'devices_list',
	    SIGN_OUT_ALL_OTHER_DEVICES: 'sign_out_of_devices_button',
	    TABLINK: 'tablink',
	    BUTTON_GROUP: 'button_group',
	    LINK_BUTTON: 'link_button',
	    RECIPIENT_NAME: 'recipient_name',
	    RECIPIENT_EMAIL: 'recipient_email',
	    RECIPIENT_ADDRESS: 'recipient_address',
	    RECIPIENT_MESSAGE: 'recipient_message',
	    GIFT_CODE: 'gift_code',
	    GIFT_SUBSCRIPTIONS_LIST: 'gift_subscriptions_list',
	    GIFT_TOGGLE: 'gift_toggle',
	    GIFT_FUTURE_DATE_TOGGLE: 'gift_future_date_toggle',
	    GIFT_FUTURE_DATE_INPUT: 'gift_future_date_input',
	    PAYMENT_AUTO_RENEW_TOGGLE: 'payment_auto_renew_toggle',
	    SUSPEND_RESUME_SUBSCRIPTION: 'suspend_resume_subscription',
	    SUBSCRIPTION_CUSTOM_FIELDS_UPDATE: 'subscription_custom_fields_update',
	    SUBSCRIPTION_CUSTOM_FIELDS_LIST: 'subscription_custom_fields_list',
	    BILL_TO_CONTACT: 'bill_to_contact',
	};

	var FormEvent;
	(function (FormEvent) {
	    FormEvent["FORM_START"] = "FORM_START";
	    FormEvent["LOGIN_REGISTRATION_COMPLETE"] = "LOGIN_REGISTRATION_COMPLETE";
	    FormEvent["SECTION_EMAIL_COMPLETE"] = "SECTION_EMAIL_COMPLETE";
	    FormEvent["SECTION_PASSWORD_RESET_COMPLETE"] = "SECTION_PASSWORD_RESET_COMPLETE";
	    FormEvent["SECTION_FORGOT_PASSWORD_COMPLETE"] = "SECTION_FORGOT_PASSWORD_COMPLETE";
	    FormEvent["PART_PLAN_SELECT_COMPLETE"] = "PART_PLAN_SELECT_COMPLETE";
	    FormEvent["PART_ACCOUNT_VERIFICATION_COMPLETE"] = "PART_ACCOUNT_VERIFICATION_COMPLETE";
	    FormEvent["PART_GIFT_RECIPIENT_COMPLETE"] = "PART_GIFT_RECIPIENT_COMPLETE";
	    FormEvent["PART_PAYMENT_COMPLETE"] = "PART_PAYMENT_COMPLETE";
	    FormEvent["PART_SUCCESS_COMPLETE"] = "PART_SUCCESS_COMPLETE";
	    FormEvent["PART_CONTACT_VERIFICATION_COMPLETE"] = "PART_CONTACT_VERIFICATION_COMPLETE";
	    FormEvent["PART_PROFILE_UPDATE_COMPLETE"] = "PART_PROFILE_UPDATE_COMPLETE";
	    FormEvent["PART_EMAIL_UPDATE_COMPLETE"] = "PART_EMAIL_UPDATE_COMPLETE";
	    FormEvent["PART_EMAIL_UPDATE_OTP_COMPLETE"] = "PART_EMAIL_UPDATE_OTP_COMPLETE";
	    FormEvent["PART_PASSWORD_UPDATE_COMPLETE"] = "PART_PASSWORD_UPDATE_COMPLETE";
	    FormEvent["PART_PASSWORD_UPDATE_OTP_COMPLETE"] = "PART_PASSWORD_UPDATE_OTP_COMPLETE";
	    FormEvent["PART_ATTRIBUTES_UPDATE_COMPLETE"] = "PART_ATTRIBUTES_UPDATE_COMPLETE";
	    FormEvent["REGISTRATION_CUSTOM_COMPLETE"] = "REGISTRATION_CUSTOM_COMPLETE";
	    FormEvent["SELECT_SUBSCRIPTION_COMPLETE"] = "SELECT_SUBSCRIPTION_COMPLETE";
	    FormEvent["UPDATE"] = "UPDATE";
	    FormEvent["GO_BACK"] = "GO_BACK";
	    FormEvent["VERIFY_EMAIL_UPDATE_OTP"] = "VERIFY_EMAIL_UPDATE_OTP";
	    FormEvent["VERIFY_PASSWORD_UPDATE_OTP"] = "VERIFY_PASSWORD_UPDATE_OTP";
	    FormEvent["PART_CHANGE_PAYMENT_COMPLETE"] = "PART_CHANGE_PAYMENT_COMPLETE";
	    FormEvent["LIST_DEVICES_SESSIONS"] = "LIST_DEVICES_SESSIONS";
	    FormEvent["SIGN_OUT_ALL_DEVICES"] = "SIGN_OUT_ALL_DEVICES";
	    FormEvent["SIGN_OUT_SINGLE_DEVICE"] = "SIGN_OUT_SINGLE_DEVICE";
	    FormEvent["GIFT_REDEMPTION_COMPLETE"] = "GIFT_REDEMPTION_COMPLETE";
	    FormEvent["SUSPEND_RESUME_SUBSCRIPTION_COMPLETE"] = "SUSPEND_RESUME_SUBSCRIPTION_COMPLETE";
	    FormEvent["BILL_TO_CONTACT_COMPLETE"] = "BILL_TO_CONTACT_COMPLETE";
	})(FormEvent || (FormEvent = {}));

	const partTypes = {
	    PLAN_SELECT: {
	        type: 'plan-select',
	        order: 0,
	        completionEvent: FormEvent.PART_PLAN_SELECT_COMPLETE
	    },
	    ACCOUNT_VERIFICATION: {
	        type: 'account-verification',
	        order: 1,
	        completionEvent: FormEvent.PART_ACCOUNT_VERIFICATION_COMPLETE
	    },
	    GIFT_RECIPIENT: {
	        type: 'gift-recipient',
	        order: 1,
	        completionEvent: FormEvent.PART_GIFT_RECIPIENT_COMPLETE
	    },
	    PAYMENT: {
	        type: 'payment',
	        order: 2,
	        completionEvent: FormEvent.PART_PAYMENT_COMPLETE
	    },
	    SUCCESS: {
	        type: 'success',
	        order: 3,
	        completionEvent: FormEvent.PART_SUCCESS_COMPLETE
	    },
	    CONTACT_VERIFICATION: {
	        type: 'contact-verification',
	        order: 1,
	        completionEvent: FormEvent.PART_CONTACT_VERIFICATION_COMPLETE
	    },
	    PROFILE_UPDATE: {
	        type: 'profile-update',
	        order: 0,
	        completionEvent: FormEvent.PART_PROFILE_UPDATE_COMPLETE
	    },
	    SELECT_SUBSCRIPTION: {
	        type: 'select-subscription',
	        order: 0,
	        completionEvent: FormEvent.SELECT_SUBSCRIPTION_COMPLETE
	    },
	    EMAIL_UPDATE: {
	        type: 'email-update',
	        order: 0,
	        completionEvent: FormEvent.PART_EMAIL_UPDATE_COMPLETE
	    },
	    EMAIL_UPDATE_OTP: {
	        type: 'email-update-otp',
	        order: 0,
	        completionEvent: FormEvent.PART_EMAIL_UPDATE_OTP_COMPLETE
	    },
	    PASSWORD_UPDATE: {
	        type: 'password-update',
	        order: 0,
	        completionEvent: FormEvent.PART_PASSWORD_UPDATE_COMPLETE
	    },
	    PASSWORD_UPDATE_OTP: {
	        type: 'password-update-otp',
	        order: 0,
	        completionEvent: FormEvent.PART_PASSWORD_UPDATE_OTP_COMPLETE
	    },
	    ATTRIBUTES_UPDATE: {
	        type: 'attributes-update',
	        order: 0,
	        completionEvent: FormEvent.PART_ATTRIBUTES_UPDATE_COMPLETE
	    },
	    LIST_SUBSCRIPTIONS: {
	        type: 'list-subscriptions',
	        order: 0,
	    },
	    BILLING_HISTORY: {
	        type: 'billing-history',
	        order: 0,
	    },
	    PAST_SUBSCRIPTIONS: {
	        type: 'past-subscriptions',
	        order: 0,
	    },
	    CHANGE_PAYMENT: {
	        type: 'change-payment',
	        order: 2,
	        completionEvent: FormEvent.PART_CHANGE_PAYMENT_COMPLETE
	    },
	    DEVICES_SESSIONS: {
	        type: 'devices-sessions',
	        order: 0,
	        completionEvent: FormEvent.LIST_DEVICES_SESSIONS
	    },
	    CANCEL_SUCCESS: {
	        type: 'cancel-success',
	        order: 3,
	    },
	    GIFT_REDEMPTION: {
	        type: 'gift_redemption',
	        order: 4
	    },
	    GIFT_DETAILS: {
	        type: 'gift-details',
	        order: 1
	    },
	    SUSPEND_RESUME_SUBSCRIPTION: {
	        type: 'suspend-resume-subscription',
	        order: 0,
	        completionEvent: FormEvent.SUSPEND_RESUME_SUBSCRIPTION_COMPLETE
	    },
	    SUBSCRIPTION_CUSTOM_FIELDS: {
	        type: 'subscription-custom-fields',
	        order: 0,
	    },
	    BILL_TO_CONTACT: {
	        type: 'bill-to-contact',
	        order: 0,
	        completionEvent: FormEvent.BILL_TO_CONTACT_COMPLETE
	    }
	};
	const partTypeFor = (type) => Object.values(partTypes).find(p => p.type == type) || (() => { throw `No part ${type} found`; })();

	var ServerError;
	(function (ServerError) {
	    ServerError[ServerError["USER_DOES_NOT_EXIST"] = 0] = "USER_DOES_NOT_EXIST";
	    ServerError[ServerError["USER_ALREADY_EXISTS"] = 1] = "USER_ALREADY_EXISTS";
	    ServerError[ServerError["PASSWORD_NOT_STRONG_ENOUGH"] = 2] = "PASSWORD_NOT_STRONG_ENOUGH";
	    ServerError[ServerError["EMAIL_VERIFICATION_REQUIRED"] = 3] = "EMAIL_VERIFICATION_REQUIRED";
	    ServerError[ServerError["VERIFICATION_CODE_OR_PASSWORD_INCORRECT"] = 4] = "VERIFICATION_CODE_OR_PASSWORD_INCORRECT";
	    ServerError[ServerError["VERIFICATION_CODE_INCORRECT"] = 5] = "VERIFICATION_CODE_INCORRECT";
	    ServerError[ServerError["LOGIN_FAILED"] = 6] = "LOGIN_FAILED";
	    ServerError[ServerError["UNKNOWN_LOGIN_REGISTER_ERROR"] = 7] = "UNKNOWN_LOGIN_REGISTER_ERROR";
	    ServerError[ServerError["NO_COOKIE_FROM_LOGIN_REGISTER_ERROR"] = 8] = "NO_COOKIE_FROM_LOGIN_REGISTER_ERROR";
	    ServerError[ServerError["NO_ACCOUNT_ACCESS"] = 9] = "NO_ACCOUNT_ACCESS";
	    ServerError[ServerError["ACCOUNT_NOT_FOUND"] = 10] = "ACCOUNT_NOT_FOUND";
	    ServerError[ServerError["PAYMENT_PROCESSING_ERROR"] = 11] = "PAYMENT_PROCESSING_ERROR";
	    ServerError[ServerError["MOBILE_PAYMENT_PROCESSING_ERROR"] = 12] = "MOBILE_PAYMENT_PROCESSING_ERROR";
	    ServerError[ServerError["PASSWORD_RESET_LINK_SEND_ERROR"] = 13] = "PASSWORD_RESET_LINK_SEND_ERROR";
	    ServerError[ServerError["PASSWORD_RESET_ERROR"] = 14] = "PASSWORD_RESET_ERROR";
	    ServerError[ServerError["VERIFICATION_CODE_SEND_ERROR"] = 15] = "VERIFICATION_CODE_SEND_ERROR";
	    ServerError[ServerError["SOCIAL_SIGNIN_REGISTRATION_LOGIN_ERROR"] = 16] = "SOCIAL_SIGNIN_REGISTRATION_LOGIN_ERROR";
	    ServerError[ServerError["PROMO_CODE_EXPIRED_ERROR"] = 17] = "PROMO_CODE_EXPIRED_ERROR";
	    ServerError[ServerError["PROMO_CODE_INVALID_ERROR"] = 18] = "PROMO_CODE_INVALID_ERROR";
	    ServerError[ServerError["PROMO_CODE_NOT_VALID_FOR_PLAN_ERROR"] = 19] = "PROMO_CODE_NOT_VALID_FOR_PLAN_ERROR";
	    ServerError[ServerError["INVITATION_FAILED_LIMIT_REACHED"] = 20] = "INVITATION_FAILED_LIMIT_REACHED";
	    ServerError[ServerError["INVITATION_FAILED_DUPLICATE_EMAIL"] = 21] = "INVITATION_FAILED_DUPLICATE_EMAIL";
	    ServerError[ServerError["INVITATION_FAILED_INVALID_EMAIL"] = 22] = "INVITATION_FAILED_INVALID_EMAIL";
	    ServerError[ServerError["INVITATION_FAILED_NO_PRODUCT_ACCESS"] = 23] = "INVITATION_FAILED_NO_PRODUCT_ACCESS";
	    ServerError[ServerError["INVITATION_FAILED_UNKNOWN"] = 24] = "INVITATION_FAILED_UNKNOWN";
	    ServerError[ServerError["TOO_MANY_SESSIONS"] = 25] = "TOO_MANY_SESSIONS";
	    ServerError[ServerError["INVALID_USER_ATTRIBUTES"] = 26] = "INVALID_USER_ATTRIBUTES";
	    ServerError[ServerError["CONTACT_CREATION_NOT_ENABLED"] = 27] = "CONTACT_CREATION_NOT_ENABLED";
	    ServerError[ServerError["NO_AUTHENTICATED_SESSION"] = 28] = "NO_AUTHENTICATED_SESSION";
	    ServerError[ServerError["BLOCKED_EMAIL_DOMAIN"] = 29] = "BLOCKED_EMAIL_DOMAIN";
	    ServerError[ServerError["UNKNOWN"] = 30] = "UNKNOWN";
	    ServerError[ServerError["GIFT_CODE_INVALID"] = 31] = "GIFT_CODE_INVALID";
	    ServerError[ServerError["GIFT_CODE_ALREADY_REDEEMED"] = 32] = "GIFT_CODE_ALREADY_REDEEMED";
	    ServerError[ServerError["GIFT_CODE_SERVER_ERROR"] = 33] = "GIFT_CODE_SERVER_ERROR";
	})(ServerError || (ServerError = {}));
	const ServerErrors = {
	    [ServerError.USER_DOES_NOT_EXIST]: {
	        languagePackKey: 'forms.errors.user-not-found',
	        fallbackMessage: 'User not found.',
	        jumpToPart: partTypes.ACCOUNT_VERIFICATION.type,
	        displayOnElements: [elementTypes.EMAIL_ADDRESS]
	    },
	    [ServerError.USER_ALREADY_EXISTS]: {
	        languagePackKey: 'forms.errors.email-taken',
	        fallbackMessage: 'This email address is already registered. Please log in to continue.',
	        jumpToPart: partTypes.ACCOUNT_VERIFICATION.type,
	        displayOnElements: [elementTypes.EMAIL_ADDRESS]
	    },
	    [ServerError.EMAIL_VERIFICATION_REQUIRED]: {
	        languagePackKey: 'forms.errors.email-verification-required',
	        fallbackMessage: 'Email verification is required',
	        jumpToPart: partTypes.ACCOUNT_VERIFICATION.type,
	        displayOnElements: [elementTypes.EMAIL_ADDRESS]
	    },
	    [ServerError.VERIFICATION_CODE_OR_PASSWORD_INCORRECT]: {
	        languagePackKey: 'forms.errors.otp-or-password-incorrect',
	        fallbackMessage: 'The password or code you entered is incorrect.',
	        displayOnElements: [elementTypes.VERIFICATION_CODE, elementTypes.PASSWORD]
	    },
	    [ServerError.VERIFICATION_CODE_INCORRECT]: {
	        languagePackKey: 'forms.errors.otp-incorrect',
	        fallbackMessage: 'The code you entered is incorrect.',
	        displayOnElements: [elementTypes.VERIFICATION_CODE]
	    },
	    [ServerError.LOGIN_FAILED]: {
	        languagePackKey: 'forms.errors.login-failed',
	        fallbackMessage: 'The email address or password you entered is incorrect.',
	        displayOnElements: [elementTypes.PASSWORD, elementTypes.VERIFICATION_CODE]
	    },
	    [ServerError.PASSWORD_NOT_STRONG_ENOUGH]: {
	        languagePackKey: 'n/a',
	        fallbackMessage: '',
	        useDymamicMessage: true,
	        displayOnElements: [elementTypes.PASSWORD]
	    },
	    [ServerError.UNKNOWN_LOGIN_REGISTER_ERROR]: {
	        languagePackKey: 'forms.errors.unknown-error',
	        fallbackMessage: 'Something went wrong. Please try again later',
	        displayOnElements: [elementTypes.PASSWORD, elementTypes.VERIFICATION_CODE]
	    },
	    [ServerError.NO_COOKIE_FROM_LOGIN_REGISTER_ERROR]: {
	        languagePackKey: 'forms.errors.unknown-error',
	        fallbackMessage: 'Something went wrong. Please try again later',
	        displayOnElements: [elementTypes.PASSWORD, elementTypes.VERIFICATION_CODE]
	    },
	    [ServerError.NO_ACCOUNT_ACCESS]: {
	        languagePackKey: 'forms.errors.too-many-requests',
	        fallbackMessage: 'To gain login access, please contact your administrator.',
	        displayOnElements: [elementTypes.PASSWORD]
	    },
	    [ServerError.ACCOUNT_NOT_FOUND]: {
	        languagePackKey: 'forms.errors.company-account-not-found',
	        fallbackMessage: 'Account not found.',
	        jumpToPart: partTypes.ACCOUNT_VERIFICATION.type,
	        displayOnElements: [elementTypes.ACCOUNT_MEMBERSHIP_CODE]
	    },
	    [ServerError.PAYMENT_PROCESSING_ERROR]: {
	        languagePackKey: 'forms.errors.unknown-payment-error',
	        fallbackMessage: 'Something went wrong when processing your payment. Please try again later.',
	        displayOnElements: [elementTypes.PAYMENT]
	    },
	    [ServerError.MOBILE_PAYMENT_PROCESSING_ERROR]: {
	        languagePackKey: 'forms.errors.unknown-payment-error',
	        fallbackMessage: 'Something went wrong when processing your payment. Please try again later.',
	        displayOnElements: [elementTypes.MOBILE_PAYMENT]
	    },
	    [ServerError.PASSWORD_RESET_LINK_SEND_ERROR]: {
	        languagePackKey: 'forms.errors.password-reset-link-send-failed',
	        fallbackMessage: 'Unable to send a password reset link. Please try again later',
	        displayOnElements: [elementTypes.RESET_PASSWORD_LINK]
	    },
	    [ServerError.VERIFICATION_CODE_SEND_ERROR]: {
	        languagePackKey: 'forms.errors.otp-send-failed',
	        fallbackMessage: 'Unable to send a verification code. Please try again later',
	        displayOnElements: [elementTypes.VERIFICATION_CODE]
	    },
	    [ServerError.PASSWORD_RESET_ERROR]: {
	        languagePackKey: 'forms.errors.password-reset-failed',
	        fallbackMessage: 'Unable to reset your password. Please try again later',
	        displayOnElements: [elementTypes.PASSWORD]
	    },
	    [ServerError.SOCIAL_SIGNIN_REGISTRATION_LOGIN_ERROR]: {
	        languagePackKey: 'forms.errors.unknown-error',
	        fallbackMessage: 'Something went wrong. Please try again later',
	        displayOnElements: [elementTypes.SOCIAL_SIGNIN]
	    },
	    [ServerError.PROMO_CODE_EXPIRED_ERROR]: {
	        languagePackKey: 'forms.errors.promo-code-expired',
	        fallbackMessage: 'Promo code expired',
	        displayOnElements: [elementTypes.PAYMENT_SUMMARY]
	    },
	    [ServerError.PROMO_CODE_INVALID_ERROR]: {
	        languagePackKey: 'forms.errors.promo-code-invalid',
	        fallbackMessage: 'Invalid promo code',
	        displayOnElements: [elementTypes.PAYMENT_SUMMARY]
	    },
	    [ServerError.PROMO_CODE_NOT_VALID_FOR_PLAN_ERROR]: {
	        languagePackKey: 'forms.errors.promo-code-invalid-for-payment-option',
	        fallbackMessage: 'Promo code cannot be applied to selected option',
	        displayOnElements: [elementTypes.PAYMENT_SUMMARY]
	    },
	    [ServerError.INVITATION_FAILED_LIMIT_REACHED]: {
	        languagePackKey: 'forms.errors.invitation-failed-limit-reached',
	        fallbackMessage: 'You have reached the sharing limit for this product',
	        displayOnElements: [elementTypes.INVITATION]
	    },
	    [ServerError.INVITATION_FAILED_DUPLICATE_EMAIL]: {
	        languagePackKey: 'forms.errors.invitation-failed-duplicate-email',
	        fallbackMessage: 'An invite has already been created for this email',
	        displayOnElements: [elementTypes.INVITATION]
	    },
	    [ServerError.INVITATION_FAILED_INVALID_EMAIL]: {
	        languagePackKey: 'forms.errors.invitation-failed-invalid-email',
	        fallbackMessage: 'Invalid email address',
	        displayOnElements: [elementTypes.INVITATION]
	    },
	    [ServerError.INVITATION_FAILED_NO_PRODUCT_ACCESS]: {
	        languagePackKey: 'forms.errors.invitation-failed-no-product-access',
	        fallbackMessage: 'You do not currently have access to this product',
	        displayOnElements: [elementTypes.INVITATION]
	    },
	    [ServerError.INVITATION_FAILED_UNKNOWN]: {
	        languagePackKey: 'forms.errors.unknown-error',
	        fallbackMessage: 'Something went wrong. Please try again later',
	        displayOnElements: [elementTypes.INVITATION]
	    },
	    [ServerError.TOO_MANY_SESSIONS]: {
	        languagePackKey: 'forms.errors.session-limit-reached',
	        fallbackMessage: 'You have reached the session limit. Please log out from another device to access this content.',
	        displayOnElements: [elementTypes.EMAIL_ADDRESS]
	    },
	    [ServerError.INVALID_USER_ATTRIBUTES]: {
	        languagePackKey: 'forms.errors.user-attribute-invalid',
	        fallbackMessage: 'Invalid User Attribute',
	        displayOnElements: [elementTypes.USER_ATTRIBUTE]
	    },
	    [ServerError.CONTACT_CREATION_NOT_ENABLED]: {
	        languagePackKey: 'forms.errors.contact-creation-disabled',
	        fallbackMessage: 'This operation is not possible at the moment, please try again later.',
	        jumpToPart: partTypes.ACCOUNT_VERIFICATION.type,
	        displayOnElements: [elementTypes.EMAIL_ADDRESS]
	    },
	    [ServerError.NO_AUTHENTICATED_SESSION]: {
	        languagePackKey: 'forms.errors.no-authenticated-session',
	        fallbackMessage: 'Please login to update your profile',
	    },
	    [ServerError.BLOCKED_EMAIL_DOMAIN]: {
	        languagePackKey: 'forms.errors.email-domain-blocked',
	        fallbackMessage: 'Please use a different email address, this domain is not supported.',
	        jumpToPart: partTypes.ACCOUNT_VERIFICATION.type,
	        displayOnElements: [elementTypes.EMAIL_ADDRESS]
	    },
	    [ServerError.UNKNOWN]: {
	        languagePackKey: 'forms.errors.unknown-error',
	        fallbackMessage: 'Something went wrong. Please try again later',
	    },
	    [ServerError.GIFT_CODE_INVALID]: {
	        languagePackKey: 'forms.errors.gift-code-invalid',
	        fallbackMessage: 'Invalid gift code',
	        displayOnElements: [elementTypes.GIFT_CODE]
	    },
	    [ServerError.GIFT_CODE_ALREADY_REDEEMED]: {
	        languagePackKey: 'forms.errors.gift-code-already-redeemed',
	        fallbackMessage: 'Gift code already redeemed',
	        displayOnElements: [elementTypes.GIFT_CODE]
	    },
	    [ServerError.GIFT_CODE_SERVER_ERROR]: {
	        languagePackKey: 'forms.errors.gift-code-server-error',
	        fallbackMessage: 'Something went wrong with the gift code. Please try again later',
	        displayOnElements: [elementTypes.GIFT_CODE]
	    }
	};
	const serverErrorForElement = (elementType, formState) => formState.serverErrors.find(e => ServerErrors[e].displayOnElements?.includes(elementType)) ?? undefined;

	const sectionTypes = {
	    PLAN_SELECT: {
	        type: 'plan_select',
	        defaultLabel: 'Plan Select',
	        fullWidth: true
	    },
	    EMAIL: {
	        type: 'email',
	        defaultLabel: 'Account Verification',
	        completionEvent: FormEvent.SECTION_EMAIL_COMPLETE,
	    },
	    RECIPIENT_DETAILS: {
	        type: 'recipient_details',
	        defaultLabel: 'Recipient',
	    },
	    PASSWORD_SETUP: {
	        type: 'password_setup',
	        defaultLabel: 'Password Setup'
	    },
	    PASSWORDLESS_VIA_LOGIN_LINK: {
	        type: 'passwordless_login_via_link',
	        defaultLabel: 'Passwordless Login via Login Link'
	    },
	    VERIFICATION_CODE_LOGIN: {
	        type: 'verification_code_login',
	        defaultLabel: ''
	    },
	    VERIFICATION_CODE_REGISTRATION: {
	        type: 'verification_code_registration',
	        defaultLabel: ''
	    },
	    LOGIN_PASSWORD: {
	        type: 'login_password',
	        defaultLabel: 'Login'
	    },
	    REGISTRATION_CUSTOM: {
	        type: 'registration_custom',
	        defaultLabel: '',
	    },
	    FORGOT_PASSWORD: {
	        type: 'forgot_password',
	        defaultLabel: '',
	        completionEvent: FormEvent.SECTION_FORGOT_PASSWORD_COMPLETE,
	    },
	    PASSWORD_RESET: {
	        type: 'reset_password',
	        defaultLabel: '',
	        completionEvent: FormEvent.SECTION_PASSWORD_RESET_COMPLETE,
	    },
	    SUCCESS: {
	        type: 'success',
	        defaultLabel: ''
	    },
	    EMAIL_VERIFIED: {
	        type: 'email_verified',
	        defaultLabel: ''
	    },
	    READ_ONLY_PROFILE: {
	        type: 'read_only_profile',
	        defaultLabel: 'Read Only Profile'
	    },
	    UPDATE_EMAIL: {
	        type: 'update_email',
	        defaultLabel: 'Update Email'
	    },
	    UPDATE_PASSWORD: {
	        type: 'update_password',
	        defaultLabel: 'Update Password'
	    },
	    UPDATE_ATTRIBUTES: {
	        type: 'update_attributes',
	        defaultLabel: 'Update Attributes'
	    },
	    CHANGE_PAYMENT: {
	        type: 'change-payment',
	        completionEvent: FormEvent.PART_CHANGE_PAYMENT_COMPLETE,
	        defaultLabel: ''
	    },
	    SELECT: {
	        type: 'select',
	        defaultLabel: '',
	        fullWidth: true,
	    },
	    LIST: {
	        type: 'list',
	        defaultLabel: '',
	        fullWidth: true,
	    },
	    PAST_SUBSCRIPTIONS: {
	        type: 'past-subscriptions',
	        defaultLabel: '',
	        fullWidth: true,
	    },
	    GIFT_REDEMPTION: {
	        type: 'gift_redemption',
	        defaultLabel: 'Gift Code Redemption',
	        completionEvent: FormEvent.GIFT_REDEMPTION_COMPLETE
	    },
	    GIFT_REDEEMED: {
	        type: 'gift_redeemed',
	        defaultLabel: 'Gift Redeemed'
	    },
	    GIFT_DETAIL: {
	        type: 'gift-detail',
	        defaultLabel: 'Gift Details'
	    },
	    SUSPEND_RESUME_SUBSCRIPTION: {
	        type: 'suspend_resume_subscription',
	        defaultLabel: 'Suspend/Resume Subscription',
	    },
	    BILL_TO_CONTACT: {
	        type: 'bill_to_contact',
	        defaultLabel: 'Update Bill To Contact Address',
	    },
	};
	const sectionTypeFor = (type) => Object.values(sectionTypes).find(s => s.type == type);

	function logDataLayerEvent(form, eventName, customDimensions) {
	    const event = {
	        event: eventName,
	        formType: form.formType,
	        formId: form.formId,
	        ruleId: form.ruleId,
	        outcomeId: form.outcomeId,
	        ...customDimensions
	    };
	    window.postMessage({ 'zephr-form-datalayer-event': event }, window.origin);
	    if (!form.organisationConfiguration.trackFormDataLayerEvents) {
	        return;
	    }
	    const dataLayerName = form.organisationConfiguration.dataLayerName || 'dataLayer';
	    window[dataLayerName] = window[dataLayerName] || [];
	    window[dataLayerName].push(event);
	}

	const reScrollToFormTop = (formId) => {
	    try {
	        const formRootElement = document.getElementById(formId);
	        if (!formRootElement)
	            return;
	        const { top } = formRootElement.getBoundingClientRect();
	        if (top < 0) {
	            formRootElement.scrollIntoView({
	                block: "start",
	                inline: "nearest",
	            });
	        }
	    }
	    catch (err) {
	        console.error(err);
	    }
	};

	/**
	 * Functions to initiate movements through the form sections.
	 */
	const findSection = (sectionType, form) => {
	    return form.parts
	        .flatMap(part => part.sections.map(section => ({ part, section })))
	        .find(partSection => partSection.section.type === sectionType);
	};
	const findSectionByAddress = (address, form) => {
	    const [part, section] = address.includes(':') ? address.split(':') : [null, address];
	    return form.parts
	        .flatMap(part => part.sections.map(section => ({ part, section })))
	        .find(partSection => partSection.section.type === section && (!part || partSection.part.type === part));
	};
	const jumpToSection = (sectionType, form, formActions) => {
	    const destination = findSection(sectionType, form);
	    if (!destination) {
	        throw `Cannot find section ${sectionType}`;
	    }
	    const formState = formActions.getFormState();
	    setSection({
	        form,
	        formActions,
	        part: destination.part,
	        section: destination.section,
	        previousPart: formState.currentPart,
	        previousSection: formState.currentSection
	    });
	    return Promise.resolve();
	};
	const jumpToPart = (partType, form, formActions) => {
	    if (form.environment.previewMode) {
	        return;
	    }
	    const part = form.parts.find(p => p.type == partType);
	    const formState = formActions.getFormState();
	    setSection({
	        form,
	        formActions,
	        part,
	        section: part.sections[0],
	        previousPart: formState.currentPart,
	        previousSection: formState.currentSection
	    });
	    return Promise.resolve();
	};
	const findNextPart = (currentPart, form) => {
	    const partType = partTypeFor(currentPart.type);
	    if (partType) {
	        const nextPart = form.parts.find((p) => partTypeFor(p.type).order === partType.order + 1)
	            ?? form.parts[form.parts.indexOf(currentPart) + 1];
	        if (nextPart) {
	            return {
	                section: nextPart.sections[0],
	                part: nextPart
	            };
	        }
	    }
	    return null;
	};
	const findNextSection = (currentSection, currentPart, form) => {
	    // Next section in part ...
	    const currentSectionIndex = currentPart.sections.findIndex((s) => s.order == currentSection.order);
	    if (currentPart.sections.length > currentSectionIndex + 1) {
	        return {
	            section: currentPart.sections[currentSectionIndex + 1],
	            part: currentPart
	        };
	    }
	    // ... or the first setion in next part
	    return findNextPart(currentPart, form);
	};
	const mapCustomSectionType = (sectionType) => {
	    return sectionType?.startsWith('custom_') ? 'registration_custom' : sectionType;
	};
	const isSectionVisible = (section, form, formState) => form.sectionFlow.sectionVisibilities.find((s) => s.type === mapCustomSectionType(section.type))
	    ?.isVisible(form, formState) ?? true;
	const isSectionDisplayedInProgressBar = (section, form, formState) => {
	    const sectionConfig = form.sectionFlow.sectionVisibilities
	        .find((s) => (s.type === mapCustomSectionType(section.type)));
	    return (sectionConfig?.isDisplayedInProgressBar && isSectionVisible(section, form, formState)) ?? true;
	};
	const moveToNextSection = (form, formState, formActions) => {
	    if (form.environment.previewMode) {
	        return;
	    }
	    // Find the next visible section
	    let i = 0;
	    let nextPartSection = { part: formState.currentPart, section: formState.currentSection };
	    do {
	        i++;
	        if (i > 50) {
	            throw new Error(`Cannot move from ${formState.currentPart.type}:${formState.currentSection.type}. 
      Exceeded max loop size after ${nextPartSection?.part?.type}:${nextPartSection?.section?.type}
    `);
	        }
	        const next = findNextSection(nextPartSection?.section, nextPartSection?.part, form);
	        if (next?.part.type === nextPartSection?.part?.type
	            && next?.section.type === nextPartSection?.section?.type
	            && next?.section.order === nextPartSection?.section?.order) {
	            throw new Error(`Cannot move from ${formState.currentPart.type}:${formState.currentSection.type}. 
        Infinte loop found at next section ${next?.part?.type}:${next?.section?.type}
      `);
	        }
	        nextPartSection = next;
	    } while (nextPartSection && !isSectionVisible(nextPartSection.section, form, formState));
	    if (!nextPartSection || nextPartSection.part !== formState.currentPart) {
	        const part = partTypeFor(formState.currentPart.type);
	        const action = part?.completionEvent && form.sectionFlow.eventHandlers[part.completionEvent];
	        if (action) {
	            return action(form, formState, formActions);
	        }
	    }
	    if (!nextPartSection) {
	        throw "No next section";
	    }
	    setSection({
	        form,
	        formActions,
	        part: nextPartSection.part,
	        section: nextPartSection.section,
	        previousPart: formState.currentPart,
	        previousSection: formState.currentSection
	    });
	    return Promise.resolve();
	};
	const completeSection = (form, formState, formActions) => {
	    if (form.environment.previewMode) {
	        return;
	    }
	    const sectionType = sectionTypeFor(formState.currentSection.type);
	    const action = (sectionType && form.sectionFlow.eventHandlers[sectionType.completionEvent]) ?? moveToNextSection;
	    return action(form, formState, formActions);
	};
	const attemptCompleteSection = (form, _, formActions) => {
	    if (formActions.getFormState().canAttemptSectionCompletion) {
	        const updatedState = formActions.updateFormState({
	            showFieldErrors: false
	        });
	        return completeSection(form, updatedState, formActions);
	    }
	    formActions.updateFormState({
	        showFieldErrors: true
	    });
	    return Promise.resolve();
	};
	const setSection = ({ form, formActions, part, section, previousSection, previousPart }) => {
	    formActions.updateFormState({
	        currentPart: part,
	        currentSection: section
	    });
	    logDataLayerEvent(form, 'zephr_form_section_change', {
	        sectionId: section.type,
	        previousSectionId: previousSection.type,
	        partId: part.type,
	        previousPartId: previousPart.type
	    });
	    reScrollToFormTop(form.formId);
	};

	/* src/components/elements/progressBar/ProgressBar.svelte generated by Svelte v4.2.12 */

	function get_each_context$g(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[7] = list[i];
		const constants_0 = !/*disabled*/ child_ctx[0] && !/*item*/ child_ctx[7].isDisabled && /*item*/ child_ctx[7].order < /*currentItem*/ child_ctx[2].order;
		child_ctx[8] = constants_0;
		return child_ctx;
	}

	// (15:0) {#if !isNaN(value)}
	function create_if_block$K(ctx) {
		let div;
		let t;
		let progress;
		let each_value = ensure_array_like(/*visibleItems*/ ctx[3]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$g(get_each_context$g(ctx, each_value, i));
		}

		return {
			c() {
				div = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t = space();
				progress = element("progress");
				attr(div, "class", "zephr-form-flex-container");
				toggle_class(div, "zephr-payment-form-flex-container", /*isPaymentForm*/ ctx[1]);
				attr(progress, "class", "zephr-form-progress-bar svelte-19rlx92");
				attr(progress, "id", "progress-bar");
				attr(progress, "max", "100");
				progress.value = /*value*/ ctx[4];
				toggle_class(progress, "zephr-payment-form-progress-bar", /*isPaymentForm*/ ctx[1]);
			},
			m(target, anchor) {
				insert(target, div, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div, null);
					}
				}

				insert(target, t, anchor);
				insert(target, progress, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*isPaymentForm, visibleItems, disabled, currentItem*/ 15) {
					each_value = ensure_array_like(/*visibleItems*/ ctx[3]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$g(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$g(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(div, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}

				if (dirty & /*isPaymentForm*/ 2) {
					toggle_class(div, "zephr-payment-form-flex-container", /*isPaymentForm*/ ctx[1]);
				}

				if (dirty & /*value*/ 16) {
					progress.value = /*value*/ ctx[4];
				}

				if (dirty & /*isPaymentForm*/ 2) {
					toggle_class(progress, "zephr-payment-form-progress-bar", /*isPaymentForm*/ ctx[1]);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t);
					detach(progress);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (33:6) {:else}
	function create_else_block$c(ctx) {
		let div;
		let t0_value = /*item*/ ctx[7].label + "";
		let t0;
		let t1;

		return {
			c() {
				div = element("div");
				t0 = text(t0_value);
				t1 = space();
				attr(div, "class", "zephr-progress-bar-step disabled svelte-19rlx92");
				toggle_class(div, "zephr-payment-progress-bar-step", /*isPaymentForm*/ ctx[1]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t0);
				append(div, t1);
			},
			p(ctx, dirty) {
				if (dirty & /*visibleItems*/ 8 && t0_value !== (t0_value = /*item*/ ctx[7].label + "")) set_data(t0, t0_value);

				if (dirty & /*isPaymentForm*/ 2) {
					toggle_class(div, "zephr-payment-progress-bar-step", /*isPaymentForm*/ ctx[1]);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (24:6) {#if isClickable}
	function create_if_block_1$y(ctx) {
		let button;
		let t0_value = /*item*/ ctx[7].label + "";
		let t0;
		let t1;
		let mounted;
		let dispose;

		function click_handler() {
			return /*click_handler*/ ctx[6](/*item*/ ctx[7]);
		}

		return {
			c() {
				button = element("button");
				t0 = text(t0_value);
				t1 = space();
				attr(button, "type", "button");
				attr(button, "class", "zephr-progress-bar-step svelte-19rlx92");
				toggle_class(button, "zephr-payment-progress-bar-step", /*isPaymentForm*/ ctx[1]);
			},
			m(target, anchor) {
				insert(target, button, anchor);
				append(button, t0);
				append(button, t1);

				if (!mounted) {
					dispose = listen(button, "click", prevent_default(click_handler));
					mounted = true;
				}
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				if (dirty & /*visibleItems*/ 8 && t0_value !== (t0_value = /*item*/ ctx[7].label + "")) set_data(t0, t0_value);

				if (dirty & /*isPaymentForm*/ 2) {
					toggle_class(button, "zephr-payment-progress-bar-step", /*isPaymentForm*/ ctx[1]);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(button);
				}

				mounted = false;
				dispose();
			}
		};
	}

	// (20:4) {#each visibleItems as item}
	function create_each_block$g(ctx) {
		let if_block_anchor;

		function select_block_type(ctx, dirty) {
			if (/*isClickable*/ ctx[8]) return create_if_block_1$y;
			return create_else_block$c;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_block.d(detaching);
			}
		};
	}

	function create_fragment$1b(ctx) {
		let show_if = !isNaN(/*value*/ ctx[4]);
		let if_block_anchor;
		let if_block = show_if && create_if_block$K(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, [dirty]) {
				if (dirty & /*value*/ 16) show_if = !isNaN(/*value*/ ctx[4]);

				if (show_if) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$K(ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	function instance$19($$self, $$props, $$invalidate) {
		let currentItem;
		let visibleItems;
		let value;
		let { disabled } = $$props;
		let { items } = $$props;
		let { isPaymentForm = false } = $$props;

		const click_handler = item => {
			item.onSelect();
		};

		$$self.$$set = $$props => {
			if ('disabled' in $$props) $$invalidate(0, disabled = $$props.disabled);
			if ('items' in $$props) $$invalidate(5, items = $$props.items);
			if ('isPaymentForm' in $$props) $$invalidate(1, isPaymentForm = $$props.isPaymentForm);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*items*/ 32) {
				$$invalidate(2, currentItem = items.find(i => i.isCurrent));
			}

			if ($$self.$$.dirty & /*items*/ 32) {
				$$invalidate(3, visibleItems = items.filter(i => i.isVisible));
			}

			if ($$self.$$.dirty & /*visibleItems, currentItem*/ 12) {
				$$invalidate(4, value = Math.floor(100 / (visibleItems.length - 1) * (currentItem.isVisible
				? currentItem.visibleOrder
				: Math.max.apply(Math, visibleItems.filter(i => i.order < currentItem.order).map(i => i.visibleOrder)))));
			}
		};

		return [
			disabled,
			isPaymentForm,
			currentItem,
			visibleItems,
			value,
			items,
			click_handler
		];
	}

	class ProgressBar extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$19, create_fragment$1b, safe_not_equal, { disabled: 0, items: 5, isPaymentForm: 1 });
		}
	}

	var FormType;
	(function (FormType) {
	    FormType["EMPTY"] = "EMPTY";
	    FormType["PAYMENT"] = "PAYMENT";
	    FormType["CHANGE_SUBSCRIPTION"] = "CHANGE_SUBSCRIPTION";
	    FormType["REGISTRATION"] = "REGISTRATION";
	    FormType["CONTACT"] = "CONTACT";
	    FormType["DATA_CAPTURE"] = "DATA_CAPTURE";
	    FormType["COMPLETE_REGISTRATION"] = "COMPLETE_REGISTRATION";
	    FormType["UPDATE_PROFILE"] = "UPDATE_PROFILE";
	    FormType["CANCEL_SUBSCRIPTION"] = "CANCEL_SUBSCRIPTION";
	    FormType["LIST_SUBSCRIPTIONS"] = "LIST_SUBSCRIPTIONS";
	    FormType["SUSPEND_RESUME_SUBSCRIPTION"] = "SUSPEND_RESUME_SUBSCRIPTION";
	    FormType["DEVICES"] = "DEVICES";
	    FormType["GIFT_SUBSCRIPTION"] = "GIFT_SUBSCRIPTION";
	    FormType["GIFT_REDEMPTION"] = "GIFT_REDEMPTION";
	    FormType["LIST_GIFT_SUBSCRIPTIONS_SENT"] = "LIST_GIFT_SUBSCRIPTIONS_SENT";
	    FormType["BILL_TO_CONTACT"] = "BILL_TO_CONTACT";
	})(FormType || (FormType = {}));

	const toProgressBarItems = (form, formState, formActions) => {
	    let order = 0;
	    let visibleOrder = 0;
	    return form.parts.flatMap(part => part.sections
	        .map(section => ({ part, section })))
	        .map(({ part, section }) => ({
	        type: section.type,
	        isVisible: isSectionDisplayedInProgressBar(section, form, formState),
	        label: (section.label ?? part.label) ?? sectionTypeFor(section.type)?.defaultLabel,
	        isCurrent: formState.currentSection == section,
	        // Do not allow users to go backwards from PAYMENT if they have just registered
	        isDisabled: formState.loginRegistrationComplete && ![partTypes.PLAN_SELECT.type ].includes(part.type),
	        order: order++,
	        visibleOrder: isSectionDisplayedInProgressBar(section, form, formState) ? visibleOrder++ : null,
	        onSelect: () => setSection({ form, formActions, part, section, previousSection: formState.currentSection, previousPart: formState.currentPart })
	    }));
	};
	const factory$s = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.PROGRESS_BAR,
	    create: (form, formState, formActions) => {
	        return {
	            component: ProgressBar,
	            props: {
	                disabled: formState.isBusy,
	                items: toProgressBarItems(form, formState, formActions),
	                isPaymentForm: form.formType === FormType.PAYMENT,
	            }
	        };
	    }
	};

	const formConfigAs = (form) => {
	    return form.typeConfiguration;
	};

	/* src/components/elements/button/Button.svelte generated by Svelte v4.2.12 */

	function create_fragment$1a(ctx) {
		let button;
		let t;
		let mounted;
		let dispose;

		return {
			c() {
				button = element("button");
				t = text(/*text*/ ctx[1]);
				attr(button, "class", "zephr-form-button svelte-gd8hr6");
				attr(button, "type", "submit");
				button.disabled = /*disabled*/ ctx[0];
				toggle_class(button, "zephr-payment-form-button", /*isPaymentForm*/ ctx[5]);
				toggle_class(button, "zephr-form-button-top-margin", !/*noMargin*/ ctx[2]);
				toggle_class(button, "zephr-payment-form-button-top-margin", /*isPaymentForm*/ ctx[5] && !/*noMargin*/ ctx[2]);
				toggle_class(button, "inputHeight", /*inputHeight*/ ctx[3]);
				toggle_class(button, "aside", /*aside*/ ctx[4]);
			},
			m(target, anchor) {
				insert(target, button, anchor);
				append(button, t);

				if (!mounted) {
					dispose = listen(button, "click", prevent_default(function () {
						if (is_function(/*onClick*/ ctx[6])) /*onClick*/ ctx[6].apply(this, arguments);
					}));

					mounted = true;
				}
			},
			p(new_ctx, [dirty]) {
				ctx = new_ctx;
				if (dirty & /*text*/ 2) set_data(t, /*text*/ ctx[1]);

				if (dirty & /*disabled*/ 1) {
					button.disabled = /*disabled*/ ctx[0];
				}

				if (dirty & /*isPaymentForm*/ 32) {
					toggle_class(button, "zephr-payment-form-button", /*isPaymentForm*/ ctx[5]);
				}

				if (dirty & /*noMargin*/ 4) {
					toggle_class(button, "zephr-form-button-top-margin", !/*noMargin*/ ctx[2]);
				}

				if (dirty & /*isPaymentForm, noMargin*/ 36) {
					toggle_class(button, "zephr-payment-form-button-top-margin", /*isPaymentForm*/ ctx[5] && !/*noMargin*/ ctx[2]);
				}

				if (dirty & /*inputHeight*/ 8) {
					toggle_class(button, "inputHeight", /*inputHeight*/ ctx[3]);
				}

				if (dirty & /*aside*/ 16) {
					toggle_class(button, "aside", /*aside*/ ctx[4]);
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(button);
				}

				mounted = false;
				dispose();
			}
		};
	}

	function instance$18($$self, $$props, $$invalidate) {
		let { disabled } = $$props;
		let { text } = $$props;
		let { noMargin = false } = $$props;
		let { inputHeight = false } = $$props;
		let { aside = false } = $$props;
		let { isPaymentForm = false } = $$props;
		let { onClick } = $$props;

		$$self.$$set = $$props => {
			if ('disabled' in $$props) $$invalidate(0, disabled = $$props.disabled);
			if ('text' in $$props) $$invalidate(1, text = $$props.text);
			if ('noMargin' in $$props) $$invalidate(2, noMargin = $$props.noMargin);
			if ('inputHeight' in $$props) $$invalidate(3, inputHeight = $$props.inputHeight);
			if ('aside' in $$props) $$invalidate(4, aside = $$props.aside);
			if ('isPaymentForm' in $$props) $$invalidate(5, isPaymentForm = $$props.isPaymentForm);
			if ('onClick' in $$props) $$invalidate(6, onClick = $$props.onClick);
		};

		return [disabled, text, noMargin, inputHeight, aside, isPaymentForm, onClick];
	}

	class Button extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$18, create_fragment$1a, safe_not_equal, {
				disabled: 0,
				text: 1,
				noMargin: 2,
				inputHeight: 3,
				aside: 4,
				isPaymentForm: 5,
				onClick: 6
			});
		}
	}

	/* src/components/elements/paymentOptionSelection/PaymentOptionComponent.svelte generated by Svelte v4.2.12 */

	function create_if_block_1$x(ctx) {
		let div;
		let t_value = /*paymentOption*/ ctx[1].highlightedText + "";
		let t;

		return {
			c() {
				div = element("div");
				t = text(t_value);
				attr(div, "class", "box-top-text svelte-hcxnnv");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty & /*paymentOption*/ 2 && t_value !== (t_value = /*paymentOption*/ ctx[1].highlightedText + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (38:8) {#if paymentOption.disclaimerMessage}
	function create_if_block$J(ctx) {
		let span;
		let t_value = /*paymentOption*/ ctx[1].disclaimerMessage + "";
		let t;

		return {
			c() {
				span = element("span");
				t = text(t_value);
				attr(span, "class", "button-sub-text svelte-hcxnnv");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty & /*paymentOption*/ 2 && t_value !== (t_value = /*paymentOption*/ ctx[1].disclaimerMessage + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	function create_fragment$19(ctx) {
		let div5;
		let input;
		let input_id_value;
		let input_value_value;
		let t0;
		let div4;
		let div0;
		let t1;
		let div3;
		let div1;
		let raw_value = (/*paymentOption*/ ctx[1].description ?? '') + "";
		let t2;
		let div2;
		let button;
		let t3;
		let div3_class_value;
		let div4_class_value;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*paymentOption*/ ctx[1].highlightedText && create_if_block_1$x(ctx);

		button = new Button({
				props: {
					disabled: false,
					text: /*paymentOption*/ ctx[1].selectButtonText ?? 'Select Plan',
					onClick: /*onSelect*/ ctx[0],
					isPaymentForm: true
				}
			});

		let if_block1 = /*paymentOption*/ ctx[1].disclaimerMessage && create_if_block$J(ctx);

		return {
			c() {
				div5 = element("div");
				input = element("input");
				t0 = space();
				div4 = element("div");
				div0 = element("div");
				if (if_block0) if_block0.c();
				t1 = space();
				div3 = element("div");
				div1 = element("div");
				t2 = space();
				div2 = element("div");
				create_component(button.$$.fragment);
				t3 = space();
				if (if_block1) if_block1.c();
				attr(input, "type", "radio");
				attr(input, "name", "boxSelect");
				attr(input, "id", input_id_value = "boxSelect-" + /*paymentOption*/ ctx[1].slug + "-" + /*paymentOption*/ ctx[1].productId + "}");
				input.value = input_value_value = /*paymentOption*/ ctx[1].price;
				attr(input, "class", "svelte-hcxnnv");
				attr(div0, "class", "box-top svelte-hcxnnv");
				attr(div1, "class", "box-content svelte-hcxnnv");
				toggle_class(div1, "styled-box-content", /*styleDescription*/ ctx[2]);
				attr(div2, "class", "box-bottom svelte-hcxnnv");
				attr(div3, "class", div3_class_value = "inner-box " + (/*paymentOption*/ ctx[1].highlightedText || '') + " svelte-hcxnnv");

				attr(div4, "class", div4_class_value = "box-container " + (/*paymentOption*/ ctx[1].highlightedText
				? 'highlighted'
				: '') + " svelte-hcxnnv");

				attr(div4, "aria-hidden", "true");
				set_style(div4, "cursor", "pointer");
				attr(div5, "class", "payment-option-wrapper svelte-hcxnnv");
			},
			m(target, anchor) {
				insert(target, div5, anchor);
				append(div5, input);
				append(div5, t0);
				append(div5, div4);
				append(div4, div0);
				if (if_block0) if_block0.m(div0, null);
				append(div4, t1);
				append(div4, div3);
				append(div3, div1);
				div1.innerHTML = raw_value;
				append(div3, t2);
				append(div3, div2);
				mount_component(button, div2, null);
				append(div2, t3);
				if (if_block1) if_block1.m(div2, null);
				current = true;

				if (!mounted) {
					dispose = listen(div4, "click", prevent_default(function () {
						if (is_function(/*onSelect*/ ctx[0])) /*onSelect*/ ctx[0].apply(this, arguments);
					}));

					mounted = true;
				}
			},
			p(new_ctx, [dirty]) {
				ctx = new_ctx;

				if (!current || dirty & /*paymentOption*/ 2 && input_id_value !== (input_id_value = "boxSelect-" + /*paymentOption*/ ctx[1].slug + "-" + /*paymentOption*/ ctx[1].productId + "}")) {
					attr(input, "id", input_id_value);
				}

				if (!current || dirty & /*paymentOption*/ 2 && input_value_value !== (input_value_value = /*paymentOption*/ ctx[1].price)) {
					input.value = input_value_value;
				}

				if (/*paymentOption*/ ctx[1].highlightedText) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_1$x(ctx);
						if_block0.c();
						if_block0.m(div0, null);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if ((!current || dirty & /*paymentOption*/ 2) && raw_value !== (raw_value = (/*paymentOption*/ ctx[1].description ?? '') + "")) div1.innerHTML = raw_value;
				if (!current || dirty & /*styleDescription*/ 4) {
					toggle_class(div1, "styled-box-content", /*styleDescription*/ ctx[2]);
				}

				const button_changes = {};
				if (dirty & /*paymentOption*/ 2) button_changes.text = /*paymentOption*/ ctx[1].selectButtonText ?? 'Select Plan';
				if (dirty & /*onSelect*/ 1) button_changes.onClick = /*onSelect*/ ctx[0];
				button.$set(button_changes);

				if (/*paymentOption*/ ctx[1].disclaimerMessage) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block$J(ctx);
						if_block1.c();
						if_block1.m(div2, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (!current || dirty & /*paymentOption*/ 2 && div3_class_value !== (div3_class_value = "inner-box " + (/*paymentOption*/ ctx[1].highlightedText || '') + " svelte-hcxnnv")) {
					attr(div3, "class", div3_class_value);
				}

				if (!current || dirty & /*paymentOption*/ 2 && div4_class_value !== (div4_class_value = "box-container " + (/*paymentOption*/ ctx[1].highlightedText
				? 'highlighted'
				: '') + " svelte-hcxnnv")) {
					attr(div4, "class", div4_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(button.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(button.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div5);
				}

				if (if_block0) if_block0.d();
				destroy_component(button);
				if (if_block1) if_block1.d();
				mounted = false;
				dispose();
			}
		};
	}

	function instance$17($$self, $$props, $$invalidate) {
		let { onSelect } = $$props;
		let { paymentOption } = $$props;
		let { styleDescription } = $$props;

		$$self.$$set = $$props => {
			if ('onSelect' in $$props) $$invalidate(0, onSelect = $$props.onSelect);
			if ('paymentOption' in $$props) $$invalidate(1, paymentOption = $$props.paymentOption);
			if ('styleDescription' in $$props) $$invalidate(2, styleDescription = $$props.styleDescription);
		};

		return [onSelect, paymentOption, styleDescription];
	}

	class PaymentOptionComponent extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$17, create_fragment$19, safe_not_equal, {
				onSelect: 0,
				paymentOption: 1,
				styleDescription: 2
			});
		}
	}

	/* src/components/elements/paymentOptionSelection/PaymentOptionSelectionComponent.svelte generated by Svelte v4.2.12 */

	function get_each_context$f(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[6] = list[i];
		return child_ctx;
	}

	// (12:2) {#each orderedPaymentOptions as paymentOption}
	function create_each_block$f(ctx) {
		let paymentoptioncomponent;
		let current;

		function func() {
			return /*func*/ ctx[5](/*paymentOption*/ ctx[6]);
		}

		paymentoptioncomponent = new PaymentOptionComponent({
				props: {
					paymentOption: /*paymentOption*/ ctx[6],
					styleDescription: /*config*/ ctx[0].styleDescription,
					onSelect: func
				}
			});

		return {
			c() {
				create_component(paymentoptioncomponent.$$.fragment);
			},
			m(target, anchor) {
				mount_component(paymentoptioncomponent, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				const paymentoptioncomponent_changes = {};
				if (dirty & /*orderedPaymentOptions*/ 4) paymentoptioncomponent_changes.paymentOption = /*paymentOption*/ ctx[6];
				if (dirty & /*config*/ 1) paymentoptioncomponent_changes.styleDescription = /*config*/ ctx[0].styleDescription;
				if (dirty & /*onSelect, orderedPaymentOptions*/ 6) paymentoptioncomponent_changes.onSelect = func;
				paymentoptioncomponent.$set(paymentoptioncomponent_changes);
			},
			i(local) {
				if (current) return;
				transition_in(paymentoptioncomponent.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(paymentoptioncomponent.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(paymentoptioncomponent, detaching);
			}
		};
	}

	function create_fragment$18(ctx) {
		let div;
		let current;
		let each_value = ensure_array_like(/*orderedPaymentOptions*/ ctx[2]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				div = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(div, "class", "payment-options-container svelte-tqlhky");
			},
			m(target, anchor) {
				insert(target, div, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div, null);
					}
				}

				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*orderedPaymentOptions, config, onSelect*/ 7) {
					each_value = ensure_array_like(/*orderedPaymentOptions*/ ctx[2]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$f(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$f(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	function instance$16($$self, $$props, $$invalidate) {
		let orderedPaymentOptions;
		let { paymentOptions } = $$props;
		let { config } = $$props;
		let { onSelect } = $$props;
		let { logView } = $$props;
		logView();
		const func = paymentOption => onSelect(paymentOption);

		$$self.$$set = $$props => {
			if ('paymentOptions' in $$props) $$invalidate(3, paymentOptions = $$props.paymentOptions);
			if ('config' in $$props) $$invalidate(0, config = $$props.config);
			if ('onSelect' in $$props) $$invalidate(1, onSelect = $$props.onSelect);
			if ('logView' in $$props) $$invalidate(4, logView = $$props.logView);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*paymentOptions*/ 8) {
				$$invalidate(2, orderedPaymentOptions = paymentOptions.sort((a, b) => a.fieldOrder - b.fieldOrder));
			}
		};

		return [config, onSelect, orderedPaymentOptions, paymentOptions, logView, func];
	}

	class PaymentOptionSelectionComponent extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$16, create_fragment$18, safe_not_equal, {
				paymentOptions: 3,
				config: 0,
				onSelect: 1,
				logView: 4
			});
		}
	}

	const filterValidPaymentOptions = (form, formState) => {
	    if (!formConfigAs(form).changeSubscriptionMode) {
	        return formConfigAs(form).paymentOptions;
	    }
	    return formConfigAs(form).paymentOptions
	        .filter(paymentOption => formState
	        .validChangeFromPlans
	        .some(validPlan => validPlan.productId === paymentOption.productId && validPlan.planSlug === paymentOption.slug));
	};
	const factory$r = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.PAYMENT_OPTION_SELECTION,
	    create: (form, formState, formActions, elementConfig) => ({
	        component: PaymentOptionSelectionComponent,
	        props: {
	            paymentOptions: filterValidPaymentOptions(form, formState),
	            config: elementConfig ? elementConfig : {},
	            onSelect: (paymentOption) => {
	                const paymentOptionKey = `${paymentOption.productId}-${paymentOption.slug}`;
	                const updateState = {
	                    paymentOption: {
	                        ...paymentOption,
	                        autoRenewConfig: paymentOption.autoRenewConfig,
	                        autoRenewToggleLabel: paymentOption.autoRenewToggleLabel
	                    },
	                    serverErrors: [],
	                    billingAddress: {
	                        country: null,
	                        postalCode: null,
	                    }
	                };
	                // Only initialize auto-renew state for payment options with custom_toggle config
	                if (paymentOption.autoRenewConfig === 'custom_toggle') {
	                    updateState.paymentOptionAutoRenew = {
	                        ...formState.paymentOptionAutoRenew,
	                        [paymentOptionKey]: paymentOption.terms?.autoRenew ?? false
	                    };
	                }
	                formActions.updateFormState(updateState);
	                if (form.organisationConfiguration.trackFormDataLayerEvents) {
	                    logDataLayerEvent(form, 'zephr_form_button_press', {
	                        sectionId: formState.currentSection.type,
	                        buttonType: 'SUBMIT'
	                    });
	                }
	                void formActions.completeSection();
	            },
	            logView: () => {
	                filterValidPaymentOptions(form, formState).forEach(paymentOption => logDataLayerEvent(form, 'view_item', {
	                    ecommerce: {
	                        currency: formConfigAs(form).formCurrency ?? paymentOption?.currencyCode,
	                        value: paymentOption.price,
	                        items: [{
	                                item_id: paymentOption.slug,
	                                item_name: paymentOption.productId,
	                                price: paymentOption.price,
	                                quantity: 1
	                            }]
	                    }
	                }));
	            }
	        }
	    })
	};

	/* src/components/elements/ErrorMessage.svelte generated by Svelte v4.2.12 */

	function create_fragment$17(ctx) {
		let div1;
		let div0;
		let t;

		return {
			c() {
				div1 = element("div");
				div0 = element("div");
				t = text(/*error*/ ctx[0]);
				attr(div0, "class", "zephr-form-error-message svelte-1ko2lqj");
				attr(div0, "aria-live", "assertive");
				toggle_class(div0, "zephr-payment-form-error-message", !/*isPaymentForm*/ ctx[1]);
				attr(div1, "class", "zephr-form-error-message-min-height svelte-1ko2lqj");
				toggle_class(div1, "zephr-payment-form-error-message-min-height", !/*isPaymentForm*/ ctx[1]);
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, div0);
				append(div0, t);
			},
			p(ctx, [dirty]) {
				if (dirty & /*error*/ 1) set_data(t, /*error*/ ctx[0]);

				if (dirty & /*isPaymentForm*/ 2) {
					toggle_class(div0, "zephr-payment-form-error-message", !/*isPaymentForm*/ ctx[1]);
				}

				if (dirty & /*isPaymentForm*/ 2) {
					toggle_class(div1, "zephr-payment-form-error-message-min-height", !/*isPaymentForm*/ ctx[1]);
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(div1);
				}
			}
		};
	}

	function instance$15($$self, $$props, $$invalidate) {
		let { error } = $$props;
		let { isPaymentForm = false } = $$props;

		$$self.$$set = $$props => {
			if ('error' in $$props) $$invalidate(0, error = $$props.error);
			if ('isPaymentForm' in $$props) $$invalidate(1, isPaymentForm = $$props.isPaymentForm);
		};

		return [error, isPaymentForm];
	}

	class ErrorMessage extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$15, create_fragment$17, safe_not_equal, { error: 0, isPaymentForm: 1 });
		}
	}

	/* src/components/elements/Input.svelte generated by Svelte v4.2.12 */

	function create_if_block_1$w(ctx) {
		let button;
		let span;
		let t;
		let mounted;
		let dispose;

		return {
			c() {
				button = element("button");
				span = element("span");
				t = text(/*innerText*/ ctx[16]);
				attr(span, "class", "zephr-form-input-inner-text");
				toggle_class(span, "zephr-payment-form-input-inner-text", /*isPaymentForm*/ ctx[7]);
				attr(button, "type", "button");
				attr(button, "class", "zephr-form-input-inner-button");
			},
			m(target, anchor) {
				insert(target, button, anchor);
				append(button, span);
				append(span, t);
				/*button_binding*/ ctx[28](button);

				if (!mounted) {
					dispose = listen(button, "click", prevent_default(function () {
						if (is_function(/*innerTextOnClick*/ ctx[17])) /*innerTextOnClick*/ ctx[17].apply(this, arguments);
					}));

					mounted = true;
				}
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				if (dirty & /*innerText*/ 65536) set_data(t, /*innerText*/ ctx[16]);

				if (dirty & /*isPaymentForm*/ 128) {
					toggle_class(span, "zephr-payment-form-input-inner-text", /*isPaymentForm*/ ctx[7]);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(button);
				}

				/*button_binding*/ ctx[28](null);
				mounted = false;
				dispose();
			}
		};
	}

	// (89:0) {#if errorMessage}
	function create_if_block$I(ctx) {
		let errormessage;
		let current;

		errormessage = new ErrorMessage({
				props: {
					error: /*errorMessage*/ ctx[6],
					isPaymentForm: /*isPaymentForm*/ ctx[7]
				}
			});

		return {
			c() {
				create_component(errormessage.$$.fragment);
			},
			m(target, anchor) {
				mount_component(errormessage, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const errormessage_changes = {};
				if (dirty & /*errorMessage*/ 64) errormessage_changes.error = /*errorMessage*/ ctx[6];
				if (dirty & /*isPaymentForm*/ 128) errormessage_changes.isPaymentForm = /*isPaymentForm*/ ctx[7];
				errormessage.$set(errormessage_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errormessage.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errormessage.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(errormessage, detaching);
			}
		};
	}

	function create_fragment$16(ctx) {
		let div;
		let input;
		let input_value_value;
		let input_autocomplete_value;
		let input_checked_value;
		let input_placeholder_value;
		let input_pattern_value;
		let input_min_value;
		let input_max_value;
		let input_step_value;
		let input_class_value;
		let t0;
		let t1;
		let t2;
		let if_block1_anchor;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*innerText*/ ctx[16] && create_if_block_1$w(ctx);
		const default_slot_template = /*#slots*/ ctx[26].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[25], null);
		let if_block1 = /*errorMessage*/ ctx[6] && create_if_block$I(ctx);

		return {
			c() {
				div = element("div");
				input = element("input");
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (default_slot) default_slot.c();
				t2 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
				attr(input, "id", /*id*/ ctx[0]);
				attr(input, "name", /*name*/ ctx[1]);
				input.required = /*required*/ ctx[3];
				input.disabled = /*disabled*/ ctx[4];
				attr(input, "type", /*type*/ ctx[2]);
				input.value = input_value_value = /*value*/ ctx[8] || null;
				attr(input, "autocomplete", input_autocomplete_value = /*autocomplete*/ ctx[19] || null);
				input.checked = input_checked_value = /*checked*/ ctx[10] || null;
				attr(input, "placeholder", input_placeholder_value = /*placeholder*/ ctx[9] || null);
				attr(input, "pattern", input_pattern_value = /*pattern*/ ctx[11] || null);
				attr(input, "min", input_min_value = /*min*/ ctx[12] || null);
				attr(input, "max", input_max_value = /*max*/ ctx[13] || null);
				attr(input, "maxlength", /*maxlength*/ ctx[15]);
				attr(input, "step", input_step_value = /*step*/ ctx[14] || null);
				attr(input, "class", input_class_value = "" + (null_to_empty(`zephr-form-input ${/*type*/ ctx[2] && `zephr-form-input-${/*type*/ ctx[2]}`} ${/*isPaymentForm*/ ctx[7] && /*type*/ ctx[2] && `zephr-payment-form-input-${/*type*/ ctx[2]}`}`) + " svelte-88cmol"));
				toggle_class(input, "disabled", /*disabled*/ ctx[4]);
				toggle_class(input, "error", /*hasError*/ ctx[5] || /*errorMessage*/ ctx[6]);
				toggle_class(input, "zephr-form-input-full-width", /*fill*/ ctx[18]);
				toggle_class(input, "zephr-payment-form-input", /*isPaymentForm*/ ctx[7]);
				toggle_class(input, "zephr-payment-form-input-full-width", /*isPaymentForm*/ ctx[7] && /*fill*/ ctx[18]);
				attr(div, "class", "zephr-form-input-inner-container svelte-88cmol");
				toggle_class(div, "zephr-payment-form-input-inner-container", /*isPaymentForm*/ ctx[7]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, input);
				/*input_binding*/ ctx[27](input);
				append(div, t0);
				if (if_block0) if_block0.m(div, null);
				insert(target, t1, anchor);

				if (default_slot) {
					default_slot.m(target, anchor);
				}

				insert(target, t2, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);
				current = true;

				if (!mounted) {
					dispose = [
						listen(input, "focus", function () {
							if (is_function(/*onFocus*/ ctx[20])) /*onFocus*/ ctx[20].apply(this, arguments);
						}),
						listen(input, "blur", function () {
							if (is_function(/*onBlur*/ ctx[21])) /*onBlur*/ ctx[21].apply(this, arguments);
						}),
						listen(input, "input", /*handleInputChange*/ ctx[24]),
						listen(input, "paste", /*handleInputChange*/ ctx[24])
					];

					mounted = true;
				}
			},
			p(new_ctx, [dirty]) {
				ctx = new_ctx;

				if (!current || dirty & /*id*/ 1) {
					attr(input, "id", /*id*/ ctx[0]);
				}

				if (!current || dirty & /*name*/ 2) {
					attr(input, "name", /*name*/ ctx[1]);
				}

				if (!current || dirty & /*required*/ 8) {
					input.required = /*required*/ ctx[3];
				}

				if (!current || dirty & /*disabled*/ 16) {
					input.disabled = /*disabled*/ ctx[4];
				}

				if (!current || dirty & /*type*/ 4) {
					attr(input, "type", /*type*/ ctx[2]);
				}

				if (!current || dirty & /*value*/ 256 && input_value_value !== (input_value_value = /*value*/ ctx[8] || null) && input.value !== input_value_value) {
					input.value = input_value_value;
				}

				if (!current || dirty & /*autocomplete*/ 524288 && input_autocomplete_value !== (input_autocomplete_value = /*autocomplete*/ ctx[19] || null)) {
					attr(input, "autocomplete", input_autocomplete_value);
				}

				if (!current || dirty & /*checked*/ 1024 && input_checked_value !== (input_checked_value = /*checked*/ ctx[10] || null)) {
					input.checked = input_checked_value;
				}

				if (!current || dirty & /*placeholder*/ 512 && input_placeholder_value !== (input_placeholder_value = /*placeholder*/ ctx[9] || null)) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (!current || dirty & /*pattern*/ 2048 && input_pattern_value !== (input_pattern_value = /*pattern*/ ctx[11] || null)) {
					attr(input, "pattern", input_pattern_value);
				}

				if (!current || dirty & /*min*/ 4096 && input_min_value !== (input_min_value = /*min*/ ctx[12] || null)) {
					attr(input, "min", input_min_value);
				}

				if (!current || dirty & /*max*/ 8192 && input_max_value !== (input_max_value = /*max*/ ctx[13] || null)) {
					attr(input, "max", input_max_value);
				}

				if (!current || dirty & /*maxlength*/ 32768) {
					attr(input, "maxlength", /*maxlength*/ ctx[15]);
				}

				if (!current || dirty & /*step*/ 16384 && input_step_value !== (input_step_value = /*step*/ ctx[14] || null)) {
					attr(input, "step", input_step_value);
				}

				if (!current || dirty & /*type, isPaymentForm*/ 132 && input_class_value !== (input_class_value = "" + (null_to_empty(`zephr-form-input ${/*type*/ ctx[2] && `zephr-form-input-${/*type*/ ctx[2]}`} ${/*isPaymentForm*/ ctx[7] && /*type*/ ctx[2] && `zephr-payment-form-input-${/*type*/ ctx[2]}`}`) + " svelte-88cmol"))) {
					attr(input, "class", input_class_value);
				}

				if (!current || dirty & /*type, isPaymentForm, disabled*/ 148) {
					toggle_class(input, "disabled", /*disabled*/ ctx[4]);
				}

				if (!current || dirty & /*type, isPaymentForm, hasError, errorMessage*/ 228) {
					toggle_class(input, "error", /*hasError*/ ctx[5] || /*errorMessage*/ ctx[6]);
				}

				if (!current || dirty & /*type, isPaymentForm, fill*/ 262276) {
					toggle_class(input, "zephr-form-input-full-width", /*fill*/ ctx[18]);
				}

				if (!current || dirty & /*type, isPaymentForm, isPaymentForm*/ 132) {
					toggle_class(input, "zephr-payment-form-input", /*isPaymentForm*/ ctx[7]);
				}

				if (!current || dirty & /*type, isPaymentForm, isPaymentForm, fill*/ 262276) {
					toggle_class(input, "zephr-payment-form-input-full-width", /*isPaymentForm*/ ctx[7] && /*fill*/ ctx[18]);
				}

				if (/*innerText*/ ctx[16]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_1$w(ctx);
						if_block0.c();
						if_block0.m(div, null);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (!current || dirty & /*isPaymentForm*/ 128) {
					toggle_class(div, "zephr-payment-form-input-inner-container", /*isPaymentForm*/ ctx[7]);
				}

				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 33554432)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[25],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[25])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[25], dirty, null),
							null
						);
					}
				}

				if (/*errorMessage*/ ctx[6]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*errorMessage*/ 64) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block$I(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
					detach(t1);
					detach(t2);
					detach(if_block1_anchor);
				}

				/*input_binding*/ ctx[27](null);
				if (if_block0) if_block0.d();
				if (default_slot) default_slot.d(detaching);
				if (if_block1) if_block1.d(detaching);
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$14($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		const dispatch = createEventDispatcher();
		let { id } = $$props;
		let { name = id } = $$props;
		let { type = "text" } = $$props;
		let { required = true } = $$props;
		let { disabled = false } = $$props;
		let { hasError = false } = $$props;
		let { errorMessage = null } = $$props;
		let { isPaymentForm = false } = $$props;
		let { value = "" } = $$props;
		let { placeholder = "" } = $$props;
		let { checked = false } = $$props;
		let { pattern = "" } = $$props;
		let { min = 0 } = $$props;
		let { max = 0 } = $$props;
		let { step = 0 } = $$props;
		let { maxlength = null } = $$props;
		let { innerText = null } = $$props;
		let { innerTextOnClick = null } = $$props;
		let { fill = false } = $$props;
		let { autocomplete = "" } = $$props;
		let { onFocus } = $$props;
		let { onBlur } = $$props;
		let inputElement;
		let buttonElement;

		const handleInputChange = e => {
			dispatch("change", type !== "checkbox" ? e.target.value : e.target.checked);
		};

		afterUpdate(() => {
			if (innerText && buttonElement && inputElement) {
				$$invalidate(22, inputElement.style.paddingRight = `${buttonElement.offsetWidth + 8}px`, inputElement);
			}
		});

		function input_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				inputElement = $$value;
				$$invalidate(22, inputElement);
			});
		}

		function button_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				buttonElement = $$value;
				$$invalidate(23, buttonElement);
			});
		}

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(0, id = $$props.id);
			if ('name' in $$props) $$invalidate(1, name = $$props.name);
			if ('type' in $$props) $$invalidate(2, type = $$props.type);
			if ('required' in $$props) $$invalidate(3, required = $$props.required);
			if ('disabled' in $$props) $$invalidate(4, disabled = $$props.disabled);
			if ('hasError' in $$props) $$invalidate(5, hasError = $$props.hasError);
			if ('errorMessage' in $$props) $$invalidate(6, errorMessage = $$props.errorMessage);
			if ('isPaymentForm' in $$props) $$invalidate(7, isPaymentForm = $$props.isPaymentForm);
			if ('value' in $$props) $$invalidate(8, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(9, placeholder = $$props.placeholder);
			if ('checked' in $$props) $$invalidate(10, checked = $$props.checked);
			if ('pattern' in $$props) $$invalidate(11, pattern = $$props.pattern);
			if ('min' in $$props) $$invalidate(12, min = $$props.min);
			if ('max' in $$props) $$invalidate(13, max = $$props.max);
			if ('step' in $$props) $$invalidate(14, step = $$props.step);
			if ('maxlength' in $$props) $$invalidate(15, maxlength = $$props.maxlength);
			if ('innerText' in $$props) $$invalidate(16, innerText = $$props.innerText);
			if ('innerTextOnClick' in $$props) $$invalidate(17, innerTextOnClick = $$props.innerTextOnClick);
			if ('fill' in $$props) $$invalidate(18, fill = $$props.fill);
			if ('autocomplete' in $$props) $$invalidate(19, autocomplete = $$props.autocomplete);
			if ('onFocus' in $$props) $$invalidate(20, onFocus = $$props.onFocus);
			if ('onBlur' in $$props) $$invalidate(21, onBlur = $$props.onBlur);
			if ('$$scope' in $$props) $$invalidate(25, $$scope = $$props.$$scope);
		};

		return [
			id,
			name,
			type,
			required,
			disabled,
			hasError,
			errorMessage,
			isPaymentForm,
			value,
			placeholder,
			checked,
			pattern,
			min,
			max,
			step,
			maxlength,
			innerText,
			innerTextOnClick,
			fill,
			autocomplete,
			onFocus,
			onBlur,
			inputElement,
			buttonElement,
			handleInputChange,
			$$scope,
			slots,
			input_binding,
			button_binding
		];
	}

	class Input extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$14, create_fragment$16, safe_not_equal, {
				id: 0,
				name: 1,
				type: 2,
				required: 3,
				disabled: 4,
				hasError: 5,
				errorMessage: 6,
				isPaymentForm: 7,
				value: 8,
				placeholder: 9,
				checked: 10,
				pattern: 11,
				min: 12,
				max: 13,
				step: 14,
				maxlength: 15,
				innerText: 16,
				innerTextOnClick: 17,
				fill: 18,
				autocomplete: 19,
				onFocus: 20,
				onBlur: 21
			});
		}
	}

	/* src/components/elements/Label.svelte generated by Svelte v4.2.12 */

	function create_if_block$H(ctx) {
		let span;
		let t;

		return {
			c() {
				span = element("span");
				t = text(/*sublabel*/ ctx[1]);
				attr(span, "class", "svelte-yaw4yg");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty & /*sublabel*/ 2) set_data(t, /*sublabel*/ ctx[1]);
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	function create_fragment$15(ctx) {
		let label_1;
		let span;
		let t0;
		let t1;
		let t2;
		let current;
		let if_block = /*sublabel*/ ctx[1] && create_if_block$H(ctx);
		const default_slot_template = /*#slots*/ ctx[6].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

		return {
			c() {
				label_1 = element("label");
				span = element("span");
				t0 = text(/*label*/ ctx[2]);
				t1 = space();
				if (if_block) if_block.c();
				t2 = space();
				if (default_slot) default_slot.c();
				attr(span, "class", "svelte-yaw4yg");
				attr(label_1, "class", "zephr-form-input-label svelte-yaw4yg");
				attr(label_1, "for", /*forInput*/ ctx[0]);
				attr(label_1, "style", /*style*/ ctx[3]);
				toggle_class(label_1, "zephr-payment-form-input-label", /*isPaymentForm*/ ctx[4]);
			},
			m(target, anchor) {
				insert(target, label_1, anchor);
				append(label_1, span);
				append(span, t0);
				append(label_1, t1);
				if (if_block) if_block.m(label_1, null);
				append(label_1, t2);

				if (default_slot) {
					default_slot.m(label_1, null);
				}

				current = true;
			},
			p(ctx, [dirty]) {
				if (!current || dirty & /*label*/ 4) set_data(t0, /*label*/ ctx[2]);

				if (/*sublabel*/ ctx[1]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$H(ctx);
						if_block.c();
						if_block.m(label_1, t2);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[5],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
							null
						);
					}
				}

				if (!current || dirty & /*forInput*/ 1) {
					attr(label_1, "for", /*forInput*/ ctx[0]);
				}

				if (!current || dirty & /*style*/ 8) {
					attr(label_1, "style", /*style*/ ctx[3]);
				}

				if (!current || dirty & /*isPaymentForm*/ 16) {
					toggle_class(label_1, "zephr-payment-form-input-label", /*isPaymentForm*/ ctx[4]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(label_1);
				}

				if (if_block) if_block.d();
				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	function instance$13($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		let { forInput } = $$props;
		let { sublabel = "" } = $$props;
		let { label = "" } = $$props;
		let { style = "" } = $$props;
		let { isPaymentForm = false } = $$props;

		$$self.$$set = $$props => {
			if ('forInput' in $$props) $$invalidate(0, forInput = $$props.forInput);
			if ('sublabel' in $$props) $$invalidate(1, sublabel = $$props.sublabel);
			if ('label' in $$props) $$invalidate(2, label = $$props.label);
			if ('style' in $$props) $$invalidate(3, style = $$props.style);
			if ('isPaymentForm' in $$props) $$invalidate(4, isPaymentForm = $$props.isPaymentForm);
			if ('$$scope' in $$props) $$invalidate(5, $$scope = $$props.$$scope);
		};

		return [forInput, sublabel, label, style, isPaymentForm, $$scope, slots];
	}

	class Label extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$13, create_fragment$15, safe_not_equal, {
				forInput: 0,
				sublabel: 1,
				label: 2,
				style: 3,
				isPaymentForm: 4
			});
		}
	}

	/* src/components/elements/password/PasswordInput.svelte generated by Svelte v4.2.12 */

	function create_fragment$14(ctx) {
		let label_1;
		let t;
		let div;
		let input;
		let current;

		label_1 = new Label({
				props: {
					forInput: /*inputId*/ ctx[13],
					label: /*label*/ ctx[1],
					isPaymentForm: /*isPaymentForm*/ ctx[8]
				}
			});

		input = new Input({
				props: {
					disabled: /*disabled*/ ctx[0],
					required: true,
					id: /*inputId*/ ctx[13],
					type: /*passwordInputType*/ ctx[14],
					value: /*password*/ ctx[11],
					placeholder: /*placeholder*/ ctx[2],
					errorMessage: /*error*/ ctx[5],
					autocomplete: /*autocomplete*/ ctx[7],
					isPaymentForm: /*isPaymentForm*/ ctx[8],
					innerTextOnClick: /*func*/ ctx[16],
					innerText: /*showPassword*/ ctx[12]
					? /*hideLabel*/ ctx[4]
					: /*showLabel*/ ctx[3],
					onFocus: /*onFocus*/ ctx[9],
					onBlur: /*onBlur*/ ctx[10]
				}
			});

		input.$on("change", /*change_handler*/ ctx[17]);

		return {
			c() {
				create_component(label_1.$$.fragment);
				t = space();
				div = element("div");
				create_component(input.$$.fragment);
				attr(div, "class", "zephr-form-relative-container");
				toggle_class(div, "zephr-payment-form-relative-container", /*isPaymentForm*/ ctx[8]);
			},
			m(target, anchor) {
				mount_component(label_1, target, anchor);
				insert(target, t, anchor);
				insert(target, div, anchor);
				mount_component(input, div, null);
				current = true;
			},
			p(ctx, [dirty]) {
				const label_1_changes = {};
				if (dirty & /*inputId*/ 8192) label_1_changes.forInput = /*inputId*/ ctx[13];
				if (dirty & /*label*/ 2) label_1_changes.label = /*label*/ ctx[1];
				if (dirty & /*isPaymentForm*/ 256) label_1_changes.isPaymentForm = /*isPaymentForm*/ ctx[8];
				label_1.$set(label_1_changes);
				const input_changes = {};
				if (dirty & /*disabled*/ 1) input_changes.disabled = /*disabled*/ ctx[0];
				if (dirty & /*inputId*/ 8192) input_changes.id = /*inputId*/ ctx[13];
				if (dirty & /*passwordInputType*/ 16384) input_changes.type = /*passwordInputType*/ ctx[14];
				if (dirty & /*password*/ 2048) input_changes.value = /*password*/ ctx[11];
				if (dirty & /*placeholder*/ 4) input_changes.placeholder = /*placeholder*/ ctx[2];
				if (dirty & /*error*/ 32) input_changes.errorMessage = /*error*/ ctx[5];
				if (dirty & /*autocomplete*/ 128) input_changes.autocomplete = /*autocomplete*/ ctx[7];
				if (dirty & /*isPaymentForm*/ 256) input_changes.isPaymentForm = /*isPaymentForm*/ ctx[8];
				if (dirty & /*showPassword*/ 4096) input_changes.innerTextOnClick = /*func*/ ctx[16];

				if (dirty & /*showPassword, hideLabel, showLabel*/ 4120) input_changes.innerText = /*showPassword*/ ctx[12]
				? /*hideLabel*/ ctx[4]
				: /*showLabel*/ ctx[3];

				if (dirty & /*onFocus*/ 512) input_changes.onFocus = /*onFocus*/ ctx[9];
				if (dirty & /*onBlur*/ 1024) input_changes.onBlur = /*onBlur*/ ctx[10];
				input.$set(input_changes);

				if (!current || dirty & /*isPaymentForm*/ 256) {
					toggle_class(div, "zephr-payment-form-relative-container", /*isPaymentForm*/ ctx[8]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(label_1.$$.fragment, local);
				transition_in(input.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(label_1.$$.fragment, local);
				transition_out(input.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(div);
				}

				destroy_component(label_1, detaching);
				destroy_component(input);
			}
		};
	}

	function instance$12($$self, $$props, $$invalidate) {
		let passwordInputType;
		let inputId;
		let { disabled } = $$props;
		let { label } = $$props;
		let { placeholder } = $$props;
		let { isMainPassword } = $$props;
		let { showLabel } = $$props;
		let { hideLabel } = $$props;
		let { error = null } = $$props;
		let { onChange } = $$props;
		let { autocomplete } = $$props;
		let { isPaymentForm = false } = $$props;
		let { onFocus } = $$props;
		let { onBlur } = $$props;
		let { password } = $$props;
		let showPassword = false;
		const func = () => $$invalidate(12, showPassword = !showPassword);
		const change_handler = ({ detail }) => onChange(detail);

		$$self.$$set = $$props => {
			if ('disabled' in $$props) $$invalidate(0, disabled = $$props.disabled);
			if ('label' in $$props) $$invalidate(1, label = $$props.label);
			if ('placeholder' in $$props) $$invalidate(2, placeholder = $$props.placeholder);
			if ('isMainPassword' in $$props) $$invalidate(15, isMainPassword = $$props.isMainPassword);
			if ('showLabel' in $$props) $$invalidate(3, showLabel = $$props.showLabel);
			if ('hideLabel' in $$props) $$invalidate(4, hideLabel = $$props.hideLabel);
			if ('error' in $$props) $$invalidate(5, error = $$props.error);
			if ('onChange' in $$props) $$invalidate(6, onChange = $$props.onChange);
			if ('autocomplete' in $$props) $$invalidate(7, autocomplete = $$props.autocomplete);
			if ('isPaymentForm' in $$props) $$invalidate(8, isPaymentForm = $$props.isPaymentForm);
			if ('onFocus' in $$props) $$invalidate(9, onFocus = $$props.onFocus);
			if ('onBlur' in $$props) $$invalidate(10, onBlur = $$props.onBlur);
			if ('password' in $$props) $$invalidate(11, password = $$props.password);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*showPassword*/ 4096) {
				$$invalidate(14, passwordInputType = showPassword ? "text" : "password");
			}

			if ($$self.$$.dirty & /*isMainPassword*/ 32768) {
				$$invalidate(13, inputId = `zephr-form-${isMainPassword ? 'password' : 'confirm-password'}`);
			}
		};

		return [
			disabled,
			label,
			placeholder,
			showLabel,
			hideLabel,
			error,
			onChange,
			autocomplete,
			isPaymentForm,
			onFocus,
			onBlur,
			password,
			showPassword,
			inputId,
			passwordInputType,
			isMainPassword,
			func,
			change_handler
		];
	}

	class PasswordInput extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$12, create_fragment$14, safe_not_equal, {
				disabled: 0,
				label: 1,
				placeholder: 2,
				isMainPassword: 15,
				showLabel: 3,
				hideLabel: 4,
				error: 5,
				onChange: 6,
				autocomplete: 7,
				isPaymentForm: 8,
				onFocus: 9,
				onBlur: 10,
				password: 11
			});
		}
	}

	function setCustomFontSize(element, size) {
	    if (size && size !== "lg" && size !== "sm" && size !== "xs") {
	        element.style.fontSize = size.replace("x", "em");
	    }
	    else {
	        element.style.fontSize = "";
	    }
	}
	function getTransform(scale, translateX, translateY, rotate, flip, translateTimes = 1, translateUnit = "", rotateUnit = "") {
	    let flipX = 1;
	    let flipY = 1;
	    if (flip) {
	        if (flip == "horizontal") {
	            flipX = -1;
	        }
	        else if (flip == "vertical") {
	            flipY = -1;
	        }
	        else {
	            flipX = flipY = -1;
	        }
	    }
	    if (typeof scale === "string") {
	        scale = parseFloat(scale);
	    }
	    if (typeof translateX === "string") {
	        translateX = parseFloat(translateX);
	    }
	    if (typeof translateY === "string") {
	        translateY = parseFloat(translateY);
	    }
	    const x = `${translateX * translateTimes}${translateUnit}`;
	    const y = `${translateY * translateTimes}${translateUnit}`;
	    let output = `translate(${x},${y}) scale(${flipX * scale},${flipY * scale})`;
	    if (rotate) {
	        output += ` rotate(${rotate}${rotateUnit})`;
	    }
	    return output;
	}

	/* node_modules/svelte-fa/dist/fa.svelte generated by Svelte v4.2.12 */

	function create_if_block$G(ctx) {
		let svg;
		let g1;
		let g0;
		let g1_transform_value;
		let g1_transform_origin_value;
		let svg_class_value;
		let svg_viewBox_value;

		function select_block_type(ctx, dirty) {
			if (typeof /*i*/ ctx[16][4] == "string") return create_if_block_1$v;
			return create_else_block$b;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		return {
			c() {
				svg = svg_element("svg");
				g1 = svg_element("g");
				g0 = svg_element("g");
				if_block.c();
				attr(g0, "transform", /*transform*/ ctx[15]);
				attr(g1, "transform", g1_transform_value = "translate(" + /*i*/ ctx[16][0] / 2 + " " + /*i*/ ctx[16][1] / 2 + ")");
				attr(g1, "transform-origin", g1_transform_origin_value = "" + (/*i*/ ctx[16][0] / 4 + " 0"));
				attr(svg, "id", /*id*/ ctx[1]);
				attr(svg, "class", svg_class_value = "svelte-fa svelte-fa-base " + /*clazz*/ ctx[0] + " svelte-f5ydbn");
				attr(svg, "style", /*style*/ ctx[2]);
				attr(svg, "viewBox", svg_viewBox_value = "0 0 " + /*i*/ ctx[16][0] + " " + /*i*/ ctx[16][1]);
				attr(svg, "aria-hidden", "true");
				attr(svg, "role", "img");
				attr(svg, "xmlns", "http://www.w3.org/2000/svg");
				toggle_class(svg, "pulse", /*pulse*/ ctx[8]);
				toggle_class(svg, "svelte-fa-size-lg", /*size*/ ctx[3] === "lg");
				toggle_class(svg, "svelte-fa-size-sm", /*size*/ ctx[3] === "sm");
				toggle_class(svg, "svelte-fa-size-xs", /*size*/ ctx[3] === "xs");
				toggle_class(svg, "svelte-fa-fw", /*fw*/ ctx[5]);
				toggle_class(svg, "svelte-fa-pull-left", /*pull*/ ctx[6] === "left");
				toggle_class(svg, "svelte-fa-pull-right", /*pull*/ ctx[6] === "right");
				toggle_class(svg, "spin", /*spin*/ ctx[7]);
			},
			m(target, anchor) {
				insert(target, svg, anchor);
				append(svg, g1);
				append(g1, g0);
				if_block.m(g0, null);
				/*svg_binding*/ ctx[23](svg);
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(g0, null);
					}
				}

				if (dirty & /*transform*/ 32768) {
					attr(g0, "transform", /*transform*/ ctx[15]);
				}

				if (dirty & /*i*/ 65536 && g1_transform_value !== (g1_transform_value = "translate(" + /*i*/ ctx[16][0] / 2 + " " + /*i*/ ctx[16][1] / 2 + ")")) {
					attr(g1, "transform", g1_transform_value);
				}

				if (dirty & /*i*/ 65536 && g1_transform_origin_value !== (g1_transform_origin_value = "" + (/*i*/ ctx[16][0] / 4 + " 0"))) {
					attr(g1, "transform-origin", g1_transform_origin_value);
				}

				if (dirty & /*id*/ 2) {
					attr(svg, "id", /*id*/ ctx[1]);
				}

				if (dirty & /*clazz*/ 1 && svg_class_value !== (svg_class_value = "svelte-fa svelte-fa-base " + /*clazz*/ ctx[0] + " svelte-f5ydbn")) {
					attr(svg, "class", svg_class_value);
				}

				if (dirty & /*style*/ 4) {
					attr(svg, "style", /*style*/ ctx[2]);
				}

				if (dirty & /*i*/ 65536 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*i*/ ctx[16][0] + " " + /*i*/ ctx[16][1])) {
					attr(svg, "viewBox", svg_viewBox_value);
				}

				if (dirty & /*clazz, pulse*/ 257) {
					toggle_class(svg, "pulse", /*pulse*/ ctx[8]);
				}

				if (dirty & /*clazz, size*/ 9) {
					toggle_class(svg, "svelte-fa-size-lg", /*size*/ ctx[3] === "lg");
				}

				if (dirty & /*clazz, size*/ 9) {
					toggle_class(svg, "svelte-fa-size-sm", /*size*/ ctx[3] === "sm");
				}

				if (dirty & /*clazz, size*/ 9) {
					toggle_class(svg, "svelte-fa-size-xs", /*size*/ ctx[3] === "xs");
				}

				if (dirty & /*clazz, fw*/ 33) {
					toggle_class(svg, "svelte-fa-fw", /*fw*/ ctx[5]);
				}

				if (dirty & /*clazz, pull*/ 65) {
					toggle_class(svg, "svelte-fa-pull-left", /*pull*/ ctx[6] === "left");
				}

				if (dirty & /*clazz, pull*/ 65) {
					toggle_class(svg, "svelte-fa-pull-right", /*pull*/ ctx[6] === "right");
				}

				if (dirty & /*clazz, spin*/ 129) {
					toggle_class(svg, "spin", /*spin*/ ctx[7]);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(svg);
				}

				if_block.d();
				/*svg_binding*/ ctx[23](null);
			}
		};
	}

	// (61:8) {:else}
	function create_else_block$b(ctx) {
		let path0;
		let path0_d_value;
		let path0_fill_value;
		let path0_fill_opacity_value;
		let path0_transform_value;
		let path1;
		let path1_d_value;
		let path1_fill_value;
		let path1_fill_opacity_value;
		let path1_transform_value;

		return {
			c() {
				path0 = svg_element("path");
				path1 = svg_element("path");
				attr(path0, "d", path0_d_value = /*i*/ ctx[16][4][0]);
				attr(path0, "fill", path0_fill_value = /*secondaryColor*/ ctx[10] || /*color*/ ctx[4] || "currentColor");

				attr(path0, "fill-opacity", path0_fill_opacity_value = /*swapOpacity*/ ctx[13] != false
				? /*primaryOpacity*/ ctx[11]
				: /*secondaryOpacity*/ ctx[12]);

				attr(path0, "transform", path0_transform_value = "translate(" + /*i*/ ctx[16][0] / -2 + " " + /*i*/ ctx[16][1] / -2 + ")");
				attr(path1, "d", path1_d_value = /*i*/ ctx[16][4][1]);
				attr(path1, "fill", path1_fill_value = /*primaryColor*/ ctx[9] || /*color*/ ctx[4] || "currentColor");

				attr(path1, "fill-opacity", path1_fill_opacity_value = /*swapOpacity*/ ctx[13] != false
				? /*secondaryOpacity*/ ctx[12]
				: /*primaryOpacity*/ ctx[11]);

				attr(path1, "transform", path1_transform_value = "translate(" + /*i*/ ctx[16][0] / -2 + " " + /*i*/ ctx[16][1] / -2 + ")");
			},
			m(target, anchor) {
				insert(target, path0, anchor);
				insert(target, path1, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*i*/ 65536 && path0_d_value !== (path0_d_value = /*i*/ ctx[16][4][0])) {
					attr(path0, "d", path0_d_value);
				}

				if (dirty & /*secondaryColor, color*/ 1040 && path0_fill_value !== (path0_fill_value = /*secondaryColor*/ ctx[10] || /*color*/ ctx[4] || "currentColor")) {
					attr(path0, "fill", path0_fill_value);
				}

				if (dirty & /*swapOpacity, primaryOpacity, secondaryOpacity*/ 14336 && path0_fill_opacity_value !== (path0_fill_opacity_value = /*swapOpacity*/ ctx[13] != false
				? /*primaryOpacity*/ ctx[11]
				: /*secondaryOpacity*/ ctx[12])) {
					attr(path0, "fill-opacity", path0_fill_opacity_value);
				}

				if (dirty & /*i*/ 65536 && path0_transform_value !== (path0_transform_value = "translate(" + /*i*/ ctx[16][0] / -2 + " " + /*i*/ ctx[16][1] / -2 + ")")) {
					attr(path0, "transform", path0_transform_value);
				}

				if (dirty & /*i*/ 65536 && path1_d_value !== (path1_d_value = /*i*/ ctx[16][4][1])) {
					attr(path1, "d", path1_d_value);
				}

				if (dirty & /*primaryColor, color*/ 528 && path1_fill_value !== (path1_fill_value = /*primaryColor*/ ctx[9] || /*color*/ ctx[4] || "currentColor")) {
					attr(path1, "fill", path1_fill_value);
				}

				if (dirty & /*swapOpacity, secondaryOpacity, primaryOpacity*/ 14336 && path1_fill_opacity_value !== (path1_fill_opacity_value = /*swapOpacity*/ ctx[13] != false
				? /*secondaryOpacity*/ ctx[12]
				: /*primaryOpacity*/ ctx[11])) {
					attr(path1, "fill-opacity", path1_fill_opacity_value);
				}

				if (dirty & /*i*/ 65536 && path1_transform_value !== (path1_transform_value = "translate(" + /*i*/ ctx[16][0] / -2 + " " + /*i*/ ctx[16][1] / -2 + ")")) {
					attr(path1, "transform", path1_transform_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(path0);
					detach(path1);
				}
			}
		};
	}

	// (55:8) {#if typeof i[4] == "string"}
	function create_if_block_1$v(ctx) {
		let path;
		let path_d_value;
		let path_fill_value;
		let path_transform_value;

		return {
			c() {
				path = svg_element("path");
				attr(path, "d", path_d_value = /*i*/ ctx[16][4]);
				attr(path, "fill", path_fill_value = /*color*/ ctx[4] || /*primaryColor*/ ctx[9] || "currentColor");
				attr(path, "transform", path_transform_value = "translate(" + /*i*/ ctx[16][0] / -2 + " " + /*i*/ ctx[16][1] / -2 + ")");
			},
			m(target, anchor) {
				insert(target, path, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*i*/ 65536 && path_d_value !== (path_d_value = /*i*/ ctx[16][4])) {
					attr(path, "d", path_d_value);
				}

				if (dirty & /*color, primaryColor*/ 528 && path_fill_value !== (path_fill_value = /*color*/ ctx[4] || /*primaryColor*/ ctx[9] || "currentColor")) {
					attr(path, "fill", path_fill_value);
				}

				if (dirty & /*i*/ 65536 && path_transform_value !== (path_transform_value = "translate(" + /*i*/ ctx[16][0] / -2 + " " + /*i*/ ctx[16][1] / -2 + ")")) {
					attr(path, "transform", path_transform_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(path);
				}
			}
		};
	}

	function create_fragment$13(ctx) {
		let if_block_anchor;
		let if_block = /*i*/ ctx[16][4] && create_if_block$G(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, [dirty]) {
				if (/*i*/ ctx[16][4]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$G(ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	function instance$11($$self, $$props, $$invalidate) {
		let i;
		let transform;
		let { class: clazz = void 0 } = $$props;
		let { id = void 0 } = $$props;
		let { style = void 0 } = $$props;
		let { icon } = $$props;
		let { size = void 0 } = $$props;
		let { color = void 0 } = $$props;
		let { fw = false } = $$props;
		let { pull = void 0 } = $$props;
		let { scale = 1 } = $$props;
		let { translateX = 0 } = $$props;
		let { translateY = 0 } = $$props;
		let { rotate = void 0 } = $$props;
		let { flip = void 0 } = $$props;
		let { spin = false } = $$props;
		let { pulse = false } = $$props;
		let { primaryColor = "" } = $$props;
		let { secondaryColor = "" } = $$props;
		let { primaryOpacity = 1 } = $$props;
		let { secondaryOpacity = 0.4 } = $$props;
		let { swapOpacity = false } = $$props;
		let svgElement;

		function svg_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				svgElement = $$value;
				$$invalidate(14, svgElement);
			});
		}

		$$self.$$set = $$props => {
			if ('class' in $$props) $$invalidate(0, clazz = $$props.class);
			if ('id' in $$props) $$invalidate(1, id = $$props.id);
			if ('style' in $$props) $$invalidate(2, style = $$props.style);
			if ('icon' in $$props) $$invalidate(17, icon = $$props.icon);
			if ('size' in $$props) $$invalidate(3, size = $$props.size);
			if ('color' in $$props) $$invalidate(4, color = $$props.color);
			if ('fw' in $$props) $$invalidate(5, fw = $$props.fw);
			if ('pull' in $$props) $$invalidate(6, pull = $$props.pull);
			if ('scale' in $$props) $$invalidate(18, scale = $$props.scale);
			if ('translateX' in $$props) $$invalidate(19, translateX = $$props.translateX);
			if ('translateY' in $$props) $$invalidate(20, translateY = $$props.translateY);
			if ('rotate' in $$props) $$invalidate(21, rotate = $$props.rotate);
			if ('flip' in $$props) $$invalidate(22, flip = $$props.flip);
			if ('spin' in $$props) $$invalidate(7, spin = $$props.spin);
			if ('pulse' in $$props) $$invalidate(8, pulse = $$props.pulse);
			if ('primaryColor' in $$props) $$invalidate(9, primaryColor = $$props.primaryColor);
			if ('secondaryColor' in $$props) $$invalidate(10, secondaryColor = $$props.secondaryColor);
			if ('primaryOpacity' in $$props) $$invalidate(11, primaryOpacity = $$props.primaryOpacity);
			if ('secondaryOpacity' in $$props) $$invalidate(12, secondaryOpacity = $$props.secondaryOpacity);
			if ('swapOpacity' in $$props) $$invalidate(13, swapOpacity = $$props.swapOpacity);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*svgElement, size*/ 16392) {
				svgElement && size && setCustomFontSize(svgElement, size);
			}

			if ($$self.$$.dirty & /*icon*/ 131072) {
				$$invalidate(16, i = icon && icon.icon || [0, 0, "", [], ""]);
			}

			if ($$self.$$.dirty & /*scale, translateX, translateY, rotate, flip*/ 8126464) {
				$$invalidate(15, transform = getTransform(scale, translateX, translateY, rotate, flip, 512));
			}
		};

		return [
			clazz,
			id,
			style,
			size,
			color,
			fw,
			pull,
			spin,
			pulse,
			primaryColor,
			secondaryColor,
			primaryOpacity,
			secondaryOpacity,
			swapOpacity,
			svgElement,
			transform,
			i,
			icon,
			scale,
			translateX,
			translateY,
			rotate,
			flip,
			svg_binding
		];
	}

	class Fa extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$11, create_fragment$13, safe_not_equal, {
				class: 0,
				id: 1,
				style: 2,
				icon: 17,
				size: 3,
				color: 4,
				fw: 5,
				pull: 6,
				scale: 18,
				translateX: 19,
				translateY: 20,
				rotate: 21,
				flip: 22,
				spin: 7,
				pulse: 8,
				primaryColor: 9,
				secondaryColor: 10,
				primaryOpacity: 11,
				secondaryOpacity: 12,
				swapOpacity: 13
			});
		}
	}

	var faCircleCheck = {
	  prefix: 'fas',
	  iconName: 'circle-check',
	  icon: [512, 512, [61533, "check-circle"], "f058", "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM369 209L241 337c-9.4 9.4-24.6 9.4-33.9 0l-64-64c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0l47 47L335 175c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9z"]
	};
	var faCheckCircle = faCircleCheck;
	var faSpinner = {
	  prefix: 'fas',
	  iconName: 'spinner',
	  icon: [512, 512, [], "f110", "M304 48a48 48 0 1 0 -96 0 48 48 0 1 0 96 0zm0 416a48 48 0 1 0 -96 0 48 48 0 1 0 96 0zM48 304a48 48 0 1 0 0-96 48 48 0 1 0 0 96zm464-48a48 48 0 1 0 -96 0 48 48 0 1 0 96 0zM142.9 437A48 48 0 1 0 75 369.1 48 48 0 1 0 142.9 437zm0-294.2A48 48 0 1 0 75 75a48 48 0 1 0 67.9 67.9zM369.1 437A48 48 0 1 0 437 369.1 48 48 0 1 0 369.1 437z"]
	};
	var faCheck = {
	  prefix: 'fas',
	  iconName: 'check',
	  icon: [448, 512, [10003, 10004], "f00c", "M438.6 105.4c12.5 12.5 12.5 32.8 0 45.3l-256 256c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0L160 338.7 393.4 105.4c12.5-12.5 32.8-12.5 45.3 0z"]
	};
	var faCircleXmark = {
	  prefix: 'fas',
	  iconName: 'circle-xmark',
	  icon: [512, 512, [61532, "times-circle", "xmark-circle"], "f057", "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM175 175c9.4-9.4 24.6-9.4 33.9 0l47 47 47-47c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-47 47 47 47c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-47-47-47 47c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l47-47-47-47c-9.4-9.4-9.4-24.6 0-33.9z"]
	};
	var faTimesCircle = faCircleXmark;

	/* src/components/elements/password/PasswordMatchIndicator.svelte generated by Svelte v4.2.12 */

	function create_fragment$12(ctx) {
		let div1;
		let ul;
		let li;
		let div0;
		let fa;
		let t0;
		let t1;
		let current;

		fa = new Fa({
				props: {
					icon: faCheckCircle,
					color: /*password*/ ctx[0] && /*password*/ ctx[0] === /*confirmPassword*/ ctx[1]
					? validColor$1
					: invalidColor$1
				}
			});

		return {
			c() {
				div1 = element("div");
				ul = element("ul");
				li = element("li");
				div0 = element("div");
				create_component(fa.$$.fragment);
				t0 = space();
				t1 = text(/*passwordsMatchText*/ ctx[2]);
				attr(div0, "class", "zephr-form-password-requirement-icon svelte-tsrdk3");
				toggle_class(div0, "zephr-payment-form-password-requirement-icon", /*isPaymentForm*/ ctx[3]);
				attr(li, "class", "zephr-form-password-requirement svelte-tsrdk3");
				toggle_class(li, "zephr-payment-form-password-requirement", /*isPaymentForm*/ ctx[3]);
				attr(ul, "class", "svelte-tsrdk3");
				attr(div1, "class", "zephr-form-flex-container zephr-form-password-match svelte-tsrdk3");
				toggle_class(div1, "zephr-payment-form-flex-container", /*isPaymentForm*/ ctx[3]);
				toggle_class(div1, "zephr-payment-form-password-match", /*isPaymentForm*/ ctx[3]);
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, ul);
				append(ul, li);
				append(li, div0);
				mount_component(fa, div0, null);
				append(li, t0);
				append(li, t1);
				current = true;
			},
			p(ctx, [dirty]) {
				const fa_changes = {};

				if (dirty & /*password, confirmPassword*/ 3) fa_changes.color = /*password*/ ctx[0] && /*password*/ ctx[0] === /*confirmPassword*/ ctx[1]
				? validColor$1
				: invalidColor$1;

				fa.$set(fa_changes);

				if (!current || dirty & /*isPaymentForm*/ 8) {
					toggle_class(div0, "zephr-payment-form-password-requirement-icon", /*isPaymentForm*/ ctx[3]);
				}

				if (!current || dirty & /*passwordsMatchText*/ 4) set_data(t1, /*passwordsMatchText*/ ctx[2]);

				if (!current || dirty & /*isPaymentForm*/ 8) {
					toggle_class(li, "zephr-payment-form-password-requirement", /*isPaymentForm*/ ctx[3]);
				}

				if (!current || dirty & /*isPaymentForm*/ 8) {
					toggle_class(div1, "zephr-payment-form-flex-container", /*isPaymentForm*/ ctx[3]);
				}

				if (!current || dirty & /*isPaymentForm*/ 8) {
					toggle_class(div1, "zephr-payment-form-password-match", /*isPaymentForm*/ ctx[3]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(fa.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(fa.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
				}

				destroy_component(fa);
			}
		};
	}

	const validColor$1 = "var(--zf-password-valid-color)";
	const invalidColor$1 = "var(--zf-password-invalid-color)";

	function instance$10($$self, $$props, $$invalidate) {
		let { password } = $$props;
		let { confirmPassword } = $$props;
		let { passwordsMatchText } = $$props;
		let { isPaymentForm = false } = $$props;

		$$self.$$set = $$props => {
			if ('password' in $$props) $$invalidate(0, password = $$props.password);
			if ('confirmPassword' in $$props) $$invalidate(1, confirmPassword = $$props.confirmPassword);
			if ('passwordsMatchText' in $$props) $$invalidate(2, passwordsMatchText = $$props.passwordsMatchText);
			if ('isPaymentForm' in $$props) $$invalidate(3, isPaymentForm = $$props.isPaymentForm);
		};

		return [password, confirmPassword, passwordsMatchText, isPaymentForm];
	}

	class PasswordMatchIndicator extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$10, create_fragment$12, safe_not_equal, {
				password: 0,
				confirmPassword: 1,
				passwordsMatchText: 2,
				isPaymentForm: 3
			});
		}
	}

	/* src/components/elements/password/PasswordValidator.svelte generated by Svelte v4.2.12 */

	function get_each_context$e(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[12] = list[i];
		child_ctx[14] = i;
		return child_ctx;
	}

	// (43:2) {#each Array(maxScore) as _, i}
	function create_each_block$e(ctx) {
		let div;

		return {
			c() {
				div = element("div");
				attr(div, "class", "zephr-form-password-bar svelte-1bpbne4");

				set_style(div, "background-color", /*score*/ ctx[3] > /*i*/ ctx[14]
				? validColor
				: invalidColor);

				toggle_class(div, "zephr-payment-form-password-bar", /*isPaymentForm*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*score*/ 8) {
					set_style(div, "background-color", /*score*/ ctx[3] > /*i*/ ctx[14]
					? validColor
					: invalidColor);
				}

				if (dirty & /*isPaymentForm*/ 4) {
					toggle_class(div, "zephr-payment-form-password-bar", /*isPaymentForm*/ ctx[2]);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (57:4) {#if passwordRequirements.minLength}
	function create_if_block_3$e(ctx) {
		let li;
		let div;
		let fa;
		let t0;
		let t1_value = /*passwordValidationTexts*/ ctx[1].minLengthValidationText + "";
		let t1;
		let current;

		fa = new Fa({
				props: {
					icon: faCheckCircle,
					color: /*isLong*/ ctx[4] ? validColor : invalidColor
				}
			});

		return {
			c() {
				li = element("li");
				div = element("div");
				create_component(fa.$$.fragment);
				t0 = space();
				t1 = text(t1_value);
				attr(div, "class", "zephr-form-password-requirement-icon svelte-1bpbne4");
				toggle_class(div, "zephr-payment-form-password-requirement-icon", /*isPaymentForm*/ ctx[2]);
				attr(li, "class", "zephr-form-password-requirement svelte-1bpbne4");
				toggle_class(li, "zephr-payment-form-password-requirement", /*isPaymentForm*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, li, anchor);
				append(li, div);
				mount_component(fa, div, null);
				append(li, t0);
				append(li, t1);
				current = true;
			},
			p(ctx, dirty) {
				const fa_changes = {};
				if (dirty & /*isLong*/ 16) fa_changes.color = /*isLong*/ ctx[4] ? validColor : invalidColor;
				fa.$set(fa_changes);

				if (!current || dirty & /*isPaymentForm*/ 4) {
					toggle_class(div, "zephr-payment-form-password-requirement-icon", /*isPaymentForm*/ ctx[2]);
				}

				if ((!current || dirty & /*passwordValidationTexts*/ 2) && t1_value !== (t1_value = /*passwordValidationTexts*/ ctx[1].minLengthValidationText + "")) set_data(t1, t1_value);

				if (!current || dirty & /*isPaymentForm*/ 4) {
					toggle_class(li, "zephr-payment-form-password-requirement", /*isPaymentForm*/ ctx[2]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(fa.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(fa.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(li);
				}

				destroy_component(fa);
			}
		};
	}

	// (75:4) {#if passwordRequirements.requireUppercase}
	function create_if_block_2$j(ctx) {
		let li;
		let div;
		let fa;
		let t0;
		let t1_value = /*passwordValidationTexts*/ ctx[1].uppercaseValidationText + "";
		let t1;
		let current;

		fa = new Fa({
				props: {
					icon: faCheckCircle,
					color: /*hasUppercaseLetter*/ ctx[7]
					? validColor
					: invalidColor
				}
			});

		return {
			c() {
				li = element("li");
				div = element("div");
				create_component(fa.$$.fragment);
				t0 = space();
				t1 = text(t1_value);
				attr(div, "class", "zephr-form-password-requirement-icon svelte-1bpbne4");
				toggle_class(div, "zephr-payment-form-password-requirement-icon", /*isPaymentForm*/ ctx[2]);
				attr(li, "class", "zephr-form-password-requirement svelte-1bpbne4");
				toggle_class(li, "zephr-payment-form-password-requirement", /*isPaymentForm*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, li, anchor);
				append(li, div);
				mount_component(fa, div, null);
				append(li, t0);
				append(li, t1);
				current = true;
			},
			p(ctx, dirty) {
				const fa_changes = {};

				if (dirty & /*hasUppercaseLetter*/ 128) fa_changes.color = /*hasUppercaseLetter*/ ctx[7]
				? validColor
				: invalidColor;

				fa.$set(fa_changes);

				if (!current || dirty & /*isPaymentForm*/ 4) {
					toggle_class(div, "zephr-payment-form-password-requirement-icon", /*isPaymentForm*/ ctx[2]);
				}

				if ((!current || dirty & /*passwordValidationTexts*/ 2) && t1_value !== (t1_value = /*passwordValidationTexts*/ ctx[1].uppercaseValidationText + "")) set_data(t1, t1_value);

				if (!current || dirty & /*isPaymentForm*/ 4) {
					toggle_class(li, "zephr-payment-form-password-requirement", /*isPaymentForm*/ ctx[2]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(fa.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(fa.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(li);
				}

				destroy_component(fa);
			}
		};
	}

	// (93:4) {#if passwordRequirements.requireNumbers}
	function create_if_block_1$u(ctx) {
		let li;
		let div;
		let fa;
		let t0;
		let t1_value = /*passwordValidationTexts*/ ctx[1].numberValidationText + "";
		let t1;
		let current;

		fa = new Fa({
				props: {
					icon: faCheckCircle,
					color: /*hasNumber*/ ctx[6] ? validColor : invalidColor
				}
			});

		return {
			c() {
				li = element("li");
				div = element("div");
				create_component(fa.$$.fragment);
				t0 = space();
				t1 = text(t1_value);
				attr(div, "class", "zephr-form-password-requirement-icon svelte-1bpbne4");
				toggle_class(div, "zephr-payment-form-password-requirement-icon", /*isPaymentForm*/ ctx[2]);
				attr(li, "class", "zephr-form-password-requirement svelte-1bpbne4");
				toggle_class(li, "zephr-payment-form-password-requirement", /*isPaymentForm*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, li, anchor);
				append(li, div);
				mount_component(fa, div, null);
				append(li, t0);
				append(li, t1);
				current = true;
			},
			p(ctx, dirty) {
				const fa_changes = {};
				if (dirty & /*hasNumber*/ 64) fa_changes.color = /*hasNumber*/ ctx[6] ? validColor : invalidColor;
				fa.$set(fa_changes);

				if (!current || dirty & /*isPaymentForm*/ 4) {
					toggle_class(div, "zephr-payment-form-password-requirement-icon", /*isPaymentForm*/ ctx[2]);
				}

				if ((!current || dirty & /*passwordValidationTexts*/ 2) && t1_value !== (t1_value = /*passwordValidationTexts*/ ctx[1].numberValidationText + "")) set_data(t1, t1_value);

				if (!current || dirty & /*isPaymentForm*/ 4) {
					toggle_class(li, "zephr-payment-form-password-requirement", /*isPaymentForm*/ ctx[2]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(fa.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(fa.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(li);
				}

				destroy_component(fa);
			}
		};
	}

	// (111:4) {#if passwordRequirements.requireSpecialCharacters}
	function create_if_block$F(ctx) {
		let li;
		let div;
		let fa;
		let t0;
		let t1_value = /*passwordValidationTexts*/ ctx[1].symbolValidationText + "";
		let t1;
		let current;

		fa = new Fa({
				props: {
					icon: faCheckCircle,
					color: /*hasSpecialCharacter*/ ctx[5]
					? validColor
					: invalidColor
				}
			});

		return {
			c() {
				li = element("li");
				div = element("div");
				create_component(fa.$$.fragment);
				t0 = space();
				t1 = text(t1_value);
				attr(div, "class", "zephr-form-password-requirement-icon svelte-1bpbne4");
				toggle_class(div, "zephr-payment-form-password-requirement-icon", /*isPaymentForm*/ ctx[2]);
				attr(li, "class", "zephr-form-password-requirement svelte-1bpbne4");
				toggle_class(li, "zephr-payment-form-password-requirement", /*isPaymentForm*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, li, anchor);
				append(li, div);
				mount_component(fa, div, null);
				append(li, t0);
				append(li, t1);
				current = true;
			},
			p(ctx, dirty) {
				const fa_changes = {};

				if (dirty & /*hasSpecialCharacter*/ 32) fa_changes.color = /*hasSpecialCharacter*/ ctx[5]
				? validColor
				: invalidColor;

				fa.$set(fa_changes);

				if (!current || dirty & /*isPaymentForm*/ 4) {
					toggle_class(div, "zephr-payment-form-password-requirement-icon", /*isPaymentForm*/ ctx[2]);
				}

				if ((!current || dirty & /*passwordValidationTexts*/ 2) && t1_value !== (t1_value = /*passwordValidationTexts*/ ctx[1].symbolValidationText + "")) set_data(t1, t1_value);

				if (!current || dirty & /*isPaymentForm*/ 4) {
					toggle_class(li, "zephr-payment-form-password-requirement", /*isPaymentForm*/ ctx[2]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(fa.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(fa.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(li);
				}

				destroy_component(fa);
			}
		};
	}

	function create_fragment$11(ctx) {
		let div0;
		let t0;
		let div1;
		let ul;
		let t1;
		let t2;
		let t3;
		let current;
		let each_value = ensure_array_like(Array(/*maxScore*/ ctx[8]));
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
		}

		let if_block0 = /*passwordRequirements*/ ctx[0].minLength && create_if_block_3$e(ctx);
		let if_block1 = /*passwordRequirements*/ ctx[0].requireUppercase && create_if_block_2$j(ctx);
		let if_block2 = /*passwordRequirements*/ ctx[0].requireNumbers && create_if_block_1$u(ctx);
		let if_block3 = /*passwordRequirements*/ ctx[0].requireSpecialCharacters && create_if_block$F(ctx);

		return {
			c() {
				div0 = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t0 = space();
				div1 = element("div");
				ul = element("ul");
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				t2 = space();
				if (if_block2) if_block2.c();
				t3 = space();
				if (if_block3) if_block3.c();
				attr(div0, "class", "zephr-form-password-progress svelte-1bpbne4");
				toggle_class(div0, "zephr-payment-form-password-progress", /*isPaymentForm*/ ctx[2]);
				attr(ul, "class", "svelte-1bpbne4");
				attr(div1, "class", "zephr-form-flex-container zephr-form-password-requirements svelte-1bpbne4");
				toggle_class(div1, "zephr-payment-form-flex-container", /*isPaymentForm*/ ctx[2]);
				toggle_class(div1, "zephr-payment-form-password-requirements", /*isPaymentForm*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, div0, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div0, null);
					}
				}

				insert(target, t0, anchor);
				insert(target, div1, anchor);
				append(div1, ul);
				if (if_block0) if_block0.m(ul, null);
				append(ul, t1);
				if (if_block1) if_block1.m(ul, null);
				append(ul, t2);
				if (if_block2) if_block2.m(ul, null);
				append(ul, t3);
				if (if_block3) if_block3.m(ul, null);
				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*score, validColor, invalidColor, isPaymentForm*/ 12) {
					each_value = ensure_array_like(Array(/*maxScore*/ ctx[8]));
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$e(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$e(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(div0, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}

				if (!current || dirty & /*isPaymentForm*/ 4) {
					toggle_class(div0, "zephr-payment-form-password-progress", /*isPaymentForm*/ ctx[2]);
				}

				if (/*passwordRequirements*/ ctx[0].minLength) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*passwordRequirements*/ 1) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_3$e(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(ul, t1);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*passwordRequirements*/ ctx[0].requireUppercase) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*passwordRequirements*/ 1) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_2$j(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(ul, t2);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (/*passwordRequirements*/ ctx[0].requireNumbers) {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty & /*passwordRequirements*/ 1) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block_1$u(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(ul, t3);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}

				if (/*passwordRequirements*/ ctx[0].requireSpecialCharacters) {
					if (if_block3) {
						if_block3.p(ctx, dirty);

						if (dirty & /*passwordRequirements*/ 1) {
							transition_in(if_block3, 1);
						}
					} else {
						if_block3 = create_if_block$F(ctx);
						if_block3.c();
						transition_in(if_block3, 1);
						if_block3.m(ul, null);
					}
				} else if (if_block3) {
					group_outros();

					transition_out(if_block3, 1, 1, () => {
						if_block3 = null;
					});

					check_outros();
				}

				if (!current || dirty & /*isPaymentForm*/ 4) {
					toggle_class(div1, "zephr-payment-form-flex-container", /*isPaymentForm*/ ctx[2]);
				}

				if (!current || dirty & /*isPaymentForm*/ 4) {
					toggle_class(div1, "zephr-payment-form-password-requirements", /*isPaymentForm*/ ctx[2]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(if_block2);
				transition_in(if_block3);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(if_block2);
				transition_out(if_block3);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div0);
					detach(t0);
					detach(div1);
				}

				destroy_each(each_blocks, detaching);
				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
				if (if_block3) if_block3.d();
			}
		};
	}

	const validColor = "var(--zf-password-valid-color)";
	const invalidColor = "var(--zf-password-invalid-color)";

	function instance$$($$self, $$props, $$invalidate) {
		let hasUppercaseLetter;
		let hasNumber;
		let hasSpecialCharacter;
		let isLong;
		let { passwordRequirements } = $$props;
		let { passwordValidationTexts } = $$props;
		let { isPaymentForm = false } = $$props;
		let { onChange } = $$props;
		let { password } = $$props;
		let { passwordIsValid } = $$props;
		let score = 0;

		let maxScore = Object.values(passwordRequirements).reduce(
			(acc, curr) => {
				return acc += curr ? 1 : 0;
			},
			0
		);

		$$self.$$set = $$props => {
			if ('passwordRequirements' in $$props) $$invalidate(0, passwordRequirements = $$props.passwordRequirements);
			if ('passwordValidationTexts' in $$props) $$invalidate(1, passwordValidationTexts = $$props.passwordValidationTexts);
			if ('isPaymentForm' in $$props) $$invalidate(2, isPaymentForm = $$props.isPaymentForm);
			if ('onChange' in $$props) $$invalidate(9, onChange = $$props.onChange);
			if ('password' in $$props) $$invalidate(10, password = $$props.password);
			if ('passwordIsValid' in $$props) $$invalidate(11, passwordIsValid = $$props.passwordIsValid);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*password*/ 1024) {
				$$invalidate(7, hasUppercaseLetter = (/[A-Z]+/).test(password));
			}

			if ($$self.$$.dirty & /*password*/ 1024) {
				$$invalidate(6, hasNumber = (/[0-9]+/).test(password));
			}

			if ($$self.$$.dirty & /*password*/ 1024) {
				$$invalidate(5, hasSpecialCharacter = (/[^a-z0-9A-Z]+/).test(password));
			}

			if ($$self.$$.dirty & /*password, passwordRequirements*/ 1025) {
				$$invalidate(4, isLong = password?.length >= passwordRequirements.minLength);
			}

			if ($$self.$$.dirty & /*password, passwordRequirements, score, passwordIsValid, onChange*/ 3593) {
				{
					$$invalidate(3, score = 0);

					if ((/[A-Z]+/).test(password) && passwordRequirements.requireUppercase) {
						$$invalidate(3, score += 1);
					}

					if ((/[0-9]+/).test(password) && passwordRequirements.requireNumbers) {
						$$invalidate(3, score += 1);
					}

					if ((/[^a-z0-9A-Z]+/).test(password) && passwordRequirements.requireSpecialCharacters) {
						$$invalidate(3, score += 1);
					}

					if (password?.length >= passwordRequirements.minLength && passwordRequirements.minLength) {
						$$invalidate(3, score += 1);
					}

					score >= maxScore !== passwordIsValid && onChange(score >= maxScore);
				}
			}
		};

		return [
			passwordRequirements,
			passwordValidationTexts,
			isPaymentForm,
			score,
			isLong,
			hasSpecialCharacter,
			hasNumber,
			hasUppercaseLetter,
			maxScore,
			onChange,
			password,
			passwordIsValid
		];
	}

	class PasswordValidator extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$$, create_fragment$11, safe_not_equal, {
				passwordRequirements: 0,
				passwordValidationTexts: 1,
				isPaymentForm: 2,
				onChange: 9,
				password: 10,
				passwordIsValid: 11
			});
		}
	}

	/* src/components/elements/password/CreatePassword.svelte generated by Svelte v4.2.12 */

	function create_if_block_3$d(ctx) {
		let passwordvalidator;
		let current;

		passwordvalidator = new PasswordValidator({
				props: {
					password: /*password*/ ctx[12],
					passwordIsValid: /*passwordIsValid*/ ctx[14],
					passwordRequirements: /*passwordRequirements*/ ctx[1],
					passwordValidationTexts: /*passwordValidationTexts*/ ctx[16],
					isPaymentForm: /*isPaymentForm*/ ctx[3],
					onChange: /*onPasswordIsValidChange*/ ctx[10]
				}
			});

		return {
			c() {
				create_component(passwordvalidator.$$.fragment);
			},
			m(target, anchor) {
				mount_component(passwordvalidator, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const passwordvalidator_changes = {};
				if (dirty & /*password*/ 4096) passwordvalidator_changes.password = /*password*/ ctx[12];
				if (dirty & /*passwordIsValid*/ 16384) passwordvalidator_changes.passwordIsValid = /*passwordIsValid*/ ctx[14];
				if (dirty & /*passwordRequirements*/ 2) passwordvalidator_changes.passwordRequirements = /*passwordRequirements*/ ctx[1];
				if (dirty & /*isPaymentForm*/ 8) passwordvalidator_changes.isPaymentForm = /*isPaymentForm*/ ctx[3];
				if (dirty & /*onPasswordIsValidChange*/ 1024) passwordvalidator_changes.onChange = /*onPasswordIsValidChange*/ ctx[10];
				passwordvalidator.$set(passwordvalidator_changes);
			},
			i(local) {
				if (current) return;
				transition_in(passwordvalidator.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(passwordvalidator.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(passwordvalidator, detaching);
			}
		};
	}

	// (58:0) {#if !hideConfirmPassword}
	function create_if_block_2$i(ctx) {
		let passwordinput;
		let current;

		passwordinput = new PasswordInput({
				props: {
					disabled: /*disabled*/ ctx[11],
					password: /*confirmPassword*/ ctx[13],
					isMainPassword: false,
					label: /*config*/ ctx[0].confirm,
					hideLabel: /*config*/ ctx[0].hide,
					showLabel: /*config*/ ctx[0].show,
					placeholder: /*config*/ ctx[0].confirmPlaceholder,
					isPaymentForm: /*isPaymentForm*/ ctx[3],
					autocomplete: "new-password",
					onChange: /*onConfirmPasswordChange*/ ctx[7],
					onFocus: /*onConfirmPasswordFocus*/ ctx[8],
					onBlur: /*onConfirmPasswordBlur*/ ctx[9]
				}
			});

		return {
			c() {
				create_component(passwordinput.$$.fragment);
			},
			m(target, anchor) {
				mount_component(passwordinput, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const passwordinput_changes = {};
				if (dirty & /*disabled*/ 2048) passwordinput_changes.disabled = /*disabled*/ ctx[11];
				if (dirty & /*confirmPassword*/ 8192) passwordinput_changes.password = /*confirmPassword*/ ctx[13];
				if (dirty & /*config*/ 1) passwordinput_changes.label = /*config*/ ctx[0].confirm;
				if (dirty & /*config*/ 1) passwordinput_changes.hideLabel = /*config*/ ctx[0].hide;
				if (dirty & /*config*/ 1) passwordinput_changes.showLabel = /*config*/ ctx[0].show;
				if (dirty & /*config*/ 1) passwordinput_changes.placeholder = /*config*/ ctx[0].confirmPlaceholder;
				if (dirty & /*isPaymentForm*/ 8) passwordinput_changes.isPaymentForm = /*isPaymentForm*/ ctx[3];
				if (dirty & /*onConfirmPasswordChange*/ 128) passwordinput_changes.onChange = /*onConfirmPasswordChange*/ ctx[7];
				if (dirty & /*onConfirmPasswordFocus*/ 256) passwordinput_changes.onFocus = /*onConfirmPasswordFocus*/ ctx[8];
				if (dirty & /*onConfirmPasswordBlur*/ 512) passwordinput_changes.onBlur = /*onConfirmPasswordBlur*/ ctx[9];
				passwordinput.$set(passwordinput_changes);
			},
			i(local) {
				if (current) return;
				transition_in(passwordinput.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(passwordinput.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(passwordinput, detaching);
			}
		};
	}

	// (75:0) {#if config.passwordsMatchIndicatorEnabled}
	function create_if_block_1$t(ctx) {
		let passwordmatchindicator;
		let current;

		passwordmatchindicator = new PasswordMatchIndicator({
				props: {
					password: /*password*/ ctx[12],
					confirmPassword: /*confirmPassword*/ ctx[13],
					passwordsMatchText: /*passwordValidationTexts*/ ctx[16].passwordsMatchText,
					isPaymentForm: /*isPaymentForm*/ ctx[3]
				}
			});

		return {
			c() {
				create_component(passwordmatchindicator.$$.fragment);
			},
			m(target, anchor) {
				mount_component(passwordmatchindicator, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const passwordmatchindicator_changes = {};
				if (dirty & /*password*/ 4096) passwordmatchindicator_changes.password = /*password*/ ctx[12];
				if (dirty & /*confirmPassword*/ 8192) passwordmatchindicator_changes.confirmPassword = /*confirmPassword*/ ctx[13];
				if (dirty & /*isPaymentForm*/ 8) passwordmatchindicator_changes.isPaymentForm = /*isPaymentForm*/ ctx[3];
				passwordmatchindicator.$set(passwordmatchindicator_changes);
			},
			i(local) {
				if (current) return;
				transition_in(passwordmatchindicator.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(passwordmatchindicator.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(passwordmatchindicator, detaching);
			}
		};
	}

	// (84:0) {#if error}
	function create_if_block$E(ctx) {
		let errormessage;
		let current;

		errormessage = new ErrorMessage({
				props: {
					error: /*error*/ ctx[15] ?? "",
					isPaymentForm: /*isPaymentForm*/ ctx[3]
				}
			});

		return {
			c() {
				create_component(errormessage.$$.fragment);
			},
			m(target, anchor) {
				mount_component(errormessage, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const errormessage_changes = {};
				if (dirty & /*error*/ 32768) errormessage_changes.error = /*error*/ ctx[15] ?? "";
				if (dirty & /*isPaymentForm*/ 8) errormessage_changes.isPaymentForm = /*isPaymentForm*/ ctx[3];
				errormessage.$set(errormessage_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errormessage.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errormessage.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(errormessage, detaching);
			}
		};
	}

	function create_fragment$10(ctx) {
		let passwordinput;
		let t0;
		let t1;
		let t2;
		let t3;
		let if_block3_anchor;
		let current;

		passwordinput = new PasswordInput({
				props: {
					disabled: /*disabled*/ ctx[11],
					password: /*password*/ ctx[12],
					isMainPassword: true,
					label: /*config*/ ctx[0].password,
					hideLabel: /*config*/ ctx[0].hide,
					showLabel: /*config*/ ctx[0].show,
					placeholder: /*config*/ ctx[0].placeholder,
					isPaymentForm: /*isPaymentForm*/ ctx[3],
					autocomplete: /*hideConfirmPassword*/ ctx[2]
					? "current-password"
					: "new-password",
					onChange: /*onPasswordChange*/ ctx[4],
					onFocus: /*onPasswordFocus*/ ctx[5],
					onBlur: /*onPasswordBlur*/ ctx[6]
				}
			});

		let if_block0 = /*config*/ ctx[0].passValidatorEnabled && create_if_block_3$d(ctx);
		let if_block1 = !/*hideConfirmPassword*/ ctx[2] && create_if_block_2$i(ctx);
		let if_block2 = /*config*/ ctx[0].passwordsMatchIndicatorEnabled && create_if_block_1$t(ctx);
		let if_block3 = /*error*/ ctx[15] && create_if_block$E(ctx);

		return {
			c() {
				create_component(passwordinput.$$.fragment);
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				t2 = space();
				if (if_block2) if_block2.c();
				t3 = space();
				if (if_block3) if_block3.c();
				if_block3_anchor = empty();
			},
			m(target, anchor) {
				mount_component(passwordinput, target, anchor);
				insert(target, t0, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, t2, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, t3, anchor);
				if (if_block3) if_block3.m(target, anchor);
				insert(target, if_block3_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				const passwordinput_changes = {};
				if (dirty & /*disabled*/ 2048) passwordinput_changes.disabled = /*disabled*/ ctx[11];
				if (dirty & /*password*/ 4096) passwordinput_changes.password = /*password*/ ctx[12];
				if (dirty & /*config*/ 1) passwordinput_changes.label = /*config*/ ctx[0].password;
				if (dirty & /*config*/ 1) passwordinput_changes.hideLabel = /*config*/ ctx[0].hide;
				if (dirty & /*config*/ 1) passwordinput_changes.showLabel = /*config*/ ctx[0].show;
				if (dirty & /*config*/ 1) passwordinput_changes.placeholder = /*config*/ ctx[0].placeholder;
				if (dirty & /*isPaymentForm*/ 8) passwordinput_changes.isPaymentForm = /*isPaymentForm*/ ctx[3];

				if (dirty & /*hideConfirmPassword*/ 4) passwordinput_changes.autocomplete = /*hideConfirmPassword*/ ctx[2]
				? "current-password"
				: "new-password";

				if (dirty & /*onPasswordChange*/ 16) passwordinput_changes.onChange = /*onPasswordChange*/ ctx[4];
				if (dirty & /*onPasswordFocus*/ 32) passwordinput_changes.onFocus = /*onPasswordFocus*/ ctx[5];
				if (dirty & /*onPasswordBlur*/ 64) passwordinput_changes.onBlur = /*onPasswordBlur*/ ctx[6];
				passwordinput.$set(passwordinput_changes);

				if (/*config*/ ctx[0].passValidatorEnabled) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*config*/ 1) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_3$d(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(t1.parentNode, t1);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (!/*hideConfirmPassword*/ ctx[2]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*hideConfirmPassword*/ 4) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_2$i(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(t2.parentNode, t2);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (/*config*/ ctx[0].passwordsMatchIndicatorEnabled) {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty & /*config*/ 1) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block_1$t(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(t3.parentNode, t3);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}

				if (/*error*/ ctx[15]) {
					if (if_block3) {
						if_block3.p(ctx, dirty);

						if (dirty & /*error*/ 32768) {
							transition_in(if_block3, 1);
						}
					} else {
						if_block3 = create_if_block$E(ctx);
						if_block3.c();
						transition_in(if_block3, 1);
						if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
					}
				} else if (if_block3) {
					group_outros();

					transition_out(if_block3, 1, 1, () => {
						if_block3 = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(passwordinput.$$.fragment, local);
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(if_block2);
				transition_in(if_block3);
				current = true;
			},
			o(local) {
				transition_out(passwordinput.$$.fragment, local);
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(if_block2);
				transition_out(if_block3);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
					detach(t2);
					detach(t3);
					detach(if_block3_anchor);
				}

				destroy_component(passwordinput, detaching);
				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				if (if_block2) if_block2.d(detaching);
				if (if_block3) if_block3.d(detaching);
			}
		};
	}

	function instance$_($$self, $$props, $$invalidate) {
		let { config } = $$props;
		let { passwordRequirements } = $$props;
		let { hideConfirmPassword } = $$props;
		let { isPaymentForm = false } = $$props;
		let { onPasswordChange } = $$props;
		let { onPasswordFocus } = $$props;
		let { onPasswordBlur } = $$props;
		let { onConfirmPasswordChange } = $$props;
		let { onConfirmPasswordFocus } = $$props;
		let { onConfirmPasswordBlur } = $$props;
		let { onPasswordIsValidChange } = $$props;
		let { disabled } = $$props;
		let { password } = $$props;
		let { confirmPassword } = $$props;
		let { passwordIsValid } = $$props;
		let { error = null } = $$props;

		let passwordValidationTexts = {
			minLengthValidationText: config.minLengthValidation || `Must include at least ${passwordRequirements.minLength} characters`,
			uppercaseValidationText: config.uppercaseValidation || 'Must include an uppercase letter',
			numberValidationText: config.numberValidation || 'Must include a number character',
			symbolValidationText: config.symbolValidation || 'Must include a supported symbol',
			passwordsMatchText: config.passwordsMatchText || 'Passwords match'
		};

		$$self.$$set = $$props => {
			if ('config' in $$props) $$invalidate(0, config = $$props.config);
			if ('passwordRequirements' in $$props) $$invalidate(1, passwordRequirements = $$props.passwordRequirements);
			if ('hideConfirmPassword' in $$props) $$invalidate(2, hideConfirmPassword = $$props.hideConfirmPassword);
			if ('isPaymentForm' in $$props) $$invalidate(3, isPaymentForm = $$props.isPaymentForm);
			if ('onPasswordChange' in $$props) $$invalidate(4, onPasswordChange = $$props.onPasswordChange);
			if ('onPasswordFocus' in $$props) $$invalidate(5, onPasswordFocus = $$props.onPasswordFocus);
			if ('onPasswordBlur' in $$props) $$invalidate(6, onPasswordBlur = $$props.onPasswordBlur);
			if ('onConfirmPasswordChange' in $$props) $$invalidate(7, onConfirmPasswordChange = $$props.onConfirmPasswordChange);
			if ('onConfirmPasswordFocus' in $$props) $$invalidate(8, onConfirmPasswordFocus = $$props.onConfirmPasswordFocus);
			if ('onConfirmPasswordBlur' in $$props) $$invalidate(9, onConfirmPasswordBlur = $$props.onConfirmPasswordBlur);
			if ('onPasswordIsValidChange' in $$props) $$invalidate(10, onPasswordIsValidChange = $$props.onPasswordIsValidChange);
			if ('disabled' in $$props) $$invalidate(11, disabled = $$props.disabled);
			if ('password' in $$props) $$invalidate(12, password = $$props.password);
			if ('confirmPassword' in $$props) $$invalidate(13, confirmPassword = $$props.confirmPassword);
			if ('passwordIsValid' in $$props) $$invalidate(14, passwordIsValid = $$props.passwordIsValid);
			if ('error' in $$props) $$invalidate(15, error = $$props.error);
		};

		return [
			config,
			passwordRequirements,
			hideConfirmPassword,
			isPaymentForm,
			onPasswordChange,
			onPasswordFocus,
			onPasswordBlur,
			onConfirmPasswordChange,
			onConfirmPasswordFocus,
			onConfirmPasswordBlur,
			onPasswordIsValidChange,
			disabled,
			password,
			confirmPassword,
			passwordIsValid,
			error,
			passwordValidationTexts
		];
	}

	class CreatePassword extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$_, create_fragment$10, safe_not_equal, {
				config: 0,
				passwordRequirements: 1,
				hideConfirmPassword: 2,
				isPaymentForm: 3,
				onPasswordChange: 4,
				onPasswordFocus: 5,
				onPasswordBlur: 6,
				onConfirmPasswordChange: 7,
				onConfirmPasswordFocus: 8,
				onConfirmPasswordBlur: 9,
				onPasswordIsValidChange: 10,
				disabled: 11,
				password: 12,
				confirmPassword: 13,
				passwordIsValid: 14,
				error: 15
			});
		}
	}

	const factory$q = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.PASSWORD && sectionElement.config?.confirm != null,
	    create: (form, formState, formActions, elementConfig) => ({
	        component: CreatePassword,
	        props: {
	            disabled: formState.isBusy,
	            config: elementConfig,
	            passwordRequirements: form.organisationConfiguration.passwordStrengthRequirements,
	            hideConfirmPassword: form.organisationConfiguration.hideConfirmPasswordOnRegForm,
	            isPaymentForm: form.formType === FormType.PAYMENT,
	            onPasswordChange: (value) => {
	                formActions.updateFormState({
	                    createPassword: value
	                });
	                logDataLayerEvent(form, 'zephr_form_input_change', {
	                    inputName: 'zephr-form-password',
	                    sectionId: formState.currentSection.type,
	                    field: 'create-password'
	                });
	            },
	            onPasswordFocus: () => logDataLayerEvent(form, 'zephr_form_input_focus', {
	                inputName: 'zephr-form-password',
	                sectionId: formState.currentSection.type,
	                field: 'create-password'
	            }),
	            onPasswordBlur: () => logDataLayerEvent(form, 'zephr_form_input_blur', {
	                inputName: 'zephr-form-password',
	                sectionId: formState.currentSection.type,
	                field: 'create-password'
	            }),
	            onConfirmPasswordChange: (value) => {
	                formActions.updateFormState({
	                    confirmCreatePassword: value
	                });
	                logDataLayerEvent(form, 'zephr_form_input_change', {
	                    inputName: 'zephr-form-confirm-password',
	                    sectionId: formState.currentSection.type,
	                    field: 'confirm-password'
	                });
	            },
	            onConfirmPasswordFocus: () => logDataLayerEvent(form, 'zephr_form_input_focus', {
	                inputName: 'zephr-form-confirm-password',
	                sectionId: formState.currentSection.type,
	                field: 'confirm-password'
	            }),
	            onConfirmPasswordBlur: () => logDataLayerEvent(form, 'zephr_form_input_blur', {
	                inputName: 'zephr-form-confirm-password',
	                sectionId: formState.currentSection.type,
	                field: 'confirm-password'
	            }),
	            onPasswordIsValidChange: (value) => formActions.updateFormState({
	                passwordIsValid: value
	            }),
	            password: formState.createPassword,
	            confirmPassword: formState.confirmCreatePassword,
	            passwordIsValid: formState.passwordIsValid
	        },
	        isValid: formState.password != null
	            && (!elementConfig.passValidatorEnabled || formState.passwordIsValid) && (form.organisationConfiguration.hideConfirmPasswordOnRegForm ||
	            formState.createPassword === formState.confirmCreatePassword),
	    })
	};

	// TODO
	const isValid = (password) => password != null && password.length > 2;
	const factory$p = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.PASSWORD && sectionElement.config?.confirm == null,
	    create: (form, formState, formActions, elementConfig) => {
	        const stateKey = elementConfig.isUpdatePasswordCurrentPassword ? 'currentPassword' : 'password';
	        return {
	            component: PasswordInput,
	            props: {
	                disabled: formState.isBusy,
	                label: elementConfig.password,
	                placeholder: elementConfig.placeholder,
	                isMainPassword: true,
	                showLabel: elementConfig.showLabel,
	                hideLabel: elementConfig.hideLabel,
	                password: formState[stateKey],
	                autocomplete: 'password',
	                onChange: (value) => {
	                    formActions.updateFormState({ [stateKey]: value });
	                    logDataLayerEvent(form, 'zephr_form_input_change', {
	                        inputName: 'zephr-form-password',
	                        sectionId: formState.currentSection.type,
	                        field: 'password'
	                    });
	                },
	                onFocus: () => logDataLayerEvent(form, 'zephr_form_input_focus', {
	                    inputName: 'zephr-form-password',
	                    sectionId: formState.currentSection.type,
	                    field: 'password'
	                }),
	                onBlur: () => logDataLayerEvent(form, 'zephr_form_input_blur', {
	                    inputName: 'zephr-form-password',
	                    sectionId: formState.currentSection.type,
	                    field: 'password'
	                }),
	            },
	            isValid: isValid(formState[stateKey])
	        };
	    }
	};

	const factory$o = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.BUTTON && !sectionElement.config.isLogin && !sectionElement.config.isCancel,
	    create: (form, formState, formActions, elementConfig) => ({
	        component: Button,
	        props: {
	            disabled: formState.isBusy || !formState.canAttemptSectionCompletion,
	            text: elementConfig.text,
	            onClick: () => {
	                logDataLayerEvent(form, 'zephr_form_button_press', {
	                    sectionId: formState.currentSection.type,
	                    buttonType: 'SUBMIT'
	                });
	                formActions.attemptCompleteSection();
	            },
	            isPaymentForm: form.formType === FormType.PAYMENT,
	        }
	    })
	};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var EmailValidatorPro$1 = {exports: {}};

	EmailValidatorPro$1.exports;

	(function (module) {

		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		/**
		 * @author Leandro Silva
		 * @copyright 2012, 2017 Leandro Silva (http://grafluxe.com)
		 * @license MIT
		 *
		 * @classdesc
		 * Validate email address patterns that others don't. This project aims to support all common addresses along
		 * with many rare ones that are considered valid under RFC standards. It can be used in both client and server
		 * side environments.
		 *
		 * <p>
		 *   <b>Valid email addresses that are supported:</b>
		 *   <ul>
		 *     <li>niceandsimple@example.com</li>
		 *     <li>very.common@example.com</li>
		 *     <li>a.little.lengthy.but.fine@dept.example.com</li>
		 *     <li>disposable.style.email.with+symbol@example.com</li>
		 *     <li>other.email-with-dash@example.com</li>
		 *     <li>"much.more unusual"@example.com</li>
		 *     <li>"very.unusual.@.unusual.com"@example.com</li>
		 *     <li>#!$%&\'*+-/=?^_\`{}|~@example.org</li>
		 *     <li>" "@example.org</li>
		 *     <li>üñîçøðé@üñîçøðé.com</li>
		 *     <li>admin@mailserver1</li>
		 *     <li>user@tt</li>
		 *     <li>"hi"@example.com</li>
		 *     <li>jsmith@[192.168.2.1]</li>
		 *     <li>jsmith@[IPv6:2001:db8::1]</li>
		 *     <li>email@123.123.123.123</li>
		 *     <li>"()<>[]:,;@\\\"!#$%&\'*+-/=?^_\`{}| ~.a"@example.org</li>
		 *     <li>abc."defghi".xyz@example.com</li>
		 *     <li>_______@example.com</li>
		 *     <li>very.unusual."@".unusual.com@example.com</li>
		 *     <li>john.smith(comment)@example.com</li>
		 *     <li>(comment)john.smith@example.com</li>
		 *     <li>"()<>[]:,;@\\\"!#$%&\'*+-/=?^_\`{}| ~.a"(comment)@example.org</li>
		 *   </ul>
		 *
		 *   <b>Valid (but rare) email addresses that are not supported:</b>
		 *   <ul>
		 *     <li>"very.(),:;<>[]\".VERY.\"very@\\ \"very\".unusual"@strange.example.com</li>
		 *     <li>"()<>[]:,;@\"!#$%&\'*+-/=?^_\`{}| ~.a"@example.org</li>
		 *     <li>abc."d\"efghi".xyz@example.com</li>
		 *     <li>much."more\ unusual"@example.com</li>
		 *   </ul>
		 * </p>
		*/

		//jshint esversion:6, node:true

		var EmailValidatorPro = function () {
		  function EmailValidatorPro() {
		    _classCallCheck(this, EmailValidatorPro);
		  }

		  _createClass(EmailValidatorPro, [{
		    key: "isValidAddress",

		    /**
		     * Checks whether an email address is valid.
		     * @param   {String}  address An email address.
		     * @returns {Boolean}
		     */
		    value: function isValidAddress(address) {
		      return this._whitelist(address) && !this._blacklist(address) && !this._tooLong(address);
		    }

		    /**
		     * Gets the two parts of an email address (local and domain). This method does not check your email validity.
		     * @param   {String} address An email address.
		     * @example
		     * let evp = new EmailValidatorPro(),
		     *     parts = evp.getParts("contact@email.com");
		     *
		     * console.log(parts); //{local: "contact", domain: "email.com"}
		     * @returns {Object}
		     */

		  }, {
		    key: "getParts",
		    value: function getParts(address) {
		      var domainMatch = address.match(/[^@]*$/);

		      return {
		        local: address.substr(0, domainMatch.index - 1) || "",
		        domain: domainMatch[0] || ""
		      };
		    }
		  }, {
		    key: "_whitelist",
		    value: function _whitelist(address) {
		      return (/^(?=\s)|^(?:(?!.+\.{2,})(?!\.)(?:[\w.!#$%&'*+\-\/=?\^`{|} ~]|[^\x00-\x7F])+[^\."]@|^"(?:[\w.!#$%&'*+\-\/=?\^`{|} ~(),:;<>@\[\]]|[^\x00-\x7F])+"@|(?:[\w.!#$%&'*+\-\/=?\^`{|} ~]|[^\x00-\x7F])+\."(?:[\w.!#$%&'*+\-\/=?\^`{|} ~"(),:;<>\\@\[\]]|[^\x00-\x7F])+"\.(?:[\w.!#$%&'*+\-\/=?\^`{|} ~]|[^\x00-\x7F])+@)(?!-)(?!.*-\.)(?:[a-zA-Z0-9-.]|[^\x00-\x7F])+$|^".+"@.+|.+@\[(?:\w+\.|\w+:){3}.+\]|^\(.+\)|\(.+\)@/.test(address)
		      );
		    }
		  }, {
		    key: "_blacklist",
		    value: function _blacklist(address) {
		      return (/^@|^\s|@\[?(?=\d).*\d{4,}|"(?!.+\\").+".+"|.\(.+\)@(?=.+@)/.test(address)
		      );
		    }
		  }, {
		    key: "_tooLong",
		    value: function _tooLong(address) {
		      var pts = this.getParts(address);

		      return pts.domain.length >= 253 || pts.local.length >= 64 || address.length >= 254;
		    }
		  }]);

		  return EmailValidatorPro;
		}();

		//Support CJS/Node


		if ((_typeof(module)) === "object" && module.exports) {
		  module.exports = EmailValidatorPro;
		} 
	} (EmailValidatorPro$1));

	var EmailValidatorProExports = EmailValidatorPro$1.exports;
	var EmailValidatorPro = /*@__PURE__*/getDefaultExportFromCjs(EmailValidatorProExports);

	const emailValidator = new EmailValidatorPro();
	const isValidEmail = (email) => {
	    if (!email)
	        return false;
	    // EmailValidatorPro doesn't match 1 char emails like a@subdomain.domain.tld, so let's allow it
	    if (email.match(/^[^@]@[a-zA-Z0-9].+$/)) {
	        return true;
	    }
	    return emailValidator.isValidAddress(email);
	};
	const updateElementValidity = (component, formState, sectionElement, formActions) => {
	    if (component?.isValid !== undefined) {
	        const validity = {
	            partType: formState.currentPart.type,
	            sectionType: formState.currentSection.type,
	            sectionOrder: formState.currentSection.order,
	            elementType: sectionElement.type,
	            elementOrder: sectionElement.order,
	            isValid: component.isValid,
	            elementId: sectionElement.config?.slug,
	        };
	        const existingValidity = formState.elementValidity.find((other) => other.partType === validity.partType &&
	            other.sectionType === validity.sectionType &&
	            other.sectionOrder === validity.sectionOrder &&
	            other.elementType === validity.elementType &&
	            other.elementOrder === validity.elementOrder);
	        if (existingValidity?.isValid !== validity.isValid) {
	            formActions.updateFormState({
	                elementValidity: [
	                    ...formState.elementValidity.filter((v) => v != existingValidity),
	                    validity,
	                ],
	            });
	        }
	    }
	};

	/* src/components/elements/email/EmailAddress.svelte generated by Svelte v4.2.12 */

	function create_fragment$$(ctx) {
		let label_1;
		let t;
		let div;
		let input;
		let current;

		label_1 = new Label({
				props: {
					forInput: /*id*/ ctx[11],
					label: /*label*/ ctx[2],
					isPaymentForm: /*isPaymentForm*/ ctx[6]
				}
			});

		input = new Input({
				props: {
					id: /*id*/ ctx[11],
					autocomplete: "email",
					type: "email",
					name: "email",
					disabled: /*disabled*/ ctx[1],
					value: /*emailAddress*/ ctx[0],
					placeholder: /*placeholder*/ ctx[3],
					errorMessage: /*error*/ ctx[5],
					innerTextOnClick: /*onEdit*/ ctx[7],
					innerText: /*onEdit*/ ctx[7] && (/*editText*/ ctx[4] || 'Edit'),
					isPaymentForm: /*isPaymentForm*/ ctx[6],
					onFocus: /*onFocus*/ ctx[9],
					onBlur: /*onBlur*/ ctx[10]
				}
			});

		input.$on("change", /*change_handler*/ ctx[13]);

		return {
			c() {
				create_component(label_1.$$.fragment);
				t = space();
				div = element("div");
				create_component(input.$$.fragment);
				attr(div, "class", "zephr-form-relative-container");
				toggle_class(div, "zephr-payment-form-relative-container", /*isPaymentForm*/ ctx[6]);
			},
			m(target, anchor) {
				mount_component(label_1, target, anchor);
				insert(target, t, anchor);
				insert(target, div, anchor);
				mount_component(input, div, null);
				current = true;
			},
			p(ctx, [dirty]) {
				const label_1_changes = {};
				if (dirty & /*label*/ 4) label_1_changes.label = /*label*/ ctx[2];
				if (dirty & /*isPaymentForm*/ 64) label_1_changes.isPaymentForm = /*isPaymentForm*/ ctx[6];
				label_1.$set(label_1_changes);
				const input_changes = {};
				if (dirty & /*disabled*/ 2) input_changes.disabled = /*disabled*/ ctx[1];
				if (dirty & /*emailAddress*/ 1) input_changes.value = /*emailAddress*/ ctx[0];
				if (dirty & /*placeholder*/ 8) input_changes.placeholder = /*placeholder*/ ctx[3];
				if (dirty & /*error*/ 32) input_changes.errorMessage = /*error*/ ctx[5];
				if (dirty & /*onEdit*/ 128) input_changes.innerTextOnClick = /*onEdit*/ ctx[7];
				if (dirty & /*onEdit, editText*/ 144) input_changes.innerText = /*onEdit*/ ctx[7] && (/*editText*/ ctx[4] || 'Edit');
				if (dirty & /*isPaymentForm*/ 64) input_changes.isPaymentForm = /*isPaymentForm*/ ctx[6];
				if (dirty & /*onFocus*/ 512) input_changes.onFocus = /*onFocus*/ ctx[9];
				if (dirty & /*onBlur*/ 1024) input_changes.onBlur = /*onBlur*/ ctx[10];
				input.$set(input_changes);

				if (!current || dirty & /*isPaymentForm*/ 64) {
					toggle_class(div, "zephr-payment-form-relative-container", /*isPaymentForm*/ ctx[6]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(label_1.$$.fragment, local);
				transition_in(input.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(label_1.$$.fragment, local);
				transition_out(input.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(div);
				}

				destroy_component(label_1, detaching);
				destroy_component(input);
			}
		};
	}

	function instance$Z($$self, $$props, $$invalidate) {
		let { formKey } = $$props;
		let { emailAddress } = $$props;
		let { disabled } = $$props;
		let { label } = $$props;
		let { placeholder } = $$props;
		let { editText } = $$props;
		let { error = null } = $$props;
		let { isPaymentForm = false } = $$props;
		let { onEdit } = $$props;
		let { onChange } = $$props;
		let { onFocus } = $$props;
		let { onBlur } = $$props;
		const id = `zephr-form-identifier-${formKey}`;
		const change_handler = ({ detail }) => onChange(detail);

		$$self.$$set = $$props => {
			if ('formKey' in $$props) $$invalidate(12, formKey = $$props.formKey);
			if ('emailAddress' in $$props) $$invalidate(0, emailAddress = $$props.emailAddress);
			if ('disabled' in $$props) $$invalidate(1, disabled = $$props.disabled);
			if ('label' in $$props) $$invalidate(2, label = $$props.label);
			if ('placeholder' in $$props) $$invalidate(3, placeholder = $$props.placeholder);
			if ('editText' in $$props) $$invalidate(4, editText = $$props.editText);
			if ('error' in $$props) $$invalidate(5, error = $$props.error);
			if ('isPaymentForm' in $$props) $$invalidate(6, isPaymentForm = $$props.isPaymentForm);
			if ('onEdit' in $$props) $$invalidate(7, onEdit = $$props.onEdit);
			if ('onChange' in $$props) $$invalidate(8, onChange = $$props.onChange);
			if ('onFocus' in $$props) $$invalidate(9, onFocus = $$props.onFocus);
			if ('onBlur' in $$props) $$invalidate(10, onBlur = $$props.onBlur);
		};

		return [
			emailAddress,
			disabled,
			label,
			placeholder,
			editText,
			error,
			isPaymentForm,
			onEdit,
			onChange,
			onFocus,
			onBlur,
			id,
			formKey,
			change_handler
		];
	}

	class EmailAddress extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$Z, create_fragment$$, safe_not_equal, {
				formKey: 12,
				emailAddress: 0,
				disabled: 1,
				label: 2,
				placeholder: 3,
				editText: 4,
				error: 5,
				isPaymentForm: 6,
				onEdit: 7,
				onChange: 8,
				onFocus: 9,
				onBlur: 10
			});
		}
	}

	const factory$n = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.EMAIL_ADDRESS,
	    create: (form, formState, formActions, elementConfig) => {
	        const disabled = elementConfig.disabled || formState.isBusy;
	        return ({
	            component: EmailAddress,
	            props: {
	                formKey: form.uniqueKey,
	                disabled,
	                emailAddress: formState.emailAddress,
	                label: elementConfig.label,
	                placeholder: elementConfig.placeholder,
	                editText: elementConfig.editText,
	                onChange: (value) => {
	                    !disabled && formActions.updateFormState({
	                        userExists: undefined,
	                        emailIsContact: undefined,
	                        emailAddress: value,
	                        verificationCode: "",
	                        verificationCodeValid: undefined,
	                        serverErrors: []
	                    });
	                    logDataLayerEvent(form, 'zephr_form_input_change', {
	                        inputName: `zephr-form-identifier-${form.uniqueKey}`,
	                        sectionId: formState.currentSection.type,
	                        field: 'email'
	                    });
	                },
	                onFocus: () => logDataLayerEvent(form, 'zephr_form_input_focus', {
	                    inputName: `zephr-form-identifier-${form.uniqueKey}`,
	                    sectionId: formState.currentSection.type,
	                    field: 'email'
	                }),
	                onBlur: () => logDataLayerEvent(form, 'zephr_form_input_blur', {
	                    inputName: `zephr-form-identifier-${form.uniqueKey}`,
	                    sectionId: formState.currentSection.type,
	                    field: 'email'
	                }),
	                onEdit: elementConfig.disabled && (() => {
	                    formActions.jumpToPartStart(partTypes.ACCOUNT_VERIFICATION.type);
	                }),
	                isPaymentForm: form.formType === FormType.PAYMENT,
	            },
	            isValid: isValidEmail(formState.emailAddress)
	        });
	    }
	};

	/* src/components/elements/payment/braintree/BraintreeMobilePayment.svelte generated by Svelte v4.2.12 */

	function create_fragment$_(ctx) {
		let script0;
		let script0_src_value;
		let script1;
		let script1_src_value;
		let script2;
		let script2_src_value;
		let script3;
		let script3_src_value;
		let t0;
		let div0;
		let t1;
		let div1;

		return {
			c() {
				script0 = element("script");
				script0.innerHTML = ``;
				script1 = element("script");
				script1.innerHTML = ``;
				script2 = element("script");
				script2.innerHTML = ``;
				script3 = element("script");
				script3.innerHTML = ``;
				t0 = space();
				div0 = element("div");
				t1 = space();
				div1 = element("div");
				div1.innerHTML = ``;
				if (!src_url_equal(script0.src, script0_src_value = "https://js.braintreegateway.com/web/3.85.3/js/google-payment.min.js")) attr(script0, "src", script0_src_value);
				if (!src_url_equal(script1.src, script1_src_value = "https://pay.google.com/gp/p/js/pay.js")) attr(script1, "src", script1_src_value);
				attr(script1, "onload", "window.googlePayLoadBraintreeCallback()");
				if (!src_url_equal(script2.src, script2_src_value = "https://js.braintreegateway.com/web/3.85.3/js/client.min.js")) attr(script2, "src", script2_src_value);
				attr(script2, "onload", "window.braintreeLoadCallback()");
				if (!src_url_equal(script3.src, script3_src_value = "https://js.braintreegateway.com/web/3.85.3/js/apple-pay.min.js")) attr(script3, "src", script3_src_value);
				attr(script3, "onload", "window.applePayLoadBraintreeCallback()");
				attr(div0, "id", "google-pay-button");
				attr(div0, "class", "svelte-1drqjgk");
				toggle_class(div0, "zephr-form-disabled-div", /*isDisabled*/ ctx[0]);
				toggle_class(div0, "zephr-payment-form-disabled-div", /*isDisabled*/ ctx[0]);
				attr(div1, "id", "apple_pay_button");
			},
			m(target, anchor) {
				append(document.head, script0);
				append(document.head, script1);
				append(document.head, script2);
				append(document.head, script3);
				insert(target, t0, anchor);
				insert(target, div0, anchor);
				insert(target, t1, anchor);
				insert(target, div1, anchor);
			},
			p(ctx, [dirty]) {
				if (dirty & /*isDisabled*/ 1) {
					toggle_class(div0, "zephr-form-disabled-div", /*isDisabled*/ ctx[0]);
				}

				if (dirty & /*isDisabled*/ 1) {
					toggle_class(div0, "zephr-payment-form-disabled-div", /*isDisabled*/ ctx[0]);
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(div0);
					detach(t1);
					detach(div1);
				}

				detach(script0);
				detach(script1);
				detach(script2);
				detach(script3);
			}
		};
	}

	function instance$Y($$self, $$props, $$invalidate) {
		let { onMountCallback } = $$props;
		let { isDisabled } = $$props;
		let { disableCoreDependencyHeader } = $$props;
		onMount(onMountCallback);

		$$self.$$set = $$props => {
			if ('onMountCallback' in $$props) $$invalidate(1, onMountCallback = $$props.onMountCallback);
			if ('isDisabled' in $$props) $$invalidate(0, isDisabled = $$props.isDisabled);
			if ('disableCoreDependencyHeader' in $$props) $$invalidate(2, disableCoreDependencyHeader = $$props.disableCoreDependencyHeader);
		};

		return [isDisabled, onMountCallback, disableCoreDependencyHeader];
	}

	class BraintreeMobilePayment extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$Y, create_fragment$_, safe_not_equal, {
				onMountCallback: 1,
				isDisabled: 0,
				disableCoreDependencyHeader: 2
			});
		}
	}

	/* src/components/elements/payment/braintree/BraintreePayment.svelte generated by Svelte v4.2.12 */

	function create_fragment$Z(ctx) {
		let script;
		let script_src_value;
		let t0;
		let div;
		let t1;
		let errormessage;
		let current;

		errormessage = new ErrorMessage({
				props: {
					error: /*providerError*/ ctx[0]?.message ?? /*error*/ ctx[2] ?? "",
					isPaymentForm: true
				}
			});

		return {
			c() {
				script = element("script");
				script.innerHTML = ``;
				t0 = space();
				div = element("div");
				t1 = space();
				create_component(errormessage.$$.fragment);
				if (!src_url_equal(script.src, script_src_value = "https://js.braintreegateway.com/web/dropin/1.33.2/js/dropin.min.js")) attr(script, "src", script_src_value);
				attr(script, "onload", "window.braintreeLoadCallback()");
				attr(div, "id", "braintree-dropin-container");
				attr(div, "class", "svelte-w52z2j");
				toggle_class(div, "zephr-form-disabled-div", /*isDisabled*/ ctx[1]);
				toggle_class(div, "zephr-payment-form-disabled-div", /*isDisabled*/ ctx[1]);
			},
			m(target, anchor) {
				append(document.head, script);
				insert(target, t0, anchor);
				insert(target, div, anchor);
				insert(target, t1, anchor);
				mount_component(errormessage, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (!current || dirty & /*isDisabled*/ 2) {
					toggle_class(div, "zephr-form-disabled-div", /*isDisabled*/ ctx[1]);
				}

				if (!current || dirty & /*isDisabled*/ 2) {
					toggle_class(div, "zephr-payment-form-disabled-div", /*isDisabled*/ ctx[1]);
				}

				const errormessage_changes = {};
				if (dirty & /*providerError, error*/ 5) errormessage_changes.error = /*providerError*/ ctx[0]?.message ?? /*error*/ ctx[2] ?? "";
				errormessage.$set(errormessage_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errormessage.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errormessage.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(div);
					detach(t1);
				}

				detach(script);
				destroy_component(errormessage, detaching);
			}
		};
	}

	function instance$X($$self, $$props, $$invalidate) {
		let { onMountCallback } = $$props;
		let { providerError } = $$props;
		let { isDisabled } = $$props;
		let { isLoaded } = $$props;
		let { error = null } = $$props;
		onMount(onMountCallback);

		$$self.$$set = $$props => {
			if ('onMountCallback' in $$props) $$invalidate(3, onMountCallback = $$props.onMountCallback);
			if ('providerError' in $$props) $$invalidate(0, providerError = $$props.providerError);
			if ('isDisabled' in $$props) $$invalidate(1, isDisabled = $$props.isDisabled);
			if ('isLoaded' in $$props) $$invalidate(4, isLoaded = $$props.isLoaded);
			if ('error' in $$props) $$invalidate(2, error = $$props.error);
		};

		return [providerError, isDisabled, error, onMountCallback, isLoaded];
	}

	class BraintreePayment extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$X, create_fragment$Z, safe_not_equal, {
				onMountCallback: 3,
				providerError: 0,
				isDisabled: 1,
				isLoaded: 4,
				error: 2
			});
		}
	}

	/* src/components/elements/payment/stripe/StripePayment.svelte generated by Svelte v4.2.12 */

	function create_fragment$Y(ctx) {
		let script;
		let script_src_value;
		let t0;
		let div;
		let t1;
		let errormessage;
		let current;

		errormessage = new ErrorMessage({
				props: {
					error: /*providerError*/ ctx[0]?.message ?? (/*isComplete*/ ctx[2] ? /*error*/ ctx[3] : "") ?? "",
					isPaymentForm: true
				}
			});

		return {
			c() {
				script = element("script");
				script.innerHTML = ``;
				t0 = space();
				div = element("div");
				t1 = space();
				create_component(errormessage.$$.fragment);
				if (!src_url_equal(script.src, script_src_value = "https://js.stripe.com/v3/")) attr(script, "src", script_src_value);
				attr(script, "onload", "window.stripeLoadCallback()");
				attr(div, "id", /*id*/ ctx[4]);
				attr(div, "class", "stripe-element svelte-1bi6tmz");
				toggle_class(div, "zephr-form-disabled-div", /*isDisabled*/ ctx[1]);
				toggle_class(div, "zephr-payment-form-disabled-div", /*isDisabled*/ ctx[1]);
			},
			m(target, anchor) {
				append(document.head, script);
				insert(target, t0, anchor);
				insert(target, div, anchor);
				insert(target, t1, anchor);
				mount_component(errormessage, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (!current || dirty & /*isDisabled*/ 2) {
					toggle_class(div, "zephr-form-disabled-div", /*isDisabled*/ ctx[1]);
				}

				if (!current || dirty & /*isDisabled*/ 2) {
					toggle_class(div, "zephr-payment-form-disabled-div", /*isDisabled*/ ctx[1]);
				}

				const errormessage_changes = {};
				if (dirty & /*providerError, isComplete, error*/ 13) errormessage_changes.error = /*providerError*/ ctx[0]?.message ?? (/*isComplete*/ ctx[2] ? /*error*/ ctx[3] : "") ?? "";
				errormessage.$set(errormessage_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errormessage.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errormessage.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(div);
					detach(t1);
				}

				detach(script);
				destroy_component(errormessage, detaching);
			}
		};
	}

	function instance$W($$self, $$props, $$invalidate) {
		let { onMountCallback } = $$props;
		let { providerError } = $$props;
		let { isDisabled } = $$props;
		let { isComplete } = $$props;
		let { isLoaded } = $$props;
		let { error = null } = $$props;
		let { formKey } = $$props;
		const id = `stripe-element-${formKey}`;
		onMount(onMountCallback);

		$$self.$$set = $$props => {
			if ('onMountCallback' in $$props) $$invalidate(5, onMountCallback = $$props.onMountCallback);
			if ('providerError' in $$props) $$invalidate(0, providerError = $$props.providerError);
			if ('isDisabled' in $$props) $$invalidate(1, isDisabled = $$props.isDisabled);
			if ('isComplete' in $$props) $$invalidate(2, isComplete = $$props.isComplete);
			if ('isLoaded' in $$props) $$invalidate(6, isLoaded = $$props.isLoaded);
			if ('error' in $$props) $$invalidate(3, error = $$props.error);
			if ('formKey' in $$props) $$invalidate(7, formKey = $$props.formKey);
		};

		return [
			providerError,
			isDisabled,
			isComplete,
			error,
			id,
			onMountCallback,
			isLoaded,
			formKey
		];
	}

	class StripePayment extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$W, create_fragment$Y, safe_not_equal, {
				onMountCallback: 5,
				providerError: 0,
				isDisabled: 1,
				isComplete: 2,
				isLoaded: 6,
				error: 3,
				formKey: 7
			});
		}
	}

	/* src/components/elements/payment/stripe/StripeMobilePayment.svelte generated by Svelte v4.2.12 */

	function create_if_block$D(ctx) {
		let script;
		let script_src_value;

		return {
			c() {
				script = element("script");
				script.innerHTML = ``;
				if (!src_url_equal(script.src, script_src_value = "https://js.stripe.com/v3/")) attr(script, "src", script_src_value);
				attr(script, "onload", "window.stripeLoadCallback()");
			},
			m(target, anchor) {
				insert(target, script, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(script);
				}
			}
		};
	}

	function create_fragment$X(ctx) {
		let script;
		let script_src_value;
		let if_block_anchor;
		let t;
		let div;
		let if_block = !/*disableCoreDependencyHeader*/ ctx[1] && create_if_block$D();

		return {
			c() {
				script = element("script");
				script.innerHTML = ``;
				if (if_block) if_block.c();
				if_block_anchor = empty();
				t = space();
				div = element("div");
				if (!src_url_equal(script.src, script_src_value = "https://pay.google.com/gp/p/js/pay.js")) attr(script, "src", script_src_value);
				attr(script, "onload", "window.googlePayLoadStripeCallback()");
				attr(div, "id", "stripe-mobile-pay-button");
				attr(div, "class", "svelte-12ehv8b");
				toggle_class(div, "zephr-form-disabled-div", /*isDisabled*/ ctx[0]);
				toggle_class(div, "zephr-payment-form-disabled-div", /*isDisabled*/ ctx[0]);
			},
			m(target, anchor) {
				append(document.head, script);
				if (if_block) if_block.m(document.head, null);
				append(document.head, if_block_anchor);
				insert(target, t, anchor);
				insert(target, div, anchor);
			},
			p(ctx, [dirty]) {
				if (!/*disableCoreDependencyHeader*/ ctx[1]) {
					if (if_block) ; else {
						if_block = create_if_block$D();
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (dirty & /*isDisabled*/ 1) {
					toggle_class(div, "zephr-form-disabled-div", /*isDisabled*/ ctx[0]);
				}

				if (dirty & /*isDisabled*/ 1) {
					toggle_class(div, "zephr-payment-form-disabled-div", /*isDisabled*/ ctx[0]);
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(div);
				}

				detach(script);
				if (if_block) if_block.d(detaching);
				detach(if_block_anchor);
			}
		};
	}

	function instance$V($$self, $$props, $$invalidate) {
		let { onMountCallback } = $$props;
		let { isDisabled } = $$props;
		let { disableCoreDependencyHeader } = $$props;
		onMount(onMountCallback);

		$$self.$$set = $$props => {
			if ('onMountCallback' in $$props) $$invalidate(2, onMountCallback = $$props.onMountCallback);
			if ('isDisabled' in $$props) $$invalidate(0, isDisabled = $$props.isDisabled);
			if ('disableCoreDependencyHeader' in $$props) $$invalidate(1, disableCoreDependencyHeader = $$props.disableCoreDependencyHeader);
		};

		return [isDisabled, disableCoreDependencyHeader, onMountCallback];
	}

	class StripeMobilePayment extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$V, create_fragment$X, safe_not_equal, {
				onMountCallback: 2,
				isDisabled: 0,
				disableCoreDependencyHeader: 1
			});
		}
	}

	/* src/components/elements/Spinner.svelte generated by Svelte v4.2.12 */

	function create_fragment$W(ctx) {
		let div;
		let fa;
		let current;

		fa = new Fa({
				props: { size: "2x", icon: faSpinner, spin: true }
			});

		return {
			c() {
				div = element("div");
				create_component(fa.$$.fragment);
				attr(div, "class", "spinner-container svelte-1c5ov4v");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(fa, div, null);
				current = true;
			},
			p: noop,
			i(local) {
				if (current) return;
				transition_in(fa.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(fa.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(fa);
			}
		};
	}

	class Spinner extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, null, create_fragment$W, safe_not_equal, {});
		}
	}

	/* src/components/elements/payment/zuora/ZuoraPayment.svelte generated by Svelte v4.2.12 */

	function create_if_block_1$s(ctx) {
		let spinner;
		let current;
		spinner = new Spinner({});

		return {
			c() {
				create_component(spinner.$$.fragment);
			},
			m(target, anchor) {
				mount_component(spinner, target, anchor);
				current = true;
			},
			i(local) {
				if (current) return;
				transition_in(spinner.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(spinner.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(spinner, detaching);
			}
		};
	}

	// (19:4) {#if isBusy}
	function create_if_block$C(ctx) {
		let div;
		let spinner;
		let current;
		spinner = new Spinner({});

		return {
			c() {
				div = element("div");
				create_component(spinner.$$.fragment);
				attr(div, "class", "spinner-overlay svelte-1vnsk3p");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(spinner, div, null);
				current = true;
			},
			i(local) {
				if (current) return;
				transition_in(spinner.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(spinner.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(spinner);
			}
		};
	}

	function create_fragment$V(ctx) {
		let t0;
		let div1;
		let t1;
		let div0;
		let div0_class_value;
		let div1_class_value;
		let t2;
		let div2;
		let t3;
		let errormessage;
		let current;
		let if_block0 = !/*isLoaded*/ ctx[2] && create_if_block_1$s();
		let if_block1 = /*isBusy*/ ctx[3] && create_if_block$C();

		errormessage = new ErrorMessage({
				props: {
					error: /*providerError*/ ctx[1]?.message ?? /*error*/ ctx[4] ?? "",
					isPaymentForm: true
				}
			});

		return {
			c() {
				if (if_block0) if_block0.c();
				t0 = space();
				div1 = element("div");
				if (if_block1) if_block1.c();
				t1 = space();
				div0 = element("div");
				t2 = space();
				div2 = element("div");
				t3 = space();
				create_component(errormessage.$$.fragment);
				attr(div0, "id", "zuora_payment");

				attr(div0, "class", div0_class_value = "" + (null_to_empty(/*isDisabled*/ ctx[0]
				? "zuora-disabled-iframe-container zuora-dynamic-form-disabled"
				: "") + " svelte-1vnsk3p"));

				attr(div1, "class", div1_class_value = "" + (null_to_empty(/*isBusy*/ ctx[3]
				? "zuora-dynamic-form-disabled form-wrapper"
				: "form-wrapper") + " svelte-1vnsk3p"));

				attr(div2, "id", "core-style");
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t0, anchor);
				insert(target, div1, anchor);
				if (if_block1) if_block1.m(div1, null);
				append(div1, t1);
				append(div1, div0);
				insert(target, t2, anchor);
				insert(target, div2, anchor);
				insert(target, t3, anchor);
				mount_component(errormessage, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (!/*isLoaded*/ ctx[2]) {
					if (if_block0) {
						if (dirty & /*isLoaded*/ 4) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_1$s();
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(t0.parentNode, t0);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*isBusy*/ ctx[3]) {
					if (if_block1) {
						if (dirty & /*isBusy*/ 8) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block$C();
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div1, t1);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (!current || dirty & /*isDisabled*/ 1 && div0_class_value !== (div0_class_value = "" + (null_to_empty(/*isDisabled*/ ctx[0]
				? "zuora-disabled-iframe-container zuora-dynamic-form-disabled"
				: "") + " svelte-1vnsk3p"))) {
					attr(div0, "class", div0_class_value);
				}

				if (!current || dirty & /*isBusy*/ 8 && div1_class_value !== (div1_class_value = "" + (null_to_empty(/*isBusy*/ ctx[3]
				? "zuora-dynamic-form-disabled form-wrapper"
				: "form-wrapper") + " svelte-1vnsk3p"))) {
					attr(div1, "class", div1_class_value);
				}

				const errormessage_changes = {};
				if (dirty & /*providerError, error*/ 18) errormessage_changes.error = /*providerError*/ ctx[1]?.message ?? /*error*/ ctx[4] ?? "";
				errormessage.$set(errormessage_changes);
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(errormessage.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(errormessage.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(div1);
					detach(t2);
					detach(div2);
					detach(t3);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d();
				destroy_component(errormessage, detaching);
			}
		};
	}

	function instance$U($$self, $$props, $$invalidate) {
		let { onMountCallback } = $$props;
		let { isDisabled } = $$props;
		let { providerError } = $$props;
		let { isLoaded } = $$props;
		let { isBusy } = $$props;
		let { error = null } = $$props;
		onMount(onMountCallback);

		$$self.$$set = $$props => {
			if ('onMountCallback' in $$props) $$invalidate(5, onMountCallback = $$props.onMountCallback);
			if ('isDisabled' in $$props) $$invalidate(0, isDisabled = $$props.isDisabled);
			if ('providerError' in $$props) $$invalidate(1, providerError = $$props.providerError);
			if ('isLoaded' in $$props) $$invalidate(2, isLoaded = $$props.isLoaded);
			if ('isBusy' in $$props) $$invalidate(3, isBusy = $$props.isBusy);
			if ('error' in $$props) $$invalidate(4, error = $$props.error);
		};

		return [isDisabled, providerError, isLoaded, isBusy, error, onMountCallback];
	}

	class ZuoraPayment extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$U, create_fragment$V, safe_not_equal, {
				onMountCallback: 5,
				isDisabled: 0,
				providerError: 1,
				isLoaded: 2,
				isBusy: 3,
				error: 4
			});
		}
	}

	/* src/components/elements/payment/zuora/ZuoraPreLoader.svelte generated by Svelte v4.2.12 */

	function create_fragment$U(ctx) {
		let script;
		let script_src_value;

		return {
			c() {
				script = element("script");
				script.innerHTML = ``;
				attr(script, "type", "text/javascript");
				if (!src_url_equal(script.src, script_src_value = "https://static.zuora.com/Resources/libs/hosted/1.3.1/zuora-min.js")) attr(script, "src", script_src_value);
				attr(script, "onload", "window.zuoraLoadCallback()");
			},
			m(target, anchor) {
				append(document.head, script);
			},
			p: noop,
			i: noop,
			o: noop,
			d(detaching) {
				detach(script);
			}
		};
	}

	function instance$T($$self, $$props, $$invalidate) {
		let { onMountCallback } = $$props;
		onMount(onMountCallback);

		$$self.$$set = $$props => {
			if ('onMountCallback' in $$props) $$invalidate(0, onMountCallback = $$props.onMountCallback);
		};

		return [onMountCallback];
	}

	class ZuoraPreLoader extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$T, create_fragment$U, safe_not_equal, { onMountCallback: 0 });
		}
	}

	const paymentProviders = {
	    BRAINTREE: 'braintree',
	    STRIPE: 'stripe',
	    ZUORA: 'zuora-billing',
	};

	const defaultHeaders = new Headers();
	defaultHeaders.append("Content-Type", "application/json");
	defaultHeaders.append("Accept", "application/json");
	const request = async (url, options, formActions, busyKey = null, clearFormErrors = false) => {
	    if (!clearFormErrors) {
	        formActions.updateFormState({
	            serverErrors: []
	        });
	    }
	    formActions.incrementRequestCount(busyKey);
	    try {
	        return await fetch(`${formActions.apiUrlBase}/${url}`, {
	            method: options.method,
	            body: options.bodyObject == null ? undefined : JSON.stringify(options.bodyObject),
	            headers: defaultHeaders,
	            credentials: "include"
	        });
	    }
	    finally {
	        formActions.decrementRequestCount(busyKey);
	    }
	};

	const isOneOffPurchase = (paymentOption) => paymentOption.type === 'ONE_OFF';
	const mapToPayRequest = (form, formState, paymentProvider, vendorFields) => {
	    if (formState.paymentOption.pricePointId) {
	        return {
	            url: `blaize/payment/${paymentProvider}/buy`,
	            body: {
	                product_id: formState.paymentOption.productId,
	                price_point_id: formState.paymentOption.slug,
	                discount_code: formState.promoCodeValid ? formState.promoCode : undefined,
	                ...vendorFields
	            }
	        };
	    }
	    let endpoint;
	    let method;
	    let changeSubscriptionBodyParams = {};
	    if (formConfigAs(form).changeSubscriptionMode) {
	        const changingFromSubscription = formState
	            .validChangeFromPlans
	            .find(plan => formState.paymentOption.slug === plan.planSlug && formState.paymentOption.productId === plan.productId)
	            .changesFromSubscription;
	        endpoint = `subscriptions/${changingFromSubscription.externalId}`;
	        method = 'PATCH';
	        changeSubscriptionBodyParams = {
	            navigated_from: `ChangeForm ${window.location.href}`
	        };
	    }
	    else if (isOneOffPurchase(formState.paymentOption)) {
	        endpoint = 'payment/buy';
	        method = 'POST';
	    }
	    else {
	        endpoint = 'subscribe';
	        method = 'POST';
	    }
	    return {
	        url: `zephr/${endpoint}`,
	        method,
	        body: {
	            product_id: formState.paymentOption.productId,
	            plan_id: formState.paymentOption.slug,
	            discount_code: formState.promoCodeValid ? formState.promoCode : undefined,
	            ...changeSubscriptionBodyParams,
	            vendor_fields: vendorFields ?? {}
	        }
	    };
	};

	const tokenPath = 'blaize/payment/braintree/token';
	let braintreeInstance;
	const loadBraintree = new Promise(function (resolve) {
	    window.braintreeLoadCallback = resolve;
	});
	// https://braintree.github.io/braintree-web-drop-in/docs/current/module-braintree-web-drop-in.html#~paypalCreateOptions
	const paypalConfiguration = (formState) => ({
	    flow: formState.paymentOption.type === 'ONE_OFF' ? 'checkout' : 'vault',
	    singleUse: true,
	    buttonStyle: {
	        shape: 'rect',
	        size: 'medium'
	    },
	    // Show 'continue' button rather than 'pay now' on the PayPal modal
	    commit: false,
	    currency: formState.paymentOption.currencyCode.toLowerCase(),
	    amount: formState.paymentOptionPrices.totalPrice,
	});
	const getBraintreeToken = (formState, formActions) => request(tokenPath, {
	    method: "GET"
	}, formActions, null, true)
	    .then(response => response.json())
	    .then(json => json.token);
	const loadBraintreeUi = (form, formState, formActions) => {
	    const paypalEnabled = formConfigAs(form).paymentProviderFormConfig?.enablePaypal;
	    formActions.incrementRequestCount();
	    void loadBraintree
	        .then(() => getBraintreeToken(formState, formActions))
	        .then((braintreeToken) => {
	        window.braintree.dropin.create({
	            authorization: braintreeToken,
	            container: '#braintree-dropin-container',
	            ...(paypalEnabled ? {
	                paypal: paypalConfiguration(formState)
	            } : {})
	        }, (createErr, instance) => {
	            formActions.decrementRequestCount();
	            braintreeInstance = instance;
	            formActions.updateFormState({
	                paymentProviderFormLoaded: true,
	            });
	            if (createErr) {
	                throw createErr;
	            }
	            // If this is an existing user, they may already have a payment option and paymentMethodRequestable won't be fired
	            if (braintreeInstance.isPaymentMethodRequestable()) {
	                formActions.updateFormState({
	                    paymentFormComplete: true
	                });
	            }
	            braintreeInstance.on('paymentMethodRequestable', () => {
	                formActions.updateFormState({
	                    paymentFormComplete: true
	                });
	            });
	            braintreeInstance.on('noPaymentMethodRequestable', () => {
	                formActions.updateFormState({
	                    paymentFormComplete: false
	                });
	            });
	        });
	    }).catch(err => {
	        console.error(err);
	        formActions.decrementRequestCount();
	    });
	};
	const braintreePay = async (form, formState, formActions) => {
	    formActions.incrementRequestCount();
	    let resolveHandle, rejectHandle;
	    const promise = new Promise((resolve, reject) => { resolveHandle = resolve, rejectHandle = reject; });
	    const success = () => {
	        formActions.decrementRequestCount();
	        resolveHandle();
	    };
	    const errored = (err) => {
	        console.error(err);
	        formActions.decrementRequestCount();
	        rejectHandle();
	    };
	    braintreeInstance.requestPaymentMethod((err, payload) => {
	        if (err || !payload) {
	            errored(`Error requesting payment method ${JSON.stringify(err)}`);
	        }
	        const { url, body, method } = mapToPayRequest(form, formState, paymentProviders.BRAINTREE, {
	            payment_nonce: payload.nonce,
	            ...(payload.type === 'PayPalAccount' ? { paypal: true } : {})
	        });
	        return request(url, {
	            method,
	            bodyObject: body
	        }, formActions)
	            .then(response => {
	            if (response?.ok) {
	                success();
	                return;
	            }
	            errored(response);
	        }).catch((err) => {
	            errored(err);
	        });
	    });
	    return promise;
	};
	const braintreeChangePayment = async (form, formState, formActions) => {
	    let resolveHandle, rejectHandle;
	    const promise = new Promise((resolve, reject) => { resolveHandle = resolve, rejectHandle = reject; });
	    braintreeInstance.requestPaymentMethod((err, payload) => {
	        if (err || !payload) {
	            console.error(`Error requesting payment method ${JSON.stringify(err)}`);
	        }
	        return request(`blaize/payment/braintree/subscriptions/${formState.selectedSubscription?.externalId}`, {
	            method: 'PATCH',
	            bodyObject: {
	                payment_method_nonce: payload?.nonce,
	            }
	        }, formActions)
	            .then(response => {
	            console.log(response);
	            if (response?.ok) {
	                resolveHandle();
	                return;
	            }
	            rejectHandle(response);
	        }).catch((err) => {
	            rejectHandle(err);
	        });
	    });
	    return promise;
	};

	/**
	 * Mobile (Social) payment services
	 *
	 * note: Using a string-backed enum here for better debug logging.
	 */
	var MobilePaymentService;
	(function (MobilePaymentService) {
	    MobilePaymentService["GOOGLE_PAY"] = "GOOGLE_PAY";
	    MobilePaymentService["APPLE_PAY"] = "APPLE_PAY";
	})(MobilePaymentService || (MobilePaymentService = {}));

	const loadGooglePay$1 = new Promise(function (resolve) {
	    window.googlePayLoadBraintreeCallback = resolve;
	});
	const loadBraintreeApplePay = new Promise(function (resolve) {
	    window.applePayLoadBraintreeCallback = resolve;
	});
	const braintreePayWithMobile = (form, formState, formActions) => {
	    const { url, body, method } = mapToPayRequest(form, formState, paymentProviders.BRAINTREE, {
	        payment_nonce: formState.mobilePaymentMethodId,
	        vault_payment_method: true
	    });
	    return request(url, {
	        method,
	        bodyObject: body
	    }, formActions)
	        .then(response => {
	        if (!response?.ok) {
	            throw JSON.stringify(response);
	        }
	    });
	};
	const configureBraintreeMobilePayments = async (form, formState, formActions) => {
	    await configureBraintreeGooglePay(form, formState, formActions);
	    await configureBraintreeApplePay(form, formState, formActions);
	};
	const configureBraintreeGooglePay = (form, formState, formActions) => {
	    const braintreeMobilePaymentConfig = JSON.parse(form.organisationConfiguration?.braintreeMobilePaymentConfig ?? "{}");
	    let googlePaymentsClient;
	    return loadGooglePay$1
	        .then(() => {
	        const container = document.getElementById('google-pay-button');
	        // Empty the container
	        while (container.firstChild) {
	            container.removeChild(container.lastChild);
	        }
	        // No need to show the user any errors here just hide the button
	        if (!braintreeMobilePaymentConfig?.google) {
	            container.style.display = 'none';
	            console.error("Braintree Mobile payments are not configured in the console");
	            return;
	        }
	        formState = formActions.getFormState();
	        googlePaymentsClient = new window.google.payments.api.PaymentsClient({
	            environment: form.organisationConfiguration.braintreeSandboxEnv ? 'TEST' : 'PRODUCTION'
	        });
	        void loadBraintree
	            .then(() => getBraintreeToken(formState, formActions))
	            .then((braintreeToken) => {
	            window.braintree.client.create({
	                authorization: braintreeToken
	            }, (createErr, clientInstance) => {
	                // Empty the container
	                while (container.firstChild) {
	                    container.removeChild(container.lastChild);
	                }
	                if (createErr) {
	                    // No need to show the user any errors here just hide the button
	                    console.error("Error creating braintree client", createErr);
	                    container.style.display = 'none';
	                    return;
	                }
	                window.braintree.googlePayment.create({
	                    client: clientInstance,
	                    googlePayVersion: 2,
	                    googleMerchantId: braintreeMobilePaymentConfig.google.googleMerchantId
	                }, (googlePaymentErr, googlePaymentInstance) => {
	                    if (googlePaymentErr) {
	                        // No need to show the user any errors here just hide the button
	                        console.error("Error creating braintree client", googlePaymentErr);
	                        container.style.display = 'none';
	                        return;
	                    }
	                    googlePaymentsClient.isReadyToPay({
	                        apiVersion: 2,
	                        apiVersionMinor: 0,
	                        allowedPaymentMethods: googlePaymentInstance.createPaymentDataRequest().allowedPaymentMethods,
	                        existingPaymentMethodRequired: true,
	                    }).then((response) => {
	                        if (!response.result || !response.paymentMethodPresent) {
	                            container.style.display = 'none';
	                            console.error(response.paymentMethodPresent ? "Google Pay support not found" : "No payment method");
	                            formActions.updateFormState({
	                                serverErrors: [ServerError.MOBILE_PAYMENT_PROCESSING_ERROR]
	                            });
	                            logDataLayerEvent(form, 'zephr_form_error', {
	                                error: ServerError[ServerError.MOBILE_PAYMENT_PROCESSING_ERROR],
	                            });
	                        }
	                        container.appendChild(googlePaymentsClient.createButton({
	                            buttonColor: 'default',
	                            buttonType: 'plain',
	                            buttonSizeMode: 'fill',
	                            onClick: () => {
	                                onClickPaymentButton$1(form, formState, formActions, googlePaymentInstance, googlePaymentsClient);
	                            },
	                        }));
	                    });
	                });
	            });
	        });
	    });
	};
	const onClickPaymentButton$1 = (form, formState, formActions, googlePaymentInstance, googlePaymentsClient) => {
	    formActions.updateFormState({
	        mobilePaymentService: MobilePaymentService.GOOGLE_PAY,
	        serverErrors: [],
	    });
	    const paymentDataRequest = googlePaymentInstance.createPaymentDataRequest({
	        transactionInfo: {
	            currencyCode: formState.paymentOption.currencyCode,
	            totalPriceStatus: 'FINAL',
	            totalPrice: formState.paymentOptionPrices.totalPrice.toFixed(2)
	        },
	        emailRequired: false,
	        shippingAddressRequired: false
	    });
	    googlePaymentsClient.loadPaymentData(paymentDataRequest).then(function (paymentData) {
	        googlePaymentInstance.parseResponse(paymentData, (err, result) => {
	            if (err || !result.nonce) {
	                formActions.updateFormState({
	                    serverErrors: [ServerError.MOBILE_PAYMENT_PROCESSING_ERROR],
	                    mobilePaymentService: null,
	                });
	                console.error('Error requesting payment data', err, result);
	                logDataLayerEvent(form, 'zephr_form_error', {
	                    error: ServerError[ServerError.MOBILE_PAYMENT_PROCESSING_ERROR],
	                });
	                return;
	            }
	            formActions.updateFormState({
	                mobilePaymentMethodId: result.nonce
	            });
	            formActions.completeSection();
	        });
	    }).catch(function (err) {
	        // If we get heree, the user may have just closed the modal without paying.
	        // Not sure if we should be showing an error in that case, but we cant distinguish
	        // it from other failure cases https://developers.google.com/pay/api/web/reference/client#errors_1 
	        console.warn('Error requesting payment data', err);
	        formActions.updateFormState({
	            mobilePaymentService: null,
	            serverErrors: [ServerError.MOBILE_PAYMENT_PROCESSING_ERROR],
	        });
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[ServerError.MOBILE_PAYMENT_PROCESSING_ERROR],
	        });
	    });
	};
	const configureBraintreeApplePay = (form, formState, formActions) => {
	    const apple_container = document.getElementById('apple_pay_button');
	    while (apple_container.firstChild) {
	        apple_container.removeChild(apple_container.lastChild);
	    }
	    return loadBraintreeApplePay
	        .then(() => {
	        if (!(window.ApplePaySession && window.ApplePaySession.supportsVersion(3) && window.ApplePaySession.canMakePayments())) {
	            apple_container.style.display = 'none';
	            console.log('Cannot make payments with Apple Pay');
	            return;
	        }
	        return loadBraintree
	            .then(() => getBraintreeToken(formState, formActions))
	            .then((braintreeToken) => {
	            window.braintree.client.create({
	                authorization: braintreeToken
	            }, (clientErr, clientInstance) => {
	                if (clientErr) {
	                    apple_container.style.display = 'none';
	                    console.error('Error creating braintree client:', clientErr);
	                    return;
	                }
	                window.braintree.applePay.create({
	                    client: clientInstance
	                }, function (applePayErr, applePayInstance) {
	                    while (apple_container.firstChild) {
	                        apple_container.removeChild(apple_container.lastChild);
	                    }
	                    if (applePayErr) {
	                        apple_container.style.display = 'none';
	                        console.error('Error creating applePayInstance:', applePayErr);
	                        return;
	                    }
	                    const paymentRequest = applePayInstance.createPaymentRequest({
	                        total: {
	                            label: formState.paymentOption.label,
	                            amount: formState.paymentOptionPrices.totalPrice.toFixed(2)
	                        }
	                    });
	                    const applePayDiv = document.createElement("div");
	                    applePayDiv.classList.add("apple-pay-button");
	                    applePayDiv.classList.add("apple-pay-button-black");
	                    apple_container.appendChild(applePayDiv);
	                    applePayDiv.addEventListener('click', function () {
	                        onClickApplePayment(form, formState, formActions, paymentRequest, applePayInstance);
	                    });
	                });
	            });
	        });
	    });
	};
	const onClickApplePayment = (form, formState, formActions, paymentRequest, applePayInstance) => {
	    formActions.updateFormState({
	        mobilePaymentService: MobilePaymentService.APPLE_PAY,
	        serverErrors: [],
	    });
	    const session = new ApplePaySession(3, paymentRequest);
	    session.onvalidatemerchant = function (event) {
	        applePayInstance.performValidation({
	            validationURL: event.validationURL,
	            displayName: formState.paymentOption.label
	        }, function (err, merchantSession) {
	            if (err) {
	                formActions.updateFormState({
	                    serverErrors: [ServerError.MOBILE_PAYMENT_PROCESSING_ERROR],
	                    mobilePaymentService: null,
	                });
	                console.log('err in onvalidatemerchant in apple pay configuration: ', err);
	                logDataLayerEvent(form, 'zephr_form_error', {
	                    error: ServerError[ServerError.MOBILE_PAYMENT_PROCESSING_ERROR],
	                });
	                return;
	            }
	            session.completeMerchantValidation(merchantSession);
	        });
	    };
	    session.onpaymentauthorized = function (event) {
	        applePayInstance.tokenize({
	            token: event.payment.token
	        }, function (tokenizeErr, payload) {
	            if (tokenizeErr) {
	                formActions.updateFormState({
	                    serverErrors: [ServerError.MOBILE_PAYMENT_PROCESSING_ERROR],
	                    mobilePaymentService: null,
	                });
	                console.error('Error tokenizing Apple Pay:', tokenizeErr);
	                logDataLayerEvent(form, 'zephr_form_error', {
	                    error: ServerError[ServerError.MOBILE_PAYMENT_PROCESSING_ERROR],
	                });
	                session.completePayment(ApplePaySession.STATUS_FAILURE);
	                return;
	            }
	            formActions.updateFormState({
	                mobilePaymentMethodId: payload.nonce
	            });
	            formActions.completeSection();
	            session.completePayment(ApplePaySession.STATUS_SUCCESS);
	        });
	    };
	    session.begin();
	};

	const invalidCurrencySymbol = '¤';
	const roundingErrorSmallNumber = 0.00001;
	const formatFromCurrencyCode = (price, currencyCode) => new Intl.NumberFormat(undefined, {
	    style: 'currency',
	    currency: currencyCode,
	    minimumFractionDigits: Math.abs(price) % 1 < roundingErrorSmallNumber ? 0 : undefined,
	    maximumFractionDigits: Math.abs(price) % 1 < roundingErrorSmallNumber ? 0 : 2,
	}).format(price);
	const formatFromCurrencySymbol = (price, currencySymbol) => currencySymbol?.length === 1 ?
	    `${currencySymbol}${price}` :
	    `${price} ${currencySymbol}`.trim();
	/**
	 * currency might either be a symbol ($,£,etc) or a code (GBP,EUR)
	 */
	const formatCurrency = (price, currency) => {
	    try {
	        if (currency?.length === 3) {
	            const formatted = formatFromCurrencyCode(price, currency);
	            if (!formatted.includes(invalidCurrencySymbol)) {
	                return formatted;
	            }
	        }
	    }
	    catch (e) {
	        console.warn(`Error formatting currency for symbol ${currency}`, e);
	    }
	    return formatFromCurrencySymbol(price, currency);
	};

	const getProductAddons = async (form, formState, formActions, skipMobileReload = false) => {
	    const providerConfig = paymentProviderFor(form.organisationConfiguration.paymentProvider);
	    if (!providerConfig.hasProductAddons || !(formState.loginRegistrationComplete || formState.userSession)) {
	        return Promise.resolve(formState);
	    }
	    return request(providerConfig.productAddonPath, {
	        method: 'POST',
	        bodyObject: {
	            promoCode: formState.promoCodeValid ? formState.promoCode : null,
	            paymentOptions: formConfigAs(form).paymentOptions
	        }
	    }, formActions, null, true)
	        .then(async (response) => {
	        if (!response.ok) {
	            console.log("error loading product addons", response);
	            logDataLayerEvent(form, 'zephr_form_error', {
	                error: ServerError[ServerError.UNKNOWN],
	            });
	            return formActions.updateFormState({
	                addons: [],
	                serverErrors: [ServerError.UNKNOWN]
	            });
	        }
	        const json = await response.json();
	        try {
	            const addons = json.map(addon => ({
	                id: addon.id,
	                label: addon.label,
	                planPrices: addon.paymentOptions.map(planAddon => ({
	                    planSlug: planAddon.slug,
	                    productId: planAddon.productId,
	                    addonPrice: planAddon.addonPrice
	                }))
	            }));
	            return formActions.updateFormState({
	                addons
	            });
	        }
	        catch (err) {
	            console.error("Error parsing product addons response", err, json);
	            return formState;
	        }
	    }).then(async (updatedFormState) => {
	        if (!skipMobileReload) {
	            await afterProductAddonChange(form, updatedFormState, formActions);
	        }
	        return updatedFormState;
	    });
	};
	/*
	If we're using mobile payment and we're on the payment screen,
	we'll need to reload the mobile payment button so it has the discounted amount
	and make sure they can't press the button while the button is updating
	*/
	const afterProductAddonChange = async (form, formState, formActions) => {
	    if (formState.currentSection.elements.some(element => element.type === elementTypes.MOBILE_PAYMENT && element.config?.enabled !== false)) {
	        formActions.incrementRequestCount();
	        try {
	            await mobilePaymentServiceFor(form.organisationConfiguration.paymentProvider).loader(form, formState, formActions);
	        }
	        finally {
	            formActions.decrementRequestCount();
	        }
	    }
	};
	const addonsForPlan = (formState) => formState.addons.map(addon => {
	    const plan = addon.planPrices
	        .find(plan => plan.planSlug === formState.paymentOption.slug && plan.productId === formState.paymentOption.productId);
	    return plan && {
	        label: addon.label,
	        addonPrice: plan.addonPrice,
	        addonPriceFormattedString: formatCurrency(plan.addonPrice, formState.paymentOption.currencyCode)
	    };
	}).filter(o => o);

	/**
	 * Calculate the actual prices for a payment option, considering:
	 * - The payment option
	 * - Discount code
	 *
	 * Try not to run the calculation if the inputs have not changed from the previous calculation.
	 */
	const calculatePrices = async (form, formState, formActions) => {
	    if (formState.paymentOptionPrices != null
	        && formState.paymentOptionPrices.productId === formState.paymentOption.productId
	        && formState.paymentOptionPrices.slug === formState.paymentOption.slug
	        && formState.paymentOptionPrices.promoCode === formState.promoCode
	        && formState.paymentOptionPrices.addonPrices == addonsForPlan(formState)
	        && formState.paymentOptionPrices.billingAddress.country === formState.billingAddress.country
	        && formState.paymentOptionPrices.billingAddress.postalCode === formState.billingAddress.postalCode
	        // // This is a bit of a fudge but we know that there are only addons for braintree where the price calculation is non-io
	        && formState.paymentOptionPrices.addonPrices.length == 0
	        && addonsForPlan(formState).length == 0) {
	        return formState;
	    }
	    formActions.updateFormState({
	        paymentOptionPrices: null
	    });
	    const paymentOptionPrices = await paymentProviderFor(form.organisationConfiguration.paymentProvider).priceCalculator(form, formState, formActions);
	    return formActions.updateFormState({
	        paymentOptionPrices
	    });
	};

	// See https://stripe.com/docs/currencies
	const currencies = [
	    "BIF",
	    "CLP",
	    "DJF",
	    "GNF",
	    "JPY",
	    "KMF",
	    "KRW",
	    "MGA",
	    "PYG",
	    "RWF",
	    "UGX",
	    "VND",
	    "VUV",
	    "XAF",
	    "XOF",
	    "XPF",
	];
	const isZeroDecimalCurrency = currencyCode => currencies.includes(currencyCode);

	const stripePaymentElementAppearance = (siteStyles) => {
	    const stylesObj = JSON.parse(siteStyles ?? "{}");
	    return {
	        variables: {
	            color: stylesObj?.color?.text?.main ?? '#32325d',
	            fontFamily: `${stylesObj?.typography?.body?.font}, ${stylesObj?.typography?.body?.fallbackFont},  "Helvetica Neue", Helvetica, sans-serif`,
	            fontSmooth: 'always',
	            fontSizeBase: '16px',
	            colorWarningText: stylesObj?.color?.warning?.main ?? '#fa755a',
	            colorIconCardError: stylesObj?.color?.warning?.main ?? '#fa755a',
	            borderRadius: `${(stylesObj?.input?.borderRadius ?? '4')}px`
	        },
	        rules: {
	            '.Input::placeholder': {
	                color: '#aab7c4'
	            },
	        }
	    };
	};
	const stripeCardElementStyle = {
	    base: {
	        color: '#32325d',
	        fontFamily: '"Helvetica Neue", Helvetica, sans-serif',
	        fontSmoothing: 'antialiased',
	        fontSize: '16px',
	        '::placeholder': {
	            color: '#aab7c4'
	        }
	    },
	    invalid: {
	        color: '#fa755a',
	        iconColor: '#fa755a'
	    }
	};
	const createStripePaymentElement = (stripe, form, formActions) => {
	    const formState = formActions.getFormState();
	    const currencyMultiplier = isZeroDecimalCurrency(formState.paymentOption.currencyCode.toUpperCase()) ? 1 : 100;
	    const elements = stripe.elements({
	        mode: 'payment',
	        currency: formState.paymentOption.currencyCode.toLowerCase(),
	        amount: parseFloat((formState.paymentOptionPrices.totalPrice * currencyMultiplier).toFixed(2)),
	        setup_future_usage: 'off_session',
	        appearance: stripePaymentElementAppearance(form.organisationConfiguration.siteStyles),
	        paymentMethodTypes: ['card']
	    });
	    return elements.create('payment', {
	        terms: {
	            card: 'never'
	        },
	        wallets: {
	            applePay: 'never',
	            googlePay: 'never'
	        }
	    });
	};
	const createStripeCardElement = (stripe) => {
	    return stripe.elements().create('card', { style: stripeCardElementStyle });
	};
	const createStripeElement = (stripe, form, formActions) => {
	    if (form.organisationConfiguration.stripeAutomaticTaxEnabled && form.formType !== FormType.LIST_SUBSCRIPTIONS
	        || formConfigAs(form).paymentProviderFormConfig?.usePaymentElement) {
	        return createStripePaymentElement(stripe, form, formActions);
	    }
	    else {
	        return createStripeCardElement(stripe);
	    }
	};

	/*!
	 * mustache.js - Logic-less {{mustache}} templates with JavaScript
	 * http://github.com/janl/mustache.js
	 */

	var objectToString = Object.prototype.toString;
	var isArray = Array.isArray || function isArrayPolyfill (object) {
	  return objectToString.call(object) === '[object Array]';
	};

	function isFunction (object) {
	  return typeof object === 'function';
	}

	/**
	 * More correct typeof string handling array
	 * which normally returns typeof 'object'
	 */
	function typeStr (obj) {
	  return isArray(obj) ? 'array' : typeof obj;
	}

	function escapeRegExp (string) {
	  return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
	}

	/**
	 * Null safe way of checking whether or not an object,
	 * including its prototype, has a given property
	 */
	function hasProperty (obj, propName) {
	  return obj != null && typeof obj === 'object' && (propName in obj);
	}

	/**
	 * Safe way of detecting whether or not the given thing is a primitive and
	 * whether it has the given property
	 */
	function primitiveHasOwnProperty (primitive, propName) {
	  return (
	    primitive != null
	    && typeof primitive !== 'object'
	    && primitive.hasOwnProperty
	    && primitive.hasOwnProperty(propName)
	  );
	}

	// Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
	// See https://github.com/janl/mustache.js/issues/189
	var regExpTest = RegExp.prototype.test;
	function testRegExp (re, string) {
	  return regExpTest.call(re, string);
	}

	var nonSpaceRe = /\S/;
	function isWhitespace (string) {
	  return !testRegExp(nonSpaceRe, string);
	}

	var entityMap = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  "'": '&#39;',
	  '/': '&#x2F;',
	  '`': '&#x60;',
	  '=': '&#x3D;'
	};

	function escapeHtml (string) {
	  return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap (s) {
	    return entityMap[s];
	  });
	}

	var whiteRe = /\s*/;
	var spaceRe = /\s+/;
	var equalsRe = /\s*=/;
	var curlyRe = /\s*\}/;
	var tagRe = /#|\^|\/|>|\{|&|=|!/;

	/**
	 * Breaks up the given `template` string into a tree of tokens. If the `tags`
	 * argument is given here it must be an array with two string values: the
	 * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
	 * course, the default is to use mustaches (i.e. mustache.tags).
	 *
	 * A token is an array with at least 4 elements. The first element is the
	 * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
	 * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
	 * all text that appears outside a symbol this element is "text".
	 *
	 * The second element of a token is its "value". For mustache tags this is
	 * whatever else was inside the tag besides the opening symbol. For text tokens
	 * this is the text itself.
	 *
	 * The third and fourth elements of the token are the start and end indices,
	 * respectively, of the token in the original template.
	 *
	 * Tokens that are the root node of a subtree contain two more elements: 1) an
	 * array of tokens in the subtree and 2) the index in the original template at
	 * which the closing tag for that section begins.
	 *
	 * Tokens for partials also contain two more elements: 1) a string value of
	 * indendation prior to that tag and 2) the index of that tag on that line -
	 * eg a value of 2 indicates the partial is the third tag on this line.
	 */
	function parseTemplate (template, tags) {
	  if (!template)
	    return [];
	  var lineHasNonSpace = false;
	  var sections = [];     // Stack to hold section tokens
	  var tokens = [];       // Buffer to hold the tokens
	  var spaces = [];       // Indices of whitespace tokens on the current line
	  var hasTag = false;    // Is there a {{tag}} on the current line?
	  var nonSpace = false;  // Is there a non-space char on the current line?
	  var indentation = '';  // Tracks indentation for tags that use it
	  var tagIndex = 0;      // Stores a count of number of tags encountered on a line

	  // Strips all whitespace tokens array for the current line
	  // if there was a {{#tag}} on it and otherwise only space.
	  function stripSpace () {
	    if (hasTag && !nonSpace) {
	      while (spaces.length)
	        delete tokens[spaces.pop()];
	    } else {
	      spaces = [];
	    }

	    hasTag = false;
	    nonSpace = false;
	  }

	  var openingTagRe, closingTagRe, closingCurlyRe;
	  function compileTags (tagsToCompile) {
	    if (typeof tagsToCompile === 'string')
	      tagsToCompile = tagsToCompile.split(spaceRe, 2);

	    if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
	      throw new Error('Invalid tags: ' + tagsToCompile);

	    openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\s*');
	    closingTagRe = new RegExp('\\s*' + escapeRegExp(tagsToCompile[1]));
	    closingCurlyRe = new RegExp('\\s*' + escapeRegExp('}' + tagsToCompile[1]));
	  }

	  compileTags(tags || mustache.tags);

	  var scanner = new Scanner(template);

	  var start, type, value, chr, token, openSection;
	  while (!scanner.eos()) {
	    start = scanner.pos;

	    // Match any text between tags.
	    value = scanner.scanUntil(openingTagRe);

	    if (value) {
	      for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
	        chr = value.charAt(i);

	        if (isWhitespace(chr)) {
	          spaces.push(tokens.length);
	          indentation += chr;
	        } else {
	          nonSpace = true;
	          lineHasNonSpace = true;
	          indentation += ' ';
	        }

	        tokens.push([ 'text', chr, start, start + 1 ]);
	        start += 1;

	        // Check for whitespace on the current line.
	        if (chr === '\n') {
	          stripSpace();
	          indentation = '';
	          tagIndex = 0;
	          lineHasNonSpace = false;
	        }
	      }
	    }

	    // Match the opening tag.
	    if (!scanner.scan(openingTagRe))
	      break;

	    hasTag = true;

	    // Get the tag type.
	    type = scanner.scan(tagRe) || 'name';
	    scanner.scan(whiteRe);

	    // Get the tag value.
	    if (type === '=') {
	      value = scanner.scanUntil(equalsRe);
	      scanner.scan(equalsRe);
	      scanner.scanUntil(closingTagRe);
	    } else if (type === '{') {
	      value = scanner.scanUntil(closingCurlyRe);
	      scanner.scan(curlyRe);
	      scanner.scanUntil(closingTagRe);
	      type = '&';
	    } else {
	      value = scanner.scanUntil(closingTagRe);
	    }

	    // Match the closing tag.
	    if (!scanner.scan(closingTagRe))
	      throw new Error('Unclosed tag at ' + scanner.pos);

	    if (type == '>') {
	      token = [ type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace ];
	    } else {
	      token = [ type, value, start, scanner.pos ];
	    }
	    tagIndex++;
	    tokens.push(token);

	    if (type === '#' || type === '^') {
	      sections.push(token);
	    } else if (type === '/') {
	      // Check section nesting.
	      openSection = sections.pop();

	      if (!openSection)
	        throw new Error('Unopened section "' + value + '" at ' + start);

	      if (openSection[1] !== value)
	        throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
	    } else if (type === 'name' || type === '{' || type === '&') {
	      nonSpace = true;
	    } else if (type === '=') {
	      // Set the tags for the next time around.
	      compileTags(value);
	    }
	  }

	  stripSpace();

	  // Make sure there are no open sections when we're done.
	  openSection = sections.pop();

	  if (openSection)
	    throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);

	  return nestTokens(squashTokens(tokens));
	}

	/**
	 * Combines the values of consecutive text tokens in the given `tokens` array
	 * to a single token.
	 */
	function squashTokens (tokens) {
	  var squashedTokens = [];

	  var token, lastToken;
	  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
	    token = tokens[i];

	    if (token) {
	      if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
	        lastToken[1] += token[1];
	        lastToken[3] = token[3];
	      } else {
	        squashedTokens.push(token);
	        lastToken = token;
	      }
	    }
	  }

	  return squashedTokens;
	}

	/**
	 * Forms the given array of `tokens` into a nested tree structure where
	 * tokens that represent a section have two additional items: 1) an array of
	 * all tokens that appear in that section and 2) the index in the original
	 * template that represents the end of that section.
	 */
	function nestTokens (tokens) {
	  var nestedTokens = [];
	  var collector = nestedTokens;
	  var sections = [];

	  var token, section;
	  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
	    token = tokens[i];

	    switch (token[0]) {
	      case '#':
	      case '^':
	        collector.push(token);
	        sections.push(token);
	        collector = token[4] = [];
	        break;
	      case '/':
	        section = sections.pop();
	        section[5] = token[2];
	        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
	        break;
	      default:
	        collector.push(token);
	    }
	  }

	  return nestedTokens;
	}

	/**
	 * A simple string scanner that is used by the template parser to find
	 * tokens in template strings.
	 */
	function Scanner (string) {
	  this.string = string;
	  this.tail = string;
	  this.pos = 0;
	}

	/**
	 * Returns `true` if the tail is empty (end of string).
	 */
	Scanner.prototype.eos = function eos () {
	  return this.tail === '';
	};

	/**
	 * Tries to match the given regular expression at the current position.
	 * Returns the matched text if it can match, the empty string otherwise.
	 */
	Scanner.prototype.scan = function scan (re) {
	  var match = this.tail.match(re);

	  if (!match || match.index !== 0)
	    return '';

	  var string = match[0];

	  this.tail = this.tail.substring(string.length);
	  this.pos += string.length;

	  return string;
	};

	/**
	 * Skips all text until the given regular expression can be matched. Returns
	 * the skipped string, which is the entire tail if no match can be made.
	 */
	Scanner.prototype.scanUntil = function scanUntil (re) {
	  var index = this.tail.search(re), match;

	  switch (index) {
	    case -1:
	      match = this.tail;
	      this.tail = '';
	      break;
	    case 0:
	      match = '';
	      break;
	    default:
	      match = this.tail.substring(0, index);
	      this.tail = this.tail.substring(index);
	  }

	  this.pos += match.length;

	  return match;
	};

	/**
	 * Represents a rendering context by wrapping a view object and
	 * maintaining a reference to the parent context.
	 */
	function Context (view, parentContext) {
	  this.view = view;
	  this.cache = { '.': this.view };
	  this.parent = parentContext;
	}

	/**
	 * Creates a new context using the given view with this context
	 * as the parent.
	 */
	Context.prototype.push = function push (view) {
	  return new Context(view, this);
	};

	/**
	 * Returns the value of the given name in this context, traversing
	 * up the context hierarchy if the value is absent in this context's view.
	 */
	Context.prototype.lookup = function lookup (name) {
	  var cache = this.cache;

	  var value;
	  if (cache.hasOwnProperty(name)) {
	    value = cache[name];
	  } else {
	    var context = this, intermediateValue, names, index, lookupHit = false;

	    while (context) {
	      if (name.indexOf('.') > 0) {
	        intermediateValue = context.view;
	        names = name.split('.');
	        index = 0;

	        /**
	         * Using the dot notion path in `name`, we descend through the
	         * nested objects.
	         *
	         * To be certain that the lookup has been successful, we have to
	         * check if the last object in the path actually has the property
	         * we are looking for. We store the result in `lookupHit`.
	         *
	         * This is specially necessary for when the value has been set to
	         * `undefined` and we want to avoid looking up parent contexts.
	         *
	         * In the case where dot notation is used, we consider the lookup
	         * to be successful even if the last "object" in the path is
	         * not actually an object but a primitive (e.g., a string, or an
	         * integer), because it is sometimes useful to access a property
	         * of an autoboxed primitive, such as the length of a string.
	         **/
	        while (intermediateValue != null && index < names.length) {
	          if (index === names.length - 1)
	            lookupHit = (
	              hasProperty(intermediateValue, names[index])
	              || primitiveHasOwnProperty(intermediateValue, names[index])
	            );

	          intermediateValue = intermediateValue[names[index++]];
	        }
	      } else {
	        intermediateValue = context.view[name];

	        /**
	         * Only checking against `hasProperty`, which always returns `false` if
	         * `context.view` is not an object. Deliberately omitting the check
	         * against `primitiveHasOwnProperty` if dot notation is not used.
	         *
	         * Consider this example:
	         * ```
	         * Mustache.render("The length of a football field is {{#length}}{{length}}{{/length}}.", {length: "100 yards"})
	         * ```
	         *
	         * If we were to check also against `primitiveHasOwnProperty`, as we do
	         * in the dot notation case, then render call would return:
	         *
	         * "The length of a football field is 9."
	         *
	         * rather than the expected:
	         *
	         * "The length of a football field is 100 yards."
	         **/
	        lookupHit = hasProperty(context.view, name);
	      }

	      if (lookupHit) {
	        value = intermediateValue;
	        break;
	      }

	      context = context.parent;
	    }

	    cache[name] = value;
	  }

	  if (isFunction(value))
	    value = value.call(this.view);

	  return value;
	};

	/**
	 * A Writer knows how to take a stream of tokens and render them to a
	 * string, given a context. It also maintains a cache of templates to
	 * avoid the need to parse the same template twice.
	 */
	function Writer () {
	  this.templateCache = {
	    _cache: {},
	    set: function set (key, value) {
	      this._cache[key] = value;
	    },
	    get: function get (key) {
	      return this._cache[key];
	    },
	    clear: function clear () {
	      this._cache = {};
	    }
	  };
	}

	/**
	 * Clears all cached templates in this writer.
	 */
	Writer.prototype.clearCache = function clearCache () {
	  if (typeof this.templateCache !== 'undefined') {
	    this.templateCache.clear();
	  }
	};

	/**
	 * Parses and caches the given `template` according to the given `tags` or
	 * `mustache.tags` if `tags` is omitted,  and returns the array of tokens
	 * that is generated from the parse.
	 */
	Writer.prototype.parse = function parse (template, tags) {
	  var cache = this.templateCache;
	  var cacheKey = template + ':' + (tags || mustache.tags).join(':');
	  var isCacheEnabled = typeof cache !== 'undefined';
	  var tokens = isCacheEnabled ? cache.get(cacheKey) : undefined;

	  if (tokens == undefined) {
	    tokens = parseTemplate(template, tags);
	    isCacheEnabled && cache.set(cacheKey, tokens);
	  }
	  return tokens;
	};

	/**
	 * High-level method that is used to render the given `template` with
	 * the given `view`.
	 *
	 * The optional `partials` argument may be an object that contains the
	 * names and templates of partials that are used in the template. It may
	 * also be a function that is used to load partial templates on the fly
	 * that takes a single argument: the name of the partial.
	 *
	 * If the optional `config` argument is given here, then it should be an
	 * object with a `tags` attribute or an `escape` attribute or both.
	 * If an array is passed, then it will be interpreted the same way as
	 * a `tags` attribute on a `config` object.
	 *
	 * The `tags` attribute of a `config` object must be an array with two
	 * string values: the opening and closing tags used in the template (e.g.
	 * [ "<%", "%>" ]). The default is to mustache.tags.
	 *
	 * The `escape` attribute of a `config` object must be a function which
	 * accepts a string as input and outputs a safely escaped string.
	 * If an `escape` function is not provided, then an HTML-safe string
	 * escaping function is used as the default.
	 */
	Writer.prototype.render = function render (template, view, partials, config) {
	  var tags = this.getConfigTags(config);
	  var tokens = this.parse(template, tags);
	  var context = (view instanceof Context) ? view : new Context(view, undefined);
	  return this.renderTokens(tokens, context, partials, template, config);
	};

	/**
	 * Low-level method that renders the given array of `tokens` using
	 * the given `context` and `partials`.
	 *
	 * Note: The `originalTemplate` is only ever used to extract the portion
	 * of the original template that was contained in a higher-order section.
	 * If the template doesn't use higher-order sections, this argument may
	 * be omitted.
	 */
	Writer.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate, config) {
	  var buffer = '';

	  var token, symbol, value;
	  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
	    value = undefined;
	    token = tokens[i];
	    symbol = token[0];

	    if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate, config);
	    else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate, config);
	    else if (symbol === '>') value = this.renderPartial(token, context, partials, config);
	    else if (symbol === '&') value = this.unescapedValue(token, context);
	    else if (symbol === 'name') value = this.escapedValue(token, context, config);
	    else if (symbol === 'text') value = this.rawValue(token);

	    if (value !== undefined)
	      buffer += value;
	  }

	  return buffer;
	};

	Writer.prototype.renderSection = function renderSection (token, context, partials, originalTemplate, config) {
	  var self = this;
	  var buffer = '';
	  var value = context.lookup(token[1]);

	  // This function is used to render an arbitrary template
	  // in the current context by higher-order sections.
	  function subRender (template) {
	    return self.render(template, context, partials, config);
	  }

	  if (!value) return;

	  if (isArray(value)) {
	    for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
	      buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);
	    }
	  } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {
	    buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);
	  } else if (isFunction(value)) {
	    if (typeof originalTemplate !== 'string')
	      throw new Error('Cannot use higher-order sections without the original template');

	    // Extract the portion of the original template that the section contains.
	    value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);

	    if (value != null)
	      buffer += value;
	  } else {
	    buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);
	  }
	  return buffer;
	};

	Writer.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate, config) {
	  var value = context.lookup(token[1]);

	  // Use JavaScript's definition of falsy. Include empty arrays.
	  // See https://github.com/janl/mustache.js/issues/186
	  if (!value || (isArray(value) && value.length === 0))
	    return this.renderTokens(token[4], context, partials, originalTemplate, config);
	};

	Writer.prototype.indentPartial = function indentPartial (partial, indentation, lineHasNonSpace) {
	  var filteredIndentation = indentation.replace(/[^ \t]/g, '');
	  var partialByNl = partial.split('\n');
	  for (var i = 0; i < partialByNl.length; i++) {
	    if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
	      partialByNl[i] = filteredIndentation + partialByNl[i];
	    }
	  }
	  return partialByNl.join('\n');
	};

	Writer.prototype.renderPartial = function renderPartial (token, context, partials, config) {
	  if (!partials) return;
	  var tags = this.getConfigTags(config);

	  var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
	  if (value != null) {
	    var lineHasNonSpace = token[6];
	    var tagIndex = token[5];
	    var indentation = token[4];
	    var indentedValue = value;
	    if (tagIndex == 0 && indentation) {
	      indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
	    }
	    var tokens = this.parse(indentedValue, tags);
	    return this.renderTokens(tokens, context, partials, indentedValue, config);
	  }
	};

	Writer.prototype.unescapedValue = function unescapedValue (token, context) {
	  var value = context.lookup(token[1]);
	  if (value != null)
	    return value;
	};

	Writer.prototype.escapedValue = function escapedValue (token, context, config) {
	  var escape = this.getConfigEscape(config) || mustache.escape;
	  var value = context.lookup(token[1]);
	  if (value != null)
	    return (typeof value === 'number' && escape === mustache.escape) ? String(value) : escape(value);
	};

	Writer.prototype.rawValue = function rawValue (token) {
	  return token[1];
	};

	Writer.prototype.getConfigTags = function getConfigTags (config) {
	  if (isArray(config)) {
	    return config;
	  }
	  else if (config && typeof config === 'object') {
	    return config.tags;
	  }
	  else {
	    return undefined;
	  }
	};

	Writer.prototype.getConfigEscape = function getConfigEscape (config) {
	  if (config && typeof config === 'object' && !isArray(config)) {
	    return config.escape;
	  }
	  else {
	    return undefined;
	  }
	};

	var mustache = {
	  name: 'mustache.js',
	  version: '4.2.0',
	  tags: [ '{{', '}}' ],
	  clearCache: undefined,
	  escape: undefined,
	  parse: undefined,
	  render: undefined,
	  Scanner: undefined,
	  Context: undefined,
	  Writer: undefined,
	  /**
	   * Allows a user to override the default caching strategy, by providing an
	   * object with set, get and clear methods. This can also be used to disable
	   * the cache by setting it to the literal `undefined`.
	   */
	  set templateCache (cache) {
	    defaultWriter.templateCache = cache;
	  },
	  /**
	   * Gets the default or overridden caching object from the default writer.
	   */
	  get templateCache () {
	    return defaultWriter.templateCache;
	  }
	};

	// All high-level mustache.* functions use this writer.
	var defaultWriter = new Writer();

	/**
	 * Clears all cached templates in the default writer.
	 */
	mustache.clearCache = function clearCache () {
	  return defaultWriter.clearCache();
	};

	/**
	 * Parses and caches the given template in the default writer and returns the
	 * array of tokens it contains. Doing this ahead of time avoids the need to
	 * parse templates on the fly as they are rendered.
	 */
	mustache.parse = function parse (template, tags) {
	  return defaultWriter.parse(template, tags);
	};

	/**
	 * Renders the `template` with the given `view`, `partials`, and `config`
	 * using the default writer.
	 */
	mustache.render = function render (template, view, partials, config) {
	  if (typeof template !== 'string') {
	    throw new TypeError('Invalid template! Template should be a "string" ' +
	                        'but "' + typeStr(template) + '" was given as the first ' +
	                        'argument for mustache#render(template, view, partials)');
	  }

	  return defaultWriter.render(template, view, partials, config);
	};

	// Export the escaping function so that the user may override it.
	// See https://github.com/janl/mustache.js/issues/244
	mustache.escape = escapeHtml;

	// Export these mainly for testing, but also for advanced usage.
	mustache.Scanner = Scanner;
	mustache.Context = Context;
	mustache.Writer = Writer;

	const processMustacheTemplate = (template, scope) => {
	    return mustache.render(template, scope);
	};

	const getUserAttributes = async (formActions) => {
	    try {
	        return await request('blaize/profile', {
	            method: "GET"
	        }, formActions).then(response => response.json());
	    }
	    catch (error) {
	        console.error('Failed to fetch user attributes:', error);
	        return {};
	    }
	};
	const getSessions = async (formActions) => {
	    try {
	        const response = await request('zephr/public/sessions/v1/sessions', {
	            method: "GET"
	        }, formActions, null, true);
	        return await response.json();
	    }
	    catch (error) {
	        console.error('Failed to fetch sessions:', error);
	        return [];
	    }
	};
	const getUtmParameters = () => {
	    const params = new URLSearchParams(window.location.search);
	    return {
	        source: params.get('utm_source'),
	        medium: params.get('utm_medium'),
	        campaign: params.get('utm_campaign'),
	        term: params.get('utm_term'),
	        content: params.get('utm_content')
	    };
	};
	const initializeSubscriptionScope = async (form, formActions) => {
	    try {
	        const [sessions, attributes] = await Promise.all([
	            getSessions(formActions),
	            getUserAttributes(formActions)
	        ]);
	        const deviceSession = sessions.find(session => session.requestingSession) || null;
	        return {
	            page: {
	                url: window.location.href,
	                path: window.location.pathname,
	                searchParameters: Object.fromEntries(new URLSearchParams(window.location.search)),
	                utmParameters: getUtmParameters(),
	                referrer: document.referrer || null
	            },
	            user: {
	                attributes: attributes,
	                session: deviceSession ? {
	                    id: deviceSession.id,
	                    tenantId: deviceSession.tenantId,
	                    userId: deviceSession.userId,
	                    deviceName: deviceSession.deviceName,
	                    browser: deviceSession.browser,
	                    startDate: deviceSession.startDate,
	                    ipAddress: deviceSession.ipAddress ?? null,
	                    requestingSession: deviceSession.requestingSession
	                } : null,
	                geoLocation: {
	                    city: deviceSession?.city ?? "unknown",
	                    country: deviceSession?.country ?? "unknown",
	                    state: deviceSession?.geoState ?? "unknown",
	                    ipAddress: deviceSession?.ipAddress ?? null
	                }
	            },
	            form: {
	                id: form.id,
	                outcomeId: form.outcomeId,
	                ruleId: form.ruleId
	            }
	        };
	    }
	    catch (error) {
	        console.error('Failed to initialize subscription scope:', error);
	        throw error;
	    }
	};

	const publicKeyPath = 'blaize/payment/stripe/publicKey';
	const getStripePublicKey = (formActions) => request(publicKeyPath, {
	    method: "GET"
	}, formActions, null, true)
	    .then(response => response.text());
	let loadStripePromise, stripe, stripeElement;
	const loadStripe = (formActions) => {
	    if (loadStripePromise) {
	        return loadStripePromise;
	    }
	    return loadStripePromise = new Promise(function (resolve) {
	        window.stripeLoadCallback = resolve;
	    }).then(() => getStripePublicKey(formActions))
	        .then(publicKey => { stripe = window.Stripe(publicKey); return stripe; });
	};
	const handleStripeFormChecktax = (event, form, formActions) => {
	    // only check tax if the form is complete
	    if (!event.complete) {
	        return;
	    }
	    formActions.incrementRequestCount();
	    stripe
	        .createPaymentMethod('card', stripeElement, {})
	        .then(({ error, paymentMethod }) => {
	        if (error || !paymentMethod) {
	            console.error(`Error requesting payment method ${JSON.stringify(error)}`);
	            return null;
	        }
	        formActions.updateFormState({
	            paymentMethodId: paymentMethod.id
	        });
	        return paymentMethod?.billing_details?.address;
	    })
	        .catch((error) => {
	        console.error(`Error requesting payment method ${JSON.stringify(error)}`);
	        return null;
	    }).then((billingAddress) => calculatePrices(form, formActions.updateFormState({
	        billingAddress: {
	            country: billingAddress?.country,
	            postalCode: billingAddress?.postal_code,
	        }
	    }), formActions))
	        .catch((error) => {
	        console.error(`Error requesting payment method ${JSON.stringify(error)}`);
	    }).finally(() => {
	        formActions.decrementRequestCount();
	    });
	};
	const loadStripeUi = (form, formState, formActions) => {
	    formActions.incrementRequestCount();
	    void loadStripe(formActions).then(() => {
	        stripeElement = createStripeElement(stripe, form, formActions);
	        const id = '#stripe-element-' + form.uniqueKey;
	        stripeElement.mount(id);
	        stripeElement.addEventListener('change', (event) => {
	            formActions.updateFormState({
	                paymentProviderError: event.error,
	                paymentFormComplete: event.complete,
	                serverErrors: []
	            });
	            if (form.organisationConfiguration.stripeAutomaticTaxEnabled && form.formType !== FormType.LIST_SUBSCRIPTIONS) {
	                handleStripeFormChecktax(event, form, formActions);
	            }
	        });
	        stripeElement.addEventListener('ready', () => {
	            formActions.updateFormState({
	                paymentProviderFormLoaded: true,
	            });
	        });
	        formActions.decrementRequestCount();
	    }).catch(err => {
	        console.error(err);
	        formActions.decrementRequestCount();
	    });
	};
	const stripePay = (form, formState, formActions) => {
	    const paymentMethodId = formState.paymentMethodId;
	    formActions.incrementRequestCount();
	    if (paymentMethodId) {
	        return performPay(form, formState, formActions, paymentMethodId);
	    }
	    else {
	        return stripe.createPaymentMethod('card', stripeElement, {})
	            .then(async ({ error, paymentMethod }) => {
	            if (error || !paymentMethod) {
	                formActions.decrementRequestCount();
	                throw `Error requesting payment method ${JSON.stringify(error)}`;
	            }
	            await performPay(form, formState, formActions, paymentMethod.id);
	        });
	    }
	};
	const stripeChangePayment = (form, formState, formActions) => {
	    const paymentMethodId = formState.paymentMethodId;
	    formActions.incrementRequestCount();
	    if (paymentMethodId) {
	        return performChangePayment(form, formState, formActions, paymentMethodId);
	    }
	    else {
	        return stripe.createPaymentMethod('card', stripeElement, {})
	            .then(async ({ error, paymentMethod }) => {
	            if (error || !paymentMethod) {
	                formActions.decrementRequestCount();
	                throw `Error requesting payment method ${JSON.stringify(error)}`;
	            }
	            await request('zephr/payment/stripe/setupIntentSecret', {
	                method: 'POST',
	            }, formActions)
	                .then(async (resp) => {
	                const json = await resp.json();
	                const token = json.clientSecret;
	                return stripe.confirmCardSetup(token, {
	                    payment_method: {
	                        card: stripeElement,
	                    },
	                });
	            }).then(async (resp) => {
	                return performChangePayment(form, formState, formActions, resp.setupIntent.payment_method);
	            });
	        });
	    }
	};
	const performChangePayment = (form, formState, formActions, paymentMethod) => {
	    return request('zephr/payment/stripe/updateSubscription', {
	        method: 'POST',
	        bodyObject: {
	            payment_method_id: paymentMethod,
	            subscription_id: formState.selectedSubscription.externalId,
	        },
	    }, formActions);
	};
	const performPay = async (form, formState, formActions, paymentMethod) => {
	    const subscriptionMetadataRaw = (formConfigAs(form).paymentProviderFormConfig?.subscriptionMetadata || {});
	    const subscriptionMetadata = {};
	    if (subscriptionMetadataRaw) {
	        const subscriptionFormScope = await initializeSubscriptionScope(form, formActions);
	        for (const [key, value] of Object.entries(subscriptionMetadataRaw)) {
	            subscriptionMetadata[key] = processMustacheTemplate(value, subscriptionFormScope) || '';
	        }
	    }
	    const hasSubscriptionMetadata = !!Object.keys(subscriptionMetadata).length;
	    const { url, body, method } = mapToPayRequest(form, formState, paymentProviders.STRIPE, {
	        payment_method: paymentMethod,
	        billing_address_provided: !!formState.billingAddress.country,
	        ...(hasSubscriptionMetadata ? { subscription_metadata: JSON.stringify(subscriptionMetadata) } : {}),
	    });
	    return request(url, {
	        method,
	        bodyObject: body
	    }, formActions)
	        .then(async (response) => {
	        if (!response?.ok) {
	            throw JSON.stringify(response);
	        }
	        return response.json();
	    }).then(responseJson => {
	        if (responseJson.grant_id) {
	            return;
	        }
	        if (responseJson.paymentIntentStatus === 'requires_action') {
	            return stripe.confirmCardPayment(responseJson.clientSecret ?? responseJson.client_secret)
	                .then(afterConfirmResponse => {
	                if (afterConfirmResponse.error || !afterConfirmResponse.paymentIntent) {
	                    throw `Error requesting payment method ${JSON.stringify(afterConfirmResponse)}`;
	                }
	                if (isOneOffPurchase(formState.paymentOption) && responseJson.payment_intent_id) {
	                    const { url, body, method } = mapToPayRequest(form, formState, paymentProviders.STRIPE, {
	                        payment_method: paymentMethod,
	                        billing_address_provided: !!formState.billingAddress.country,
	                        payment_intent_id: responseJson.payment_intent_id,
	                        ...(hasSubscriptionMetadata ? { subscription_metadata: JSON.stringify(subscriptionMetadata) } : {}),
	                    });
	                    return request(url, {
	                        method,
	                        bodyObject: body
	                    }, formActions).then(response => {
	                        if (response?.ok) {
	                            return;
	                        }
	                        throw response;
	                    });
	                }
	                else {
	                    return request('blaize/payment/stripe/subscription/confirmation', {
	                        method: 'POST',
	                        bodyObject: {
	                            subscriptionId: responseJson.subscriptionId
	                        }
	                    }, formActions)
	                        .then(response => {
	                        if (response?.ok) {
	                            return;
	                        }
	                        throw response;
	                    });
	                }
	            });
	        }
	        throw JSON.stringify(responseJson);
	    }).catch((err) => {
	        console.error(err);
	        // TODO
	        throw err;
	    }).finally(() => {
	        formActions.decrementRequestCount();
	    });
	};

	/**
	 * See https://stripe.com/docs/stripe-js/elements/payment-request-button
	 */
	const loadGooglePay = new Promise(function (resolve) {
	    window.googlePayLoadStripeCallback = resolve;
	});
	const configureStripeMobilePay = async (form, formState, formActions) => {
	    const stripeMobilePaymentConfig = JSON.parse(form.organisationConfiguration?.stripeMobilePaymentConfig ?? "{}");
	    const container = document.getElementById('stripe-mobile-pay-button');
	    // No need to show the user any errors here just hide the button
	    if (!stripeMobilePaymentConfig?.google && !stripeMobilePaymentConfig?.apple) {
	        container.style.display = 'none';
	        console.error("Stripe Mobile payments are not configured in the console");
	        return;
	    }
	    return loadGooglePay
	        .then(async () => await loadStripe(formActions))
	        .then(stripe => {
	        formState = formActions.getFormState();
	        const currencyMultiplier = isZeroDecimalCurrency(formState.paymentOption.currencyCode.toUpperCase()) ? 1 : 100;
	        const paymentLabels = {
	            country: stripeMobilePaymentConfig.google?.countryCode ?? stripeMobilePaymentConfig.apple?.countryCode,
	            currency: formState.paymentOption.currencyCode.toLowerCase(),
	            total: {
	                label: formState.paymentOption.label,
	                amount: parseFloat((formState.paymentOptionPrices.totalPrice * currencyMultiplier).toFixed(2)),
	            },
	            requestPayerName: true
	        };
	        const paymentRequest = stripe.paymentRequest(paymentLabels);
	        const elements = stripe.elements();
	        const paymentButton = elements.create('paymentRequestButton', {
	            paymentRequest: paymentRequest,
	        });
	        paymentRequest.canMakePayment().then(result => {
	            if (!result || (!result.googlePay && !result.applePay)) {
	                // Not an error - Google Pay or Apple Pay are not supported here
	                console.warn("Cannot make mobile payments on this browser", result);
	                container.style.display = 'none';
	                return;
	            }
	            paymentButton.mount('#stripe-mobile-pay-button');
	            paymentRequest.on('paymentmethod', (ev) => {
	                void onClickPaymentButton(formState, formActions, stripe, ev, result, form);
	            });
	        });
	    }).catch(err => {
	        console.error(err);
	        formActions.updateFormState({
	            serverErrors: [ServerError.UNKNOWN]
	        });
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[ServerError.UNKNOWN],
	        });
	    });
	};
	const onClickPaymentButton = async (formState, formActions, stripe, ev, mobilePaymentType, form) => {
	    if (mobilePaymentType.googlePay) {
	        formActions.updateFormState({
	            mobilePaymentService: MobilePaymentService.GOOGLE_PAY,
	            serverErrors: [],
	        });
	    }
	    else if (mobilePaymentType.applePay) {
	        formActions.updateFormState({
	            mobilePaymentService: MobilePaymentService.APPLE_PAY,
	            serverErrors: [],
	        });
	    }
	    if (!ev) {
	        ev.complete('fail');
	        formActions.updateFormState({
	            serverErrors: [ServerError.MOBILE_PAYMENT_PROCESSING_ERROR]
	        });
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[ServerError.MOBILE_PAYMENT_PROCESSING_ERROR],
	        });
	        return;
	    }
	    const billingAddress = ev.paymentMethod.billing_details.address;
	    if (form.organisationConfiguration.stripeAutomaticTaxEnabled) {
	        formState = await (calculatePrices(form, formActions.updateFormState({
	            billingAddress: {
	                country: billingAddress.country,
	                postalCode: billingAddress.postal_code,
	            }
	        }), formActions));
	    }
	    formState = formActions.updateFormState({
	        paymentMethodId: ev.paymentMethod.id
	    });
	    ev.complete('success');
	    if (formState.paymentOptionPrices.taxPrice || !formState.canAttemptSectionCompletion) {
	        const elementId = formState.elementValidity.find((e) => !e.isValid && e.elementType != 'payment')?.elementId;
	        const element = elementId ? document.getElementById(`zephr-form-${elementId}`) : document.getElementsByClassName('zephr-form-button')[0];
	        element?.scrollIntoView({
	            block: "center",
	        });
	    }
	    else {
	        formActions.completeSection();
	    }
	};

	const calculateBraintreeStripePrice = (form, formState, _) => {
	    const addons = addonsForPlan(formState);
	    const paymentOption = formConfigAs(form).paymentOptions.find(opt => opt.productId == formState.paymentOption.productId && opt.slug == formState.paymentOption.slug);
	    const planPrice = paymentOption.price;
	    const priceAfterPromoCode = formState.discountedPlanPrices.find(discount => discount.planSlug === formState.paymentOption.slug && discount.productId === formState.paymentOption.productId)
	        ?.discountPrice;
	    let finalPrice = priceAfterPromoCode ?? planPrice;
	    let discountTotal = planPrice - finalPrice;
	    // For Braintree only, we apply discounts on top of any promo code discounts
	    if (form.organisationConfiguration.paymentProvider === 'braintree' &&
	        paymentOption.discounts &&
	        paymentOption.discounts.length > 0) {
	        const totalBuiltInDiscount = paymentOption.discounts.reduce((sum, discount) => {
	            return sum + (discount.amount || 0);
	        }, 0);
	        finalPrice = Math.max(0, finalPrice - totalBuiltInDiscount);
	        discountTotal = planPrice - finalPrice;
	    }
	    const total = addons.reduce((total, addon) => total + addon.addonPrice, finalPrice);
	    return Promise.resolve({
	        slug: formState.paymentOption.slug,
	        productId: formState.paymentOption.productId,
	        promoCode: formState.promoCode,
	        addonPrices: addons,
	        billingAddress: formState.billingAddress,
	        totalPrice: total,
	        totalPriceFormattedString: formatCurrency(total, formState.paymentOption.currencyCode),
	        netPrice: planPrice,
	        netPriceFormattedString: formatCurrency(planPrice, formState.paymentOption.currencyCode),
	        discountPrice: discountTotal,
	        discountPriceFormattedPrice: formatCurrency(discountTotal, formState.paymentOption.currencyCode),
	        chargeItems: []
	    });
	};

	const getRelevantCurrency = (form, formState) => {
	    const formConfig = formConfigAs(form);
	    if (formConfig.dynamicOffer?.id) {
	        return formState.paymentOption?.currencyCode;
	    }
	    return formConfigAs(form).formCurrency ?? formState.paymentOption?.currencyCode;
	};

	const loadZuoraDynamicFormKey = async (_, formActions) => {
	    const response = await request("zephr/public/payment/v1/billing/publishable-key", { method: "GET", }, formActions);
	    return (await response.json())?.message;
	};
	// Helper to cast custom field values to appropriate types
	const castCustomFieldValue$1 = (value, type) => {
	    const trimmedValue = value.trim();
	    try {
	        switch (type.toUpperCase()) {
	            case 'INTEGER': {
	                const intVal = parseInt(trimmedValue, 10);
	                if (isNaN(intVal))
	                    throw new Error();
	                return intVal;
	            }
	            case 'NUMBER': {
	                const floatVal = parseFloat(trimmedValue);
	                if (isNaN(floatVal))
	                    throw new Error();
	                return floatVal;
	            }
	            case 'BOOLEAN':
	                return trimmedValue.toLowerCase() === 'true';
	            case 'TEXT':
	            case 'LONGTEXT':
	            case 'PICKLIST':
	            default:
	                return trimmedValue.toString();
	        }
	    }
	    catch (e) {
	        console.warn(`Error casting custom field value "${trimmedValue}" to type ${type}`);
	        return null;
	    }
	};
	const createPaymentSession = async (form, formActions) => {
	    if (formActions.getFormState().isBusy) {
	        console.warn('Form is busy - ignoring payment request');
	        return;
	    }
	    formActions.updateFormState({
	        serverErrors: [],
	        paymentProviderFormBusy: true
	    });
	    formActions.incrementRequestCount();
	    try {
	        const response = await request('zephr/public/payment/v1/billing/payment-sessions', {
	            method: "POST",
	            bodyObject: {
	                currency: getRelevantCurrency(form, formActions.getFormState()),
	                amount: formActions.getFormState().paymentOptionPrices?.totalPrice || 0.01
	            }
	        }, formActions);
	        if (response.ok) {
	            return (await response.json())?.token;
	        }
	        else {
	            console.error("Error occurred while creating payment session.", response);
	            formActions.updateFormState({
	                serverErrors: [ServerError.PAYMENT_PROCESSING_ERROR],
	                paymentProviderFormBusy: false
	            });
	            logDataLayerEvent(form, 'zephr_form_error', {
	                error: ServerError[ServerError.PAYMENT_PROCESSING_ERROR],
	            });
	        }
	    }
	    catch (error) {
	        console.error("Error occurred while creating payment session.", error);
	        formActions.updateFormState({
	            serverErrors: [ServerError.PAYMENT_PROCESSING_ERROR],
	            paymentProviderFormBusy: false
	        });
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[ServerError.PAYMENT_PROCESSING_ERROR],
	        });
	    }
	};
	const onComplete = async (form, formActions, result) => {
	    if (!result?.success || !result.paymentMethodId) {
	        formActions.decrementRequestCount();
	        console.warn('Non-success payment result', result);
	        formActions.updateFormState({
	            serverErrors: [ServerError.PAYMENT_PROCESSING_ERROR],
	            paymentProviderFormBusy: false
	        });
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[ServerError.PAYMENT_PROCESSING_ERROR],
	        });
	        return;
	    }
	    console.log('Payment completed successfully - Test 3ds', result);
	    const currentFormState = formActions.getFormState();
	    // Get the autoRenew value based on payment option configuration
	    const autoRenewConfig = currentFormState.paymentOption.autoRenewConfig;
	    let autoRenewValue;
	    if (autoRenewConfig === 'auto_renew') {
	        autoRenewValue = true;
	    }
	    else if (autoRenewConfig === 'no_auto_renew') {
	        autoRenewValue = false;
	    }
	    else if (autoRenewConfig === 'custom_toggle') {
	        // Use user's choice from the toggle
	        const paymentOptionKey = `${currentFormState.paymentOption.productId}-${currentFormState.paymentOption.slug}`;
	        autoRenewValue = currentFormState.paymentOptionAutoRenew?.[paymentOptionKey] ?? false;
	    }
	    else {
	        // Default behavior for legacy payment options without configuration
	        autoRenewValue = true;
	    }
	    // Process subscription custom fields if any
	    const rawCustomFields = formConfigAs(form).paymentProviderFormConfig?.subscriptionCustomFields || [];
	    const subscriptionCustomFields = {};
	    if (rawCustomFields?.length) {
	        const subscriptionFormScope = await initializeSubscriptionScope(form, formActions);
	        for (const field of rawCustomFields) {
	            const processedTemplate = processMustacheTemplate(field.value, subscriptionFormScope) || '';
	            subscriptionCustomFields[field.name] = castCustomFieldValue$1(processedTemplate, field.type);
	        }
	    }
	    const hasCustomFields = !!Object.keys(subscriptionCustomFields).length;
	    formActions.updateFormState({
	        paymentFormComplete: true,
	        paymentProviderVendorFields: {
	            currency: getRelevantCurrency(form, currentFormState),
	            detail: JSON.stringify({
	                refId: result.paymentMethodId,
	                email: currentFormState.emailAddress,
	            }),
	            ...(currentFormState.dynamicOfferResult ? { dynamicOfferResult: JSON.stringify(currentFormState.dynamicOfferResult) } : {}),
	            ...(currentFormState.paymentOption?.terms ? {
	                terms: JSON.stringify({
	                    ...currentFormState.paymentOption.terms,
	                    autoRenew: autoRenewValue
	                })
	            } : {}),
	            ...(currentFormState.paymentOption?.termsAndConditions ? {
	                termsAndConditions: JSON.stringify({
	                    ...currentFormState.paymentOption.termsAndConditions,
	                    autoRenew: autoRenewValue
	                })
	            } : {}),
	            ...(currentFormState.paymentOption?.triggerOffsets ? { triggerOffsets: JSON.stringify(currentFormState.paymentOption.triggerOffsets) } : {}),
	            ...(currentFormState.paymentOption?.changeSubscriptionTriggerOffsets ? { changeSubscriptionTriggerOffsets: JSON.stringify(currentFormState.paymentOption.changeSubscriptionTriggerOffsets) } : {}),
	            ...(hasCustomFields ? { subscriptionCustomFields: JSON.stringify(subscriptionCustomFields) } : {})
	        }
	    });
	    formActions.decrementRequestCount();
	    formActions.completeSection();
	};
	const loadZuoraDynamicFormUi = async (form, formState, formActions, publishableKey) => {
	    const state = formState.paymentOption && await calculatePrices(form, formState, formActions);
	    const [locale, region] = (navigator.language ?? '').split('-');
	    const configuration = {
	        locale: locale || "en",
	        region: formConfigAs(form).requestCountry || region || 'US',
	        currency: getRelevantCurrency(form, formState),
	        amount: `${state?.paymentOptionPrices?.totalPrice ?? '0.00'}`,
	        profile: formConfigAs(form).paymentProviderFormConfig?.paymentFormNumber ?? undefined,
	        createPaymentSession: () => createPaymentSession(form, formActions),
	        onComplete: (result) => onComplete(form, formActions, result),
	    };
	    // Render form
	    const zuora = window.Zuora(publishableKey);
	    const paymentForm = await zuora.createPaymentForm(configuration);
	    paymentForm.mount("#zuora_payment");
	    formActions.updateFormState({
	        paymentProviderFormLoaded: true,
	    });
	};

	let zuoraLoadPromise;
	const loadZuora = () => {
	    if (zuoraLoadPromise != null) {
	        return zuoraLoadPromise;
	    }
	    return zuoraLoadPromise = new Promise(function (resolve) {
	        window.zuoraLoadCallback = resolve;
	    });
	};
	const isDynamicForm = (form) => formConfigAs(form).paymentProviderFormConfig?.useDynamicForm;
	const loadZuoraFormConfiguration = (form, formActions) => isDynamicForm(form)
	    ? loadZuoraDynamicFormKey(form, formActions)
	    : request("plugins/public/zuora-billing/payment-form-token", {
	        method: "POST",
	        bodyObject: {
	            hostedPageId: formConfigAs(form).paymentProviderFormConfig.hostedPageId,
	            hostedPageUrl: formConfigAs(form).paymentProviderFormConfig.hostedPageUrl,
	        }
	    }, formActions).then((response) => response.json());
	const loadZuoraUi = (form, formState, formActions) => {
	    // Don't show card form if changing a Zuora subscription
	    if (formConfigAs(form).changeSubscriptionMode) {
	        formActions.updateFormState({
	            paymentFormComplete: true,
	        });
	        return;
	    }
	    if (form.formType === FormType.LIST_SUBSCRIPTIONS) {
	        void loadZuora()
	            .then(() => loadZuoraFormConfiguration(form, formActions))
	            .then(formToken => {
	            if (isDynamicForm(form)) {
	                return loadZuoraDynamicFormUi(form, formState, formActions, formToken);
	            }
	            const formConfiguration = {
	                tenantId: formToken.tenantId,
	                token: formToken.token,
	                signature: formToken.signature,
	                key: formToken.key,
	                id: formToken.id,
	                url: formToken.url,
	                style: 'inline',
	                submitEnabled: true,
	            };
	            const prePopulatedFields = {
	                email: formState.emailAddress,
	            };
	            window.Z.setEventHandler("onloadCallback", () => {
	                formActions.updateFormState({
	                    paymentProviderFormLoaded: true,
	                });
	            });
	            window.Z.render(formConfiguration, prePopulatedFields, (event) => {
	                if (event.success !== "true") {
	                    console.error("Payment failed", event);
	                    formActions.updateFormState({
	                        serverErrors: [ServerError.PAYMENT_PROCESSING_ERROR]
	                    });
	                    logDataLayerEvent(form, 'zephr_form_error', {
	                        error: ServerError[ServerError.PAYMENT_PROCESSING_ERROR],
	                    });
	                    return;
	                }
	                formActions.updateFormState({
	                    paymentFormComplete: true,
	                    paymentProviderVendorFields: {
	                        detail: JSON.stringify({
	                            creditCardCountry: event.creditCardCountry,
	                            creditCardState: event.creditCardState,
	                            refId: event.refId,
	                            email: event.email,
	                        }),
	                    }
	                });
	                formActions.completeSection();
	            });
	        });
	    }
	    else {
	        void loadZuora()
	            .then(() => loadZuoraFormConfiguration(form, formActions))
	            .then(formToken => {
	            if (!getRelevantCurrency(form, formState)) {
	                formActions.updateFormState({
	                    serverErrors: [ServerError.PAYMENT_PROCESSING_ERROR]
	                });
	                console.error("Form currency not set");
	                logDataLayerEvent(form, 'zephr_form_error', {
	                    error: ServerError[ServerError.PAYMENT_PROCESSING_ERROR],
	                });
	                return;
	            }
	            if (isDynamicForm(form)) {
	                return loadZuoraDynamicFormUi(form, formState, formActions, formToken);
	            }
	            const formConfiguration = {
	                tenantId: formToken.tenantId,
	                token: formToken.token,
	                signature: formToken.signature,
	                key: formToken.key,
	                id: formToken.id,
	                url: formToken.url,
	                style: 'inline',
	                submitEnabled: true,
	            };
	            const prePopulatedFields = {
	                email: formState.emailAddress,
	            };
	            window.Z.setEventHandler("onloadCallback", () => {
	                formActions.updateFormState({
	                    paymentProviderFormLoaded: true,
	                });
	            });
	            window.Z.render(formConfiguration, prePopulatedFields, (event) => {
	                if (event.success !== "true") {
	                    console.error("Payment failed", event);
	                    formActions.updateFormState({
	                        serverErrors: [ServerError.PAYMENT_PROCESSING_ERROR]
	                    });
	                    logDataLayerEvent(form, 'zephr_form_error', {
	                        error: ServerError[ServerError.PAYMENT_PROCESSING_ERROR],
	                    });
	                    return;
	                }
	                const currentFormState = formActions.getFormState();
	                // Get the autoRenew value based on payment option configuration
	                const autoRenewConfig = currentFormState.paymentOption.autoRenewConfig;
	                let autoRenewValue;
	                if (autoRenewConfig === 'auto_renew') {
	                    autoRenewValue = true;
	                }
	                else if (autoRenewConfig === 'no_auto_renew') {
	                    autoRenewValue = false;
	                }
	                else if (autoRenewConfig === 'custom_toggle') {
	                    // Use user's choice from the toggle
	                    const paymentOptionKey = `${currentFormState.paymentOption.productId}-${currentFormState.paymentOption.slug}`;
	                    autoRenewValue = currentFormState.paymentOptionAutoRenew?.[paymentOptionKey] ?? false;
	                }
	                else {
	                    // Default behavior for legacy payment options without configuration
	                    autoRenewValue = true;
	                }
	                formActions.updateFormState({
	                    paymentFormComplete: true,
	                    paymentProviderVendorFields: {
	                        currency: getRelevantCurrency(form, currentFormState),
	                        detail: JSON.stringify({
	                            creditCardCountry: event.creditCardCountry,
	                            creditCardState: event.creditCardState,
	                            refId: event.refId,
	                            email: event.email,
	                        }),
	                        ...(currentFormState.dynamicOfferResult ? { dynamicOfferResult: JSON.stringify(currentFormState.dynamicOfferResult) } : {}),
	                        ...(currentFormState.paymentOption?.terms ? {
	                            terms: JSON.stringify({
	                                ...currentFormState.paymentOption.terms,
	                                autoRenew: autoRenewValue
	                            })
	                        } : {}),
	                        ...(currentFormState.paymentOption?.termsAndConditions ? {
	                            termsAndConditions: JSON.stringify({
	                                ...currentFormState.paymentOption.termsAndConditions,
	                                autoRenew: autoRenewValue
	                            })
	                        } : {}),
	                        ...(currentFormState.paymentOption?.triggerOffsets ? { triggerOffsets: JSON.stringify(currentFormState.paymentOption.triggerOffsets) } : {}),
	                        ...(currentFormState.paymentOption?.changeSubscriptionTriggerOffsets ? { changeSubscriptionTriggerOffsets: JSON.stringify(currentFormState.paymentOption.changeSubscriptionTriggerOffsets) } : {}),
	                    }
	                });
	                formActions.completeSection();
	            });
	        });
	    }
	};
	// TODO: Remove the ability to add MULTISELECT fields in the Console (Filter it out from the listBillingCustomFields endpoint)
	const castCustomFieldValue = (value, type) => {
	    const trimmedValue = value.trim();
	    try {
	        switch (type.toUpperCase()) {
	            case 'INTEGER': {
	                const intVal = parseInt(trimmedValue, 10);
	                if (isNaN(intVal))
	                    throw new Error();
	                return intVal;
	            }
	            case 'NUMBER': {
	                const floatVal = parseFloat(trimmedValue);
	                if (isNaN(floatVal))
	                    throw new Error();
	                return floatVal;
	            }
	            case 'BOOLEAN':
	                return trimmedValue.toLowerCase() === 'true';
	            case 'TEXT':
	            case 'LONGTEXT':
	            case 'PICKLIST':
	            default:
	                return trimmedValue.toString();
	        }
	    }
	    catch (e) {
	        console.warn(`Error casting custom field value "${trimmedValue}" to type ${type}`);
	        return null;
	    }
	};
	const zuoraComplete = async (form, formState, formActions) => {
	    const typeConfiguration = formConfigAs(form);
	    const requires_address = typeConfiguration.requires_address;
	    formActions.incrementRequestCount();
	    try {
	        if (!formConfigAs(form).changeSubscriptionMode && !formState.paymentProviderVendorFields) {
	            console.error("Flow error - no Zuora vendor fields found");
	            formActions.updateFormState({
	                serverErrors: [ServerError.PAYMENT_PROCESSING_ERROR]
	            });
	            logDataLayerEvent(form, 'zephr_form_error', {
	                error: ServerError[ServerError.PAYMENT_PROCESSING_ERROR],
	            });
	            return Promise.resolve();
	        }
	        const rawCustomFields = formConfigAs(form).paymentProviderFormConfig?.subscriptionCustomFields || [];
	        const subscriptionCustomFields = {};
	        if (rawCustomFields?.length) {
	            const subscriptionFormScope = await initializeSubscriptionScope(form, formActions);
	            for (const field of rawCustomFields) {
	                const processedTemplate = processMustacheTemplate(field.value, subscriptionFormScope) || '';
	                subscriptionCustomFields[field.name] = castCustomFieldValue(processedTemplate, field.type);
	            }
	        }
	        const hasCustomFields = !!Object.keys(subscriptionCustomFields).length;
	        const enrichedVendorFields = {
	            ...formState.paymentProviderVendorFields,
	            ...(hasCustomFields ? { subscriptionCustomFields: JSON.stringify(subscriptionCustomFields) } : {})
	        };
	        const { url, body, method } = mapToPayRequest(form, formState, paymentProviders.ZUORA, enrichedVendorFields);
	        if (form.formType === FormType.GIFT_SUBSCRIPTION) {
	            const giftBody = {
	                ...body, // Includes attributes mapped by mapToPayRequest
	                plan_id: `zuora-billing_product_rate_plan-${body.plan_id}-unused`,
	                discount_code: formState.promoCodeValid ? formState.promoCode : undefined,
	                vendor_fields: {
	                    ...(body.vendor_fields || {}),
	                    // Only include giftDetails if isGiftForm is true (defaults to true if no gift toggle elements are present)
	                    ...(formState.isGiftForm ? {
	                        giftDetails: JSON.stringify({
	                            recipient_email: formState.giftRecipient.email,
	                            firstName: formState.giftRecipient.firstName,
	                            lastName: formState.giftRecipient.lastName,
	                            message: formState.giftRecipient.customMessage,
	                            ...(requires_address ? {
	                                recipient_address: {
	                                    addressLine1: formState.giftRecipient.recipientAddress?.addressLine1 || '',
	                                    addressLine2: formState.giftRecipient.recipientAddress?.addressLine2 || '',
	                                    city: formState.giftRecipient.recipientAddress?.city || '',
	                                    state: formState.giftRecipient.recipientAddress?.state || '',
	                                    country: formState.giftRecipient.recipientAddress?.country || '',
	                                    postalCode: formState.giftRecipient.recipientAddress?.postalCode || '',
	                                }
	                            } : {}),
	                            ...(formState.giftRecipient.futureDeliveryEnabled && formState.giftRecipient.futureDeliveryDate ? {
	                                startDate: formState.giftRecipient.futureDeliveryDate
	                            } : {})
	                        })
	                    } : {})
	                }
	            };
	            const giftResponse = await request('zephr/subscribe', {
	                method: 'POST',
	                bodyObject: giftBody
	            }, formActions);
	            if (!giftResponse?.ok) {
	                console.error("Error creating gift subscription", giftResponse);
	                formActions.updateFormState({
	                    serverErrors: [ServerError.PAYMENT_PROCESSING_ERROR]
	                });
	                return Promise.reject();
	            }
	            return Promise.resolve();
	        }
	        else {
	            // Regular flow for non-gift subscriptions
	            const modifiedBody = formConfigAs(form).changeSubscriptionMode ? body : {
	                ...body,
	                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
	                plan_id: `zuora-billing_product_rate_plan-${body.plan_id}-unused`,
	            };
	            return await request(url, {
	                method,
	                bodyObject: modifiedBody
	            }, formActions).then(response => {
	                if (!response?.ok) {
	                    console.error("Error when subscribing", response);
	                    return Promise.reject();
	                }
	            });
	        }
	    }
	    finally {
	        formActions.decrementRequestCount();
	        formActions.updateFormState({
	            paymentProviderFormBusy: false
	        });
	    }
	};
	const zuoraChangePayment = (form, formState, formActions) => {
	    console.log(formState.paymentProviderVendorFields);
	    const paymentMethodId = JSON.parse(formState.paymentProviderVendorFields?.detail).refId;
	    return request('plugins/public/zuora-billing/update-account', {
	        method: 'POST',
	        bodyObject: {
	            paymentMethodId,
	        }
	    }, formActions).then(response => {
	        if (!response?.ok) {
	            console.error("Error when changing default payment method", response);
	            return Promise.reject();
	        }
	    });
	};

	const getDynamicOffer = async (form, formActions) => {
	    const dynamicOfferId = formConfigAs(form).dynamicOffer?.id;
	    const dynamicOfferPreview = formConfigAs(form).dynamicOfferPreview;
	    if (form.environment.previewMode) {
	        formActions.updateFormState({ dynamicOfferResult: dynamicOfferPreview });
	        return;
	    }
	    let session;
	    let jwt;
	    try {
	        session = document.cookie.match(/blaize_session=[0-9a-z-]+/)[0].substring(15);
	    }
	    catch {
	        session = null;
	    }
	    try {
	        jwt = document.cookie.match(/(?<=blaize_jwt=)[^;]+/)[0];
	    }
	    catch {
	        jwt = null;
	    }
	    if (!dynamicOfferId) {
	        throw Error('Missing Dynamic Offer id');
	    }
	    const response = await request('zephr/public/decisions/v2/dynamic-offers', {
	        method: "POST",
	        bodyObject: {
	            "dynamic_offer": { "slug": dynamicOfferId },
	            "session": session,
	            "jwt": jwt
	        },
	    }, formActions);
	    const dynamicOfferResult = await response.json();
	    formActions.updateFormState({ dynamicOfferResult });
	};
	const mockBillingPreviewResponse = (dynamicOfferResult) => {
	    const chargeOne = dynamicOfferResult?.products
	        ? dynamicOfferResult.products[0].paymentPlans[0].charges[0]
	        : { prices: [{ price: 25 }], chargeData: { name: 'Monthly Fee' } };
	    const amount = chargeOne.prices[0]?.price;
	    const chargeName = chargeOne.chargeData?.name;
	    return {
	        "success": true,
	        "contractedMrr": amount,
	        "totalContractedValue": null,
	        "amount": amount + 3,
	        "amountWithoutTax": amount,
	        "taxAmount": 3,
	        "invoiceTargetDate": "2024-05-20",
	        "documentDate": "2024-05-20",
	        "invoiceItems": {
	            "0": {
	                "serviceStartDate": "2024-05-20",
	                "serviceEndDate": "2024-06-19",
	                "chargeAmount": amount,
	                "taxAmount": 3,
	                "chargeDescription": "",
	                "chargeName": chargeName,
	                "productName": "Product",
	                "productRatePlanChargeId": "8ad097b48f533234018f57a8982a5a45",
	                "quantity": 1,
	                "unitOfMeasure": ""
	            }
	        }
	    };
	};
	const filterChangeSubDynamicOfferResponse = (dynamicOfferResult, form, formState) => {
	    if (!formConfigAs(form).changeSubscriptionMode || form.environment.previewMode) {
	        return dynamicOfferResult;
	    }
	    return {
	        ...dynamicOfferResult,
	        products: dynamicOfferResult.products.map(product => ({
	            ...product,
	            paymentPlans: product.paymentPlans.filter(plan => formState
	                .validChangeFromPlans
	                .some(changeFromPlan => changeFromPlan.planSlug === plan.planId && changeFromPlan.productId === product.id))
	        }))
	    };
	};

	function ownKeys(e, r) {
	  var t = Object.keys(e);
	  if (Object.getOwnPropertySymbols) {
	    var o = Object.getOwnPropertySymbols(e);
	    r && (o = o.filter(function (r) {
	      return Object.getOwnPropertyDescriptor(e, r).enumerable;
	    })), t.push.apply(t, o);
	  }
	  return t;
	}
	function _objectSpread2(e) {
	  for (var r = 1; r < arguments.length; r++) {
	    var t = null != arguments[r] ? arguments[r] : {};
	    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
	      _defineProperty(e, r, t[r]);
	    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
	      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
	    });
	  }
	  return e;
	}
	function _defineProperty(obj, key, value) {
	  key = _toPropertyKey(key);
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }
	  return obj;
	}
	function _objectWithoutPropertiesLoose(source, excluded) {
	  if (source == null) return {};
	  var target = {};
	  var sourceKeys = Object.keys(source);
	  var key, i;
	  for (i = 0; i < sourceKeys.length; i++) {
	    key = sourceKeys[i];
	    if (excluded.indexOf(key) >= 0) continue;
	    target[key] = source[key];
	  }
	  return target;
	}
	function _objectWithoutProperties(source, excluded) {
	  if (source == null) return {};
	  var target = _objectWithoutPropertiesLoose(source, excluded);
	  var key, i;
	  if (Object.getOwnPropertySymbols) {
	    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
	    for (i = 0; i < sourceSymbolKeys.length; i++) {
	      key = sourceSymbolKeys[i];
	      if (excluded.indexOf(key) >= 0) continue;
	      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
	      target[key] = source[key];
	    }
	  }
	  return target;
	}
	function _toPrimitive(input, hint) {
	  if (typeof input !== "object" || input === null) return input;
	  var prim = input[Symbol.toPrimitive];
	  if (prim !== undefined) {
	    var res = prim.call(input, hint || "default");
	    if (typeof res !== "object") return res;
	    throw new TypeError("@@toPrimitive must return a primitive value.");
	  }
	  return (hint === "string" ? String : Number)(input);
	}
	function _toPropertyKey(arg) {
	  var key = _toPrimitive(arg, "string");
	  return typeof key === "symbol" ? key : String(key);
	}

	var countries$1 = {
		AD: "Andorra",
		AE: "United Arab Emirates",
		AF: "Afghanistan",
		AG: "Antigua and Barbuda",
		AI: "Anguilla",
		AL: "Albania",
		AM: "Armenia",
		AO: "Angola",
		AQ: "Antarctica",
		AR: "Argentina",
		AS: "American Samoa",
		AT: "Austria",
		AU: "Australia",
		AW: "Aruba",
		AX: "Åland Islands",
		AZ: "Azerbaijan",
		BA: "Bosnia and Herzegovina",
		BB: "Barbados",
		BD: "Bangladesh",
		BE: "Belgium",
		BF: "Burkina Faso",
		BG: "Bulgaria",
		BH: "Bahrain",
		BI: "Burundi",
		BJ: "Benin",
		BL: "Saint Barthélemy",
		BM: "Bermuda",
		BN: "Brunei",
		BO: "Bolivia",
		BQ: "Caribbean Netherlands",
		BR: "Brazil",
		BS: "Bahamas",
		BT: "Bhutan",
		BW: "Botswana",
		BY: "Belarus",
		BZ: "Belize",
		CA: "Canada",
		CC: "Cocos Islands",
		CD: "Democratic Republic of the Congo",
		CF: "Central African Republic",
		CG: "Republic of the Congo",
		CH: "Switzerland",
		CI: "Ivory Coast",
		CK: "Cook Islands",
		CL: "Chile",
		CM: "Cameroon",
		CN: "China",
		CO: "Colombia",
		CR: "Costa Rica",
		CU: "Cuba",
		CV: "Cabo Verde",
		CW: "Curaçao",
		CX: "Christmas Island",
		CY: "Cyprus",
		CZ: "Czechia",
		DE: "Germany",
		DJ: "Djibouti",
		DK: "Denmark",
		DM: "Dominica",
		DO: "Dominican Republic",
		DZ: "Algeria",
		EC: "Ecuador",
		EE: "Estonia",
		EG: "Egypt",
		EH: "Western Sahara",
		ER: "Eritrea",
		ES: "Spain",
		ET: "Ethiopia",
		FI: "Finland",
		FJ: "Fiji",
		FK: "Falkland Islands",
		FM: "Micronesia",
		FO: "Faroe Islands",
		FR: "France",
		GA: "Gabon",
		GB: "United Kingdom",
		GD: "Grenada",
		GE: "Georgia",
		GF: "French Guiana",
		GG: "Guernsey",
		GH: "Ghana",
		GI: "Gibraltar",
		GL: "Greenland",
		GM: "Gambia",
		GN: "Guinea",
		GP: "Guadeloupe",
		GQ: "Equatorial Guinea",
		GR: "Greece",
		GS: "South Georgia and the South Sandwich Islands",
		GT: "Guatemala",
		GU: "Guam",
		GW: "Guinea-Bissau",
		GY: "Guyana",
		HK: "Hong Kong",
		HN: "Honduras",
		HR: "Croatia",
		HT: "Haiti",
		HU: "Hungary",
		ID: "Indonesia",
		IE: "Ireland",
		IL: "Israel",
		IM: "Isle of Man",
		IN: "India",
		IO: "British Indian Ocean Territory",
		IQ: "Iraq",
		IR: "Iran",
		IS: "Iceland",
		IT: "Italy",
		JE: "Jersey",
		JM: "Jamaica",
		JO: "Jordan",
		JP: "Japan",
		KE: "Kenya",
		KG: "Kyrgyzstan",
		KH: "Cambodia",
		KI: "Kiribati",
		KM: "Comoros",
		KN: "Saint Kitts and Nevis",
		KP: "North Korea",
		KR: "South Korea",
		KW: "Kuwait",
		KY: "Cayman Islands",
		KZ: "Kazakhstan",
		LA: "Laos",
		LB: "Lebanon",
		LC: "Saint Lucia",
		LI: "Liechtenstein",
		LK: "Sri Lanka",
		LR: "Liberia",
		LS: "Lesotho",
		LT: "Lithuania",
		LU: "Luxembourg",
		LV: "Latvia",
		LY: "Libya",
		MA: "Morocco",
		MC: "Monaco",
		MD: "Moldova",
		ME: "Montenegro",
		MF: "Saint Martin",
		MG: "Madagascar",
		MH: "Marshall Islands",
		MK: "North Macedonia",
		ML: "Mali",
		MM: "Myanmar",
		MN: "Mongolia",
		MO: "Macao",
		MP: "Northern Mariana Islands",
		MQ: "Martinique",
		MR: "Mauritania",
		MS: "Montserrat",
		MT: "Malta",
		MU: "Mauritius",
		MV: "Maldives",
		MW: "Malawi",
		MX: "Mexico",
		MY: "Malaysia",
		MZ: "Mozambique",
		NA: "Namibia",
		NC: "New Caledonia",
		NE: "Niger",
		NF: "Norfolk Island",
		NG: "Nigeria",
		NI: "Nicaragua",
		NL: "Netherlands",
		NO: "Norway",
		NP: "Nepal",
		NR: "Nauru",
		NU: "Niue",
		NZ: "New Zealand",
		OM: "Oman",
		PA: "Panama",
		PE: "Peru",
		PF: "French Polynesia",
		PG: "Papua New Guinea",
		PH: "Philippines",
		PK: "Pakistan",
		PL: "Poland",
		PM: "Saint Pierre and Miquelon",
		PN: "Pitcairn",
		PR: "Puerto Rico",
		PS: "Palestine",
		PT: "Portugal",
		PW: "Palau",
		PY: "Paraguay",
		QA: "Qatar",
		RE: "Réunion",
		RO: "Romania",
		RS: "Serbia",
		RU: "Russia",
		RW: "Rwanda",
		SA: "Saudi Arabia",
		SB: "Solomon Islands",
		SC: "Seychelles",
		SD: "Sudan",
		SE: "Sweden",
		SG: "Singapore",
		SH: "Saint Helena, Ascension and Tristan da Cunha",
		SI: "Slovenia",
		SJ: "Svalbard and Jan Mayen",
		SK: "Slovakia",
		SL: "Sierra Leone",
		SM: "San Marino",
		SN: "Senegal",
		SO: "Somalia",
		SR: "Suriname",
		SS: "South Sudan",
		ST: "Sao Tome and Principe",
		SV: "El Salvador",
		SX: "Sint Maarten",
		SY: "Syria",
		SZ: "Eswatini",
		TC: "Turks and Caicos Islands",
		TD: "Chad",
		TF: "French Southern Territories",
		TG: "Togo",
		TH: "Thailand",
		TJ: "Tajikistan",
		TK: "Tokelau",
		TL: "Timor-Leste",
		TM: "Turkmenistan",
		TN: "Tunisia",
		TO: "Tonga",
		TR: "Türkiye",
		TT: "Trinidad and Tobago",
		TV: "Tuvalu",
		TW: "Taiwan",
		TZ: "Tanzania",
		UA: "Ukraine",
		UG: "Uganda",
		UM: "United States Minor Outlying Islands",
		US: "United States of America",
		UY: "Uruguay",
		UZ: "Uzbekistan",
		VA: "Holy See",
		VC: "Saint Vincent and the Grenadines",
		VE: "Venezuela",
		VG: "Virgin Islands (UK)",
		VI: "Virgin Islands (US)",
		VN: "Vietnam",
		VU: "Vanuatu",
		WF: "Wallis and Futuna",
		WS: "Samoa",
		YE: "Yemen",
		YT: "Mayotte",
		ZA: "South Africa",
		ZM: "Zambia",
		ZW: "Zimbabwe"
	};
	var timezones$1 = {
		"Africa/Abidjan": {
			u: 0,
			c: [
				"CI",
				"BF",
				"GH",
				"GM",
				"GN",
				"IS",
				"ML",
				"MR",
				"SH",
				"SL",
				"SN",
				"TG"
			]
		},
		"Africa/Accra": {
			a: "Africa/Abidjan",
			c: [
				"GH"
			],
			r: 1
		},
		"Africa/Addis_Ababa": {
			a: "Africa/Nairobi",
			c: [
				"ET"
			],
			r: 1
		},
		"Africa/Algiers": {
			u: 60,
			c: [
				"DZ"
			]
		},
		"Africa/Asmara": {
			a: "Africa/Nairobi",
			c: [
				"ER"
			],
			r: 1
		},
		"Africa/Asmera": {
			a: "Africa/Nairobi",
			c: [
				"ER"
			],
			r: 1
		},
		"Africa/Bamako": {
			a: "Africa/Abidjan",
			c: [
				"ML"
			],
			r: 1
		},
		"Africa/Bangui": {
			a: "Africa/Lagos",
			c: [
				"CF"
			],
			r: 1
		},
		"Africa/Banjul": {
			a: "Africa/Abidjan",
			c: [
				"GM"
			],
			r: 1
		},
		"Africa/Bissau": {
			u: 0,
			c: [
				"GW"
			]
		},
		"Africa/Blantyre": {
			a: "Africa/Maputo",
			c: [
				"MW"
			],
			r: 1
		},
		"Africa/Brazzaville": {
			a: "Africa/Lagos",
			c: [
				"CG"
			],
			r: 1
		},
		"Africa/Bujumbura": {
			a: "Africa/Maputo",
			c: [
				"BI"
			],
			r: 1
		},
		"Africa/Cairo": {
			u: 120,
			d: 180,
			c: [
				"EG"
			]
		},
		"Africa/Casablanca": {
			u: 60,
			d: 0,
			c: [
				"MA"
			]
		},
		"Africa/Ceuta": {
			u: 60,
			d: 120,
			c: [
				"ES"
			]
		},
		"Africa/Conakry": {
			a: "Africa/Abidjan",
			c: [
				"GN"
			],
			r: 1
		},
		"Africa/Dakar": {
			a: "Africa/Abidjan",
			c: [
				"SN"
			],
			r: 1
		},
		"Africa/Dar_es_Salaam": {
			a: "Africa/Nairobi",
			c: [
				"TZ"
			],
			r: 1
		},
		"Africa/Djibouti": {
			a: "Africa/Nairobi",
			c: [
				"DJ"
			],
			r: 1
		},
		"Africa/Douala": {
			a: "Africa/Lagos",
			c: [
				"CM"
			],
			r: 1
		},
		"Africa/El_Aaiun": {
			u: 60,
			d: 0,
			c: [
				"EH"
			]
		},
		"Africa/Freetown": {
			a: "Africa/Abidjan",
			c: [
				"SL"
			],
			r: 1
		},
		"Africa/Gaborone": {
			a: "Africa/Maputo",
			c: [
				"BW"
			],
			r: 1
		},
		"Africa/Harare": {
			a: "Africa/Maputo",
			c: [
				"ZW"
			],
			r: 1
		},
		"Africa/Johannesburg": {
			u: 120,
			c: [
				"ZA",
				"LS",
				"SZ"
			]
		},
		"Africa/Juba": {
			u: 120,
			c: [
				"SS"
			]
		},
		"Africa/Kampala": {
			a: "Africa/Nairobi",
			c: [
				"UG"
			],
			r: 1
		},
		"Africa/Khartoum": {
			u: 120,
			c: [
				"SD"
			]
		},
		"Africa/Kigali": {
			a: "Africa/Maputo",
			c: [
				"RW"
			],
			r: 1
		},
		"Africa/Kinshasa": {
			a: "Africa/Lagos",
			c: [
				"CD"
			],
			r: 1
		},
		"Africa/Lagos": {
			u: 60,
			c: [
				"NG",
				"AO",
				"BJ",
				"CD",
				"CF",
				"CG",
				"CM",
				"GA",
				"GQ",
				"NE"
			]
		},
		"Africa/Libreville": {
			a: "Africa/Lagos",
			c: [
				"GA"
			],
			r: 1
		},
		"Africa/Lome": {
			a: "Africa/Abidjan",
			c: [
				"TG"
			],
			r: 1
		},
		"Africa/Luanda": {
			a: "Africa/Lagos",
			c: [
				"AO"
			],
			r: 1
		},
		"Africa/Lubumbashi": {
			a: "Africa/Maputo",
			c: [
				"CD"
			],
			r: 1
		},
		"Africa/Lusaka": {
			a: "Africa/Maputo",
			c: [
				"ZM"
			],
			r: 1
		},
		"Africa/Malabo": {
			a: "Africa/Lagos",
			c: [
				"GQ"
			],
			r: 1
		},
		"Africa/Maputo": {
			u: 120,
			c: [
				"MZ",
				"BI",
				"BW",
				"CD",
				"MW",
				"RW",
				"ZM",
				"ZW"
			]
		},
		"Africa/Maseru": {
			a: "Africa/Johannesburg",
			c: [
				"LS"
			],
			r: 1
		},
		"Africa/Mbabane": {
			a: "Africa/Johannesburg",
			c: [
				"SZ"
			],
			r: 1
		},
		"Africa/Mogadishu": {
			a: "Africa/Nairobi",
			c: [
				"SO"
			],
			r: 1
		},
		"Africa/Monrovia": {
			u: 0,
			c: [
				"LR"
			]
		},
		"Africa/Nairobi": {
			u: 180,
			c: [
				"KE",
				"DJ",
				"ER",
				"ET",
				"KM",
				"MG",
				"SO",
				"TZ",
				"UG",
				"YT"
			]
		},
		"Africa/Ndjamena": {
			u: 60,
			c: [
				"TD"
			]
		},
		"Africa/Niamey": {
			a: "Africa/Lagos",
			c: [
				"NE"
			],
			r: 1
		},
		"Africa/Nouakchott": {
			a: "Africa/Abidjan",
			c: [
				"MR"
			],
			r: 1
		},
		"Africa/Ouagadougou": {
			a: "Africa/Abidjan",
			c: [
				"BF"
			],
			r: 1
		},
		"Africa/Porto-Novo": {
			a: "Africa/Lagos",
			c: [
				"BJ"
			],
			r: 1
		},
		"Africa/Sao_Tome": {
			u: 0,
			c: [
				"ST"
			]
		},
		"Africa/Timbuktu": {
			a: "Africa/Abidjan",
			c: [
				"ML"
			],
			r: 1
		},
		"Africa/Tripoli": {
			u: 120,
			c: [
				"LY"
			]
		},
		"Africa/Tunis": {
			u: 60,
			c: [
				"TN"
			]
		},
		"Africa/Windhoek": {
			u: 120,
			c: [
				"NA"
			]
		},
		"America/Adak": {
			u: -600,
			d: -540,
			c: [
				"US"
			]
		},
		"America/Anchorage": {
			u: -540,
			d: -480,
			c: [
				"US"
			]
		},
		"America/Anguilla": {
			a: "America/Puerto_Rico",
			c: [
				"AI"
			],
			r: 1
		},
		"America/Antigua": {
			a: "America/Puerto_Rico",
			c: [
				"AG"
			],
			r: 1
		},
		"America/Araguaina": {
			u: -180,
			c: [
				"BR"
			]
		},
		"America/Argentina/Buenos_Aires": {
			u: -180,
			c: [
				"AR"
			]
		},
		"America/Argentina/Catamarca": {
			u: -180,
			c: [
				"AR"
			]
		},
		"America/Argentina/ComodRivadavia": {
			a: "America/Argentina/Catamarca",
			r: 1
		},
		"America/Argentina/Cordoba": {
			u: -180,
			c: [
				"AR"
			]
		},
		"America/Argentina/Jujuy": {
			u: -180,
			c: [
				"AR"
			]
		},
		"America/Argentina/La_Rioja": {
			u: -180,
			c: [
				"AR"
			]
		},
		"America/Argentina/Mendoza": {
			u: -180,
			c: [
				"AR"
			]
		},
		"America/Argentina/Rio_Gallegos": {
			u: -180,
			c: [
				"AR"
			]
		},
		"America/Argentina/Salta": {
			u: -180,
			c: [
				"AR"
			]
		},
		"America/Argentina/San_Juan": {
			u: -180,
			c: [
				"AR"
			]
		},
		"America/Argentina/San_Luis": {
			u: -180,
			c: [
				"AR"
			]
		},
		"America/Argentina/Tucuman": {
			u: -180,
			c: [
				"AR"
			]
		},
		"America/Argentina/Ushuaia": {
			u: -180,
			c: [
				"AR"
			]
		},
		"America/Aruba": {
			a: "America/Puerto_Rico",
			c: [
				"AW"
			],
			r: 1
		},
		"America/Asuncion": {
			u: -240,
			d: -180,
			c: [
				"PY"
			]
		},
		"America/Atikokan": {
			a: "America/Panama",
			c: [
				"CA"
			],
			r: 1
		},
		"America/Atka": {
			a: "America/Adak",
			r: 1
		},
		"America/Bahia": {
			u: -180,
			c: [
				"BR"
			]
		},
		"America/Bahia_Banderas": {
			u: -360,
			c: [
				"MX"
			]
		},
		"America/Barbados": {
			u: -240,
			c: [
				"BB"
			]
		},
		"America/Belem": {
			u: -180,
			c: [
				"BR"
			]
		},
		"America/Belize": {
			u: -360,
			c: [
				"BZ"
			]
		},
		"America/Blanc-Sablon": {
			a: "America/Puerto_Rico",
			c: [
				"CA"
			],
			r: 1
		},
		"America/Boa_Vista": {
			u: -240,
			c: [
				"BR"
			]
		},
		"America/Bogota": {
			u: -300,
			c: [
				"CO"
			]
		},
		"America/Boise": {
			u: -420,
			d: -360,
			c: [
				"US"
			]
		},
		"America/Buenos_Aires": {
			a: "America/Argentina/Buenos_Aires",
			r: 1
		},
		"America/Cambridge_Bay": {
			u: -420,
			d: -360,
			c: [
				"CA"
			]
		},
		"America/Campo_Grande": {
			u: -240,
			c: [
				"BR"
			]
		},
		"America/Cancun": {
			u: -300,
			c: [
				"MX"
			]
		},
		"America/Caracas": {
			u: -240,
			c: [
				"VE"
			]
		},
		"America/Catamarca": {
			a: "America/Argentina/Catamarca",
			r: 1
		},
		"America/Cayenne": {
			u: -180,
			c: [
				"GF"
			]
		},
		"America/Cayman": {
			a: "America/Panama",
			c: [
				"KY"
			],
			r: 1
		},
		"America/Chicago": {
			u: -360,
			d: -300,
			c: [
				"US"
			]
		},
		"America/Chihuahua": {
			u: -360,
			c: [
				"MX"
			]
		},
		"America/Ciudad_Juarez": {
			u: -420,
			d: -360,
			c: [
				"MX"
			]
		},
		"America/Coral_Harbour": {
			a: "America/Panama",
			c: [
				"CA"
			],
			r: 1
		},
		"America/Cordoba": {
			a: "America/Argentina/Cordoba",
			r: 1
		},
		"America/Costa_Rica": {
			u: -360,
			c: [
				"CR"
			]
		},
		"America/Creston": {
			a: "America/Phoenix",
			c: [
				"CA"
			],
			r: 1
		},
		"America/Cuiaba": {
			u: -240,
			c: [
				"BR"
			]
		},
		"America/Curacao": {
			a: "America/Puerto_Rico",
			c: [
				"CW"
			],
			r: 1
		},
		"America/Danmarkshavn": {
			u: 0,
			c: [
				"GL"
			]
		},
		"America/Dawson": {
			u: -420,
			c: [
				"CA"
			]
		},
		"America/Dawson_Creek": {
			u: -420,
			c: [
				"CA"
			]
		},
		"America/Denver": {
			u: -420,
			d: -360,
			c: [
				"US"
			]
		},
		"America/Detroit": {
			u: -300,
			d: -240,
			c: [
				"US"
			]
		},
		"America/Dominica": {
			a: "America/Puerto_Rico",
			c: [
				"DM"
			],
			r: 1
		},
		"America/Edmonton": {
			u: -420,
			d: -360,
			c: [
				"CA"
			]
		},
		"America/Eirunepe": {
			u: -300,
			c: [
				"BR"
			]
		},
		"America/El_Salvador": {
			u: -360,
			c: [
				"SV"
			]
		},
		"America/Ensenada": {
			a: "America/Tijuana",
			r: 1
		},
		"America/Fort_Nelson": {
			u: -420,
			c: [
				"CA"
			]
		},
		"America/Fort_Wayne": {
			a: "America/Indiana/Indianapolis",
			r: 1
		},
		"America/Fortaleza": {
			u: -180,
			c: [
				"BR"
			]
		},
		"America/Glace_Bay": {
			u: -240,
			d: -180,
			c: [
				"CA"
			]
		},
		"America/Godthab": {
			a: "America/Nuuk",
			r: 1
		},
		"America/Goose_Bay": {
			u: -240,
			d: -180,
			c: [
				"CA"
			]
		},
		"America/Grand_Turk": {
			u: -300,
			d: -240,
			c: [
				"TC"
			]
		},
		"America/Grenada": {
			a: "America/Puerto_Rico",
			c: [
				"GD"
			],
			r: 1
		},
		"America/Guadeloupe": {
			a: "America/Puerto_Rico",
			c: [
				"GP"
			],
			r: 1
		},
		"America/Guatemala": {
			u: -360,
			c: [
				"GT"
			]
		},
		"America/Guayaquil": {
			u: -300,
			c: [
				"EC"
			]
		},
		"America/Guyana": {
			u: -240,
			c: [
				"GY"
			]
		},
		"America/Halifax": {
			u: -240,
			d: -180,
			c: [
				"CA"
			]
		},
		"America/Havana": {
			u: -300,
			d: -240,
			c: [
				"CU"
			]
		},
		"America/Hermosillo": {
			u: -420,
			c: [
				"MX"
			]
		},
		"America/Indiana/Indianapolis": {
			u: -300,
			d: -240,
			c: [
				"US"
			]
		},
		"America/Indiana/Knox": {
			u: -360,
			d: -300,
			c: [
				"US"
			]
		},
		"America/Indiana/Marengo": {
			u: -300,
			d: -240,
			c: [
				"US"
			]
		},
		"America/Indiana/Petersburg": {
			u: -300,
			d: -240,
			c: [
				"US"
			]
		},
		"America/Indiana/Tell_City": {
			u: -360,
			d: -300,
			c: [
				"US"
			]
		},
		"America/Indiana/Vevay": {
			u: -300,
			d: -240,
			c: [
				"US"
			]
		},
		"America/Indiana/Vincennes": {
			u: -300,
			d: -240,
			c: [
				"US"
			]
		},
		"America/Indiana/Winamac": {
			u: -300,
			d: -240,
			c: [
				"US"
			]
		},
		"America/Indianapolis": {
			a: "America/Indiana/Indianapolis",
			r: 1
		},
		"America/Inuvik": {
			u: -420,
			d: -360,
			c: [
				"CA"
			]
		},
		"America/Iqaluit": {
			u: -300,
			d: -240,
			c: [
				"CA"
			]
		},
		"America/Jamaica": {
			u: -300,
			c: [
				"JM"
			]
		},
		"America/Jujuy": {
			a: "America/Argentina/Jujuy",
			r: 1
		},
		"America/Juneau": {
			u: -540,
			d: -480,
			c: [
				"US"
			]
		},
		"America/Kentucky/Louisville": {
			u: -300,
			d: -240,
			c: [
				"US"
			]
		},
		"America/Kentucky/Monticello": {
			u: -300,
			d: -240,
			c: [
				"US"
			]
		},
		"America/Knox_IN": {
			a: "America/Indiana/Knox",
			r: 1
		},
		"America/Kralendijk": {
			a: "America/Puerto_Rico",
			c: [
				"BQ"
			],
			r: 1
		},
		"America/La_Paz": {
			u: -240,
			c: [
				"BO"
			]
		},
		"America/Lima": {
			u: -300,
			c: [
				"PE"
			]
		},
		"America/Los_Angeles": {
			u: -480,
			d: -420,
			c: [
				"US"
			]
		},
		"America/Louisville": {
			a: "America/Kentucky/Louisville",
			r: 1
		},
		"America/Lower_Princes": {
			a: "America/Puerto_Rico",
			c: [
				"SX"
			],
			r: 1
		},
		"America/Maceio": {
			u: -180,
			c: [
				"BR"
			]
		},
		"America/Managua": {
			u: -360,
			c: [
				"NI"
			]
		},
		"America/Manaus": {
			u: -240,
			c: [
				"BR"
			]
		},
		"America/Marigot": {
			a: "America/Puerto_Rico",
			c: [
				"MF"
			],
			r: 1
		},
		"America/Martinique": {
			u: -240,
			c: [
				"MQ"
			]
		},
		"America/Matamoros": {
			u: -360,
			d: -300,
			c: [
				"MX"
			]
		},
		"America/Mazatlan": {
			u: -420,
			c: [
				"MX"
			]
		},
		"America/Mendoza": {
			a: "America/Argentina/Mendoza",
			r: 1
		},
		"America/Menominee": {
			u: -360,
			d: -300,
			c: [
				"US"
			]
		},
		"America/Merida": {
			u: -360,
			c: [
				"MX"
			]
		},
		"America/Metlakatla": {
			u: -540,
			d: -480,
			c: [
				"US"
			]
		},
		"America/Mexico_City": {
			u: -360,
			c: [
				"MX"
			]
		},
		"America/Miquelon": {
			u: -180,
			d: -120,
			c: [
				"PM"
			]
		},
		"America/Moncton": {
			u: -240,
			d: -180,
			c: [
				"CA"
			]
		},
		"America/Monterrey": {
			u: -360,
			c: [
				"MX"
			]
		},
		"America/Montevideo": {
			u: -180,
			c: [
				"UY"
			]
		},
		"America/Montreal": {
			a: "America/Toronto",
			c: [
				"CA"
			],
			r: 1
		},
		"America/Montserrat": {
			a: "America/Puerto_Rico",
			c: [
				"MS"
			],
			r: 1
		},
		"America/Nassau": {
			a: "America/Toronto",
			c: [
				"BS"
			],
			r: 1
		},
		"America/New_York": {
			u: -300,
			d: -240,
			c: [
				"US"
			]
		},
		"America/Nipigon": {
			a: "America/Toronto",
			c: [
				"CA"
			],
			r: 1
		},
		"America/Nome": {
			u: -540,
			d: -480,
			c: [
				"US"
			]
		},
		"America/Noronha": {
			u: -120,
			c: [
				"BR"
			]
		},
		"America/North_Dakota/Beulah": {
			u: -360,
			d: -300,
			c: [
				"US"
			]
		},
		"America/North_Dakota/Center": {
			u: -360,
			d: -300,
			c: [
				"US"
			]
		},
		"America/North_Dakota/New_Salem": {
			u: -360,
			d: -300,
			c: [
				"US"
			]
		},
		"America/Nuuk": {
			u: -120,
			d: -60,
			c: [
				"GL"
			]
		},
		"America/Ojinaga": {
			u: -360,
			d: -300,
			c: [
				"MX"
			]
		},
		"America/Panama": {
			u: -300,
			c: [
				"PA",
				"CA",
				"KY"
			]
		},
		"America/Pangnirtung": {
			a: "America/Iqaluit",
			r: 1
		},
		"America/Paramaribo": {
			u: -180,
			c: [
				"SR"
			]
		},
		"America/Phoenix": {
			u: -420,
			c: [
				"US",
				"CA"
			]
		},
		"America/Port-au-Prince": {
			u: -300,
			d: -240,
			c: [
				"HT"
			]
		},
		"America/Port_of_Spain": {
			a: "America/Puerto_Rico",
			c: [
				"TT"
			],
			r: 1
		},
		"America/Porto_Acre": {
			a: "America/Rio_Branco",
			r: 1
		},
		"America/Porto_Velho": {
			u: -240,
			c: [
				"BR"
			]
		},
		"America/Puerto_Rico": {
			u: -240,
			c: [
				"PR",
				"AG",
				"CA",
				"AI",
				"AW",
				"BL",
				"BQ",
				"CW",
				"DM",
				"GD",
				"GP",
				"KN",
				"LC",
				"MF",
				"MS",
				"SX",
				"TT",
				"VC",
				"VG",
				"VI"
			]
		},
		"America/Punta_Arenas": {
			u: -180,
			c: [
				"CL"
			]
		},
		"America/Rainy_River": {
			a: "America/Winnipeg",
			r: 1
		},
		"America/Rankin_Inlet": {
			u: -360,
			d: -300,
			c: [
				"CA"
			]
		},
		"America/Recife": {
			u: -180,
			c: [
				"BR"
			]
		},
		"America/Regina": {
			u: -360,
			c: [
				"CA"
			]
		},
		"America/Resolute": {
			u: -360,
			d: -300,
			c: [
				"CA"
			]
		},
		"America/Rio_Branco": {
			u: -300,
			c: [
				"BR"
			]
		},
		"America/Rosario": {
			a: "America/Argentina/Cordoba",
			r: 1
		},
		"America/Santa_Isabel": {
			a: "America/Tijuana",
			r: 1
		},
		"America/Santarem": {
			u: -180,
			c: [
				"BR"
			]
		},
		"America/Santiago": {
			u: -240,
			d: -180,
			c: [
				"CL"
			]
		},
		"America/Santo_Domingo": {
			u: -240,
			c: [
				"DO"
			]
		},
		"America/Sao_Paulo": {
			u: -180,
			c: [
				"BR"
			]
		},
		"America/Scoresbysund": {
			u: -60,
			d: 0,
			c: [
				"GL"
			]
		},
		"America/Shiprock": {
			a: "America/Denver",
			r: 1
		},
		"America/Sitka": {
			u: -540,
			d: -480,
			c: [
				"US"
			]
		},
		"America/St_Barthelemy": {
			a: "America/Puerto_Rico",
			c: [
				"BL"
			],
			r: 1
		},
		"America/St_Johns": {
			u: -210,
			d: -150,
			c: [
				"CA"
			]
		},
		"America/St_Kitts": {
			a: "America/Puerto_Rico",
			c: [
				"KN"
			],
			r: 1
		},
		"America/St_Lucia": {
			a: "America/Puerto_Rico",
			c: [
				"LC"
			],
			r: 1
		},
		"America/St_Thomas": {
			a: "America/Puerto_Rico",
			c: [
				"VI"
			],
			r: 1
		},
		"America/St_Vincent": {
			a: "America/Puerto_Rico",
			c: [
				"VC"
			],
			r: 1
		},
		"America/Swift_Current": {
			u: -360,
			c: [
				"CA"
			]
		},
		"America/Tegucigalpa": {
			u: -360,
			c: [
				"HN"
			]
		},
		"America/Thule": {
			u: -240,
			d: -180,
			c: [
				"GL"
			]
		},
		"America/Thunder_Bay": {
			a: "America/Toronto",
			c: [
				"CA"
			],
			r: 1
		},
		"America/Tijuana": {
			u: -480,
			d: -420,
			c: [
				"MX"
			]
		},
		"America/Toronto": {
			u: -300,
			d: -240,
			c: [
				"CA",
				"BS"
			]
		},
		"America/Tortola": {
			a: "America/Puerto_Rico",
			c: [
				"VG"
			],
			r: 1
		},
		"America/Vancouver": {
			u: -480,
			d: -420,
			c: [
				"CA"
			]
		},
		"America/Virgin": {
			a: "America/Puerto_Rico",
			c: [
				"VI"
			],
			r: 1
		},
		"America/Whitehorse": {
			u: -420,
			c: [
				"CA"
			]
		},
		"America/Winnipeg": {
			u: -360,
			d: -300,
			c: [
				"CA"
			]
		},
		"America/Yakutat": {
			u: -540,
			d: -480,
			c: [
				"US"
			]
		},
		"America/Yellowknife": {
			a: "America/Edmonton",
			r: 1
		},
		"Antarctica/Casey": {
			u: 660,
			c: [
				"AQ"
			]
		},
		"Antarctica/Davis": {
			u: 420,
			c: [
				"AQ"
			]
		},
		"Antarctica/DumontDUrville": {
			a: "Pacific/Port_Moresby",
			c: [
				"AQ"
			],
			r: 1
		},
		"Antarctica/Macquarie": {
			u: 600,
			d: 660,
			c: [
				"AU"
			]
		},
		"Antarctica/Mawson": {
			u: 300,
			c: [
				"AQ"
			]
		},
		"Antarctica/McMurdo": {
			a: "Pacific/Auckland",
			c: [
				"AQ"
			],
			r: 1
		},
		"Antarctica/Palmer": {
			u: -180,
			c: [
				"AQ"
			]
		},
		"Antarctica/Rothera": {
			u: -180,
			c: [
				"AQ"
			]
		},
		"Antarctica/South_Pole": {
			a: "Pacific/Auckland",
			c: [
				"AQ"
			],
			r: 1
		},
		"Antarctica/Syowa": {
			a: "Asia/Riyadh",
			c: [
				"AQ"
			],
			r: 1
		},
		"Antarctica/Troll": {
			u: 0,
			d: 120,
			c: [
				"AQ"
			]
		},
		"Antarctica/Vostok": {
			a: "Asia/Urumqi",
			c: [
				"AQ"
			],
			r: 1
		},
		"Arctic/Longyearbyen": {
			a: "Europe/Berlin",
			c: [
				"SJ"
			],
			r: 1
		},
		"Asia/Aden": {
			a: "Asia/Riyadh",
			c: [
				"YE"
			],
			r: 1
		},
		"Asia/Almaty": {
			u: 360,
			c: [
				"KZ"
			]
		},
		"Asia/Amman": {
			u: 180,
			c: [
				"JO"
			]
		},
		"Asia/Anadyr": {
			u: 720,
			c: [
				"RU"
			]
		},
		"Asia/Aqtau": {
			u: 300,
			c: [
				"KZ"
			]
		},
		"Asia/Aqtobe": {
			u: 300,
			c: [
				"KZ"
			]
		},
		"Asia/Ashgabat": {
			u: 300,
			c: [
				"TM"
			]
		},
		"Asia/Ashkhabad": {
			a: "Asia/Ashgabat",
			r: 1
		},
		"Asia/Atyrau": {
			u: 300,
			c: [
				"KZ"
			]
		},
		"Asia/Baghdad": {
			u: 180,
			c: [
				"IQ"
			]
		},
		"Asia/Bahrain": {
			a: "Asia/Qatar",
			c: [
				"BH"
			],
			r: 1
		},
		"Asia/Baku": {
			u: 240,
			c: [
				"AZ"
			]
		},
		"Asia/Bangkok": {
			u: 420,
			c: [
				"TH",
				"CX",
				"KH",
				"LA",
				"VN"
			]
		},
		"Asia/Barnaul": {
			u: 420,
			c: [
				"RU"
			]
		},
		"Asia/Beirut": {
			u: 120,
			d: 180,
			c: [
				"LB"
			]
		},
		"Asia/Bishkek": {
			u: 360,
			c: [
				"KG"
			]
		},
		"Asia/Brunei": {
			a: "Asia/Kuching",
			c: [
				"BN"
			],
			r: 1
		},
		"Asia/Calcutta": {
			a: "Asia/Kolkata",
			r: 1
		},
		"Asia/Chita": {
			u: 540,
			c: [
				"RU"
			]
		},
		"Asia/Choibalsan": {
			u: 480,
			c: [
				"MN"
			]
		},
		"Asia/Chongqing": {
			a: "Asia/Shanghai",
			r: 1
		},
		"Asia/Chungking": {
			a: "Asia/Shanghai",
			r: 1
		},
		"Asia/Colombo": {
			u: 330,
			c: [
				"LK"
			]
		},
		"Asia/Dacca": {
			a: "Asia/Dhaka",
			r: 1
		},
		"Asia/Damascus": {
			u: 180,
			c: [
				"SY"
			]
		},
		"Asia/Dhaka": {
			u: 360,
			c: [
				"BD"
			]
		},
		"Asia/Dili": {
			u: 540,
			c: [
				"TL"
			]
		},
		"Asia/Dubai": {
			u: 240,
			c: [
				"AE",
				"OM",
				"RE",
				"SC",
				"TF"
			]
		},
		"Asia/Dushanbe": {
			u: 300,
			c: [
				"TJ"
			]
		},
		"Asia/Famagusta": {
			u: 120,
			d: 180,
			c: [
				"CY"
			]
		},
		"Asia/Gaza": {
			u: 120,
			d: 180,
			c: [
				"PS"
			]
		},
		"Asia/Harbin": {
			a: "Asia/Shanghai",
			r: 1
		},
		"Asia/Hebron": {
			u: 120,
			d: 180,
			c: [
				"PS"
			]
		},
		"Asia/Ho_Chi_Minh": {
			u: 420,
			c: [
				"VN"
			]
		},
		"Asia/Hong_Kong": {
			u: 480,
			c: [
				"HK"
			]
		},
		"Asia/Hovd": {
			u: 420,
			c: [
				"MN"
			]
		},
		"Asia/Irkutsk": {
			u: 480,
			c: [
				"RU"
			]
		},
		"Asia/Istanbul": {
			a: "Europe/Istanbul",
			r: 1
		},
		"Asia/Jakarta": {
			u: 420,
			c: [
				"ID"
			]
		},
		"Asia/Jayapura": {
			u: 540,
			c: [
				"ID"
			]
		},
		"Asia/Jerusalem": {
			u: 120,
			d: 180,
			c: [
				"IL"
			]
		},
		"Asia/Kabul": {
			u: 270,
			c: [
				"AF"
			]
		},
		"Asia/Kamchatka": {
			u: 720,
			c: [
				"RU"
			]
		},
		"Asia/Karachi": {
			u: 300,
			c: [
				"PK"
			]
		},
		"Asia/Kashgar": {
			a: "Asia/Urumqi",
			c: [
				"CN"
			],
			r: 1
		},
		"Asia/Kathmandu": {
			u: 345,
			c: [
				"NP"
			]
		},
		"Asia/Katmandu": {
			a: "Asia/Kathmandu",
			r: 1
		},
		"Asia/Khandyga": {
			u: 540,
			c: [
				"RU"
			]
		},
		"Asia/Kolkata": {
			u: 330,
			c: [
				"IN"
			]
		},
		"Asia/Krasnoyarsk": {
			u: 420,
			c: [
				"RU"
			]
		},
		"Asia/Kuala_Lumpur": {
			a: "Asia/Singapore",
			c: [
				"MY"
			],
			r: 1
		},
		"Asia/Kuching": {
			u: 480,
			c: [
				"MY",
				"BN"
			]
		},
		"Asia/Kuwait": {
			a: "Asia/Riyadh",
			c: [
				"KW"
			],
			r: 1
		},
		"Asia/Macao": {
			a: "Asia/Macau",
			r: 1
		},
		"Asia/Macau": {
			u: 480,
			c: [
				"MO"
			]
		},
		"Asia/Magadan": {
			u: 660,
			c: [
				"RU"
			]
		},
		"Asia/Makassar": {
			u: 480,
			c: [
				"ID"
			]
		},
		"Asia/Manila": {
			u: 480,
			c: [
				"PH"
			]
		},
		"Asia/Muscat": {
			a: "Asia/Dubai",
			c: [
				"OM"
			],
			r: 1
		},
		"Asia/Nicosia": {
			u: 120,
			d: 180,
			c: [
				"CY"
			]
		},
		"Asia/Novokuznetsk": {
			u: 420,
			c: [
				"RU"
			]
		},
		"Asia/Novosibirsk": {
			u: 420,
			c: [
				"RU"
			]
		},
		"Asia/Omsk": {
			u: 360,
			c: [
				"RU"
			]
		},
		"Asia/Oral": {
			u: 300,
			c: [
				"KZ"
			]
		},
		"Asia/Phnom_Penh": {
			a: "Asia/Bangkok",
			c: [
				"KH"
			],
			r: 1
		},
		"Asia/Pontianak": {
			u: 420,
			c: [
				"ID"
			]
		},
		"Asia/Pyongyang": {
			u: 540,
			c: [
				"KP"
			]
		},
		"Asia/Qatar": {
			u: 180,
			c: [
				"QA",
				"BH"
			]
		},
		"Asia/Qostanay": {
			u: 360,
			c: [
				"KZ"
			]
		},
		"Asia/Qyzylorda": {
			u: 300,
			c: [
				"KZ"
			]
		},
		"Asia/Rangoon": {
			a: "Asia/Yangon",
			c: [
				"MM"
			],
			r: 1
		},
		"Asia/Riyadh": {
			u: 180,
			c: [
				"SA",
				"AQ",
				"KW",
				"YE"
			]
		},
		"Asia/Saigon": {
			a: "Asia/Ho_Chi_Minh",
			r: 1
		},
		"Asia/Sakhalin": {
			u: 660,
			c: [
				"RU"
			]
		},
		"Asia/Samarkand": {
			u: 300,
			c: [
				"UZ"
			]
		},
		"Asia/Seoul": {
			u: 540,
			c: [
				"KR"
			]
		},
		"Asia/Shanghai": {
			u: 480,
			c: [
				"CN"
			]
		},
		"Asia/Singapore": {
			u: 480,
			c: [
				"SG",
				"MY"
			]
		},
		"Asia/Srednekolymsk": {
			u: 660,
			c: [
				"RU"
			]
		},
		"Asia/Taipei": {
			u: 480,
			c: [
				"TW"
			]
		},
		"Asia/Tashkent": {
			u: 300,
			c: [
				"UZ"
			]
		},
		"Asia/Tbilisi": {
			u: 240,
			c: [
				"GE"
			]
		},
		"Asia/Tehran": {
			u: 210,
			c: [
				"IR"
			]
		},
		"Asia/Tel_Aviv": {
			a: "Asia/Jerusalem",
			r: 1
		},
		"Asia/Thimbu": {
			a: "Asia/Thimphu",
			r: 1
		},
		"Asia/Thimphu": {
			u: 360,
			c: [
				"BT"
			]
		},
		"Asia/Tokyo": {
			u: 540,
			c: [
				"JP"
			]
		},
		"Asia/Tomsk": {
			u: 420,
			c: [
				"RU"
			]
		},
		"Asia/Ujung_Pandang": {
			a: "Asia/Makassar",
			r: 1
		},
		"Asia/Ulaanbaatar": {
			u: 480,
			c: [
				"MN"
			]
		},
		"Asia/Ulan_Bator": {
			a: "Asia/Ulaanbaatar",
			r: 1
		},
		"Asia/Urumqi": {
			u: 360,
			c: [
				"CN",
				"AQ"
			]
		},
		"Asia/Ust-Nera": {
			u: 600,
			c: [
				"RU"
			]
		},
		"Asia/Vientiane": {
			a: "Asia/Bangkok",
			c: [
				"LA"
			],
			r: 1
		},
		"Asia/Vladivostok": {
			u: 600,
			c: [
				"RU"
			]
		},
		"Asia/Yakutsk": {
			u: 540,
			c: [
				"RU"
			]
		},
		"Asia/Yangon": {
			u: 390,
			c: [
				"MM",
				"CC"
			]
		},
		"Asia/Yekaterinburg": {
			u: 300,
			c: [
				"RU"
			]
		},
		"Asia/Yerevan": {
			u: 240,
			c: [
				"AM"
			]
		},
		"Atlantic/Azores": {
			u: -60,
			d: 0,
			c: [
				"PT"
			]
		},
		"Atlantic/Bermuda": {
			u: -240,
			d: -180,
			c: [
				"BM"
			]
		},
		"Atlantic/Canary": {
			u: 0,
			d: 60,
			c: [
				"ES"
			]
		},
		"Atlantic/Cape_Verde": {
			u: -60,
			c: [
				"CV"
			]
		},
		"Atlantic/Faeroe": {
			a: "Atlantic/Faroe",
			r: 1
		},
		"Atlantic/Faroe": {
			u: 0,
			d: 60,
			c: [
				"FO"
			]
		},
		"Atlantic/Jan_Mayen": {
			a: "Europe/Berlin",
			c: [
				"SJ"
			],
			r: 1
		},
		"Atlantic/Madeira": {
			u: 0,
			d: 60,
			c: [
				"PT"
			]
		},
		"Atlantic/Reykjavik": {
			a: "Africa/Abidjan",
			c: [
				"IS"
			],
			r: 1
		},
		"Atlantic/South_Georgia": {
			u: -120,
			c: [
				"GS"
			]
		},
		"Atlantic/St_Helena": {
			a: "Africa/Abidjan",
			c: [
				"SH"
			],
			r: 1
		},
		"Atlantic/Stanley": {
			u: -180,
			c: [
				"FK"
			]
		},
		"Australia/ACT": {
			a: "Australia/Sydney",
			r: 1
		},
		"Australia/Adelaide": {
			u: 570,
			d: 630,
			c: [
				"AU"
			]
		},
		"Australia/Brisbane": {
			u: 600,
			c: [
				"AU"
			]
		},
		"Australia/Broken_Hill": {
			u: 570,
			d: 630,
			c: [
				"AU"
			]
		},
		"Australia/Canberra": {
			a: "Australia/Sydney",
			r: 1
		},
		"Australia/Currie": {
			a: "Australia/Hobart",
			r: 1
		},
		"Australia/Darwin": {
			u: 570,
			c: [
				"AU"
			]
		},
		"Australia/Eucla": {
			u: 525,
			c: [
				"AU"
			]
		},
		"Australia/Hobart": {
			u: 600,
			d: 660,
			c: [
				"AU"
			]
		},
		"Australia/LHI": {
			a: "Australia/Lord_Howe",
			r: 1
		},
		"Australia/Lindeman": {
			u: 600,
			c: [
				"AU"
			]
		},
		"Australia/Lord_Howe": {
			u: 630,
			d: 660,
			c: [
				"AU"
			]
		},
		"Australia/Melbourne": {
			u: 600,
			d: 660,
			c: [
				"AU"
			]
		},
		"Australia/NSW": {
			a: "Australia/Sydney",
			r: 1
		},
		"Australia/North": {
			a: "Australia/Darwin",
			r: 1
		},
		"Australia/Perth": {
			u: 480,
			c: [
				"AU"
			]
		},
		"Australia/Queensland": {
			a: "Australia/Brisbane",
			r: 1
		},
		"Australia/South": {
			a: "Australia/Adelaide",
			r: 1
		},
		"Australia/Sydney": {
			u: 600,
			d: 660,
			c: [
				"AU"
			]
		},
		"Australia/Tasmania": {
			a: "Australia/Hobart",
			r: 1
		},
		"Australia/Victoria": {
			a: "Australia/Melbourne",
			r: 1
		},
		"Australia/West": {
			a: "Australia/Perth",
			r: 1
		},
		"Australia/Yancowinna": {
			a: "Australia/Broken_Hill",
			r: 1
		},
		"Brazil/Acre": {
			a: "America/Rio_Branco",
			r: 1
		},
		"Brazil/DeNoronha": {
			a: "America/Noronha",
			r: 1
		},
		"Brazil/East": {
			a: "America/Sao_Paulo",
			r: 1
		},
		"Brazil/West": {
			a: "America/Manaus",
			r: 1
		},
		CET: {
			u: 60,
			d: 120
		},
		CST6CDT: {
			u: -360,
			d: -300
		},
		"Canada/Atlantic": {
			a: "America/Halifax",
			r: 1
		},
		"Canada/Central": {
			a: "America/Winnipeg",
			r: 1
		},
		"Canada/Eastern": {
			a: "America/Toronto",
			c: [
				"CA"
			],
			r: 1
		},
		"Canada/Mountain": {
			a: "America/Edmonton",
			r: 1
		},
		"Canada/Newfoundland": {
			a: "America/St_Johns",
			r: 1
		},
		"Canada/Pacific": {
			a: "America/Vancouver",
			r: 1
		},
		"Canada/Saskatchewan": {
			a: "America/Regina",
			r: 1
		},
		"Canada/Yukon": {
			a: "America/Whitehorse",
			r: 1
		},
		"Chile/Continental": {
			a: "America/Santiago",
			r: 1
		},
		"Chile/EasterIsland": {
			a: "Pacific/Easter",
			r: 1
		},
		Cuba: {
			a: "America/Havana",
			r: 1
		},
		EET: {
			u: 120,
			d: 180
		},
		EST: {
			u: -300
		},
		EST5EDT: {
			u: -300,
			d: -240
		},
		Egypt: {
			a: "Africa/Cairo",
			r: 1
		},
		Eire: {
			a: "Europe/Dublin",
			r: 1
		},
		"Etc/GMT": {
			u: 0
		},
		"Etc/GMT+0": {
			a: "Etc/GMT",
			r: 1
		},
		"Etc/GMT+1": {
			u: -60
		},
		"Etc/GMT+10": {
			u: -600
		},
		"Etc/GMT+11": {
			u: -660
		},
		"Etc/GMT+12": {
			u: -720
		},
		"Etc/GMT+2": {
			u: -120
		},
		"Etc/GMT+3": {
			u: -180
		},
		"Etc/GMT+4": {
			u: -240
		},
		"Etc/GMT+5": {
			u: -300
		},
		"Etc/GMT+6": {
			u: -360
		},
		"Etc/GMT+7": {
			u: -420
		},
		"Etc/GMT+8": {
			u: -480
		},
		"Etc/GMT+9": {
			u: -540
		},
		"Etc/GMT-0": {
			a: "Etc/GMT",
			r: 1
		},
		"Etc/GMT-1": {
			u: 60
		},
		"Etc/GMT-10": {
			u: 600
		},
		"Etc/GMT-11": {
			u: 660
		},
		"Etc/GMT-12": {
			u: 720
		},
		"Etc/GMT-13": {
			u: 780
		},
		"Etc/GMT-14": {
			u: 840
		},
		"Etc/GMT-2": {
			u: 120
		},
		"Etc/GMT-3": {
			u: 180
		},
		"Etc/GMT-4": {
			u: 240
		},
		"Etc/GMT-5": {
			u: 300
		},
		"Etc/GMT-6": {
			u: 360
		},
		"Etc/GMT-7": {
			u: 420
		},
		"Etc/GMT-8": {
			u: 480
		},
		"Etc/GMT-9": {
			u: 540
		},
		"Etc/GMT0": {
			a: "Etc/GMT",
			r: 1
		},
		"Etc/Greenwich": {
			a: "Etc/GMT",
			r: 1
		},
		"Etc/UCT": {
			a: "Etc/UTC",
			r: 1
		},
		"Etc/UTC": {
			u: 0
		},
		"Etc/Universal": {
			a: "Etc/UTC",
			r: 1
		},
		"Etc/Zulu": {
			a: "Etc/UTC",
			r: 1
		},
		"Europe/Amsterdam": {
			a: "Europe/Brussels",
			c: [
				"NL"
			],
			r: 1
		},
		"Europe/Andorra": {
			u: 60,
			d: 120,
			c: [
				"AD"
			]
		},
		"Europe/Astrakhan": {
			u: 240,
			c: [
				"RU"
			]
		},
		"Europe/Athens": {
			u: 120,
			d: 180,
			c: [
				"GR"
			]
		},
		"Europe/Belfast": {
			a: "Europe/London",
			c: [
				"GB"
			],
			r: 1
		},
		"Europe/Belgrade": {
			u: 60,
			d: 120,
			c: [
				"RS",
				"BA",
				"HR",
				"ME",
				"MK",
				"SI"
			]
		},
		"Europe/Berlin": {
			u: 60,
			d: 120,
			c: [
				"DE",
				"DK",
				"NO",
				"SE",
				"SJ"
			]
		},
		"Europe/Bratislava": {
			a: "Europe/Prague",
			c: [
				"SK"
			],
			r: 1
		},
		"Europe/Brussels": {
			u: 60,
			d: 120,
			c: [
				"BE",
				"LU",
				"NL"
			]
		},
		"Europe/Bucharest": {
			u: 120,
			d: 180,
			c: [
				"RO"
			]
		},
		"Europe/Budapest": {
			u: 60,
			d: 120,
			c: [
				"HU"
			]
		},
		"Europe/Busingen": {
			a: "Europe/Zurich",
			c: [
				"DE"
			],
			r: 1
		},
		"Europe/Chisinau": {
			u: 120,
			d: 180,
			c: [
				"MD"
			]
		},
		"Europe/Copenhagen": {
			a: "Europe/Berlin",
			c: [
				"DK"
			],
			r: 1
		},
		"Europe/Dublin": {
			u: 60,
			d: 0,
			c: [
				"IE"
			]
		},
		"Europe/Gibraltar": {
			u: 60,
			d: 120,
			c: [
				"GI"
			]
		},
		"Europe/Guernsey": {
			a: "Europe/London",
			c: [
				"GG"
			],
			r: 1
		},
		"Europe/Helsinki": {
			u: 120,
			d: 180,
			c: [
				"FI",
				"AX"
			]
		},
		"Europe/Isle_of_Man": {
			a: "Europe/London",
			c: [
				"IM"
			],
			r: 1
		},
		"Europe/Istanbul": {
			u: 180,
			c: [
				"TR"
			]
		},
		"Europe/Jersey": {
			a: "Europe/London",
			c: [
				"JE"
			],
			r: 1
		},
		"Europe/Kaliningrad": {
			u: 120,
			c: [
				"RU"
			]
		},
		"Europe/Kiev": {
			a: "Europe/Kyiv",
			r: 1
		},
		"Europe/Kirov": {
			u: 180,
			c: [
				"RU"
			]
		},
		"Europe/Kyiv": {
			u: 120,
			d: 180,
			c: [
				"UA"
			]
		},
		"Europe/Lisbon": {
			u: 0,
			d: 60,
			c: [
				"PT"
			]
		},
		"Europe/Ljubljana": {
			a: "Europe/Belgrade",
			c: [
				"SI"
			],
			r: 1
		},
		"Europe/London": {
			u: 0,
			d: 60,
			c: [
				"GB",
				"GG",
				"IM",
				"JE"
			]
		},
		"Europe/Luxembourg": {
			a: "Europe/Brussels",
			c: [
				"LU"
			],
			r: 1
		},
		"Europe/Madrid": {
			u: 60,
			d: 120,
			c: [
				"ES"
			]
		},
		"Europe/Malta": {
			u: 60,
			d: 120,
			c: [
				"MT"
			]
		},
		"Europe/Mariehamn": {
			a: "Europe/Helsinki",
			c: [
				"AX"
			],
			r: 1
		},
		"Europe/Minsk": {
			u: 180,
			c: [
				"BY"
			]
		},
		"Europe/Monaco": {
			a: "Europe/Paris",
			c: [
				"MC"
			],
			r: 1
		},
		"Europe/Moscow": {
			u: 180,
			c: [
				"RU"
			]
		},
		"Europe/Nicosia": {
			a: "Asia/Nicosia",
			r: 1
		},
		"Europe/Oslo": {
			a: "Europe/Berlin",
			c: [
				"NO"
			],
			r: 1
		},
		"Europe/Paris": {
			u: 60,
			d: 120,
			c: [
				"FR",
				"MC"
			]
		},
		"Europe/Podgorica": {
			a: "Europe/Belgrade",
			c: [
				"ME"
			],
			r: 1
		},
		"Europe/Prague": {
			u: 60,
			d: 120,
			c: [
				"CZ",
				"SK"
			]
		},
		"Europe/Riga": {
			u: 120,
			d: 180,
			c: [
				"LV"
			]
		},
		"Europe/Rome": {
			u: 60,
			d: 120,
			c: [
				"IT",
				"SM",
				"VA"
			]
		},
		"Europe/Samara": {
			u: 240,
			c: [
				"RU"
			]
		},
		"Europe/San_Marino": {
			a: "Europe/Rome",
			c: [
				"SM"
			],
			r: 1
		},
		"Europe/Sarajevo": {
			a: "Europe/Belgrade",
			c: [
				"BA"
			],
			r: 1
		},
		"Europe/Saratov": {
			u: 240,
			c: [
				"RU"
			]
		},
		"Europe/Simferopol": {
			u: 180,
			c: [
				"RU",
				"UA"
			]
		},
		"Europe/Skopje": {
			a: "Europe/Belgrade",
			c: [
				"MK"
			],
			r: 1
		},
		"Europe/Sofia": {
			u: 120,
			d: 180,
			c: [
				"BG"
			]
		},
		"Europe/Stockholm": {
			a: "Europe/Berlin",
			c: [
				"SE"
			],
			r: 1
		},
		"Europe/Tallinn": {
			u: 120,
			d: 180,
			c: [
				"EE"
			]
		},
		"Europe/Tirane": {
			u: 60,
			d: 120,
			c: [
				"AL"
			]
		},
		"Europe/Tiraspol": {
			a: "Europe/Chisinau",
			r: 1
		},
		"Europe/Ulyanovsk": {
			u: 240,
			c: [
				"RU"
			]
		},
		"Europe/Uzhgorod": {
			a: "Europe/Kyiv",
			r: 1
		},
		"Europe/Vaduz": {
			a: "Europe/Zurich",
			c: [
				"LI"
			],
			r: 1
		},
		"Europe/Vatican": {
			a: "Europe/Rome",
			c: [
				"VA"
			],
			r: 1
		},
		"Europe/Vienna": {
			u: 60,
			d: 120,
			c: [
				"AT"
			]
		},
		"Europe/Vilnius": {
			u: 120,
			d: 180,
			c: [
				"LT"
			]
		},
		"Europe/Volgograd": {
			u: 180,
			c: [
				"RU"
			]
		},
		"Europe/Warsaw": {
			u: 60,
			d: 120,
			c: [
				"PL"
			]
		},
		"Europe/Zagreb": {
			a: "Europe/Belgrade",
			c: [
				"HR"
			],
			r: 1
		},
		"Europe/Zaporozhye": {
			a: "Europe/Kyiv",
			r: 1
		},
		"Europe/Zurich": {
			u: 60,
			d: 120,
			c: [
				"CH",
				"DE",
				"LI"
			]
		},
		Factory: {
			u: 0
		},
		GB: {
			a: "Europe/London",
			c: [
				"GB"
			],
			r: 1
		},
		"GB-Eire": {
			a: "Europe/London",
			c: [
				"GB"
			],
			r: 1
		},
		GMT: {
			a: "Etc/GMT",
			r: 1
		},
		"GMT+0": {
			a: "Etc/GMT",
			r: 1
		},
		"GMT-0": {
			a: "Etc/GMT",
			r: 1
		},
		GMT0: {
			a: "Etc/GMT",
			r: 1
		},
		Greenwich: {
			a: "Etc/GMT",
			r: 1
		},
		HST: {
			u: -600
		},
		Hongkong: {
			a: "Asia/Hong_Kong",
			r: 1
		},
		Iceland: {
			a: "Africa/Abidjan",
			c: [
				"IS"
			],
			r: 1
		},
		"Indian/Antananarivo": {
			a: "Africa/Nairobi",
			c: [
				"MG"
			],
			r: 1
		},
		"Indian/Chagos": {
			u: 360,
			c: [
				"IO"
			]
		},
		"Indian/Christmas": {
			a: "Asia/Bangkok",
			c: [
				"CX"
			],
			r: 1
		},
		"Indian/Cocos": {
			a: "Asia/Yangon",
			c: [
				"CC"
			],
			r: 1
		},
		"Indian/Comoro": {
			a: "Africa/Nairobi",
			c: [
				"KM"
			],
			r: 1
		},
		"Indian/Kerguelen": {
			a: "Indian/Maldives",
			c: [
				"TF"
			],
			r: 1
		},
		"Indian/Mahe": {
			a: "Asia/Dubai",
			c: [
				"SC"
			],
			r: 1
		},
		"Indian/Maldives": {
			u: 300,
			c: [
				"MV",
				"TF"
			]
		},
		"Indian/Mauritius": {
			u: 240,
			c: [
				"MU"
			]
		},
		"Indian/Mayotte": {
			a: "Africa/Nairobi",
			c: [
				"YT"
			],
			r: 1
		},
		"Indian/Reunion": {
			a: "Asia/Dubai",
			c: [
				"RE"
			],
			r: 1
		},
		Iran: {
			a: "Asia/Tehran",
			r: 1
		},
		Israel: {
			a: "Asia/Jerusalem",
			r: 1
		},
		Jamaica: {
			a: "America/Jamaica",
			r: 1
		},
		Japan: {
			a: "Asia/Tokyo",
			r: 1
		},
		Kwajalein: {
			a: "Pacific/Kwajalein",
			r: 1
		},
		Libya: {
			a: "Africa/Tripoli",
			r: 1
		},
		MET: {
			u: 60,
			d: 120
		},
		MST: {
			u: -420
		},
		MST7MDT: {
			u: -420,
			d: -360
		},
		"Mexico/BajaNorte": {
			a: "America/Tijuana",
			r: 1
		},
		"Mexico/BajaSur": {
			a: "America/Mazatlan",
			r: 1
		},
		"Mexico/General": {
			a: "America/Mexico_City",
			r: 1
		},
		NZ: {
			a: "Pacific/Auckland",
			c: [
				"NZ"
			],
			r: 1
		},
		"NZ-CHAT": {
			a: "Pacific/Chatham",
			r: 1
		},
		Navajo: {
			a: "America/Denver",
			r: 1
		},
		PRC: {
			a: "Asia/Shanghai",
			r: 1
		},
		PST8PDT: {
			u: -480,
			d: -420
		},
		"Pacific/Apia": {
			u: 780,
			c: [
				"WS"
			]
		},
		"Pacific/Auckland": {
			u: 720,
			d: 780,
			c: [
				"NZ",
				"AQ"
			]
		},
		"Pacific/Bougainville": {
			u: 660,
			c: [
				"PG"
			]
		},
		"Pacific/Chatham": {
			u: 765,
			d: 825,
			c: [
				"NZ"
			]
		},
		"Pacific/Chuuk": {
			a: "Pacific/Port_Moresby",
			c: [
				"FM"
			],
			r: 1
		},
		"Pacific/Easter": {
			u: -360,
			d: -300,
			c: [
				"CL"
			]
		},
		"Pacific/Efate": {
			u: 660,
			c: [
				"VU"
			]
		},
		"Pacific/Enderbury": {
			a: "Pacific/Kanton",
			r: 1
		},
		"Pacific/Fakaofo": {
			u: 780,
			c: [
				"TK"
			]
		},
		"Pacific/Fiji": {
			u: 720,
			c: [
				"FJ"
			]
		},
		"Pacific/Funafuti": {
			a: "Pacific/Tarawa",
			c: [
				"TV"
			],
			r: 1
		},
		"Pacific/Galapagos": {
			u: -360,
			c: [
				"EC"
			]
		},
		"Pacific/Gambier": {
			u: -540,
			c: [
				"PF"
			]
		},
		"Pacific/Guadalcanal": {
			u: 660,
			c: [
				"SB",
				"FM"
			]
		},
		"Pacific/Guam": {
			u: 600,
			c: [
				"GU",
				"MP"
			]
		},
		"Pacific/Honolulu": {
			u: -600,
			c: [
				"US"
			]
		},
		"Pacific/Johnston": {
			a: "Pacific/Honolulu",
			r: 1
		},
		"Pacific/Kanton": {
			u: 780,
			c: [
				"KI"
			]
		},
		"Pacific/Kiritimati": {
			u: 840,
			c: [
				"KI"
			]
		},
		"Pacific/Kosrae": {
			u: 660,
			c: [
				"FM"
			]
		},
		"Pacific/Kwajalein": {
			u: 720,
			c: [
				"MH"
			]
		},
		"Pacific/Majuro": {
			a: "Pacific/Tarawa",
			c: [
				"MH"
			],
			r: 1
		},
		"Pacific/Marquesas": {
			u: -570,
			c: [
				"PF"
			]
		},
		"Pacific/Midway": {
			a: "Pacific/Pago_Pago",
			c: [
				"UM"
			],
			r: 1
		},
		"Pacific/Nauru": {
			u: 720,
			c: [
				"NR"
			]
		},
		"Pacific/Niue": {
			u: -660,
			c: [
				"NU"
			]
		},
		"Pacific/Norfolk": {
			u: 660,
			d: 720,
			c: [
				"NF"
			]
		},
		"Pacific/Noumea": {
			u: 660,
			c: [
				"NC"
			]
		},
		"Pacific/Pago_Pago": {
			u: -660,
			c: [
				"AS",
				"UM"
			]
		},
		"Pacific/Palau": {
			u: 540,
			c: [
				"PW"
			]
		},
		"Pacific/Pitcairn": {
			u: -480,
			c: [
				"PN"
			]
		},
		"Pacific/Pohnpei": {
			a: "Pacific/Guadalcanal",
			c: [
				"FM"
			],
			r: 1
		},
		"Pacific/Ponape": {
			a: "Pacific/Guadalcanal",
			c: [
				"FM"
			],
			r: 1
		},
		"Pacific/Port_Moresby": {
			u: 600,
			c: [
				"PG",
				"AQ",
				"FM"
			]
		},
		"Pacific/Rarotonga": {
			u: -600,
			c: [
				"CK"
			]
		},
		"Pacific/Saipan": {
			a: "Pacific/Guam",
			c: [
				"MP"
			],
			r: 1
		},
		"Pacific/Samoa": {
			a: "Pacific/Pago_Pago",
			c: [
				"AS"
			],
			r: 1
		},
		"Pacific/Tahiti": {
			u: -600,
			c: [
				"PF"
			]
		},
		"Pacific/Tarawa": {
			u: 720,
			c: [
				"KI",
				"MH",
				"TV",
				"UM",
				"WF"
			]
		},
		"Pacific/Tongatapu": {
			u: 780,
			c: [
				"TO"
			]
		},
		"Pacific/Truk": {
			a: "Pacific/Port_Moresby",
			c: [
				"FM"
			],
			r: 1
		},
		"Pacific/Wake": {
			a: "Pacific/Tarawa",
			c: [
				"UM"
			],
			r: 1
		},
		"Pacific/Wallis": {
			a: "Pacific/Tarawa",
			c: [
				"WF"
			],
			r: 1
		},
		"Pacific/Yap": {
			a: "Pacific/Port_Moresby",
			c: [
				"FM"
			],
			r: 1
		},
		Poland: {
			a: "Europe/Warsaw",
			r: 1
		},
		Portugal: {
			a: "Europe/Lisbon",
			r: 1
		},
		ROC: {
			a: "Asia/Taipei",
			r: 1
		},
		ROK: {
			a: "Asia/Seoul",
			r: 1
		},
		Singapore: {
			a: "Asia/Singapore",
			c: [
				"SG"
			],
			r: 1
		},
		Turkey: {
			a: "Europe/Istanbul",
			r: 1
		},
		UCT: {
			a: "Etc/UTC",
			r: 1
		},
		"US/Alaska": {
			a: "America/Anchorage",
			r: 1
		},
		"US/Aleutian": {
			a: "America/Adak",
			r: 1
		},
		"US/Arizona": {
			a: "America/Phoenix",
			c: [
				"US"
			],
			r: 1
		},
		"US/Central": {
			a: "America/Chicago",
			r: 1
		},
		"US/East-Indiana": {
			a: "America/Indiana/Indianapolis",
			r: 1
		},
		"US/Eastern": {
			a: "America/New_York",
			r: 1
		},
		"US/Hawaii": {
			a: "Pacific/Honolulu",
			r: 1
		},
		"US/Indiana-Starke": {
			a: "America/Indiana/Knox",
			r: 1
		},
		"US/Michigan": {
			a: "America/Detroit",
			r: 1
		},
		"US/Mountain": {
			a: "America/Denver",
			r: 1
		},
		"US/Pacific": {
			a: "America/Los_Angeles",
			r: 1
		},
		"US/Samoa": {
			a: "Pacific/Pago_Pago",
			c: [
				"AS"
			],
			r: 1
		},
		UTC: {
			a: "Etc/UTC",
			r: 1
		},
		Universal: {
			a: "Etc/UTC",
			r: 1
		},
		"W-SU": {
			a: "Europe/Moscow",
			r: 1
		},
		WET: {
			u: 0,
			d: 60
		},
		Zulu: {
			a: "Etc/UTC",
			r: 1
		}
	};
	var data = {
		countries: countries$1,
		timezones: timezones$1
	};

	var timezonesMap;
	function buildCountry(data, id) {
	  var name = data.countries[id];
	  if (!name) return null;
	  var tzMap = getTimezonesMap(data)[id] || {};
	  return {
	    id: id,
	    name: name,
	    timezones: tzMap.current || [],
	    allTimezones: tzMap.all || []
	  };
	}
	function getTimezonesMap(data) {
	  if (!timezonesMap) timezonesMap = buildTimezonesMap(data);
	  return timezonesMap;
	}
	function buildTimezonesMap(data) {
	  return Object.keys(data.timezones).reduce(function (result, id) {
	    var tz = data.timezones[id];
	    var c = tz.c,
	      a = tz.a;
	    var aliasTz = data.timezones[a] || {};
	    var countries = c || aliasTz.c;
	    if (!countries) return result;
	    countries.forEach(function (country) {
	      if (!result[country]) Object.assign(result, _defineProperty({}, country, {
	        current: [],
	        all: []
	      }));
	      if (tz.r === undefined) result[country].current.push(id);
	      result[country].all.push(id);
	    });
	    return result;
	  }, {});
	}

	function buildTimezone(data, name) {
	  var timezone = data.timezones[name];
	  if (!timezone) return null;
	  var _timezone$a = timezone.a,
	    aliasOf = _timezone$a === void 0 ? null : _timezone$a;
	  var aliasTz = aliasOf ? data.timezones[aliasOf] : {};
	  var tz = _objectSpread2(_objectSpread2({}, aliasTz), data.timezones[name]);
	  var countries = tz.c || [];
	  var utcOffset = tz.u;
	  var dstOffset = Number.isInteger(tz.d) ? tz.d : utcOffset;
	  var result = {
	    name: name,
	    countries: countries,
	    utcOffset: utcOffset,
	    utcOffsetStr: getOffsetStr(utcOffset),
	    dstOffset: dstOffset,
	    dstOffsetStr: getOffsetStr(dstOffset),
	    aliasOf: aliasOf
	  };
	  if (timezone.r) result.deprecated = true;
	  return result;
	}
	function getOffsetStr(offset) {
	  var hours = Math.floor(Math.abs(offset) / 60);
	  var min = offset % 60;
	  var sign = offset < 0 ? '-' : '+';
	  return "".concat(sign).concat(getNumStr(hours), ":").concat(getNumStr(min));
	}
	function getNumStr(input) {
	  var num = Math.abs(input);
	  var prefix = num < 10 ? '0' : '';
	  return "".concat(prefix).concat(num);
	}

	var _excluded = ["allTimezones"];
	Object.keys(data.timezones).length;
	var countries = {};
	var timezones = {};
	function getCountry(id) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  if (!countries[id]) memoizeCountry(buildCountry(data, id));
	  return deliverCountry(countries[id], options);
	}
	function memoizeCountry(country) {
	  if (!country) return;
	  countries[country.id] = country;
	}
	function getTimezone(name) {
	  if (!timezones[name]) memoizeTimezone(buildTimezone(data, name));
	  return timezones[name] ? _objectSpread2({}, timezones[name]) : null;
	}
	function memoizeTimezone(timezone) {
	  if (!timezone) return;
	  timezones[timezone.name] = timezone;
	  Object.keys(timezone).length;
	}
	function getCountriesForTimezone(tzName) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var timezone = getTimezone(tzName) || {};
	  var values = timezone.countries || [];
	  return values.map(function (c) {
	    return getCountry(c, options);
	  });
	}
	function deliverCountry(country, options) {
	  if (!country) return null;
	  var _ref2 = options || {},
	    deprecated = _ref2.deprecated;
	  country.allTimezones;
	    var other = _objectWithoutProperties(country, _excluded);
	  var tz = deprecated ? country.allTimezones : country.timezones;
	  return _objectSpread2(_objectSpread2({}, other), {}, {
	    timezones: tz
	  });
	}

	const timezoneCountryId = () => {
	    const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
	    return getCountriesForTimezone(timezone)[0]?.id ?? '';
	};

	const calculateZuoraPrice = (form, formState, formActions) => {
	    return loadZuora()
	        .then(() => getPreview(form, formState, formActions))
	        .then((previewResponse) => ({
	        slug: formState.paymentOption.slug,
	        productId: formState.paymentOption.productId,
	        promoCode: formState.promoCode,
	        addonPrices: [],
	        totalPrice: previewResponse.amount,
	        totalPriceFormattedString: formatCurrency(previewResponse.amount, getRelevantCurrency(form, formState)),
	        netPrice: previewResponse.amountWithoutTax,
	        netPriceFormattedString: formatCurrency(previewResponse.amountWithoutTax, getRelevantCurrency(form, formState)),
	        taxPrice: previewResponse.taxAmount || null,
	        taxPriceFormattedString: previewResponse.taxAmount ? formatCurrency(previewResponse.taxAmount, getRelevantCurrency(form, formState)) : null,
	        discountPrice: 0,
	        discountPriceFormattedPrice: formatCurrency(0, getRelevantCurrency(form, formState)),
	        chargeItems: [...Object.values(previewResponse.invoiceItems)]
	            .filter((invoiceItem) => invoiceItem.chargeAmount)
	            .map((invoiceItem) => ({
	            label: invoiceItem.chargeName,
	            priceFormattedString: formatCurrency(invoiceItem.chargeAmount, getRelevantCurrency(form, formState))
	        })),
	        billingAddress: formState.billingAddress
	    }));
	};
	const unknownToEmpty = (location) => location?.toLowerCase() === 'unknown' ? '' : location;
	const getPreview = (form, formState, formActions) => {
	    if (form.environment.previewMode) {
	        return mockBillingPreviewResponse(formConfigAs(form).dynamicOfferPreview ?? {});
	    }
	    const terms = formState.paymentOption.terms;
	    const previewBody = {
	        account: {
	            city: unknownToEmpty(formConfigAs(form).requestCity),
	            country: unknownToEmpty(formConfigAs(form).requestCountry) || timezoneCountryId(),
	            county: '',
	            state: unknownToEmpty(formConfigAs(form).requestState),
	            zipCode: unknownToEmpty(formConfigAs(form).requestZipCode)
	        },
	        currency: getRelevantCurrency(form, formState),
	        ratePlanIds: [formState.paymentOption.slug],
	        ...(terms ? {
	            termType: terms.initialTerm.termType,
	            ...(terms.initialTerm.termType === 'TERMED' ? {
	                initialTerm: terms.initialTerm.period,
	                initialTermPeriodType: terms.initialTerm.periodType,
	            } : {}),
	        } : {
	            termType: "EVERGREEN",
	        }),
	        ...(formState.dynamicOfferResult ? {
	            dynamicOfferResult: JSON.stringify(formState.dynamicOfferResult),
	            productId: formState.paymentOption.productId
	        } : {}),
	    };
	    return request("plugins/public/zuora-billing/preview-subscription", {
	        method: "POST",
	        bodyObject: previewBody
	    }, formActions).then(response => response.json());
	};

	const formattedDateWord = (date, locale = 'en-UK') => {
	    if (!date)
	        return '';
	    const d = new Date(date);
	    if (Number.isNaN(d.getDate()))
	        return 'Unknown';
	    return d.toLocaleDateString(locale, { day: 'numeric', month: 'short', year: 'numeric' });
	};

	// Example key: "<<<example.key|Default value>>>"
	const keyDefaultRegex = /^<<<([a-z0-9\-.]+)\|(.*)>>>$/;
	const resolveErrorLanguagePackKey = (form, serverError) => {
	    if (serverError == null) {
	        return '';
	    }
	    const packEntries = form.languagePack?.entries ?? {};
	    const error = ServerErrors[serverError];
	    return packEntries[error.languagePackKey] ?? error.fallbackMessage;
	};
	const resolveLanguagePackKey = (languagePack, string) => {
	    if (!string) {
	        return string;
	    }
	    try {
	        const match = keyDefaultRegex.exec(string);
	        if (!match || !match[1]) {
	            return string;
	        }
	        const packEntries = languagePack?.entries ?? {};
	        return packEntries[match[1]] ?? match[2];
	    }
	    catch (e) {
	        console.warn(`error resolving language pack key in string ${string}`, e);
	        return string;
	    }
	};
	const resolveLanguagePackKeyTyped = (form, key, fallback) => {
	    try {
	        const packEntries = form.languagePack?.entries ?? {};
	        return packEntries[key] ?? fallback;
	    }
	    catch (e) {
	        console.warn(`error resolving language pack key in string ${key}`, e);
	        return fallback;
	    }
	};
	const resolveLanguagePackLocale = (form) => resolveLanguagePackKeyTyped(form, 'pages.common.date-time-format-locale', 'en-US');
	const resolveLanguagePackKeys = (languagePack, object) => {
	    try {
	        if (object == null) {
	            return object;
	        }
	        if (typeof object !== 'object' && !Array.isArray(object)) {
	            if (typeof object === 'string' || object instanceof String) {
	                return resolveLanguagePackKey(languagePack, object);
	            }
	            return object;
	        }
	        if (Array.isArray(object)) {
	            return object.map(e => resolveLanguagePackKeys(languagePack, e));
	        }
	        return Object.entries(object).reduce((acc, [key, value]) => {
	            return {
	                ...acc,
	                [key]: resolveLanguagePackKeys(languagePack, value)
	            };
	        }, {});
	    }
	    catch (e) {
	        console.warn(`error resolving language pack entries`, e);
	        return object;
	    }
	};

	const getSubscriptionAmount = (form, subscription) => {
	    try {
	        if (subscription.isOneOff) {
	            return '';
	        }
	        const everyLabel = resolveLanguagePackKeyTyped(form, 'forms.billing.history.every', 'every');
	        const firstPayment = subscription['transaction-history']?.[0] ?? subscription['next-billing-time'];
	        const str = firstPayment?.['human-readable-amount'];
	        if (!str)
	            return '';
	        const currency = subscription.currency_code?.toUpperCase() ?? str.replace(/[0-9,.]/g, '');
	        const { discounts_applied: discountApplied, pre_discount_price: price, billing_frequency: freq, billing_frequency_unit: freqUnit, } = subscription ?? {};
	        if (!discountApplied && price && freq && freqUnit) {
	            if (freq === 1) {
	                return `${currency} ${price}/${freqUnit.toLowerCase()}`;
	            }
	            return `${currency} ${price} ${everyLabel} ${freq} ${freqUnit.toLowerCase()}s`;
	        }
	        const num = Number(str.replace(/[^\d.-]/g, ''));
	        const amount = Number.isInteger(num) ? num.toFixed(0) : num;
	        if (firstPayment.cycleCount === 1) {
	            return `${currency}${amount}/${firstPayment.cycle}`;
	        }
	        return `${currency} ${amount} ${everyLabel} ${firstPayment.cycleCount} ${firstPayment.cycle}s`;
	    }
	    catch {
	        console.error('Failed to get subscription amount');
	        return '';
	    }
	};
	const getPeriod = (time, cycle, cycleCount, locale) => {
	    try {
	        const d = new Date(time);
	        const addCycles = (() => {
	            switch (cycle) {
	                case 'day': return d.setDate(d.getDate() + cycleCount);
	                case 'week': return d.setDate(d.getDate() + cycleCount * 7);
	                case 'month': return d.setMonth(d.getMonth() + cycleCount);
	                case 'year': return d.setFullYear(d.getFullYear() + cycleCount);
	                default: return null;
	            }
	        })();
	        const start = formattedDateWord(time, locale);
	        const end = formattedDateWord(addCycles, locale);
	        return `${start} - ${end}`;
	    }
	    catch {
	        console.error('Failed to get subscription period');
	        return '';
	    }
	};
	const buildTaxString = (inclusive, cents, name) => (`${inclusive ? '' : '+'}`
	    + `${(cents / 100).toFixed(2)} ${name}`
	    + `${inclusive ? ' incl.' : ''}`);
	const getSpecificTax = (cents, displayName, taxInclusive, taxPercent) => {
	    try {
	        const taxAmount = taxPercent * (cents / 100);
	        const totalCents = cents + (taxInclusive ? 0 : taxAmount);
	        const total = (totalCents / 100).toFixed(2);
	        const taxes = `(${buildTaxString(taxInclusive, taxAmount, displayName)})`;
	        return { taxes, total };
	    }
	    catch {
	        console.error('Failed to get subscription tax');
	        return { taxes: '', total: 0 };
	    }
	};
	const getDefaultTaxes = (cents, defaultTax) => {
	    try {
	        const taxes = [];
	        let totalCents = cents;
	        defaultTax.forEach((e) => {
	            const taxCents = e.taxPercent * (cents / 100);
	            const tax = buildTaxString(e.taxInclusive, taxCents, e.displayName);
	            taxes.push(tax);
	            totalCents += e.taxInclusive ? 0 : taxCents;
	        });
	        const total = (totalCents / 100).toFixed(2);
	        return { taxes: `(${taxes.join(', ')})`, total };
	    }
	    catch {
	        console.error('Failed to get subscription default tax');
	        return { taxes: '', total: 0 };
	    }
	};
	const getBillingHistory = (form, subscription) => {
	    try {
	        const defaultTax = subscription['default-tax-rates'];
	        const managedBy = subscription['managed-by'].toLowerCase();
	        const isCanceled = subscription['subscription-state'].toLowerCase() === 'canceled';
	        const cancelDate = formattedDateWord(managedBy === 'stripe' ? subscription.ended : subscription.ends);
	        const locale = resolveLanguagePackLocale(form);
	        let newArr = subscription['transaction-history'].reduce((acc, e) => {
	            const date = formattedDateWord(e.time, locale);
	            const period = getPeriod(e.time, e.cycle, e.cycleCount, locale);
	            const { cents, currency, taxRate, } = e;
	            let total;
	            let taxes;
	            if (taxRate) {
	                const { displayName, taxInclusive, taxPercent } = taxRate;
	                ({ taxes, total } = getSpecificTax(cents, displayName, taxInclusive, taxPercent));
	            }
	            else if (defaultTax?.length) {
	                ({ taxes, total } = getDefaultTaxes(cents, defaultTax));
	            }
	            else {
	                total = (cents / 100).toFixed(2);
	                taxes = null;
	            }
	            const subtotal = managedBy === 'stripe'
	                ? (e.cents / 100).toFixed(2)
	                : null;
	            return [...acc, {
	                    date, period, subtotal, currency, taxes, total,
	                }];
	        }, []);
	        if (isCanceled) {
	            newArr = [{
	                    date: cancelDate,
	                    period: 'canceled',
	                }, ...newArr];
	        }
	        return newArr;
	    }
	    catch {
	        console.error('Failed to get subscription billing history');
	        return null;
	    }
	};

	const loadBraintreeStripeSubscriptions = (form, _, formActions, activeOnly) => {
	    return request(`blaize/payment/${form.organisationConfiguration.paymentProvider}/subscriptions`, {
	        method: "GET"
	    }, formActions, null, true)
	        .then(response => response.ok ? response.json() : [])
	        .then(subscriptions => subscriptions
	        .filter(subscription => !activeOnly || subscription['subscription-state']?.toLowerCase() === 'active')
	        .map(subscription => {
	        const locale = resolveLanguagePackLocale(form);
	        const multiphasePlanMappings = getMultiphasePlanMappings(subscription);
	        return {
	            externalId: subscription['external-id'],
	            productId: subscription['blaize-product'].id,
	            productLabel: subscription['blaize-product'].label ?? subscription['blaize-product'].id,
	            planId: subscription['plan_id'],
	            planLabel: subscription['plan_name'],
	            currency: subscription['currency_code'],
	            status: subscription['subscription-state']?.toLowerCase() === 'active' ? 'active' : 'inactive',
	            nextBillingTime: formattedDateWord(subscription['next-billing-time'], locale),
	            amount: getSubscriptionAmount(form, subscription),
	            transactionHistory: getBillingHistory(form, subscription),
	            ...(subscription['multiphase_plan'] && { multiphasePlan: subscription['multiphase_plan'] }),
	            ...(Object.keys(multiphasePlanMappings).length > 0 && { multiphasePlanMappings })
	        };
	    }));
	};
	const getMultiphasePlanMappings = (subscription) => {
	    const multiPhasedPlans = subscription['blaize-product'].mapping?.recurring?.multiPhasedPlans || [];
	    return multiPhasedPlans.reduce((acc, plan) => {
	        acc[plan.id] = plan;
	        return acc;
	    }, {});
	};

	const calculateStripeSubscriptionProrate = (form, formState, formActions) => {
	    const changingFromSubscription = formState
	        .validChangeFromPlans
	        .find(plan => formState.paymentOption.slug === plan.planSlug && formState.paymentOption.productId === plan.productId)
	        ?.changesFromSubscription;
	    if (!changingFromSubscription) {
	        console.error("No valid change from subscription");
	        return;
	    }
	    return request(`zephr/payment/stripe/subscriptions/${changingFromSubscription.externalId}/change-previews`, {
	        method: 'POST',
	        bodyObject: {
	            plan_id: formState.paymentOption.slug
	        }
	    }, formActions)
	        .then(response => response.json())
	        .then(preview => {
	        const currencyMultiplier = isZeroDecimalCurrency(formState.paymentOption.currencyCode.toUpperCase()) ? 1 : 0.01;
	        return {
	            totalPrice: preview.total * currencyMultiplier,
	            totalPriceFormattedString: formatCurrency(preview.total * currencyMultiplier, formState.paymentOption.currencyCode),
	            subTotalPrice: preview.sub_total * currencyMultiplier,
	            subTotalPriceFormattedString: formatCurrency(preview.sub_total * currencyMultiplier, formState.paymentOption.currencyCode),
	        };
	    });
	};

	// Helper function to extract only custom fields (those ending with "__c")
	const extractCustomFields = (subscription) => {
	    const customFields = {};
	    for (const [key, value] of Object.entries(subscription)) {
	        if (key.endsWith('__c')) {
	            customFields[key] = value;
	        }
	    }
	    return customFields;
	};
	const zuoraStatusMap = {
	    'draft': 'pending',
	    'pending activation': 'pending',
	    'pending acceptance': 'pending',
	    'active': 'active',
	    'cancelled': 'inactive',
	    'expired': 'inactive',
	    'suspended': 'inactive'
	};
	const loadZuoraSubscriptions = (form, formState, formActions, activeOnly, isGiftSubscriptions = false) => {
	    return request('plugins/public/zuora-billing/subscriptions', {
	        method: "GET"
	    }, formActions, null, true)
	        .then(response => response.json())
	        .then(subscriptionsResponse => [...Object.values(subscriptionsResponse.subscriptions)])
	        .then(subscriptions => subscriptions
	        .filter(subscription => !activeOnly || subscription.status?.toLowerCase() === 'active')
	        .map(subscription => {
	        // Assuming that Zephr created Zuora subscriptions only have 1 active rate plan
	        const ratePlanList = [...Object.values(subscription.ratePlans)];
	        const activeRatePlans = ratePlanList.length === 1
	            ? ratePlanList
	            : ratePlanList.filter(ratePlan => ratePlan.lastChangeType === 'Add');
	        if (activeRatePlans.length !== 1) {
	            console.warn(`Subscription ${subscription.id} has ${activeRatePlans.length} active rate plans`, ratePlanList);
	        }
	        // Verify currency
	        if (activeRatePlans[0]
	            && !formConfigAs(form).dynamicOffer?.id
	            && getRelevantCurrency(form, formState)
	            && ![...Object.values(activeRatePlans[0].ratePlanCharges ?? {})]
	                .every(charge => charge?.currency === getRelevantCurrency(form, formState))) {
	            console.log(`Subscription ${subscription.id} is not in the form currency`);
	            return null;
	        }
	        const amount = subscription.contractedMrr && subscription.currency && subscription.currentTermPeriodType
	            ? `${subscription.currency} ${subscription.contractedMrr}`
	            : '';
	        return {
	            // Start with only custom fields from the raw subscription (those ending with "__c")
	            ...extractCustomFields(subscription),
	            // Override with our specific mappings
	            externalId: subscription.id,
	            accountId: subscription.accountId,
	            productId: subscription['SubscriptionExperienceProductID__c'],
	            productLabel: activeRatePlans[0]?.productName,
	            planId: activeRatePlans[0]?.productRatePlanId,
	            planLabel: null,
	            currency: activeRatePlans[0]?.ratePlanCharges[0]?.currency,
	            status: zuoraStatusMap[subscription.status?.toLowerCase()] ?? 'inactive',
	            amount,
	            autoRenew: subscription?.autoRenew,
	            billToContact: subscription.billToContact,
	            termType: subscription.termType,
	            ...(isGiftSubscriptions ? {
	                recipientFirstName: subscription.soldToContact?.firstName,
	                recipientLastName: subscription.soldToContact?.lastName,
	                recipientEmail: subscription.soldToContact?.personalEmail,
	                subscriptionStartDate: subscription.subscriptionStartDate,
	                subscriptionEndDate: subscription.termEndDate,
	                subscriptionType: subscription?.ratePlans[0]?.productName,
	                subscriptionNumber: subscription.subscriptionNumber,
	            } : {})
	        };
	    })
	        .filter(existingSubscription => existingSubscription && existingSubscription.planId != null && existingSubscription.productId != null));
	};

	const calculateZuoraSubscriptionProrate = (form, formState, formActions) => {
	    const changingFromSubscription = formState
	        .validChangeFromPlans
	        .find(plan => formState.paymentOption.slug === plan.planSlug && formState.paymentOption.productId === plan.productId)
	        ?.changesFromSubscription;
	    if (!changingFromSubscription) {
	        console.error("No valid change from subscription");
	        return;
	    }
	    return request(`plugins/public/zuora-billing/subscription-change-preview`, {
	        method: 'POST',
	        bodyObject: {
	            subscriptionId: changingFromSubscription.externalId,
	            newProductRatePlanId: formState.paymentOption.slug,
	            currency: getRelevantCurrency(form, formState),
	            ...(formState.dynamicOfferResult ? {
	                dynamicOfferResult: JSON.stringify(formState.dynamicOfferResult),
	                productId: formState.paymentOption.productId
	            } : {}),
	        }
	    }, formActions)
	        .then(response => response.json())
	        .then(preview => {
	        return {
	            totalPrice: preview.amount,
	            totalPriceFormattedString: formatCurrency(preview.amount, getRelevantCurrency(form, formState)),
	            subTotalPrice: preview.amountWithoutTax,
	            subTotalPriceFormattedString: formatCurrency(preview.amountWithoutTax, getRelevantCurrency(form, formState)),
	        };
	    });
	};

	const stripePriceCalculator = (form, formState, formActions) => {
	    // Fallback to the generic price calculator if there is no billing address
	    if (!form.organisationConfiguration.stripeAutomaticTaxEnabled
	        || formState.billingAddress.country == null) {
	        return calculateBraintreeStripePrice(form, formState);
	    }
	    return fetchStripeTaxPreview(formState, formActions)
	        .then((taxPreview) => {
	        if (!taxPreview.total) {
	            return calculateBraintreeStripePrice(form, formState);
	        }
	        const currencyMultiplier = isZeroDecimalCurrency(formState.paymentOption.currencyCode.toUpperCase())
	            ? 1
	            : 0.01;
	        const currencyFormatter = (value) => formatCurrency(value * currencyMultiplier, formState.paymentOption.currencyCode);
	        return {
	            slug: formState.paymentOption.slug,
	            productId: formState.paymentOption.productId,
	            promoCode: formState.promoCode,
	            billingAddress: formState.billingAddress,
	            addonPrices: [],
	            totalPrice: taxPreview.total * currencyMultiplier,
	            totalPriceFormattedString: currencyFormatter(taxPreview.total),
	            netPrice: taxPreview.sub_total * currencyMultiplier,
	            netPriceFormattedString: currencyFormatter(taxPreview.sub_total),
	            taxPrice: taxPreview.tax ? taxPreview.tax * currencyMultiplier : null,
	            taxPriceFormattedString: taxPreview.tax ? currencyFormatter(taxPreview.tax) : null,
	            discountPrice: taxPreview.discount ? taxPreview.discount * currencyMultiplier : null,
	            discountPriceFormattedPrice: taxPreview.discount ? currencyFormatter(taxPreview.discount) : null,
	            chargeItems: [],
	        };
	    })
	        .catch((error) => {
	        console.error(`Error calculating stripe tax preview ${JSON.stringify(error)}`);
	        return calculateBraintreeStripePrice(form, formState);
	    });
	};
	const fetchStripeTaxPreview = (formState, formActions) => {
	    return request('zephr/payment/stripe/create-subscription-previews', {
	        method: 'POST',
	        bodyObject: {
	            product_id: formState.paymentOption.productId,
	            plan_id: formState.paymentOption.slug,
	            billing_country: formState.billingAddress.country,
	            billing_post_code: formState.billingAddress.postalCode,
	            promo_code: formState.promoCodeValid ? formState.promoCode : undefined,
	        },
	    }, formActions, null, true).then((response) => response.json());
	};

	const verifyingPromoCodeBusyKey$1 = "promo-code";
	const checkDoPromoCode = async (form, formState, formActions) => {
	    if (form.environment.previewMode) {
	        return;
	    }
	    const dynamicOfferId = formConfigAs(form).dynamicOffer?.id;
	    if (!dynamicOfferId) {
	        throw Error('Missing Dynamic Offer id');
	    }
	    let session;
	    try {
	        session = document.cookie.match(/blaize_session=[0-9a-z-]+/)[0].substring(15);
	    }
	    catch {
	        session = null;
	    }
	    const doProducts = formState?.dynamicOfferResult?.products ?? [];
	    const promoProducts = doProducts.flatMap(p => p.paymentPlans.map(plan => ({
	        id: p.id,
	        payment_plan: {
	            "provider": "zuora-billing",
	            "plan_id": plan.planId,
	            charges: plan.charges.map(c => ({
	                "charge_definition_id": c.chargeDefinitionData.productChargeDefinitionId,
	                "currency": c.prices[0]?.currency,
	                "price": c.prices[0].price
	            }))
	        }
	    })));
	    const response = await request('zephr/public/decisions/v1/promo-codes', {
	        method: "POST",
	        bodyObject: {
	            "promo_code": formState.promoCode,
	            "session": session,
	            "selected_products": promoProducts
	        },
	    }, formActions, verifyingPromoCodeBusyKey$1);
	    if (!response.ok) {
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[ServerError.PROMO_CODE_INVALID_ERROR],
	        });
	        return Promise.resolve(formActions.updateFormState({
	            promoCodeValid: false,
	            serverErrors: [ServerError.PROMO_CODE_INVALID_ERROR],
	            discountedPlanPrices: []
	        }));
	    }
	    const json = await response.json();
	    const matchingProduct = json?.products?.find(p => p.id === formState.paymentOption.productId && p.paymentPlans.some(plan => plan.planId === formState.paymentOption.slug));
	    if (!matchingProduct) {
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[ServerError.PROMO_CODE_INVALID_ERROR],
	        });
	        return Promise.resolve(formActions.updateFormState({
	            promoCodeValid: false,
	            serverErrors: [ServerError.PROMO_CODE_INVALID_ERROR],
	            discountedPlanPrices: []
	        }));
	    }
	    const updatedState = formActions.updateFormState({
	        promoCodeValid: true,
	        serverErrors: [],
	        discountedPlanPrices: [],
	        originalDynamicOfferResult: formState.dynamicOfferResult,
	        dynamicOfferResult: {
	            ...formState.dynamicOfferResult,
	            ...json
	        }
	    });
	    await calculatePrices(form, updatedState, formActions);
	};
	const zuoraDoPromoCodeService = async (form, formState, formActions) => checkDoPromoCode(form, formState, formActions);

	/* src/components/elements/payment/zuora/ZuoraDynamicFormPreLoader.svelte generated by Svelte v4.2.12 */

	function create_fragment$T(ctx) {
		let script;
		let script_src_value;

		return {
			c() {
				script = element("script");
				script.innerHTML = ``;
				attr(script, "type", "text/javascript");
				if (!src_url_equal(script.src, script_src_value = "https://js.zuora.com/payment/v3/zuora.js")) attr(script, "src", script_src_value);
				attr(script, "onload", "window.zuoraLoadCallback()");
			},
			m(target, anchor) {
				append(document.head, script);
			},
			p: noop,
			i: noop,
			o: noop,
			d(detaching) {
				detach(script);
			}
		};
	}

	function instance$S($$self, $$props, $$invalidate) {
		let { onMountCallback } = $$props;
		onMount(onMountCallback);

		$$self.$$set = $$props => {
			if ('onMountCallback' in $$props) $$invalidate(0, onMountCallback = $$props.onMountCallback);
		};

		return [onMountCallback];
	}

	class ZuoraDynamicFormPreLoader extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$S, create_fragment$T, safe_not_equal, { onMountCallback: 0 });
		}
	}

	const paymentProviderConfigurations = {
	    [paymentProviders.BRAINTREE]: {
	        loader: loadBraintreeUi,
	        preLoader: null,
	        completer: braintreePay,
	        changePaymentCompleter: braintreeChangePayment,
	        component: BraintreePayment,
	        preLoaderComponent: null,
	        promoCodeCheckPath: 'blaize/payment/braintree/promo-code-check',
	        productAddonPath: 'blaize/payment/braintree/addons-check',
	        existingSubscriptionLoader: loadBraintreeStripeSubscriptions,
	        priceCalculator: calculateBraintreeStripePrice,
	        hasProductAddons: true,
	        hasPromoCodes: () => true,
	        internalSubmit: () => false,
	        noPaymentForm: () => false,
	        canAttemptIncompletePaymentFormSubmission: false,
	    },
	    [paymentProviders.STRIPE]: {
	        loader: loadStripeUi,
	        preLoader: null,
	        completer: stripePay,
	        changePaymentCompleter: stripeChangePayment,
	        component: StripePayment,
	        preLoaderComponent: null,
	        promoCodeCheckPath: 'zephr/payment/stripe/promo-code-check',
	        existingSubscriptionLoader: loadBraintreeStripeSubscriptions,
	        priceCalculator: stripePriceCalculator,
	        changeSubscriptionProrateCalculator: calculateStripeSubscriptionProrate,
	        hasProductAddons: false,
	        hasPromoCodes: () => true,
	        internalSubmit: () => false,
	        noPaymentForm: () => false,
	        canAttemptIncompletePaymentFormSubmission: true,
	    },
	    [paymentProviders.ZUORA]: {
	        loader: loadZuoraUi,
	        preLoader: loadZuora,
	        completer: zuoraComplete,
	        changePaymentCompleter: zuoraChangePayment,
	        component: ZuoraPayment,
	        preLoaderComponent: (config) => config?.useDynamicForm ? ZuoraDynamicFormPreLoader : ZuoraPreLoader,
	        promoCodeCheckPath: '',
	        promoCodeServiceOverride: zuoraDoPromoCodeService,
	        priceCalculator: calculateZuoraPrice,
	        existingSubscriptionLoader: loadZuoraSubscriptions,
	        changeSubscriptionProrateCalculator: calculateZuoraSubscriptionProrate,
	        hasProductAddons: false,
	        hasPromoCodes: (form) => formConfigAs(form).dynamicOffer && !formConfigAs(form).changeSubscriptionMode,
	        internalSubmit: (form) => !formConfigAs(form).changeSubscriptionMode,
	        noPaymentForm: (form) => formConfigAs(form).changeSubscriptionMode,
	        canAttemptIncompletePaymentFormSubmission: false,
	    }
	};
	const mobilePaymentServiceConfigurations = {
	    [paymentProviders.BRAINTREE]: {
	        loader: configureBraintreeMobilePayments,
	        completer: braintreePayWithMobile,
	        component: BraintreeMobilePayment,
	        previewMode: (form) => form.environment.previewMode,
	    },
	    [paymentProviders.STRIPE]: {
	        loader: configureStripeMobilePay,
	        completer: stripePay,
	        component: StripeMobilePayment,
	        previewMode: (form) => form.environment.previewMode,
	    },
	};
	const paymentProviderFor = (providerName) => {
	    const configuration = paymentProviderConfigurations[providerName];
	    if (!configuration) {
	        throw `Payment provider ${providerName} not configured.`;
	    }
	    return configuration;
	};
	const mobilePaymentServiceFor = (providerName) => {
	    const configuration = mobilePaymentServiceConfigurations[providerName];
	    if (!configuration) {
	        throw `Mobile payment provider ${providerName} not configured.`;
	    }
	    return configuration;
	};

	/* src/components/elements/payment/EmptyPayment.svelte generated by Svelte v4.2.12 */

	function create_fragment$S(ctx) {
		let errormessage;
		let current;

		errormessage = new ErrorMessage({
				props: {
					error: /*providerError*/ ctx[0]?.message ?? /*error*/ ctx[1] ?? "",
					isPaymentForm: true
				}
			});

		return {
			c() {
				create_component(errormessage.$$.fragment);
			},
			m(target, anchor) {
				mount_component(errormessage, target, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				const errormessage_changes = {};
				if (dirty & /*providerError, error*/ 3) errormessage_changes.error = /*providerError*/ ctx[0]?.message ?? /*error*/ ctx[1] ?? "";
				errormessage.$set(errormessage_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errormessage.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errormessage.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(errormessage, detaching);
			}
		};
	}

	function instance$R($$self, $$props, $$invalidate) {
		let { providerError } = $$props;
		let { error = null } = $$props;

		$$self.$$set = $$props => {
			if ('providerError' in $$props) $$invalidate(0, providerError = $$props.providerError);
			if ('error' in $$props) $$invalidate(1, error = $$props.error);
		};

		return [providerError, error];
	}

	class EmptyPayment extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$R, create_fragment$S, safe_not_equal, { providerError: 0, error: 1 });
		}
	}

	const factory$m = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.PAYMENT || sectionElement.type === elementTypes.CHNAGE_PAYMENT_METHOD,
	    create: (form, formState, formActions) => {
	        const paymentProvider = paymentProviderFor(form.organisationConfiguration.paymentProvider);
	        if (paymentProvider.noPaymentForm(form)) {
	            return {
	                component: EmptyPayment,
	                props: {
	                    providerError: formState.paymentProviderError,
	                },
	                isValid: true
	            };
	        }
	        return {
	            component: paymentProvider.component,
	            props: {
	                isLoaded: formState.paymentProviderFormLoaded,
	                isBusy: formState.paymentProviderFormBusy,
	                providerError: formState.paymentProviderError,
	                isComplete: formState.paymentFormComplete,
	                isDisabled: paymentProvider.internalSubmit(form)
	                    ? !formState.canAttemptSectionCompletion
	                    : (formState.isBusy || formState.mobilePaymentService != null),
	                formKey: form.uniqueKey,
	                onMountCallback: () => {
	                    formActions.updateFormState({
	                        paymentProviderFormLoaded: false
	                    });
	                    void paymentProvider.loader(form, formState, formActions);
	                }
	            },
	            isValid: paymentProvider.internalSubmit(form) ? undefined : formState.paymentFormComplete && !formState.paymentProviderError
	        };
	    }
	};

	const regularPaymentElementIsPresent = form => form.parts.flatMap(part => part.sections)
	    .flatMap(section => section.elements)
	    .some(element => element.type === elementTypes.PAYMENT && element.config?.enabled !== false);
	const factory$l = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.MOBILE_PAYMENT,
	    create: (form, formState, formActions) => {
	        const paymentProvider = mobilePaymentServiceFor(form.organisationConfiguration.paymentProvider);
	        if (form.environment.previewMode) {
	            return null;
	        }
	        return {
	            component: paymentProvider.component,
	            props: {
	                isDisabled: formState.isBusy || formState.mobilePaymentService != null,
	                onMountCallback: () => paymentProvider.loader(form, formState, formActions),
	                // Minor-hack to prevent injecting the payment provider lib twice
	                disableCoreDependencyHeader: regularPaymentElementIsPresent(form)
	            }
	        };
	    }
	};

	/* src/components/elements/Checkbox.svelte generated by Svelte v4.2.12 */

	function create_fragment$R(ctx) {
		let input;
		let t0;
		let label_1;
		let div;
		let t1;
		let t2;
		let mounted;
		let dispose;

		let input_levels = [
			{ id: /*id*/ ctx[0] },
			{ name: /*name*/ ctx[1] },
			{ required: /*required*/ ctx[2] },
			{ disabled: /*disabled*/ ctx[3] },
			/*conditionalProps*/ ctx[8],
			{ type: "checkbox" },
			{ class: "zephr-form-checkbox" }
		];

		let input_data = {};

		for (let i = 0; i < input_levels.length; i += 1) {
			input_data = assign(input_data, input_levels[i]);
		}

		return {
			c() {
				input = element("input");
				t0 = space();
				label_1 = element("label");
				div = element("div");
				t1 = space();
				t2 = text(/*label*/ ctx[6]);
				set_attributes(input, input_data);
				toggle_class(input, "disabled", /*disabled*/ ctx[3]);
				toggle_class(input, "error", /*hasError*/ ctx[4]);
				toggle_class(input, "zephr-payment-form-checkbox", /*isPaymentForm*/ ctx[5]);
				toggle_class(input, "svelte-ud4i0a", true);
				attr(div, "class", "zephr-form-checkmark svelte-ud4i0a");
				toggle_class(div, "zephr-payment-form-checkmark", /*isPaymentForm*/ ctx[5]);
				toggle_class(div, "disabled", /*disabled*/ ctx[3]);
				toggle_class(div, "checked", /*checked*/ ctx[7]);
				toggle_class(div, "error", /*hasError*/ ctx[4]);
				attr(label_1, "for", /*id*/ ctx[0]);
				attr(label_1, "class", "zephr-form-checkbox-label svelte-ud4i0a");
				toggle_class(label_1, "zephr-payment-form-checkbox-label", /*isPaymentForm*/ ctx[5]);
			},
			m(target, anchor) {
				insert(target, input, anchor);
				if (input.autofocus) input.focus();
				insert(target, t0, anchor);
				insert(target, label_1, anchor);
				append(label_1, div);
				append(label_1, t1);
				append(label_1, t2);

				if (!mounted) {
					dispose = listen(input, "input", /*handleInputChange*/ ctx[9]);
					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				set_attributes(input, input_data = get_spread_update(input_levels, [
					dirty & /*id*/ 1 && { id: /*id*/ ctx[0] },
					dirty & /*name*/ 2 && { name: /*name*/ ctx[1] },
					dirty & /*required*/ 4 && { required: /*required*/ ctx[2] },
					dirty & /*disabled*/ 8 && { disabled: /*disabled*/ ctx[3] },
					dirty & /*conditionalProps*/ 256 && /*conditionalProps*/ ctx[8],
					{ type: "checkbox" },
					{ class: "zephr-form-checkbox" }
				]));

				toggle_class(input, "disabled", /*disabled*/ ctx[3]);
				toggle_class(input, "error", /*hasError*/ ctx[4]);
				toggle_class(input, "zephr-payment-form-checkbox", /*isPaymentForm*/ ctx[5]);
				toggle_class(input, "svelte-ud4i0a", true);

				if (dirty & /*isPaymentForm*/ 32) {
					toggle_class(div, "zephr-payment-form-checkmark", /*isPaymentForm*/ ctx[5]);
				}

				if (dirty & /*disabled*/ 8) {
					toggle_class(div, "disabled", /*disabled*/ ctx[3]);
				}

				if (dirty & /*checked*/ 128) {
					toggle_class(div, "checked", /*checked*/ ctx[7]);
				}

				if (dirty & /*hasError*/ 16) {
					toggle_class(div, "error", /*hasError*/ ctx[4]);
				}

				if (dirty & /*label*/ 64) set_data(t2, /*label*/ ctx[6]);

				if (dirty & /*id*/ 1) {
					attr(label_1, "for", /*id*/ ctx[0]);
				}

				if (dirty & /*isPaymentForm*/ 32) {
					toggle_class(label_1, "zephr-payment-form-checkbox-label", /*isPaymentForm*/ ctx[5]);
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(input);
					detach(t0);
					detach(label_1);
				}

				mounted = false;
				dispose();
			}
		};
	}

	function instance$Q($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { id } = $$props;
		let { name = id } = $$props;
		let { required = true } = $$props;
		let { disabled = false } = $$props;
		let { hasError = false } = $$props;
		let { isPaymentForm = false } = $$props;
		let { label = "" } = $$props;
		let { value } = $$props;
		let { placeholder = "" } = $$props;
		let { checked = false } = $$props;
		let { pattern = "" } = $$props;
		let conditionalProps = {};
		if (checked) conditionalProps.checked = checked;
		if (placeholder) conditionalProps.placeholder = placeholder;
		if (pattern) conditionalProps.pattern = pattern;
		if (value) conditionalProps.value = value;

		const handleInputChange = e => {
			dispatch("change", e.target.checked);
		};

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(0, id = $$props.id);
			if ('name' in $$props) $$invalidate(1, name = $$props.name);
			if ('required' in $$props) $$invalidate(2, required = $$props.required);
			if ('disabled' in $$props) $$invalidate(3, disabled = $$props.disabled);
			if ('hasError' in $$props) $$invalidate(4, hasError = $$props.hasError);
			if ('isPaymentForm' in $$props) $$invalidate(5, isPaymentForm = $$props.isPaymentForm);
			if ('label' in $$props) $$invalidate(6, label = $$props.label);
			if ('value' in $$props) $$invalidate(10, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(11, placeholder = $$props.placeholder);
			if ('checked' in $$props) $$invalidate(7, checked = $$props.checked);
			if ('pattern' in $$props) $$invalidate(12, pattern = $$props.pattern);
		};

		return [
			id,
			name,
			required,
			disabled,
			hasError,
			isPaymentForm,
			label,
			checked,
			conditionalProps,
			handleInputChange,
			value,
			placeholder,
			pattern
		];
	}

	class Checkbox extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$Q, create_fragment$R, safe_not_equal, {
				id: 0,
				name: 1,
				required: 2,
				disabled: 3,
				hasError: 4,
				isPaymentForm: 5,
				label: 6,
				value: 10,
				placeholder: 11,
				checked: 7,
				pattern: 12
			});
		}
	}

	/* src/components/elements/payment/PaymentAutoRenewToggle.svelte generated by Svelte v4.2.12 */

	function create_if_block$B(ctx) {
		let div;
		let checkbox;
		let current;

		checkbox = new Checkbox({
				props: {
					id: "payment-auto-renew-toggle-" + /*paymentOption*/ ctx[0].productId + "-" + /*paymentOption*/ ctx[0].slug,
					name: "payment-auto-renew-toggle",
					label: /*toggleLabel*/ ctx[3],
					value: "true",
					checked: /*checked*/ ctx[1],
					disabled: /*disabled*/ ctx[2],
					required: false
				}
			});

		checkbox.$on("change", /*handleChange*/ ctx[5]);

		return {
			c() {
				div = element("div");
				create_component(checkbox.$$.fragment);
				attr(div, "class", "zephr-form-payment-auto-renew-toggle svelte-1yfwddr");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(checkbox, div, null);
				current = true;
			},
			p(ctx, dirty) {
				const checkbox_changes = {};
				if (dirty & /*paymentOption*/ 1) checkbox_changes.id = "payment-auto-renew-toggle-" + /*paymentOption*/ ctx[0].productId + "-" + /*paymentOption*/ ctx[0].slug;
				if (dirty & /*toggleLabel*/ 8) checkbox_changes.label = /*toggleLabel*/ ctx[3];
				if (dirty & /*checked*/ 2) checkbox_changes.checked = /*checked*/ ctx[1];
				if (dirty & /*disabled*/ 4) checkbox_changes.disabled = /*disabled*/ ctx[2];
				checkbox.$set(checkbox_changes);
			},
			i(local) {
				if (current) return;
				transition_in(checkbox.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(checkbox.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(checkbox);
			}
		};
	}

	function create_fragment$Q(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*shouldShow*/ ctx[4] && create_if_block$B(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (/*shouldShow*/ ctx[4]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*shouldShow*/ 16) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$B(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	function instance$P($$self, $$props, $$invalidate) {
		let shouldShow;
		let toggleLabel;
		let { paymentOption } = $$props;
		let { checked = false } = $$props;
		let { disabled = false } = $$props;
		let { onChange } = $$props;

		const handleChange = event => {
			const isChecked = event.detail;
			onChange(isChecked);
		};

		$$self.$$set = $$props => {
			if ('paymentOption' in $$props) $$invalidate(0, paymentOption = $$props.paymentOption);
			if ('checked' in $$props) $$invalidate(1, checked = $$props.checked);
			if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
			if ('onChange' in $$props) $$invalidate(6, onChange = $$props.onChange);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*paymentOption*/ 1) {
				// Only show if the payment option is configured for custom toggle
				$$invalidate(4, shouldShow = paymentOption?.autoRenewConfig === 'custom_toggle' && paymentOption.type !== 'ONE_OFF');
			}

			if ($$self.$$.dirty & /*paymentOption*/ 1) {
				$$invalidate(3, toggleLabel = paymentOption?.autoRenewToggleLabel || 'Auto-renew subscription');
			}
		};

		return [
			paymentOption,
			checked,
			disabled,
			toggleLabel,
			shouldShow,
			handleChange,
			onChange
		];
	}

	class PaymentAutoRenewToggle extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$P, create_fragment$Q, safe_not_equal, {
				paymentOption: 0,
				checked: 1,
				disabled: 2,
				onChange: 6
			});
		}
	}

	const paymentAutoRenewToggleFactory = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.PAYMENT_AUTO_RENEW_TOGGLE,
	    create: (form, formState, formActions) => {
	        // Only show for Zuora billing payment forms
	        if (form.organisationConfiguration.paymentProvider !== 'zuora-billing') {
	            return null;
	        }
	        // Only show if there's a selected payment option
	        if (!formState.paymentOption) {
	            return null;
	        }
	        // Only show if the payment option is configured for custom toggle
	        if (formState.paymentOption.autoRenewConfig !== 'custom_toggle') {
	            return null;
	        }
	        // Don't show for one-off purchases
	        if (formState.paymentOption.type === 'ONE_OFF') {
	            return null;
	        }
	        const paymentOptionKey = `${formState.paymentOption.productId}-${formState.paymentOption.slug}`;
	        const handleToggleChange = (isChecked) => {
	            // Update the payment option specific autoRenew state
	            const updatedAutoRenewState = {
	                ...formState.paymentOptionAutoRenew,
	                [paymentOptionKey]: isChecked
	            };
	            formActions.updateFormState({
	                paymentOptionAutoRenew: updatedAutoRenewState
	            });
	            logDataLayerEvent(form, 'zephr_form_input_change', {
	                field: 'payment-auto-renew-toggle',
	                inputName: `payment-auto-renew-toggle-${formState.paymentOption.productId}-${formState.paymentOption.slug}`,
	                sectionId: formState.currentSection.type,
	            });
	        };
	        // Get the current checked state for this payment option
	        // State is now properly initialized when payment option is selected
	        const checkedState = formState.paymentOptionAutoRenew?.[paymentOptionKey] ?? false;
	        return {
	            component: PaymentAutoRenewToggle,
	            props: {
	                paymentOption: formState.paymentOption,
	                checked: checkedState,
	                disabled: formState.isBusy || formState.paymentProviderFormBusy || false,
	                onChange: handleToggleChange,
	            },
	            isValid: true,
	        };
	    },
	};

	var checkMarkImageBase64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGEAAABiCAYAAABAkr0NAAAJa0lEQVR4Xu2dT28TRxTA39oGUsHBiC/giKT/LiRHpBYIUPWQEmfVD9BwrQoJpZW4JbkhtRUO9E74AO3GQTkVCLSVOGIurVRCky/QkgNIodjezoxjsrZ3Zt7Mzu7OOraEkOLZ9Zv3m3lv/rx540BWPtc2S1Cvl6DplJjITb/1f/CTc7bAgW1w/G0oFLbg+vBWFqrnWCfkwmYRXtbH4HVuDPJwwp24MBNFRu9BtUbAERjOIzjUrMH3ow+jvC+OZ+2AQFv5q+Y0gF92z0+diaOiwXd691YJCKcKh3MrNvSW9CDQFv9Pk7TyZBTPA8t6iuMswVD+YVpAkofwzbMzUPdn3InpL+Ju8arv99bvLsNQbjFpGMlBoMp/7cwnYW5Uld9dnpmrQ/5iUv4jfgjfbo7BTuOGKeUzBeWpow35NPwi+WsRcn7RPVseiwwjoZ4RHwRq87fr8+5EeU5HGS1lw1PIE1t9AGpaJoI2gCaUoEFGWw3ntG5D8NarFRgqLGnJgKh8PBCI6XE/Lq8jfr+jiLe+ugQFfwWOFGqwMLyt+jyqfASfROS7CJWRZdTvKBQyC0Gj9Sdtfzt0c3VzGhpvplUGCaxXFAuLJhuJOQhkrO+enNzENgBSmUVSmYrJymB/u6fctT9LsJNfUILxeG3YlHkyA+HqxrR7asrDKMEq5XcLrAjD+3XVhR9GVjD1FpWJDuHy83n33IUFmSDM7Bx+cxGufxA+spG9IMnvFWB49+8uwM3ji1HEiwYBC8BQi4lSUa1nv96YcU9P3ZY9GxWEPgQEANb6j+VdK+y+TJO875G9IgoIPQgoAHevwK3jFd26W/fc3DPiuMvzIrl0QahDwAD4rTqR1JQ/UViI+Y8OCDUIlzdn3XOTwtbtPf6JDN0y4Hx16RHz5J78XDgU9+79TKzA+2grgIdAlgDcjyafCLtjvwNoVx4D4ve1cfhuuIZhjYOAmIj1fQ8ImVNIewRyQoeDcGljXbT4te8AIHsEGx3eGpmQ9QY5BIkj9hS6nUyYTH4vMdMY/yCGIDFD3r0+G4bqtgLJpM6TmCUxhNlnT3ibI2wNqDIqXa7QrVfmnpt7XiGRIbNhcsvMEh+CjG75D7kpy5wmIwhMl/Ff1Nf5jZa/F8FVpFv90OeJtG8dsYyRzD88WTsatoQTDkHgjAdmSEJCsLzB010vBJkzHpghMQViltzxyRdcKxLSG3ohCHxBXHussl6eue/Jtql7ajJ0kyusN/RAEPqCQS/AtwfBBNfr0mMnhEEvwCtZVlKw4ur9QrZFf9zbFu2EoEBPJsPge6IBjj675w17EAQOeeALNJvUpedz7vkLN0IncAEHvQdB9MB+8AU0PH+IHDAxGXQmGCkFHfQehNm/yRLFZz3xmyxSuXL8omZbsP+xrgmWzs6YsJKc5YygSWpBEJmift2qpPXmzHCNml+Rg941SS0IolFRv5oiwRKDd9+rws33yMkhMx/esL8NuwVh7q/lsBDAvjVFsjUewxBk+m1B4PqDeKKQzbQvzbdg9spNb1RJLI0DIg/ebxv3GADrayT8fXhZE3H4Y4LAAI/4BQdEjqOf/EFaAHaxcP0CGfg4wJkfyHaDjLaUuF+WMgBWvcsbK+65qXJ3VekWsQO8cSw9NVMZ0TrqFLdOld5vAwA2+Anf/qSnkxwRoczHktoCgELgWRwyEiPmKDymyMv6JM0mABTCV2SP4ZPePQbvwUrNETmMzAb12gaAQviShJF+Gh5GyocQ1/A0EFTMUhq8U3BNnf1ivsJGAFQuwTA1WQicSYssOArtiG0FYBUEzjCNyhgZhM0AsgIhEgjbAVgFAXPSBRlO/tZEZQGAVRDYpAVx9gsLIisAtCGYXkkMelcTILIEgNZdYAUc7jJ2V1gGeoSCLRgFRNYACCDQNbp0ly10QGQRgHTZIu0FPBUQWQUgXcATLCyZ3GcVWikMCJKaQZbExItjQwZrXmXluIFgdCnblk0dBAhRPa0GQAQXb+rYtL2pCcJ2AMKQIra9KaIUU7qxqKYp+Lz1AKiwvDUzsowNS++O2xnyguwRmQDAnLI4pMje4C8JiMwAQFiaFgSRX0hzh40DIksAhAOf3T2bQFQ2Z5sz7Q3/LhCZAiAyRbv+gBbZgyA6dcg5+ikbGhv7np4R3iGZf02HrhsTkP8i7tA0kA1hD4LIJA3SJ+jhEoU/BraPUcel+ioQTE+dWk/xe0Fn9pdOCJywDCpB5kNgtNQY4SGFQ5joI7SD3qAGROUocu9hcpGDzmp+UzX9RS+t0As6R0ftn9ZICxBd6v56g2pylvAEIxpJMvpLjRFqo5GcJRyCrDfEuf8cof6pP6qZnEUr6RQLXzxamDB65jd1DUYXQGiGBCvS4uxdojQL9DKHyuiV6KL3yRtEZog22qXRcV5NxRAkSVi9+6szcHPkTp+oUb8akszJskxpYghULEG6BTaJ2+/+QXYcF5GwUQ6BgZAlpzV3tYl+c0zhSZkjNpacltYNkxsaG7qYgq5i+UmDqatxPYHWAhPzs19AYAAomGk8BIR/YD6i30FgACgu/atBoFpGbML37YorJrQf4Yi7zaM6BCwIA7cuxWLLdV+KucBDAwAVRw8CFkRCF4jq6hX1HLs3uuHJ7u2MkrRXHwISBPMTaQSRoTQsKYS8xC8KgGg9oS0/wke0QKRz4bQWC3ZdfeO2rPW36hU9e360ntCuoSAjbrcSrIZBTc+/TXJ5k/wGRQbA0CaXGQhUIsSELgjEKhiKym8Nxc3domUOApWMXQXcJJfChV/mEGYaGIy8XzVxkaiy6dG4sp7dGV3ML5hcxjcLoa0F5J2Voaaq0LwTW04N2kheklvK6w65g3kq9NYPEci45j/xQNg1T7BzcE6lV3SYK3Y9vP8I8k4Ncvkt7J1lHUqkDvZNg1wND2fIvxMYRxveW823/uDvxAeh/SvIC0QxpoTt6DUdem38NoETfn18wy/pKrunZ9KGMJS/otUAMBXaLRM/hLYwGvZXoR5GiyZ9ZX1yEGLoGUY1T0c8dJAQp0/iCJw8hCCM/w4QW+3P8m5kMq3kUHtPTQ44VTiWWzY54lGRPT0IQSmp33h1kKRF9sum7LlwlNNW/OHcitGEVyqaD5S1A0K38Mx/5EgGe/805IijPVvuyWavUl9mZhrwFA41a3CkUEurxfNkthNCmLR0uFmvl8AvFMFvFKHpl3qK5Zwt9recvwWFwpYNrRzTWP4HK7laSxb9gaIAAAAASUVORK5CYII=";

	/* src/components/elements/successMessage/SuccessMessage.svelte generated by Svelte v4.2.12 */

	function create_fragment$P(ctx) {
		let div1;
		let img;
		let img_src_value;
		let t0;
		let div0;
		let t1;

		return {
			c() {
				div1 = element("div");
				img = element("img");
				t0 = space();
				div0 = element("div");
				t1 = text(/*text*/ ctx[0]);
				attr(img, "class", "check-image svelte-w5z6iw");
				if (!src_url_equal(img.src, img_src_value = checkMarkImageBase64)) attr(img, "src", img_src_value);
				attr(img, "alt", "Success indicator");
				attr(div0, "class", "zephr-form-success-message svelte-w5z6iw");
				toggle_class(div0, "zephr-payment-form-success-message", /*isPaymentForm*/ ctx[1]);
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, img);
				append(div1, t0);
				append(div1, div0);
				append(div0, t1);
			},
			p(ctx, [dirty]) {
				if (dirty & /*text*/ 1) set_data(t1, /*text*/ ctx[0]);

				if (dirty & /*isPaymentForm*/ 2) {
					toggle_class(div0, "zephr-payment-form-success-message", /*isPaymentForm*/ ctx[1]);
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(div1);
				}
			}
		};
	}

	function instance$O($$self, $$props, $$invalidate) {
		let { text } = $$props;
		let { isPaymentForm = false } = $$props;

		$$self.$$set = $$props => {
			if ('text' in $$props) $$invalidate(0, text = $$props.text);
			if ('isPaymentForm' in $$props) $$invalidate(1, isPaymentForm = $$props.isPaymentForm);
		};

		return [text, isPaymentForm];
	}

	class SuccessMessage extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$O, create_fragment$P, safe_not_equal, { text: 0, isPaymentForm: 1 });
		}
	}

	const factory$k = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.SUCCESS_MESSAGE,
	    create: (form, formState, formActions, elementConfig) => ({
	        component: SuccessMessage,
	        props: {
	            text: elementConfig?.text,
	            isPaymentForm: form.formType === FormType.PAYMENT,
	        }
	    })
	};

	const createTokenExchangePayload = (action, emailAddress) => {
	    return {
	        identifiers: {
	            email_address: emailAddress,
	        },
	        delivery: {
	            method: 'email',
	            destination: emailAddress,
	            action,
	            redirect: window.location.href.replace(window.location.origin, ''),
	        },
	    };
	};
	const sendLink = async (form, action, emailAddress, formActions) => {
	    try {
	        const response = await request('blaize/token-exchange', {
	            method: 'POST',
	            bodyObject: createTokenExchangePayload(action, emailAddress),
	        }, formActions);
	        if (!response.ok) {
	            formActions.updateFormState({
	                serverErrors: [ServerError.UNKNOWN],
	            });
	            logDataLayerEvent(form, 'zephr_form_error', {
	                error: ServerError[ServerError.UNKNOWN],
	            });
	        }
	    }
	    catch (err) {
	        formActions.updateFormState({
	            serverErrors: [ServerError.UNKNOWN],
	        });
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[ServerError.UNKNOWN],
	        });
	    }
	};

	const getFormIsPasswordless = (form) => {
	    return (form.formType === FormType.REGISTRATION &&
	        formConfigAs(form).usePassword === false &&
	        form.organisationConfiguration.requireEmailVerfication === true &&
	        formConfigAs(form).useVerificationCodes === false);
	};

	const onEmailEntered = async (form, formState, formActions) => {
	    return getUserInfo(formState, formActions)
	        .then(async (response) => {
	        if (response.redirected) {
	            window.location.replace(response.url);
	            return;
	        }
	        else {
	            const existsInAnyState = response.status === 200;
	            const formCanOtp = form.parts.flatMap(p => p.sections)
	                .some(s => s.type === sectionTypes.VERIFICATION_CODE_REGISTRATION.type);
	            const isContact = existsInAnyState ? ((await response.json()).contact) && formCanOtp : false;
	            const exists = existsInAnyState && !isContact;
	            formActions.updateFormState({
	                userExists: exists,
	                emailIsContact: isContact,
	            });
	            const isPasswordless = getFormIsPasswordless(form);
	            if (isPasswordless) {
	                if (exists) {
	                    void sendLink(form, 'login', formState.emailAddress, formActions);
	                    return jumpToSection(sectionTypes.PASSWORDLESS_VIA_LOGIN_LINK.type, form, formActions);
	                }
	                else {
	                    return moveToNextSection(form, formState, formActions);
	                }
	            }
	            if (isContact
	                || formConfigAs(form).useVerificationCodes
	                || form.organisationConfiguration.twoFactorEmailAuthenticationEnabled) {
	                void send2FaCode(form, formState, formActions);
	                return jumpToSection(exists ?
	                    sectionTypes.VERIFICATION_CODE_LOGIN.type : sectionTypes.VERIFICATION_CODE_REGISTRATION.type, form, formActions);
	            }
	            return jumpToSection(exists ?
	                sectionTypes.LOGIN_PASSWORD.type : sectionTypes.PASSWORD_SETUP.type, form, formActions);
	        }
	    });
	};
	const twoFactorPayload = (formState) => ({
	    identifiers: {
	        email_address: formState.emailAddress
	    },
	    delivery: {
	        method: "email",
	        destination: formState.emailAddress,
	        action: formState.userExists ? "login" : "register",
	        redirect: window.location.href.replace(window.location.origin, ""),
	    }
	});
	const send2FaCode = async (form, formState, formActions) => {
	    formActions.updateFormState({
	        verificationCode: "",
	        verificationCodeValid: undefined
	    });
	    const response = await request('blaize/two-factor-authentication', {
	        method: "POST",
	        bodyObject: twoFactorPayload(formState)
	    }, formActions);
	    if (!response.ok) {
	        formActions.updateFormState({
	            serverErrors: [ServerError.VERIFICATION_CODE_SEND_ERROR]
	        });
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[ServerError.MOBILE_PAYMENT_PROCESSING_ERROR],
	        });
	    }
	    return response.ok;
	};
	const getUserInfo = async (formState, formActions) => {
	    formActions.updateFormState({
	        password: "",
	        verificationCode: undefined,
	        verificationCodeValid: undefined,
	        forgotPassword: false
	    });
	    return await request('zephr/media/user/info', {
	        method: "POST",
	        bodyObject: { identifiers: { email_address: formState.emailAddress } }
	    }, formActions);
	};

	const verifyOtp = async (form, formState, formActions) => {
	    const response = await request('zephr/media/user/otp-check', {
	        method: "POST",
	        bodyObject: {
	            code: formState.verificationCode,
	            email: formState.emailAddress
	        }
	    }, formActions);
	    if (!response.ok) {
	        formActions.updateFormState({
	            verificationCodeValid: false,
	            serverErrors: [ServerError.VERIFICATION_CODE_INCORRECT]
	        });
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[ServerError.VERIFICATION_CODE_INCORRECT],
	        });
	        return;
	    }
	    formActions.updateFormState({
	        verificationCodeValid: false,
	        serverErrors: []
	    });
	    formActions.completeSection();
	};

	const postVerificationCodeDelaySeconds = 1.5;
	const waitAfterCode = async (form) => await new Promise(r => setTimeout(r, form.environment.reduceDelays ? 1 : (postVerificationCodeDelaySeconds * 1000)));

	const verifiyPasswordResetCode = async (form, formState, formActions) => {
	    formActions.incrementRequestCount();
	    formActions.updateFormState({
	        verificationCodeValid: undefined
	    });
	    const response = await request(`zephr/users/reset/${formState.verificationCode}`, {
	        method: "POST",
	        bodyObject: {
	            identifiers: {
	                email_address: formState.emailAddress,
	            },
	        }
	    }, formActions);
	    logDataLayerEvent(form, 'zephr_form_password_reset_code_validate', {
	        success: response?.ok
	    });
	    if (!response.ok) {
	        formActions.updateFormState({
	            serverErrors: [ServerError.VERIFICATION_CODE_INCORRECT]
	        });
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[ServerError.VERIFICATION_CODE_INCORRECT],
	        });
	        formActions.decrementRequestCount();
	        return Promise.resolve();
	    }
	    return waitAfterCode(form)
	        .then(() => {
	        formActions.decrementRequestCount();
	        formActions.jumpToSection(sectionTypes.PASSWORD_RESET.type);
	    });
	};
	const sendPasswordResetCode = async (form, formState, formActions) => {
	    formActions.updateFormState({
	        createPassword: "",
	        confirmCreatePassword: "",
	        forgotPassword: true,
	        verificationCode: "",
	    });
	    formActions.incrementRequestCount();
	    const response = await request('zephr/users/reset', {
	        method: "POST",
	        bodyObject: {
	            identifiers: {
	                email_address: formState.emailAddress,
	            },
	        }
	    }, formActions);
	    logDataLayerEvent(form, 'zephr_form_password_reset_code_sent', {
	        success: response?.ok
	    });
	    if (!response.ok) {
	        formActions.updateFormState({
	            serverErrors: [ServerError.PASSWORD_RESET_LINK_SEND_ERROR]
	        });
	        formActions.decrementRequestCount();
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[ServerError.PASSWORD_RESET_LINK_SEND_ERROR],
	        });
	        return Promise.resolve();
	    }
	    return waitAfterCode(form)
	        .then(() => {
	        formActions.decrementRequestCount();
	        formActions.jumpToSection(sectionTypes.FORGOT_PASSWORD.type);
	    });
	};
	const resetPassword = async (form, formState, formActions) => {
	    const response = await request(`zephr/users/reset/${formState.verificationCode}`, {
	        method: "POST",
	        bodyObject: {
	            identifiers: {
	                email_address: formState.emailAddress,
	            },
	            validators: {
	                password: formState.createPassword
	            }
	        }
	    }, formActions);
	    logDataLayerEvent(form, 'zephr_form_password_reset', {
	        success: response?.ok
	    });
	    if (!response.ok) {
	        formActions.updateFormState({
	            serverErrors: [ServerError.PASSWORD_RESET_ERROR]
	        });
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[ServerError.MOBILE_PAYMENT_PROCESSING_ERROR],
	        });
	        return Promise.resolve();
	    }
	    formActions.updateFormState({
	        verificationCode: "",
	        forgotPassword: false
	    });
	    return formActions.jumpToPartStart(partTypes.ACCOUNT_VERIFICATION.type);
	};

	/* src/components/elements/verificationCode/VerificationCode.svelte generated by Svelte v4.2.12 */

	function create_if_block_2$h(ctx) {
		let if_block_anchor;

		function select_block_type(ctx, dirty) {
			if (/*showMessage*/ ctx[14] && !/*error*/ ctx[5]) return create_if_block_3$c;
			return create_else_block$a;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_block.d(detaching);
			}
		};
	}

	// (53:6) {:else}
	function create_else_block$a(ctx) {
		let button;
		let t;
		let mounted;
		let dispose;

		return {
			c() {
				button = element("button");
				t = text(/*resendText*/ ctx[3]);
				attr(button, "class", "zephr-form-verification-resend-link svelte-1yj9ceh");
				toggle_class(button, "zephr-payment-form-verification-resend-link", /*isPaymentForm*/ ctx[9]);
			},
			m(target, anchor) {
				insert(target, button, anchor);
				append(button, t);

				if (!mounted) {
					dispose = listen(button, "click", /*click_handler*/ ctx[15]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*resendText*/ 8) set_data(t, /*resendText*/ ctx[3]);

				if (dirty & /*isPaymentForm*/ 512) {
					toggle_class(button, "zephr-payment-form-verification-resend-link", /*isPaymentForm*/ ctx[9]);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(button);
				}

				mounted = false;
				dispose();
			}
		};
	}

	// (46:6) {#if showMessage && !error}
	function create_if_block_3$c(ctx) {
		let div;
		let t;

		return {
			c() {
				div = element("div");
				t = text(/*resendMessage*/ ctx[2]);
				attr(div, "class", "zephr-form-verification-resend-text svelte-1yj9ceh");
				toggle_class(div, "zephr-payment-form-verification-resend-text", /*isPaymentForm*/ ctx[9]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty & /*resendMessage*/ 4) set_data(t, /*resendMessage*/ ctx[2]);

				if (dirty & /*isPaymentForm*/ 512) {
					toggle_class(div, "zephr-payment-form-verification-resend-text", /*isPaymentForm*/ ctx[9]);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (32:2) <Input     id="zephr-form-verification-code"     value={code}     {placeholder}     maxlength={6}     hasError={error != null}     errorMessage={error}     {isPaymentForm}     {disabled}     on:change={({ detail }) => !disabled && onChange(detail)}     onFocus={onFocus}     onBlur={onBlur}   >
	function create_default_slot$5(ctx) {
		let if_block_anchor;
		let if_block = /*resendText*/ ctx[3] && create_if_block_2$h(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, dirty) {
				if (/*resendText*/ ctx[3]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block_2$h(ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (74:4) {#if codeValid}
	function create_if_block_1$r(ctx) {
		let fa;
		let current;
		fa = new Fa({ props: { icon: faCheck } });

		return {
			c() {
				create_component(fa.$$.fragment);
			},
			m(target, anchor) {
				mount_component(fa, target, anchor);
				current = true;
			},
			i(local) {
				if (current) return;
				transition_in(fa.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(fa.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(fa, detaching);
			}
		};
	}

	// (77:4) {#if code && !codeValid && formBusy}
	function create_if_block$A(ctx) {
		let fa;
		let current;
		fa = new Fa({ props: { icon: faSpinner, spin: true } });

		return {
			c() {
				create_component(fa.$$.fragment);
			},
			m(target, anchor) {
				mount_component(fa, target, anchor);
				current = true;
			},
			i(local) {
				if (current) return;
				transition_in(fa.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(fa.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(fa, detaching);
			}
		};
	}

	function create_fragment$O(ctx) {
		let label_1;
		let t0;
		let div1;
		let input;
		let t1;
		let div0;
		let t2;
		let current;

		label_1 = new Label({
				props: {
					forInput: "zephr-form-verification-code",
					label: /*label*/ ctx[0],
					isPaymentForm: /*isPaymentForm*/ ctx[9]
				}
			});

		input = new Input({
				props: {
					id: "zephr-form-verification-code",
					value: /*code*/ ctx[8],
					placeholder: /*placeholder*/ ctx[1],
					maxlength: 6,
					hasError: /*error*/ ctx[5] != null,
					errorMessage: /*error*/ ctx[5],
					isPaymentForm: /*isPaymentForm*/ ctx[9],
					disabled: /*disabled*/ ctx[4],
					onFocus: /*onFocus*/ ctx[12],
					onBlur: /*onBlur*/ ctx[13],
					$$slots: { default: [create_default_slot$5] },
					$$scope: { ctx }
				}
			});

		input.$on("change", /*change_handler*/ ctx[16]);
		let if_block0 = /*codeValid*/ ctx[6] && create_if_block_1$r();
		let if_block1 = /*code*/ ctx[8] && !/*codeValid*/ ctx[6] && /*formBusy*/ ctx[7] && create_if_block$A();

		return {
			c() {
				create_component(label_1.$$.fragment);
				t0 = space();
				div1 = element("div");
				create_component(input.$$.fragment);
				t1 = space();
				div0 = element("div");
				if (if_block0) if_block0.c();
				t2 = space();
				if (if_block1) if_block1.c();
				attr(div0, "class", "zephr-form-input-inner-text");
				toggle_class(div0, "zephr-payment-form-input-inner-text", /*isPaymentForm*/ ctx[9]);
				attr(div1, "class", "zephr-form-relative-container zephr-form-verification-resend-link-container svelte-1yj9ceh");
				toggle_class(div1, "zephr-payment-form-relative-container", /*isPaymentForm*/ ctx[9]);
				toggle_class(div1, "zephr-payment-form-verification-resend-link-container", /*isPaymentForm*/ ctx[9]);
			},
			m(target, anchor) {
				mount_component(label_1, target, anchor);
				insert(target, t0, anchor);
				insert(target, div1, anchor);
				mount_component(input, div1, null);
				append(div1, t1);
				append(div1, div0);
				if (if_block0) if_block0.m(div0, null);
				append(div0, t2);
				if (if_block1) if_block1.m(div0, null);
				current = true;
			},
			p(ctx, [dirty]) {
				const label_1_changes = {};
				if (dirty & /*label*/ 1) label_1_changes.label = /*label*/ ctx[0];
				if (dirty & /*isPaymentForm*/ 512) label_1_changes.isPaymentForm = /*isPaymentForm*/ ctx[9];
				label_1.$set(label_1_changes);
				const input_changes = {};
				if (dirty & /*code*/ 256) input_changes.value = /*code*/ ctx[8];
				if (dirty & /*placeholder*/ 2) input_changes.placeholder = /*placeholder*/ ctx[1];
				if (dirty & /*error*/ 32) input_changes.hasError = /*error*/ ctx[5] != null;
				if (dirty & /*error*/ 32) input_changes.errorMessage = /*error*/ ctx[5];
				if (dirty & /*isPaymentForm*/ 512) input_changes.isPaymentForm = /*isPaymentForm*/ ctx[9];
				if (dirty & /*disabled*/ 16) input_changes.disabled = /*disabled*/ ctx[4];
				if (dirty & /*onFocus*/ 4096) input_changes.onFocus = /*onFocus*/ ctx[12];
				if (dirty & /*onBlur*/ 8192) input_changes.onBlur = /*onBlur*/ ctx[13];

				if (dirty & /*$$scope, isPaymentForm, resendMessage, showMessage, error, onResendVerificationCode, resendText*/ 150060) {
					input_changes.$$scope = { dirty, ctx };
				}

				input.$set(input_changes);

				if (/*codeValid*/ ctx[6]) {
					if (if_block0) {
						if (dirty & /*codeValid*/ 64) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_1$r();
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div0, t2);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*code*/ ctx[8] && !/*codeValid*/ ctx[6] && /*formBusy*/ ctx[7]) {
					if (if_block1) {
						if (dirty & /*code, codeValid, formBusy*/ 448) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block$A();
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div0, null);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (!current || dirty & /*isPaymentForm*/ 512) {
					toggle_class(div0, "zephr-payment-form-input-inner-text", /*isPaymentForm*/ ctx[9]);
				}

				if (!current || dirty & /*isPaymentForm*/ 512) {
					toggle_class(div1, "zephr-payment-form-relative-container", /*isPaymentForm*/ ctx[9]);
				}

				if (!current || dirty & /*isPaymentForm*/ 512) {
					toggle_class(div1, "zephr-payment-form-verification-resend-link-container", /*isPaymentForm*/ ctx[9]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(label_1.$$.fragment, local);
				transition_in(input.$$.fragment, local);
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(label_1.$$.fragment, local);
				transition_out(input.$$.fragment, local);
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(div1);
				}

				destroy_component(label_1, detaching);
				destroy_component(input);
				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
			}
		};
	}

	function instance$N($$self, $$props, $$invalidate) {
		let { label } = $$props;
		let { placeholder } = $$props;
		let { resendMessage = null } = $$props;
		let { resendText = null } = $$props;
		let { disabled } = $$props;
		let { error = null } = $$props;
		let { codeValid } = $$props;
		let { formBusy } = $$props;
		let { code } = $$props;
		let { isPaymentForm = false } = $$props;
		let { onChange } = $$props;
		let { onResendVerificationCode } = $$props;
		let { onFocus } = $$props;
		let { onBlur } = $$props;
		let showMessage = false;

		const click_handler = () => {
			if (resendMessage) {
				$$invalidate(14, showMessage = true);
				setTimeout(() => $$invalidate(14, showMessage = false), 2000);
			}

			onResendVerificationCode();
		};

		const change_handler = ({ detail }) => !disabled && onChange(detail);

		$$self.$$set = $$props => {
			if ('label' in $$props) $$invalidate(0, label = $$props.label);
			if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
			if ('resendMessage' in $$props) $$invalidate(2, resendMessage = $$props.resendMessage);
			if ('resendText' in $$props) $$invalidate(3, resendText = $$props.resendText);
			if ('disabled' in $$props) $$invalidate(4, disabled = $$props.disabled);
			if ('error' in $$props) $$invalidate(5, error = $$props.error);
			if ('codeValid' in $$props) $$invalidate(6, codeValid = $$props.codeValid);
			if ('formBusy' in $$props) $$invalidate(7, formBusy = $$props.formBusy);
			if ('code' in $$props) $$invalidate(8, code = $$props.code);
			if ('isPaymentForm' in $$props) $$invalidate(9, isPaymentForm = $$props.isPaymentForm);
			if ('onChange' in $$props) $$invalidate(10, onChange = $$props.onChange);
			if ('onResendVerificationCode' in $$props) $$invalidate(11, onResendVerificationCode = $$props.onResendVerificationCode);
			if ('onFocus' in $$props) $$invalidate(12, onFocus = $$props.onFocus);
			if ('onBlur' in $$props) $$invalidate(13, onBlur = $$props.onBlur);
		};

		return [
			label,
			placeholder,
			resendMessage,
			resendText,
			disabled,
			error,
			codeValid,
			formBusy,
			code,
			isPaymentForm,
			onChange,
			onResendVerificationCode,
			onFocus,
			onBlur,
			showMessage,
			click_handler,
			change_handler
		];
	}

	class VerificationCode extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$N, create_fragment$O, safe_not_equal, {
				label: 0,
				placeholder: 1,
				resendMessage: 2,
				resendText: 3,
				disabled: 4,
				error: 5,
				codeValid: 6,
				formBusy: 7,
				code: 8,
				isPaymentForm: 9,
				onChange: 10,
				onResendVerificationCode: 11,
				onFocus: 12,
				onBlur: 13
			});
		}
	}

	const verificationCodeLength = 6;
	const isPossiblyValidCode = code => code?.length === verificationCodeLength;
	const checkUserAttributesValid = (formState) => {
	    return !formState.elementValidity
	        .filter((e) => e.partType === formState.currentPart.type &&
	        e.sectionType === formState.currentSection.type &&
	        e.sectionOrder === formState.currentSection.order &&
	        e.elementType === 'user_attribute')
	        .some((e) => !e.isValid);
	};
	const factory$j = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.VERIFICATION_CODE,
	    create: (form, formState, formActions, elementConfig) => ({
	        component: VerificationCode,
	        props: {
	            code: formState.verificationCode,
	            label: elementConfig.label,
	            placeholder: elementConfig.placeholder,
	            resendMessage: elementConfig.message,
	            resendText: elementConfig.resendText,
	            disabled: formState.isBusy || formState.verificationCodeValid || !checkUserAttributesValid(formState),
	            codeValid: formState.verificationCodeValid,
	            formBusy: formState.isBusy,
	            isPaymentForm: form.formType === FormType.PAYMENT,
	            onResendVerificationCode: () => {
	                void (formState.currentSection.type === sectionTypes.FORGOT_PASSWORD.type ? sendPasswordResetCode : send2FaCode)(form, formState, formActions);
	            },
	            onChange: (value) => {
	                const updatedState = formActions.updateFormState({
	                    verificationCodeValid: undefined,
	                    verificationCode: value,
	                    serverErrors: []
	                });
	                const userAttributesValid = checkUserAttributesValid(formState);
	                formActions.updateFormState({
	                    showFieldErrors: !userAttributesValid
	                });
	                if (isPossiblyValidCode(value)) {
	                    if (elementConfig.verificationEvent) {
	                        formActions.onEvent(elementConfig.verificationEvent);
	                        return;
	                    }
	                    if (formState.currentSection.type === sectionTypes.FORGOT_PASSWORD.type) {
	                        formActions.completeSection();
	                    }
	                    else if (userAttributesValid) {
	                        void verifyOtp(form, updatedState, formActions);
	                    }
	                }
	                logDataLayerEvent(form, 'zephr_form_input_change', {
	                    inputName: 'zephr-form-verification-code',
	                    sectionId: formState.currentSection.type,
	                    field: 'verification-code'
	                });
	            },
	            onFocus: () => logDataLayerEvent(form, 'zephr_form_input_focus', {
	                inputName: 'zephr-form-verification-code',
	                sectionId: formState.currentSection.type,
	                field: 'verification-code'
	            }),
	            onBlur: () => logDataLayerEvent(form, 'zephr_form_input_blur', {
	                inputName: 'zephr-form-verification-code',
	                sectionId: formState.currentSection.type,
	                field: 'verification-code'
	            }),
	        },
	        isValid: isPossiblyValidCode(formState.verificationCode)
	    })
	};

	/* src/components/elements/text/Text.svelte generated by Svelte v4.2.12 */

	function create_fragment$N(ctx) {
		let div;

		return {
			c() {
				div = element("div");
				attr(div, "class", "zephr-form-custom-text svelte-3sd7s2");
				set_style(div, "text-align", /*centerText*/ ctx[1] ? 'center' : 'initial');
				toggle_class(div, "zephr-payment-form-custom-text", /*isPaymentForm*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				div.innerHTML = /*text*/ ctx[0];
			},
			p(ctx, [dirty]) {
				if (dirty & /*text*/ 1) div.innerHTML = /*text*/ ctx[0];
				if (dirty & /*centerText*/ 2) {
					set_style(div, "text-align", /*centerText*/ ctx[1] ? 'center' : 'initial');
				}

				if (dirty & /*isPaymentForm*/ 4) {
					toggle_class(div, "zephr-payment-form-custom-text", /*isPaymentForm*/ ctx[2]);
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	function instance$M($$self, $$props, $$invalidate) {
		let { text } = $$props;
		let { centerText = false } = $$props;
		let { isPaymentForm = false } = $$props;

		$$self.$$set = $$props => {
			if ('text' in $$props) $$invalidate(0, text = $$props.text);
			if ('centerText' in $$props) $$invalidate(1, centerText = $$props.centerText);
			if ('isPaymentForm' in $$props) $$invalidate(2, isPaymentForm = $$props.isPaymentForm);
		};

		return [text, centerText, isPaymentForm];
	}

	class Text extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$M, create_fragment$N, safe_not_equal, { text: 0, centerText: 1, isPaymentForm: 2 });
		}
	}

	const factory$i = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.TEXT,
	    create: (form, formState, formActions, elementConfig) => ({
	        component: Text,
	        props: {
	            text: elementConfig.text,
	            centerText: elementConfig.centerText,
	            isPaymentForm: form.formType === FormType.PAYMENT,
	        }
	    })
	};

	/* src/components/elements/Radio.svelte generated by Svelte v4.2.12 */

	function create_fragment$M(ctx) {
		let input;
		let t0;
		let label_1;
		let span;
		let t1;
		let t2;
		let mounted;
		let dispose;

		let input_levels = [
			{ id: /*id*/ ctx[0] },
			{ name: /*name*/ ctx[1] },
			{ required: /*required*/ ctx[2] },
			{ disabled: /*disabled*/ ctx[3] },
			/*conditionalProps*/ ctx[8],
			{ type: "radio" },
			{ class: "zephr-form-input-radio" }
		];

		let input_data = {};

		for (let i = 0; i < input_levels.length; i += 1) {
			input_data = assign(input_data, input_levels[i]);
		}

		return {
			c() {
				input = element("input");
				t0 = space();
				label_1 = element("label");
				span = element("span");
				t1 = space();
				t2 = text(/*label*/ ctx[6]);
				set_attributes(input, input_data);
				toggle_class(input, "zephr-payment-form-input-radio", /*isPaymentForm*/ ctx[5]);
				toggle_class(input, "disabled", /*disabled*/ ctx[3]);
				toggle_class(input, "error", /*hasError*/ ctx[4]);
				toggle_class(input, "svelte-1cbmaif", true);
				attr(span, "class", "zephr-form-radio-dot svelte-1cbmaif");
				toggle_class(span, "zephr-payment-form-radio-dot", /*isPaymentForm*/ ctx[5]);
				toggle_class(span, "disabled", /*disabled*/ ctx[3]);
				toggle_class(span, "checked", /*checked*/ ctx[7]);
				toggle_class(span, "error", /*hasError*/ ctx[4]);
				attr(label_1, "for", /*id*/ ctx[0]);
				attr(label_1, "class", "zephr-form-radio-label svelte-1cbmaif");
				toggle_class(label_1, "zephr-payment-form-radio-label", /*isPaymentForm*/ ctx[5]);
			},
			m(target, anchor) {
				insert(target, input, anchor);
				if (input.autofocus) input.focus();
				insert(target, t0, anchor);
				insert(target, label_1, anchor);
				append(label_1, span);
				append(label_1, t1);
				append(label_1, t2);

				if (!mounted) {
					dispose = listen(input, "input", /*handleInputChange*/ ctx[9]);
					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				set_attributes(input, input_data = get_spread_update(input_levels, [
					dirty & /*id*/ 1 && { id: /*id*/ ctx[0] },
					dirty & /*name*/ 2 && { name: /*name*/ ctx[1] },
					dirty & /*required*/ 4 && { required: /*required*/ ctx[2] },
					dirty & /*disabled*/ 8 && { disabled: /*disabled*/ ctx[3] },
					dirty & /*conditionalProps*/ 256 && /*conditionalProps*/ ctx[8],
					{ type: "radio" },
					{ class: "zephr-form-input-radio" }
				]));

				toggle_class(input, "zephr-payment-form-input-radio", /*isPaymentForm*/ ctx[5]);
				toggle_class(input, "disabled", /*disabled*/ ctx[3]);
				toggle_class(input, "error", /*hasError*/ ctx[4]);
				toggle_class(input, "svelte-1cbmaif", true);

				if (dirty & /*isPaymentForm*/ 32) {
					toggle_class(span, "zephr-payment-form-radio-dot", /*isPaymentForm*/ ctx[5]);
				}

				if (dirty & /*disabled*/ 8) {
					toggle_class(span, "disabled", /*disabled*/ ctx[3]);
				}

				if (dirty & /*checked*/ 128) {
					toggle_class(span, "checked", /*checked*/ ctx[7]);
				}

				if (dirty & /*hasError*/ 16) {
					toggle_class(span, "error", /*hasError*/ ctx[4]);
				}

				if (dirty & /*label*/ 64) set_data(t2, /*label*/ ctx[6]);

				if (dirty & /*id*/ 1) {
					attr(label_1, "for", /*id*/ ctx[0]);
				}

				if (dirty & /*isPaymentForm*/ 32) {
					toggle_class(label_1, "zephr-payment-form-radio-label", /*isPaymentForm*/ ctx[5]);
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(input);
					detach(t0);
					detach(label_1);
				}

				mounted = false;
				dispose();
			}
		};
	}

	function instance$L($$self, $$props, $$invalidate) {
		const dispatch = createEventDispatcher();
		let { id } = $$props;
		let { name = id } = $$props;
		let { required = true } = $$props;
		let { disabled = false } = $$props;
		let { hasError = false } = $$props;
		let { isPaymentForm = false } = $$props;
		let { label = "" } = $$props;
		let { value } = $$props;
		let { placeholder = "" } = $$props;
		let { checked = false } = $$props;
		let { pattern = "" } = $$props;
		let conditionalProps = {};
		if (checked) conditionalProps.checked = checked;
		if (placeholder) conditionalProps.placeholder = placeholder;
		if (pattern) conditionalProps.pattern = pattern;
		if (value) conditionalProps.value = value;

		const handleInputChange = e => {
			dispatch("change", e.target.value);
		};

		$$self.$$set = $$props => {
			if ('id' in $$props) $$invalidate(0, id = $$props.id);
			if ('name' in $$props) $$invalidate(1, name = $$props.name);
			if ('required' in $$props) $$invalidate(2, required = $$props.required);
			if ('disabled' in $$props) $$invalidate(3, disabled = $$props.disabled);
			if ('hasError' in $$props) $$invalidate(4, hasError = $$props.hasError);
			if ('isPaymentForm' in $$props) $$invalidate(5, isPaymentForm = $$props.isPaymentForm);
			if ('label' in $$props) $$invalidate(6, label = $$props.label);
			if ('value' in $$props) $$invalidate(10, value = $$props.value);
			if ('placeholder' in $$props) $$invalidate(11, placeholder = $$props.placeholder);
			if ('checked' in $$props) $$invalidate(7, checked = $$props.checked);
			if ('pattern' in $$props) $$invalidate(12, pattern = $$props.pattern);
		};

		return [
			id,
			name,
			required,
			disabled,
			hasError,
			isPaymentForm,
			label,
			checked,
			conditionalProps,
			handleInputChange,
			value,
			placeholder,
			pattern
		];
	}

	class Radio extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$L, create_fragment$M, safe_not_equal, {
				id: 0,
				name: 1,
				required: 2,
				disabled: 3,
				hasError: 4,
				isPaymentForm: 5,
				label: 6,
				value: 10,
				placeholder: 11,
				checked: 7,
				pattern: 12
			});
		}
	}

	/* src/components/elements/userAttribute/UserAttribute.svelte generated by Svelte v4.2.12 */

	function get_each_context_1$4(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[19] = list[i];
		return child_ctx;
	}

	function get_each_context$d(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[19] = list[i];
		return child_ctx;
	}

	// (120:2) {:else}
	function create_else_block$9(ctx) {
		let input;
		let current;

		input = new Input({
				props: {
					id: /*id*/ ctx[10],
					name: /*config*/ ctx[0].slug,
					required: /*config*/ ctx[0].required || /*attributeSchema*/ ctx[1]?.required,
					type: /*attributeSchema*/ ctx[1]?.["input-type"],
					value: /*value*/ ctx[2],
					checked: /*attributeSchema*/ ctx[1]?.["input-type"] === "checkbox" && /*value*/ ctx[2],
					pattern: /*attributeSchema*/ ctx[1]?.["validation-expression"],
					placeholder: /*config*/ ctx[0].placeholder,
					hasError: /*hasError*/ ctx[8],
					isPaymentForm: /*isPaymentForm*/ ctx[3],
					onFocus: /*onFocus*/ ctx[5],
					onBlur: /*onBlur*/ ctx[6]
				}
			});

		input.$on("change", /*change_handler_4*/ ctx[18]);

		return {
			c() {
				create_component(input.$$.fragment);
			},
			m(target, anchor) {
				mount_component(input, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const input_changes = {};
				if (dirty & /*config*/ 1) input_changes.name = /*config*/ ctx[0].slug;
				if (dirty & /*config, attributeSchema*/ 3) input_changes.required = /*config*/ ctx[0].required || /*attributeSchema*/ ctx[1]?.required;
				if (dirty & /*attributeSchema*/ 2) input_changes.type = /*attributeSchema*/ ctx[1]?.["input-type"];
				if (dirty & /*value*/ 4) input_changes.value = /*value*/ ctx[2];
				if (dirty & /*attributeSchema, value*/ 6) input_changes.checked = /*attributeSchema*/ ctx[1]?.["input-type"] === "checkbox" && /*value*/ ctx[2];
				if (dirty & /*attributeSchema*/ 2) input_changes.pattern = /*attributeSchema*/ ctx[1]?.["validation-expression"];
				if (dirty & /*config*/ 1) input_changes.placeholder = /*config*/ ctx[0].placeholder;
				if (dirty & /*hasError*/ 256) input_changes.hasError = /*hasError*/ ctx[8];
				if (dirty & /*isPaymentForm*/ 8) input_changes.isPaymentForm = /*isPaymentForm*/ ctx[3];
				if (dirty & /*onFocus*/ 32) input_changes.onFocus = /*onFocus*/ ctx[5];
				if (dirty & /*onBlur*/ 64) input_changes.onBlur = /*onBlur*/ ctx[6];
				input.$set(input_changes);
			},
			i(local) {
				if (current) return;
				transition_in(input.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(input.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(input, detaching);
			}
		};
	}

	// (93:56) 
	function create_if_block_5$7(ctx) {
		let div;
		let input;
		let t;
		let current;

		input = new Input({
				props: {
					id: /*id*/ ctx[10],
					required: /*config*/ ctx[0].required || /*attributeSchema*/ ctx[1]?.required,
					type: /*attributeSchema*/ ctx[1]["input-type"],
					value: /*value*/ ctx[2],
					min: /*attributeSchema*/ ctx[1]["range-start"],
					max: /*attributeSchema*/ ctx[1]["range-end"],
					step: /*attributeSchema*/ ctx[1]["range-start"],
					isPaymentForm: /*isPaymentForm*/ ctx[3],
					onFocus: /*onFocus*/ ctx[5],
					onBlur: /*onBlur*/ ctx[6]
				}
			});

		input.$on("change", /*change_handler_3*/ ctx[17]);
		let if_block = /*attributeSchema*/ ctx[1]["input-type"] === "range" && /*value*/ ctx[2] != null && create_if_block_6$7(ctx);

		return {
			c() {
				div = element("div");
				create_component(input.$$.fragment);
				t = space();
				if (if_block) if_block.c();
				attr(div, "class", "zephr-form-flex-container");
				toggle_class(div, "zephr-payment-form-flex-container", /*isPaymentForm*/ ctx[3]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(input, div, null);
				append(div, t);
				if (if_block) if_block.m(div, null);
				current = true;
			},
			p(ctx, dirty) {
				const input_changes = {};
				if (dirty & /*config, attributeSchema*/ 3) input_changes.required = /*config*/ ctx[0].required || /*attributeSchema*/ ctx[1]?.required;
				if (dirty & /*attributeSchema*/ 2) input_changes.type = /*attributeSchema*/ ctx[1]["input-type"];
				if (dirty & /*value*/ 4) input_changes.value = /*value*/ ctx[2];
				if (dirty & /*attributeSchema*/ 2) input_changes.min = /*attributeSchema*/ ctx[1]["range-start"];
				if (dirty & /*attributeSchema*/ 2) input_changes.max = /*attributeSchema*/ ctx[1]["range-end"];
				if (dirty & /*attributeSchema*/ 2) input_changes.step = /*attributeSchema*/ ctx[1]["range-start"];
				if (dirty & /*isPaymentForm*/ 8) input_changes.isPaymentForm = /*isPaymentForm*/ ctx[3];
				if (dirty & /*onFocus*/ 32) input_changes.onFocus = /*onFocus*/ ctx[5];
				if (dirty & /*onBlur*/ 64) input_changes.onBlur = /*onBlur*/ ctx[6];
				input.$set(input_changes);

				if (/*attributeSchema*/ ctx[1]["input-type"] === "range" && /*value*/ ctx[2] != null) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block_6$7(ctx);
						if_block.c();
						if_block.m(div, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (!current || dirty & /*isPaymentForm*/ 8) {
					toggle_class(div, "zephr-payment-form-flex-container", /*isPaymentForm*/ ctx[3]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(input.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(input.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(input);
				if (if_block) if_block.d();
			}
		};
	}

	// (84:59) 
	function create_if_block_4$9(ctx) {
		let textarea;
		let textarea_required_value;
		let textarea_placeholder_value;
		let mounted;
		let dispose;

		return {
			c() {
				textarea = element("textarea");
				attr(textarea, "id", /*id*/ ctx[10]);
				attr(textarea, "class", "zephr-form-input zephr-form-input-textarea svelte-wlae04");
				textarea.required = textarea_required_value = /*config*/ ctx[0].required || /*attributeSchema*/ ctx[1]?.required;
				attr(textarea, "placeholder", textarea_placeholder_value = /*config*/ ctx[0].placeholder);
				toggle_class(textarea, "zephr-payment-form-input", /*isPaymentForm*/ ctx[3]);
				toggle_class(textarea, "zephr-payment-form-input-textarea", /*isPaymentForm*/ ctx[3]);
			},
			m(target, anchor) {
				insert(target, textarea, anchor);
				set_input_value(textarea, /*currentValue*/ ctx[7]);

				if (!mounted) {
					dispose = listen(textarea, "input", /*textarea_input_handler*/ ctx[16]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*config, attributeSchema*/ 3 && textarea_required_value !== (textarea_required_value = /*config*/ ctx[0].required || /*attributeSchema*/ ctx[1]?.required)) {
					textarea.required = textarea_required_value;
				}

				if (dirty & /*config*/ 1 && textarea_placeholder_value !== (textarea_placeholder_value = /*config*/ ctx[0].placeholder)) {
					attr(textarea, "placeholder", textarea_placeholder_value);
				}

				if (dirty & /*currentValue*/ 128) {
					set_input_value(textarea, /*currentValue*/ ctx[7]);
				}

				if (dirty & /*isPaymentForm*/ 8) {
					toggle_class(textarea, "zephr-payment-form-input", /*isPaymentForm*/ ctx[3]);
				}

				if (dirty & /*isPaymentForm*/ 8) {
					toggle_class(textarea, "zephr-payment-form-input-textarea", /*isPaymentForm*/ ctx[3]);
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(textarea);
				}

				mounted = false;
				dispose();
			}
		};
	}

	// (64:57) 
	function create_if_block_3$b(ctx) {
		let select;
		let option_1;
		let t_value = (/*config*/ ctx[0].placeholder ?? "") + "";
		let t;
		let select_name_value;
		let select_required_value;
		let select_value_value;
		let mounted;
		let dispose;
		let each_value_1 = ensure_array_like(/*attributeSchema*/ ctx[1]?.["select-options"]);
		let each_blocks = [];

		for (let i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
		}

		return {
			c() {
				select = element("select");
				option_1 = element("option");
				t = text(t_value);

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				option_1.disabled = true;
				option_1.__value = "";
				set_input_value(option_1, option_1.__value);
				attr(select, "id", /*id*/ ctx[10]);
				attr(select, "name", select_name_value = /*config*/ ctx[0].slug);
				attr(select, "class", "zephr-form-input zephr-form-input-select svelte-wlae04");
				select.required = select_required_value = /*config*/ ctx[0].required || /*attributeSchema*/ ctx[1]?.required;
				toggle_class(select, "zephr-payment-form-input", /*isPaymentForm*/ ctx[3]);
				toggle_class(select, "zephr-payment-form-input-select", /*isPaymentForm*/ ctx[3]);
				toggle_class(select, "unselected", !/*value*/ ctx[2]);
				toggle_class(select, "error", /*hasError*/ ctx[8]);
			},
			m(target, anchor) {
				insert(target, select, anchor);
				append(select, option_1);
				append(option_1, t);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(select, null);
					}
				}

				select_option(select, /*value*/ ctx[2] ?? "");

				if (!mounted) {
					dispose = listen(select, "change", /*change_handler_2*/ ctx[15]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*config*/ 1 && t_value !== (t_value = (/*config*/ ctx[0].placeholder ?? "") + "")) set_data(t, t_value);

				if (dirty & /*attributeSchema, value*/ 6) {
					each_value_1 = ensure_array_like(/*attributeSchema*/ ctx[1]?.["select-options"]);
					let i;

					for (i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block_1$4(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(select, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value_1.length;
				}

				if (dirty & /*config*/ 1 && select_name_value !== (select_name_value = /*config*/ ctx[0].slug)) {
					attr(select, "name", select_name_value);
				}

				if (dirty & /*config, attributeSchema*/ 3 && select_required_value !== (select_required_value = /*config*/ ctx[0].required || /*attributeSchema*/ ctx[1]?.required)) {
					select.required = select_required_value;
				}

				if (dirty & /*value, attributeSchema*/ 6 && select_value_value !== (select_value_value = /*value*/ ctx[2] ?? "")) {
					select_option(select, /*value*/ ctx[2] ?? "");
				}

				if (dirty & /*isPaymentForm*/ 8) {
					toggle_class(select, "zephr-payment-form-input", /*isPaymentForm*/ ctx[3]);
				}

				if (dirty & /*isPaymentForm*/ 8) {
					toggle_class(select, "zephr-payment-form-input-select", /*isPaymentForm*/ ctx[3]);
				}

				if (dirty & /*value*/ 4) {
					toggle_class(select, "unselected", !/*value*/ ctx[2]);
				}

				if (dirty & /*hasError*/ 256) {
					toggle_class(select, "error", /*hasError*/ ctx[8]);
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(select);
				}

				destroy_each(each_blocks, detaching);
				mounted = false;
				dispose();
			}
		};
	}

	// (48:59) 
	function create_if_block_2$g(ctx) {
		let checkbox;
		let current;

		checkbox = new Checkbox({
				props: {
					id: /*id*/ ctx[10],
					name: /*config*/ ctx[0].slug,
					label: `${/*config*/ ctx[0].label}${/*config*/ ctx[0].required || /*attributeSchema*/ ctx[1]?.required
				? "*"
				: ""}`,
					required: /*config*/ ctx[0].required || /*attributeSchema*/ ctx[1]?.required,
					value: /*value*/ ctx[2],
					checked: /*value*/ ctx[2],
					pattern: /*attributeSchema*/ ctx[1]?.["validation-expression"],
					placeholder: /*config*/ ctx[0].placeholder,
					hasError: /*hasError*/ ctx[8],
					isPaymentForm: /*isPaymentForm*/ ctx[3]
				}
			});

		checkbox.$on("change", /*change_handler_1*/ ctx[14]);

		return {
			c() {
				create_component(checkbox.$$.fragment);
			},
			m(target, anchor) {
				mount_component(checkbox, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const checkbox_changes = {};
				if (dirty & /*config*/ 1) checkbox_changes.name = /*config*/ ctx[0].slug;

				if (dirty & /*config, attributeSchema*/ 3) checkbox_changes.label = `${/*config*/ ctx[0].label}${/*config*/ ctx[0].required || /*attributeSchema*/ ctx[1]?.required
			? "*"
			: ""}`;

				if (dirty & /*config, attributeSchema*/ 3) checkbox_changes.required = /*config*/ ctx[0].required || /*attributeSchema*/ ctx[1]?.required;
				if (dirty & /*value*/ 4) checkbox_changes.value = /*value*/ ctx[2];
				if (dirty & /*value*/ 4) checkbox_changes.checked = /*value*/ ctx[2];
				if (dirty & /*attributeSchema*/ 2) checkbox_changes.pattern = /*attributeSchema*/ ctx[1]?.["validation-expression"];
				if (dirty & /*config*/ 1) checkbox_changes.placeholder = /*config*/ ctx[0].placeholder;
				if (dirty & /*hasError*/ 256) checkbox_changes.hasError = /*hasError*/ ctx[8];
				if (dirty & /*isPaymentForm*/ 8) checkbox_changes.isPaymentForm = /*isPaymentForm*/ ctx[3];
				checkbox.$set(checkbox_changes);
			},
			i(local) {
				if (current) return;
				transition_in(checkbox.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(checkbox.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(checkbox, detaching);
			}
		};
	}

	// (34:2) {#if attributeSchema?.["input-type"] === "radio"}
	function create_if_block_1$q(ctx) {
		let each_1_anchor;
		let current;
		let each_value = ensure_array_like(/*attributeSchema*/ ctx[1]?.["select-options"]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*id, attributeSchema, config, value, hasError, isPaymentForm, onChange*/ 1311) {
					each_value = ensure_array_like(/*attributeSchema*/ ctx[1]?.["select-options"]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$d(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$d(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (111:6) {#if attributeSchema["input-type"] === "range" && value != null}
	function create_if_block_6$7(ctx) {
		let output;
		let t;

		return {
			c() {
				output = element("output");
				t = text(/*value*/ ctx[2]);
				attr(output, "class", "zephr-form-input-slider-output svelte-wlae04");
				toggle_class(output, "zephr-payment-form-input-slider-output", /*isPaymentForm*/ ctx[3]);
			},
			m(target, anchor) {
				insert(target, output, anchor);
				append(output, t);
			},
			p(ctx, dirty) {
				if (dirty & /*value*/ 4) set_data(t, /*value*/ ctx[2]);

				if (dirty & /*isPaymentForm*/ 8) {
					toggle_class(output, "zephr-payment-form-input-slider-output", /*isPaymentForm*/ ctx[3]);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(output);
				}
			}
		};
	}

	// (78:6) {#each attributeSchema?.["select-options"] as option}
	function create_each_block_1$4(ctx) {
		let option_1;
		let t0_value = /*option*/ ctx[19].label + "";
		let t0;
		let t1;
		let option_1_value_value;
		let option_1_selected_value;

		return {
			c() {
				option_1 = element("option");
				t0 = text(t0_value);
				t1 = space();
				option_1.__value = option_1_value_value = /*option*/ ctx[19].value;
				set_input_value(option_1, option_1.__value);
				option_1.selected = option_1_selected_value = /*value*/ ctx[2] === /*option*/ ctx[19].value;
			},
			m(target, anchor) {
				insert(target, option_1, anchor);
				append(option_1, t0);
				append(option_1, t1);
			},
			p(ctx, dirty) {
				if (dirty & /*attributeSchema*/ 2 && t0_value !== (t0_value = /*option*/ ctx[19].label + "")) set_data(t0, t0_value);

				if (dirty & /*attributeSchema*/ 2 && option_1_value_value !== (option_1_value_value = /*option*/ ctx[19].value)) {
					option_1.__value = option_1_value_value;
					set_input_value(option_1, option_1.__value);
				}

				if (dirty & /*value, attributeSchema*/ 6 && option_1_selected_value !== (option_1_selected_value = /*value*/ ctx[2] === /*option*/ ctx[19].value)) {
					option_1.selected = option_1_selected_value;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(option_1);
				}
			}
		};
	}

	// (35:4) {#each attributeSchema?.["select-options"] as option}
	function create_each_block$d(ctx) {
		let radio;
		let current;

		radio = new Radio({
				props: {
					id: "" + (/*id*/ ctx[10] + "-" + /*option*/ ctx[19].value),
					name: /*config*/ ctx[0].slug,
					label: /*option*/ ctx[19].label,
					required: /*config*/ ctx[0].required || /*attributeSchema*/ ctx[1]?.required,
					value: /*option*/ ctx[19].value,
					checked: /*value*/ ctx[2] === /*option*/ ctx[19].value,
					hasError: /*hasError*/ ctx[8],
					isPaymentForm: /*isPaymentForm*/ ctx[3]
				}
			});

		radio.$on("change", /*change_handler*/ ctx[13]);

		return {
			c() {
				create_component(radio.$$.fragment);
			},
			m(target, anchor) {
				mount_component(radio, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const radio_changes = {};
				if (dirty & /*attributeSchema*/ 2) radio_changes.id = "" + (/*id*/ ctx[10] + "-" + /*option*/ ctx[19].value);
				if (dirty & /*config*/ 1) radio_changes.name = /*config*/ ctx[0].slug;
				if (dirty & /*attributeSchema*/ 2) radio_changes.label = /*option*/ ctx[19].label;
				if (dirty & /*config, attributeSchema*/ 3) radio_changes.required = /*config*/ ctx[0].required || /*attributeSchema*/ ctx[1]?.required;
				if (dirty & /*attributeSchema*/ 2) radio_changes.value = /*option*/ ctx[19].value;
				if (dirty & /*value, attributeSchema*/ 6) radio_changes.checked = /*value*/ ctx[2] === /*option*/ ctx[19].value;
				if (dirty & /*hasError*/ 256) radio_changes.hasError = /*hasError*/ ctx[8];
				if (dirty & /*isPaymentForm*/ 8) radio_changes.isPaymentForm = /*isPaymentForm*/ ctx[3];
				radio.$set(radio_changes);
			},
			i(local) {
				if (current) return;
				transition_in(radio.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(radio.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(radio, detaching);
			}
		};
	}

	// (24:0) <Label   forInput={id}   sublabel={attributeSchema["public-description"]}   label={!/(hidden|checkbox)/.test(attributeSchema?.["input-type"] || "")     ? `${config.label}${         config.required || attributeSchema?.required ? "*" : ""       }`     : ""}   {isPaymentForm} >
	function create_default_slot$4(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;

		const if_block_creators = [
			create_if_block_1$q,
			create_if_block_2$g,
			create_if_block_3$b,
			create_if_block_4$9,
			create_if_block_5$7,
			create_else_block$9
		];

		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*attributeSchema*/ ctx[1]?.["input-type"] === "radio") return 0;
			if (/*attributeSchema*/ ctx[1]?.["input-type"] === "checkbox") return 1;
			if (/*attributeSchema*/ ctx[1]?.["input-type"] === "select") return 2;
			if (/*attributeSchema*/ ctx[1]?.["input-type"] === "textarea") return 3;
			if (/*attributeSchema*/ ctx[1]?.["input-type"] === "range") return 4;
			return 5;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	// (138:0) {#if hasError}
	function create_if_block$z(ctx) {
		let div;

		return {
			c() {
				div = element("div");
				div.textContent = "Mandatory information must be entered";
				attr(div, "class", "zephr-form-input-error-text svelte-wlae04");
				toggle_class(div, "zephr-payment-form-input-error-text", /*isPaymentForm*/ ctx[3]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*isPaymentForm*/ 8) {
					toggle_class(div, "zephr-payment-form-input-error-text", /*isPaymentForm*/ ctx[3]);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	function create_fragment$L(ctx) {
		let label;
		let t;
		let if_block_anchor;
		let current;

		label = new Label({
				props: {
					forInput: /*id*/ ctx[10],
					sublabel: /*attributeSchema*/ ctx[1]["public-description"],
					label: !(/(hidden|checkbox)/).test(/*attributeSchema*/ ctx[1]?.["input-type"] || "")
					? `${/*config*/ ctx[0].label}${/*config*/ ctx[0].required || /*attributeSchema*/ ctx[1]?.required
					? "*"
					: ""}`
					: "",
					isPaymentForm: /*isPaymentForm*/ ctx[3],
					$$slots: { default: [create_default_slot$4] },
					$$scope: { ctx }
				}
			});

		let if_block = /*hasError*/ ctx[8] && create_if_block$z(ctx);

		return {
			c() {
				create_component(label.$$.fragment);
				t = space();
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				mount_component(label, target, anchor);
				insert(target, t, anchor);
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				const label_changes = {};
				if (dirty & /*attributeSchema*/ 2) label_changes.sublabel = /*attributeSchema*/ ctx[1]["public-description"];

				if (dirty & /*attributeSchema, config*/ 3) label_changes.label = !(/(hidden|checkbox)/).test(/*attributeSchema*/ ctx[1]?.["input-type"] || "")
				? `${/*config*/ ctx[0].label}${/*config*/ ctx[0].required || /*attributeSchema*/ ctx[1]?.required
				? "*"
				: ""}`
				: "";

				if (dirty & /*isPaymentForm*/ 8) label_changes.isPaymentForm = /*isPaymentForm*/ ctx[3];

				if (dirty & /*$$scope, attributeSchema, config, value, hasError, isPaymentForm, onChange, currentValue, onFocus, onBlur*/ 16777727) {
					label_changes.$$scope = { dirty, ctx };
				}

				label.$set(label_changes);

				if (/*hasError*/ ctx[8]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$z(ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			i(local) {
				if (current) return;
				transition_in(label.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(label.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(if_block_anchor);
				}

				destroy_component(label, detaching);
				if (if_block) if_block.d(detaching);
			}
		};
	}

	function instance$K($$self, $$props, $$invalidate) {
		let hasError;
		let { formKey } = $$props;
		let { config } = $$props;
		let { attributeSchema } = $$props;
		let { value } = $$props;
		let { error } = $$props;
		let { isPaymentForm = false } = $$props;
		let { onChange } = $$props;
		let { onFocus } = $$props;
		let { onBlur } = $$props;
		let currentValue = value;

		// Casting functions for typescript
		const asSelect = target => target;

		const id = `zephr-form-${config.slug}-${formKey}`;
		const change_handler = ({ detail }) => onChange(detail);
		const change_handler_1 = ({ detail }) => onChange(detail);
		const change_handler_2 = e => onChange(asSelect(e.target).value);

		function textarea_input_handler() {
			currentValue = this.value;
			$$invalidate(7, currentValue);
		}

		const change_handler_3 = ({ detail }) => onChange(detail);
		const change_handler_4 = ({ detail }) => onChange(detail);

		$$self.$$set = $$props => {
			if ('formKey' in $$props) $$invalidate(11, formKey = $$props.formKey);
			if ('config' in $$props) $$invalidate(0, config = $$props.config);
			if ('attributeSchema' in $$props) $$invalidate(1, attributeSchema = $$props.attributeSchema);
			if ('value' in $$props) $$invalidate(2, value = $$props.value);
			if ('error' in $$props) $$invalidate(12, error = $$props.error);
			if ('isPaymentForm' in $$props) $$invalidate(3, isPaymentForm = $$props.isPaymentForm);
			if ('onChange' in $$props) $$invalidate(4, onChange = $$props.onChange);
			if ('onFocus' in $$props) $$invalidate(5, onFocus = $$props.onFocus);
			if ('onBlur' in $$props) $$invalidate(6, onBlur = $$props.onBlur);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*error*/ 4096) {
				$$invalidate(8, hasError = !!error);
			}

			if ($$self.$$.dirty & /*attributeSchema, currentValue, value, onChange*/ 150) {
				if (attributeSchema?.["input-type"] === "textarea" && currentValue !== value) {
					onChange(currentValue);
				}
			}
		};

		return [
			config,
			attributeSchema,
			value,
			isPaymentForm,
			onChange,
			onFocus,
			onBlur,
			currentValue,
			hasError,
			asSelect,
			id,
			formKey,
			error,
			change_handler,
			change_handler_1,
			change_handler_2,
			textarea_input_handler,
			change_handler_3,
			change_handler_4
		];
	}

	class UserAttribute extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$K, create_fragment$L, safe_not_equal, {
				formKey: 11,
				config: 0,
				attributeSchema: 1,
				value: 2,
				error: 12,
				isPaymentForm: 3,
				onChange: 4,
				onFocus: 5,
				onBlur: 6
			});
		}
	}

	const isEmpty = value => value == null || value === "";
	const factory$h = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.USER_ATTRIBUTE,
	    create: (form, formState, formActions, elementConfig) => {
	        const attributeSchema = form.organisationConfiguration.schemaFields.find(s => s.slug === elementConfig.slug);
	        const hide = formState.hideIfSetAttributes?.includes(elementConfig.slug);
	        if (attributeSchema == undefined || hide) {
	            return undefined;
	        }
	        const required = attributeSchema.required || elementConfig.required;
	        const currentValue = (formState.userAttributes[elementConfig.slug] ?? (formState.readOnlyAttributeValues ?? {})[elementConfig.slug]);
	        return {
	            component: UserAttribute,
	            props: {
	                formKey: form.uniqueKey,
	                config: elementConfig,
	                value: currentValue,
	                attributeSchema,
	                isPaymentForm: form.formType === FormType.PAYMENT,
	                onChange: (value) => {
	                    formActions.updateFormState({
	                        userAttributes: {
	                            ...formState.userAttributes,
	                            [elementConfig.slug]: value
	                        }
	                    });
	                    logDataLayerEvent(form, 'zephr_form_input_change', {
	                        inputName: `zephr-form-${elementConfig.slug}-${form.uniqueKey}`,
	                        sectionId: formState.currentSection.type,
	                        field: elementConfig.slug
	                    });
	                },
	                onFocus: () => logDataLayerEvent(form, 'zephr_form_input_focus', {
	                    inputName: `zephr-form-${elementConfig.slug}-${form.uniqueKey}`,
	                    sectionId: formState.currentSection.type,
	                    field: elementConfig.slug
	                }),
	                onBlur: () => logDataLayerEvent(form, 'zephr_form_input_blur', {
	                    inputName: `zephr-form-${elementConfig.slug}-${form.uniqueKey}`,
	                    sectionId: formState.currentSection.type,
	                    field: elementConfig.slug
	                }),
	            },
	            isValid: !(required && isEmpty(currentValue))
	                && !(required && attributeSchema["input-type"] === 'checkbox' && !currentValue)
	                && !(attributeSchema["input-type"] === 'email' && !isEmpty(currentValue) && !isValidEmail(currentValue))
	        };
	    }
	};

	/* src/components/elements/Link.svelte generated by Svelte v4.2.12 */

	function create_fragment$K(ctx) {
		let button;
		let t;
		let mounted;
		let dispose;

		return {
			c() {
				button = element("button");
				t = text(/*text*/ ctx[0]);
				attr(button, "type", "button");
				attr(button, "class", "zephr-form-link svelte-14vxk2u");
				toggle_class(button, "zephr-form-link-disabled", /*disabled*/ ctx[1]);
				toggle_class(button, "zephr-form-link-no-underline", /*noUnderline*/ ctx[3]);
			},
			m(target, anchor) {
				insert(target, button, anchor);
				append(button, t);

				if (!mounted) {
					dispose = listen(button, "click", /*click_handler*/ ctx[5]);
					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (dirty & /*text*/ 1) set_data(t, /*text*/ ctx[0]);

				if (dirty & /*disabled*/ 2) {
					toggle_class(button, "zephr-form-link-disabled", /*disabled*/ ctx[1]);
				}

				if (dirty & /*noUnderline*/ 8) {
					toggle_class(button, "zephr-form-link-no-underline", /*noUnderline*/ ctx[3]);
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(button);
				}

				mounted = false;
				dispose();
			}
		};
	}

	function instance$J($$self, $$props, $$invalidate) {
		let { text } = $$props;
		let { disabled = false } = $$props;

		let { onClick = () => {
			
		} } = $$props;

		let { noUnderline = false } = $$props;
		const dispatch = createEventDispatcher();

		const click_handler = () => {
			onClick();
			dispatch('linkClick', null);
		};

		$$self.$$set = $$props => {
			if ('text' in $$props) $$invalidate(0, text = $$props.text);
			if ('disabled' in $$props) $$invalidate(1, disabled = $$props.disabled);
			if ('onClick' in $$props) $$invalidate(2, onClick = $$props.onClick);
			if ('noUnderline' in $$props) $$invalidate(3, noUnderline = $$props.noUnderline);
		};

		return [text, disabled, onClick, noUnderline, dispatch, click_handler];
	}

	class Link extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$J, create_fragment$K, safe_not_equal, {
				text: 0,
				disabled: 1,
				onClick: 2,
				noUnderline: 3
			});
		}
	}

	/* src/components/elements/resetPasswordLink/ResetPasswordLink.svelte generated by Svelte v4.2.12 */

	function create_else_block$8(ctx) {
		let link;
		let current;

		link = new Link({
				props: {
					text: /*text*/ ctx[0],
					onClick: /*onClick*/ ctx[2]
				}
			});

		link.$on("linkClick", /*linkClick_handler*/ ctx[7]);

		return {
			c() {
				create_component(link.$$.fragment);
			},
			m(target, anchor) {
				mount_component(link, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const link_changes = {};
				if (dirty & /*text*/ 1) link_changes.text = /*text*/ ctx[0];
				if (dirty & /*onClick*/ 4) link_changes.onClick = /*onClick*/ ctx[2];
				link.$set(link_changes);
			},
			i(local) {
				if (current) return;
				transition_in(link.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(link.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(link, detaching);
			}
		};
	}

	// (16:2) {#if showMessage && !error}
	function create_if_block_1$p(ctx) {
		let div;
		let t;

		return {
			c() {
				div = element("div");
				t = text(/*message*/ ctx[1]);
				attr(div, "class", "zephr-form-link-message svelte-49aomy");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty & /*message*/ 2) set_data(t, /*message*/ ctx[1]);
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (32:2) {#if error}
	function create_if_block$y(ctx) {
		let errormessage;
		let current;

		errormessage = new ErrorMessage({
				props: {
					error: /*error*/ ctx[3],
					isPaymentForm: /*isPaymentForm*/ ctx[5]
				}
			});

		return {
			c() {
				create_component(errormessage.$$.fragment);
			},
			m(target, anchor) {
				mount_component(errormessage, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const errormessage_changes = {};
				if (dirty & /*error*/ 8) errormessage_changes.error = /*error*/ ctx[3];
				if (dirty & /*isPaymentForm*/ 32) errormessage_changes.isPaymentForm = /*isPaymentForm*/ ctx[5];
				errormessage.$set(errormessage_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errormessage.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errormessage.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(errormessage, detaching);
			}
		};
	}

	function create_fragment$J(ctx) {
		let div;
		let current_block_type_index;
		let if_block0;
		let t;
		let current;
		const if_block_creators = [create_if_block_1$p, create_else_block$8];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*showMessage*/ ctx[6] && !/*error*/ ctx[3]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		let if_block1 = /*error*/ ctx[3] && create_if_block$y(ctx);

		return {
			c() {
				div = element("div");
				if_block0.c();
				t = space();
				if (if_block1) if_block1.c();
				attr(div, "class", "zephr-form-flex-container zephr-form-reset-link-container svelte-49aomy");
				toggle_class(div, "zephr-payment-form-flex-container", /*isPaymentForm*/ ctx[5]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_blocks[current_block_type_index].m(div, null);
				append(div, t);
				if (if_block1) if_block1.m(div, null);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block0 = if_blocks[current_block_type_index];

					if (!if_block0) {
						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block0.c();
					} else {
						if_block0.p(ctx, dirty);
					}

					transition_in(if_block0, 1);
					if_block0.m(div, t);
				}

				if (/*error*/ ctx[3]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*error*/ 8) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block$y(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div, null);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (!current || dirty & /*isPaymentForm*/ 32) {
					toggle_class(div, "zephr-payment-form-flex-container", /*isPaymentForm*/ ctx[5]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if_blocks[current_block_type_index].d();
				if (if_block1) if_block1.d();
			}
		};
	}

	function instance$I($$self, $$props, $$invalidate) {
		let { text } = $$props;
		let { message } = $$props;
		let { onClick } = $$props;
		let { error = null } = $$props;
		let { delayMs } = $$props;
		let { isPaymentForm = false } = $$props;
		let showMessage = false;

		const linkClick_handler = () => {
			if (message) {
				$$invalidate(6, showMessage = true);
				setTimeout(() => $$invalidate(6, showMessage = false), delayMs);
			}
		};

		$$self.$$set = $$props => {
			if ('text' in $$props) $$invalidate(0, text = $$props.text);
			if ('message' in $$props) $$invalidate(1, message = $$props.message);
			if ('onClick' in $$props) $$invalidate(2, onClick = $$props.onClick);
			if ('error' in $$props) $$invalidate(3, error = $$props.error);
			if ('delayMs' in $$props) $$invalidate(4, delayMs = $$props.delayMs);
			if ('isPaymentForm' in $$props) $$invalidate(5, isPaymentForm = $$props.isPaymentForm);
		};

		return [
			text,
			message,
			onClick,
			error,
			delayMs,
			isPaymentForm,
			showMessage,
			linkClick_handler
		];
	}

	class ResetPasswordLink extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$I, create_fragment$J, safe_not_equal, {
				text: 0,
				message: 1,
				onClick: 2,
				error: 3,
				delayMs: 4,
				isPaymentForm: 5
			});
		}
	}

	const factory$g = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.RESET_PASSWORD_LINK,
	    create: (form, formState, formActions, elementConfig) => ({
	        component: ResetPasswordLink,
	        props: {
	            text: elementConfig.text,
	            message: elementConfig.message,
	            delayMs: form.environment.reduceDelays ? 1 : 3000,
	            isPaymentForm: form.formType === FormType.PAYMENT,
	            onClick: () => sendPasswordResetCode(form, formState, formActions)
	        }
	    })
	};

	/* src/components/elements/resendLoginLink/ResendLoginLink.svelte generated by Svelte v4.2.12 */

	function create_else_block$7(ctx) {
		let link;
		let current;

		link = new Link({
				props: {
					text: /*text*/ ctx[0],
					onClick: /*onClick*/ ctx[2]
				}
			});

		link.$on("linkClick", /*linkClick_handler*/ ctx[7]);

		return {
			c() {
				create_component(link.$$.fragment);
			},
			m(target, anchor) {
				mount_component(link, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const link_changes = {};
				if (dirty & /*text*/ 1) link_changes.text = /*text*/ ctx[0];
				if (dirty & /*onClick*/ 4) link_changes.onClick = /*onClick*/ ctx[2];
				link.$set(link_changes);
			},
			i(local) {
				if (current) return;
				transition_in(link.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(link.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(link, detaching);
			}
		};
	}

	// (16:2) {#if showMessage && !error}
	function create_if_block_1$o(ctx) {
		let div;
		let t;

		return {
			c() {
				div = element("div");
				t = text(/*message*/ ctx[1]);
				attr(div, "class", "zephr-form-link-message svelte-49aomy");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty & /*message*/ 2) set_data(t, /*message*/ ctx[1]);
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (32:2) {#if error}
	function create_if_block$x(ctx) {
		let errormessage;
		let current;

		errormessage = new ErrorMessage({
				props: {
					error: /*error*/ ctx[3],
					isPaymentForm: /*isPaymentForm*/ ctx[5]
				}
			});

		return {
			c() {
				create_component(errormessage.$$.fragment);
			},
			m(target, anchor) {
				mount_component(errormessage, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const errormessage_changes = {};
				if (dirty & /*error*/ 8) errormessage_changes.error = /*error*/ ctx[3];
				if (dirty & /*isPaymentForm*/ 32) errormessage_changes.isPaymentForm = /*isPaymentForm*/ ctx[5];
				errormessage.$set(errormessage_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errormessage.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errormessage.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(errormessage, detaching);
			}
		};
	}

	function create_fragment$I(ctx) {
		let div;
		let current_block_type_index;
		let if_block0;
		let t;
		let current;
		const if_block_creators = [create_if_block_1$o, create_else_block$7];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*showMessage*/ ctx[6] && !/*error*/ ctx[3]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		let if_block1 = /*error*/ ctx[3] && create_if_block$x(ctx);

		return {
			c() {
				div = element("div");
				if_block0.c();
				t = space();
				if (if_block1) if_block1.c();
				attr(div, "class", "zephr-form-flex-container zephr-form-reset-link-container svelte-49aomy");
				toggle_class(div, "zephr-payment-form-flex-container", /*isPaymentForm*/ ctx[5]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if_blocks[current_block_type_index].m(div, null);
				append(div, t);
				if (if_block1) if_block1.m(div, null);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block0 = if_blocks[current_block_type_index];

					if (!if_block0) {
						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block0.c();
					} else {
						if_block0.p(ctx, dirty);
					}

					transition_in(if_block0, 1);
					if_block0.m(div, t);
				}

				if (/*error*/ ctx[3]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*error*/ 8) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block$x(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div, null);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (!current || dirty & /*isPaymentForm*/ 32) {
					toggle_class(div, "zephr-payment-form-flex-container", /*isPaymentForm*/ ctx[5]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if_blocks[current_block_type_index].d();
				if (if_block1) if_block1.d();
			}
		};
	}

	function instance$H($$self, $$props, $$invalidate) {
		let { text } = $$props;
		let { message } = $$props;
		let { onClick } = $$props;
		let { error = null } = $$props;
		let { delayMs } = $$props;
		let { isPaymentForm = false } = $$props;
		let showMessage = false;

		const linkClick_handler = () => {
			if (message) {
				$$invalidate(6, showMessage = true);
				setTimeout(() => $$invalidate(6, showMessage = false), delayMs);
			}
		};

		$$self.$$set = $$props => {
			if ('text' in $$props) $$invalidate(0, text = $$props.text);
			if ('message' in $$props) $$invalidate(1, message = $$props.message);
			if ('onClick' in $$props) $$invalidate(2, onClick = $$props.onClick);
			if ('error' in $$props) $$invalidate(3, error = $$props.error);
			if ('delayMs' in $$props) $$invalidate(4, delayMs = $$props.delayMs);
			if ('isPaymentForm' in $$props) $$invalidate(5, isPaymentForm = $$props.isPaymentForm);
		};

		return [
			text,
			message,
			onClick,
			error,
			delayMs,
			isPaymentForm,
			showMessage,
			linkClick_handler
		];
	}

	class ResendLoginLink extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$H, create_fragment$I, safe_not_equal, {
				text: 0,
				message: 1,
				onClick: 2,
				error: 3,
				delayMs: 4,
				isPaymentForm: 5
			});
		}
	}

	const factory$f = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.RESEND_LOGIN_LINK,
	    create: (form, formState, formActions, elementConfig) => ({
	        component: ResendLoginLink,
	        props: {
	            text: elementConfig.text,
	            message: elementConfig.message,
	            delayMs: form.environment.reduceDelays ? 1 : 3000,
	            isPaymentForm: form.formType === FormType.PAYMENT,
	            onClick: async () => {
	                await sendLink(form, 'login', formState.emailAddress, formActions);
	            }
	        }
	    })
	};

	const oauthProviderWindowFeatures = "menubar=no,location=yes,resizable=no,scrollbars=no,status=no,width=500,height=600";
	const useOAuthProvider = (provider, form, formActions) => {
	    formActions.updateFormState({
	        socialSigninError: undefined
	    });
	    window.open(`${form.environment.apiUrlBase ?? ""}/blaize/oauth/${provider}`, provider + " sign-in", oauthProviderWindowFeatures);
	    const listener = messageAction(form, formActions);
	    window.zephrOAuthListener = listener;
	    window.addEventListener("message", listener);
	};
	const messageAction = (form, formActions) => (message) => {
	    if (!message?.data?.fromZephr) {
	        return;
	    }
	    window.removeEventListener("message", window.zephrOAuthListener);
	    form.environment.debugLogging && console.log("Social signin message:", message);
	    if (message.data.action === "register") {
	        // This is a fresh user who is registering, they may need to add some required attributes first.
	        // If not, register immediately.
	        const newFormState = formActions.updateFormState({
	            emailAddress: message.data.identifier,
	            socialSigninToken: message.data.stateKey,
	            userAttributes: message.data.userAttributes ?? {},
	            socialSignin: true,
	            userExists: false,
	            emailIsContact: undefined
	        });
	        if (formConfigAs(form).useVerificationCodes) {
	            void send2FaCode(form, newFormState, formActions);
	        }
	        void moveToNextSection(form, newFormState, formActions);
	    }
	    else if (message.data.action == "otp") {
	        // Already registered user and verification via OTP is needed
	        formActions.updateFormState({
	            emailAddress: message.data.identifier,
	            socialSigninToken: message.data.stateKey,
	            userAttributes: message.data.userAttributes ?? {},
	            socialSignin: true,
	            userExists: true,
	            emailIsContact: false
	        });
	        formActions.jumpToSection(sectionTypes.VERIFICATION_CODE_LOGIN.type);
	    }
	    else if (message.data.action === "login") {
	        // Already registered user who is now logged in.
	        document.cookie = message.data.cookie;
	        formActions.updateFormState({
	            socialSignin: true,
	            userExists: true,
	            loginRegistrationComplete: true,
	            emailIsContact: false
	        });
	        void formActions.onEvent(FormEvent.LOGIN_REGISTRATION_COMPLETE);
	    }
	    else {
	        // Failure
	        formActions.updateFormState({
	            socialSigninError: message.data.message ?? "Something went wrong. Please try again later!"
	        });
	    }
	};

	var faMicrosoft = {
	  prefix: 'fab',
	  iconName: 'microsoft',
	  icon: [448, 512, [], "f3ca", "M0 32h214.6v214.6H0V32zm233.4 0H448v214.6H233.4V32zM0 265.4h214.6V480H0V265.4zm233.4 0H448V480H233.4V265.4z"]
	};
	var faApple = {
	  prefix: 'fab',
	  iconName: 'apple',
	  icon: [384, 512, [], "f179", "M318.7 268.7c-.2-36.7 16.4-64.4 50-84.8-18.8-26.9-47.2-41.7-84.7-44.6-35.5-2.8-74.3 20.7-88.5 20.7-15 0-49.4-19.7-76.4-19.7C63.3 141.2 4 184.8 4 273.5q0 39.3 14.4 81.2c12.8 36.7 59 126.7 107.2 125.2 25.2-.6 43-17.9 75.8-17.9 31.8 0 48.3 17.9 76.4 17.9 48.6-.7 90.4-82.5 102.6-119.3-65.2-30.7-61.7-90-61.7-91.9zm-56.6-164.2c27.3-32.4 24.8-61.9 24-72.5-24.1 1.4-52 16.4-67.9 34.9-17.5 19.8-27.8 44.3-25.6 71.9 26.1 2 49.9-11.4 69.5-34.3z"]
	};
	var faLinkedin = {
	  prefix: 'fab',
	  iconName: 'linkedin',
	  icon: [448, 512, [], "f08c", "M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"]
	};
	var faFacebook = {
	  prefix: 'fab',
	  iconName: 'facebook',
	  icon: [512, 512, [62000], "f09a", "M512 256C512 114.6 397.4 0 256 0S0 114.6 0 256C0 376 82.7 476.8 194.2 504.5V334.2H141.4V256h52.8V222.3c0-87.1 39.4-127.5 125-127.5c16.2 0 44.2 3.2 55.7 6.4V172c-6-.6-16.5-1-29.6-1c-42 0-58.2 15.9-58.2 57.2V256h83.6l-14.4 78.2H287V510.1C413.8 494.8 512 386.9 512 256h0z"]
	};
	var faTwitter = {
	  prefix: 'fab',
	  iconName: 'twitter',
	  icon: [512, 512, [], "f099", "M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"]
	};

	/* src/components/elements/socialSignIn/GoogleLogo.svelte generated by Svelte v4.2.12 */

	function create_fragment$H(ctx) {
		let svg;
		let path0;
		let path1;
		let path2;
		let path3;

		return {
			c() {
				svg = svg_element("svg");
				path0 = svg_element("path");
				path1 = svg_element("path");
				path2 = svg_element("path");
				path3 = svg_element("path");
				attr(path0, "d", "M533.5 278.4c0-18.5-1.5-37.1-4.7-55.3H272.1v104.8h147c-6.1 33.8-25.7 63.7-54.4 82.7v68h87.7c51.5-47.4 81.1-117.4 81.1-200.2z");
				attr(path0, "fill", "#4285f4");
				attr(path1, "d", "M272.1 544.3c73.4 0 135.3-24.1 180.4-65.7l-87.7-68c-24.4 16.6-55.9 26-92.6 26-71 0-131.2-47.9-152.8-112.3H28.9v70.1c46.2 91.9 140.3 149.9 243.2 149.9z");
				attr(path1, "fill", "#34a853");
				attr(path2, "d", "M119.3 324.3c-11.4-33.8-11.4-70.4 0-104.2V150H28.9c-38.6 76.9-38.6 167.5 0 244.4l90.4-70.1z");
				attr(path2, "fill", "#fbbc04");
				attr(path3, "d", "M272.1 107.7c38.8-.6 76.3 14 104.4 40.8l77.7-77.7C405 24.6 339.7-.8 272.1 0 169.2 0 75.1 58 28.9 150l90.4 70.1c21.5-64.5 81.8-112.4 152.8-112.4z");
				attr(path3, "fill", "#ea4335");
				attr(svg, "class", "zephr-form-social-sign-in-icon zephr-form-google-icon svelte-aktnoc");
				attr(svg, "viewBox", "0 0 533.5 544.3");
				attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			},
			m(target, anchor) {
				insert(target, svg, anchor);
				append(svg, path0);
				append(svg, path1);
				append(svg, path2);
				append(svg, path3);
			},
			p: noop,
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(svg);
				}
			}
		};
	}

	class GoogleLogo extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, null, create_fragment$H, safe_not_equal, {});
		}
	}

	/* src/components/elements/socialSignIn/SocialSignIn.svelte generated by Svelte v4.2.12 */

	function get_each_context$c(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[8] = list[i];
		return child_ctx;
	}

	// (30:2) {#if config[option] === true && option !== 'labelText' && option !== 'allowEmptyLabel'}
	function create_if_block_1$n(ctx) {
		let button;
		let span1;
		let span0;
		let current_block_type_index;
		let if_block;
		let t0;
		let t1;
		let t2;
		let t3_value = /*option*/ ctx[8] + "";
		let t3;
		let current;
		let mounted;
		let dispose;
		const if_block_creators = [create_if_block_2$f, create_else_block$6];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*option*/ ctx[8] === "Google") return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		function click_handler() {
			return /*click_handler*/ ctx[6](/*option*/ ctx[8]);
		}

		return {
			c() {
				button = element("button");
				span1 = element("span");
				span0 = element("span");
				if_block.c();
				t0 = space();
				t1 = text(/*labelText*/ ctx[4]);
				t2 = space();
				t3 = text(t3_value);
				attr(span0, "class", "zephr-form-social-sign-in-icon svelte-1e2xtn4");
				toggle_class(span0, "zephr-payment-form-social-sign-in-icon", /*isPaymentForm*/ ctx[3]);
				attr(span1, "class", "zephr-form-flex-container zephr-form-social-sign-in svelte-1e2xtn4");
				toggle_class(span1, "zephr-payment-form-flex-container", /*isPaymentForm*/ ctx[3]);
				toggle_class(span1, "zephr-payment-form-social-sign-in", /*isPaymentForm*/ ctx[3]);
				attr(button, "type", "button");
				attr(button, "class", "zephr-form-button zephr-form-social-sign-in-button svelte-1e2xtn4");
				toggle_class(button, "zephr-payment-form-button", /*isPaymentForm*/ ctx[3]);
				toggle_class(button, "zephr-payment-form-social-sign-in-button", /*isPaymentForm*/ ctx[3]);
			},
			m(target, anchor) {
				insert(target, button, anchor);
				append(button, span1);
				append(span1, span0);
				if_blocks[current_block_type_index].m(span0, null);
				append(span1, t0);
				append(span1, t1);
				append(span1, t2);
				append(span1, t3);
				current = true;

				if (!mounted) {
					dispose = listen(button, "click", prevent_default(click_handler));
					mounted = true;
				}
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(span0, null);
				}

				if (!current || dirty & /*isPaymentForm*/ 8) {
					toggle_class(span0, "zephr-payment-form-social-sign-in-icon", /*isPaymentForm*/ ctx[3]);
				}

				if ((!current || dirty & /*config*/ 1) && t3_value !== (t3_value = /*option*/ ctx[8] + "")) set_data(t3, t3_value);

				if (!current || dirty & /*isPaymentForm*/ 8) {
					toggle_class(span1, "zephr-payment-form-flex-container", /*isPaymentForm*/ ctx[3]);
				}

				if (!current || dirty & /*isPaymentForm*/ 8) {
					toggle_class(span1, "zephr-payment-form-social-sign-in", /*isPaymentForm*/ ctx[3]);
				}

				if (!current || dirty & /*isPaymentForm*/ 8) {
					toggle_class(button, "zephr-payment-form-button", /*isPaymentForm*/ ctx[3]);
				}

				if (!current || dirty & /*isPaymentForm*/ 8) {
					toggle_class(button, "zephr-payment-form-social-sign-in-button", /*isPaymentForm*/ ctx[3]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(button);
				}

				if_blocks[current_block_type_index].d();
				mounted = false;
				dispose();
			}
		};
	}

	// (49:10) {:else}
	function create_else_block$6(ctx) {
		let fa;
		let current;
		const fa_spread_levels = [/*getProviderIcon*/ ctx[5](/*option*/ ctx[8])];
		let fa_props = {};

		for (let i = 0; i < fa_spread_levels.length; i += 1) {
			fa_props = assign(fa_props, fa_spread_levels[i]);
		}

		fa = new Fa({ props: fa_props });

		return {
			c() {
				create_component(fa.$$.fragment);
			},
			m(target, anchor) {
				mount_component(fa, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const fa_changes = (dirty & /*getProviderIcon, Object, config*/ 33)
				? get_spread_update(fa_spread_levels, [get_spread_object(/*getProviderIcon*/ ctx[5](/*option*/ ctx[8]))])
				: {};

				fa.$set(fa_changes);
			},
			i(local) {
				if (current) return;
				transition_in(fa.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(fa.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(fa, detaching);
			}
		};
	}

	// (47:10) {#if option === "Google"}
	function create_if_block_2$f(ctx) {
		let googlelogo;
		let current;
		googlelogo = new GoogleLogo({});

		return {
			c() {
				create_component(googlelogo.$$.fragment);
			},
			m(target, anchor) {
				mount_component(googlelogo, target, anchor);
				current = true;
			},
			p: noop,
			i(local) {
				if (current) return;
				transition_in(googlelogo.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(googlelogo.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(googlelogo, detaching);
			}
		};
	}

	// (29:0) {#each Object.keys(config) as option}
	function create_each_block$c(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*config*/ ctx[0][/*option*/ ctx[8]] === true && /*option*/ ctx[8] !== 'labelText' && /*option*/ ctx[8] !== 'allowEmptyLabel' && create_if_block_1$n(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*config*/ ctx[0][/*option*/ ctx[8]] === true && /*option*/ ctx[8] !== 'labelText' && /*option*/ ctx[8] !== 'allowEmptyLabel') {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*config*/ 1) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_1$n(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (58:0) {#if error}
	function create_if_block$w(ctx) {
		let errormessage;
		let current;

		errormessage = new ErrorMessage({
				props: {
					error: /*error*/ ctx[2],
					isPaymentForm: /*isPaymentForm*/ ctx[3]
				}
			});

		return {
			c() {
				create_component(errormessage.$$.fragment);
			},
			m(target, anchor) {
				mount_component(errormessage, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const errormessage_changes = {};
				if (dirty & /*error*/ 4) errormessage_changes.error = /*error*/ ctx[2];
				if (dirty & /*isPaymentForm*/ 8) errormessage_changes.isPaymentForm = /*isPaymentForm*/ ctx[3];
				errormessage.$set(errormessage_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errormessage.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errormessage.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(errormessage, detaching);
			}
		};
	}

	function create_fragment$G(ctx) {
		let t;
		let if_block_anchor;
		let current;
		let each_value = ensure_array_like(Object.keys(/*config*/ ctx[0]));
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		let if_block = /*error*/ ctx[2] && create_if_block$w(ctx);

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t = space();
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, t, anchor);
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (dirty & /*isPaymentForm, onSelectProvider, Object, config, labelText, getProviderIcon*/ 59) {
					each_value = ensure_array_like(Object.keys(/*config*/ ctx[0]));
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$c(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$c(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(t.parentNode, t);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (/*error*/ ctx[2]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*error*/ 4) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$w(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				transition_in(if_block);
				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(if_block_anchor);
				}

				destroy_each(each_blocks, detaching);
				if (if_block) if_block.d(detaching);
			}
		};
	}

	function instance$G($$self, $$props, $$invalidate) {
		let { config } = $$props;
		let { onSelectProvider } = $$props;
		let { error = null } = $$props;
		let { isPaymentForm = false } = $$props;
		const defaultLabelText = config.allowEmptyLabel ? "" : "Continue with";
		const labelText = config.labelText ? config.labelText : defaultLabelText;

		const getProviderIcon = provider => {
			switch (provider) {
				case "Facebook":
					return {
						icon: faFacebook,
						color: "#1877f2",
						size: "lg"
					};
				case "LinkedIn":
					return {
						icon: faLinkedin,
						color: "#0a66c2",
						size: "lg"
					};
				case "Apple":
					return { icon: faApple, color: "#000", size: "lg" };
				case "Microsoft":
					return {
						icon: faMicrosoft,
						color: "#00a4ef",
						size: "lg"
					};
				case "Twitter":
					return {
						icon: faTwitter,
						color: "#08a0e9",
						size: "lg"
					};
				default:
					return {
						icon: faFacebook,
						color: "#1877f2",
						size: "lg"
					};
			}
		};

		const click_handler = option => onSelectProvider(option.toLowerCase());

		$$self.$$set = $$props => {
			if ('config' in $$props) $$invalidate(0, config = $$props.config);
			if ('onSelectProvider' in $$props) $$invalidate(1, onSelectProvider = $$props.onSelectProvider);
			if ('error' in $$props) $$invalidate(2, error = $$props.error);
			if ('isPaymentForm' in $$props) $$invalidate(3, isPaymentForm = $$props.isPaymentForm);
		};

		return [
			config,
			onSelectProvider,
			error,
			isPaymentForm,
			labelText,
			getProviderIcon,
			click_handler
		];
	}

	class SocialSignIn extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$G, create_fragment$G, safe_not_equal, {
				config: 0,
				onSelectProvider: 1,
				error: 2,
				isPaymentForm: 3
			});
		}
	}

	const factory$e = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.SOCIAL_SIGNIN,
	    create: (form, _, formActions, elementConfig) => {
	        const { enabled: __, hide: ___, show: ____, ...cleanedConfig } = elementConfig ?? {};
	        return ({
	            component: SocialSignIn,
	            props: {
	                config: cleanedConfig,
	                isPaymentForm: form.formType === FormType.PAYMENT,
	                onSelectProvider: (provider) => useOAuthProvider(provider, form, formActions)
	            }
	        });
	    }
	};

	const verifyingPromoCodeBusyKey = "promo-code";
	const runPromoCodeValidation = async (form, formState, formActions) => {
	    formActions.updateFormState({
	        promoCodeValid: undefined,
	        serverErrors: [],
	        discountedPlanPrices: []
	    });
	    const providerConfig = paymentProviderFor(form.organisationConfiguration.paymentProvider);
	    const response = await request(providerConfig.promoCodeCheckPath, {
	        method: 'POST',
	        bodyObject: {
	            promoCode: formState.promoCode,
	            paymentOptions: formConfigAs(form).paymentOptions
	        }
	    }, formActions, verifyingPromoCodeBusyKey);
	    if (!response.ok) {
	        let serverError;
	        if (response.status === 403) {
	            const json = await response.json();
	            if (json?.code === 2 || json?.code === 3) {
	                serverError = ServerError.PROMO_CODE_EXPIRED_ERROR;
	            }
	            else {
	                serverError = ServerError.PROMO_CODE_INVALID_ERROR;
	            }
	        }
	        else {
	            serverError = ServerError.PROMO_CODE_INVALID_ERROR;
	            console.error("Unknown error evaluating promo code", response);
	        }
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[serverError],
	        });
	        return Promise.resolve(formActions.updateFormState({
	            promoCodeValid: false,
	            serverErrors: [serverError],
	            discountedPlanPrices: []
	        }));
	    }
	    const json = await response.json();
	    const discountedPlanPrices = json.paymentOptions.map(p => ({
	        planSlug: p.slug,
	        productId: p.productId,
	        discountPrice: p.discountPrice
	    }));
	    if (!discountedPlanPrices.find(discount => discount.planSlug === formState.paymentOption.slug && discount.productId === formState.paymentOption.productId)) {
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[ServerError.PROMO_CODE_NOT_VALID_FOR_PLAN_ERROR],
	        });
	        return Promise.resolve(formActions.updateFormState({
	            promoCodeValid: false,
	            serverErrors: [ServerError.PROMO_CODE_NOT_VALID_FOR_PLAN_ERROR],
	            discountedPlanPrices: discountedPlanPrices
	        }));
	    }
	    return Promise.resolve(formActions.updateFormState({
	        promoCodeValid: true,
	        serverErrors: [],
	        discountedPlanPrices: discountedPlanPrices
	    }));
	};
	/*
	If we're using mobile payment and we're on the payment screen,
	we'll need to reload the mobile payment button so it has the discounted amount
	and make sure they can't press the button while the button is updating
	*/
	const afterPromoCodeChange = async (form, formState, formActions) => {
	    const formStateWithAddons = await getProductAddons(form, formState, formActions, true);
	    const formStateWithPrices = await calculatePrices(form, formStateWithAddons, formActions);
	    if (formState.currentSection.elements.some(element => element.type === elementTypes.MOBILE_PAYMENT && element.config?.enabled !== false)) {
	        formActions.incrementRequestCount();
	        try {
	            await mobilePaymentServiceFor(form.organisationConfiguration.paymentProvider).loader(form, formStateWithPrices, formActions);
	        }
	        finally {
	            formActions.decrementRequestCount();
	        }
	    }
	};
	const validatePromoCode = async (form, formState, formActions) => {
	    const providerConfig = paymentProviderFor(form.organisationConfiguration.paymentProvider);
	    if (!providerConfig.hasPromoCodes(form)) {
	        return formState;
	    }
	    if (providerConfig?.promoCodeServiceOverride) {
	        return providerConfig.promoCodeServiceOverride(form, formState, formActions);
	    }
	    return runPromoCodeValidation(form, formState, formActions)
	        .then((updatedFormState) => afterPromoCodeChange(form, updatedFormState, formActions));
	};

	/* src/components/elements/paymentSummary/PaymentSummary.svelte generated by Svelte v4.2.12 */

	function get_each_context$b(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[36] = list[i];
		return child_ctx;
	}

	function get_each_context_1$3(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[39] = list[i];
		return child_ctx;
	}

	function get_each_context_2(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[42] = list[i];
		return child_ctx;
	}

	// (52:2) {#each chargeItems as chargeItem}
	function create_each_block_2(ctx) {
		let div1;
		let span0;
		let t0_value = /*chargeItem*/ ctx[42].label + "";
		let t0;
		let t1;
		let div0;
		let span1;
		let t2_value = /*chargeItem*/ ctx[42].priceFormattedString + "";
		let t2;

		return {
			c() {
				div1 = element("div");
				span0 = element("span");
				t0 = text(t0_value);
				t1 = space();
				div0 = element("div");
				span1 = element("span");
				t2 = text(t2_value);
				attr(span0, "class", "zephr-form-summary-charge-description zephr-payment-form-summary-charge-description svelte-xf8v79");
				attr(div0, "class", "zephr-form-summary-line-right zephr-payment-form-summary-line-right svelte-xf8v79");
				attr(div1, "class", "zephr-form-charge-line zephr-payment-form-charge-line svelte-xf8v79");
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, span0);
				append(span0, t0);
				append(div1, t1);
				append(div1, div0);
				append(div0, span1);
				append(span1, t2);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*chargeItems*/ 524288 && t0_value !== (t0_value = /*chargeItem*/ ctx[42].label + "")) set_data(t0, t0_value);
				if (dirty[0] & /*chargeItems*/ 524288 && t2_value !== (t2_value = /*chargeItem*/ ctx[42].priceFormattedString + "")) set_data(t2, t2_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
				}
			}
		};
	}

	// (65:2) {#if paymentProvider === 'braintree' && discounts.length > 0}
	function create_if_block_14$2(ctx) {
		let each_1_anchor;
		let each_value_1 = ensure_array_like(/*discounts*/ ctx[23]);
		let each_blocks = [];

		for (let i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
		}

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*discounts*/ 8388608) {
					each_value_1 = ensure_array_like(/*discounts*/ ctx[23]);
					let i;

					for (i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block_1$3(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value_1.length;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (66:4) {#each discounts as discount}
	function create_each_block_1$3(ctx) {
		let div2;
		let div0;
		let t0_value = /*discount*/ ctx[39].description + "";
		let t0;
		let t1;
		let div1;
		let t2_value = /*discount*/ ctx[39].formattedAmount + "";
		let t2;
		let t3;

		return {
			c() {
				div2 = element("div");
				div0 = element("div");
				t0 = text(t0_value);
				t1 = space();
				div1 = element("div");
				t2 = text(t2_value);
				t3 = space();
				attr(div0, "class", "zephr-payment-form-summary-discount-description");
				attr(div1, "class", "zephr-form-summary-line-right zephr-payment-form-summary-line-right discount-value svelte-xf8v79");
				attr(div2, "class", "zephr-form-discount-line zephr-payment-form-discount-line svelte-xf8v79");
			},
			m(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div0);
				append(div0, t0);
				append(div2, t1);
				append(div2, div1);
				append(div1, t2);
				append(div2, t3);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*discounts*/ 8388608 && t0_value !== (t0_value = /*discount*/ ctx[39].description + "")) set_data(t0, t0_value);
				if (dirty[0] & /*discounts*/ 8388608 && t2_value !== (t2_value = /*discount*/ ctx[39].formattedAmount + "")) set_data(t2, t2_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div2);
				}
			}
		};
	}

	// (78:2) {#if tax}
	function create_if_block_13$2(ctx) {
		let div2;
		let div0;
		let t0;
		let t1;
		let div1;
		let t2;

		return {
			c() {
				div2 = element("div");
				div0 = element("div");
				t0 = text(/*taxLabel*/ ctx[22]);
				t1 = space();
				div1 = element("div");
				t2 = text(/*tax*/ ctx[21]);
				attr(div0, "class", "zephr-form-summary-charge-description zephr-payment-form-summary-charge-description svelte-xf8v79");
				attr(div1, "class", "zephr-form-summary-line-right zephr-payment-form-summary-line-right svelte-xf8v79");
				attr(div2, "class", "zephr-form-charge-line zephr-payment-form-charge-line svelte-xf8v79");
			},
			m(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div0);
				append(div0, t0);
				append(div2, t1);
				append(div2, div1);
				append(div1, t2);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*taxLabel*/ 4194304) set_data(t0, /*taxLabel*/ ctx[22]);
				if (dirty[0] & /*tax*/ 2097152) set_data(t2, /*tax*/ ctx[21]);
			},
			d(detaching) {
				if (detaching) {
					detach(div2);
				}
			}
		};
	}

	// (88:2) {#each addons as addon}
	function create_each_block$b(ctx) {
		let div1;
		let span0;
		let t0_value = /*addon*/ ctx[36].label + "";
		let t0;
		let t1;
		let div0;
		let span1;
		let t2_value = /*addon*/ ctx[36].addonPrice + "";
		let t2;

		return {
			c() {
				div1 = element("div");
				span0 = element("span");
				t0 = text(t0_value);
				t1 = space();
				div0 = element("div");
				span1 = element("span");
				t2 = text(t2_value);
				attr(div0, "class", "zephr-form-summary-line-right zephr-payment-form-summary-line-right svelte-xf8v79");
				attr(div1, "class", "zephr-form-addon-line zephr-payment-form-addon-line svelte-xf8v79");
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, span0);
				append(span0, t0);
				append(div1, t1);
				append(div1, div0);
				append(div0, span1);
				append(span1, t2);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*addons*/ 262144 && t0_value !== (t0_value = /*addon*/ ctx[36].label + "")) set_data(t0, t0_value);
				if (dirty[0] & /*addons*/ 262144 && t2_value !== (t2_value = /*addon*/ ctx[36].addonPrice + "")) set_data(t2, t2_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
				}
			}
		};
	}

	// (100:2) {#if allowPromoCodes}
	function create_if_block_2$e(ctx) {
		let t;
		let if_block1_anchor;
		let current;
		let if_block0 = !/*paymentProcessed*/ ctx[17] && !(/*showPromoCode*/ ctx[29] || /*promoCode*/ ctx[11]) && create_if_block_12$2(ctx);
		let if_block1 = (/*showPromoCode*/ ctx[29] || /*promoCode*/ ctx[11]) && create_if_block_3$a(ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (!/*paymentProcessed*/ ctx[17] && !(/*showPromoCode*/ ctx[29] || /*promoCode*/ ctx[11])) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_12$2(ctx);
						if_block0.c();
						if_block0.m(t.parentNode, t);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*showPromoCode*/ ctx[29] || /*promoCode*/ ctx[11]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty[0] & /*showPromoCode, promoCode*/ 536872960) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_3$a(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
			}
		};
	}

	// (101:4) {#if !paymentProcessed && !(showPromoCode || promoCode)}
	function create_if_block_12$2(ctx) {
		let button;
		let span;
		let t;
		let mounted;
		let dispose;

		return {
			c() {
				button = element("button");
				span = element("span");
				t = text(/*promoCodeLinkText*/ ctx[4]);
				attr(button, "type", "button");
				attr(button, "class", "zephr-form-promo-activate-line zephr-payment-form-promo-activate-line svelte-xf8v79");
			},
			m(target, anchor) {
				insert(target, button, anchor);
				append(button, span);
				append(span, t);

				if (!mounted) {
					dispose = listen(button, "click", /*click_handler*/ ctx[34]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*promoCodeLinkText*/ 16) set_data(t, /*promoCodeLinkText*/ ctx[4]);
			},
			d(detaching) {
				if (detaching) {
					detach(button);
				}

				mounted = false;
				dispose();
			}
		};
	}

	// (110:4) {#if showPromoCode || promoCode}
	function create_if_block_3$a(ctx) {
		let div2;
		let div0;
		let current_block_type_index;
		let if_block0;
		let t0;
		let div1;
		let current_block_type_index_1;
		let if_block1;
		let div1_class_value;
		let t1;
		let if_block2_anchor;
		let current;
		const if_block_creators = [create_if_block_8$3, create_if_block_9$2];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*paymentProcessed*/ ctx[17] && /*promoCode*/ ctx[11]) return 0;
			if (!/*paymentProcessed*/ ctx[17]) return 1;
			return -1;
		}

		if (~(current_block_type_index = select_block_type(ctx))) {
			if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		}

		const if_block_creators_1 = [create_if_block_5$6, create_if_block_7$3];
		const if_blocks_1 = [];

		function select_block_type_2(ctx, dirty) {
			if (/*promoCodeValid*/ ctx[12]) return 0;
			if (!/*paymentProcessed*/ ctx[17]) return 1;
			return -1;
		}

		if (~(current_block_type_index_1 = select_block_type_2(ctx))) {
			if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
		}

		let if_block2 = /*error*/ ctx[14] && create_if_block_4$8(ctx);

		return {
			c() {
				div2 = element("div");
				div0 = element("div");
				if (if_block0) if_block0.c();
				t0 = space();
				div1 = element("div");
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				if_block2_anchor = empty();
				attr(div0, "class", "zephr-form-promo-input-container zephr-payment-form-promo-input-container svelte-xf8v79");

				attr(div1, "class", div1_class_value = "" + (null_to_empty(/*promoCodeValid*/ ctx[12]
				? "zephr-form-summary-line-right zephr-payment-form-summary-line-right"
				: "zephr-form-summary-line-left zephr-payment-form-summary-line-left") + " svelte-xf8v79"));

				attr(div2, "class", "zephr-form-promo-line zephr-payment-form-promo-line svelte-xf8v79");
			},
			m(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div0);

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].m(div0, null);
				}

				append(div2, t0);
				append(div2, div1);

				if (~current_block_type_index_1) {
					if_blocks_1[current_block_type_index_1].m(div1, null);
				}

				insert(target, t1, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, if_block2_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if (~current_block_type_index) {
						if_blocks[current_block_type_index].p(ctx, dirty);
					}
				} else {
					if (if_block0) {
						group_outros();

						transition_out(if_blocks[previous_block_index], 1, 1, () => {
							if_blocks[previous_block_index] = null;
						});

						check_outros();
					}

					if (~current_block_type_index) {
						if_block0 = if_blocks[current_block_type_index];

						if (!if_block0) {
							if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
							if_block0.c();
						} else {
							if_block0.p(ctx, dirty);
						}

						transition_in(if_block0, 1);
						if_block0.m(div0, null);
					} else {
						if_block0 = null;
					}
				}

				let previous_block_index_1 = current_block_type_index_1;
				current_block_type_index_1 = select_block_type_2(ctx);

				if (current_block_type_index_1 === previous_block_index_1) {
					if (~current_block_type_index_1) {
						if_blocks_1[current_block_type_index_1].p(ctx, dirty);
					}
				} else {
					if (if_block1) {
						group_outros();

						transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
							if_blocks_1[previous_block_index_1] = null;
						});

						check_outros();
					}

					if (~current_block_type_index_1) {
						if_block1 = if_blocks_1[current_block_type_index_1];

						if (!if_block1) {
							if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
							if_block1.c();
						} else {
							if_block1.p(ctx, dirty);
						}

						transition_in(if_block1, 1);
						if_block1.m(div1, null);
					} else {
						if_block1 = null;
					}
				}

				if (!current || dirty[0] & /*promoCodeValid*/ 4096 && div1_class_value !== (div1_class_value = "" + (null_to_empty(/*promoCodeValid*/ ctx[12]
				? "zephr-form-summary-line-right zephr-payment-form-summary-line-right"
				: "zephr-form-summary-line-left zephr-payment-form-summary-line-left") + " svelte-xf8v79"))) {
					attr(div1, "class", div1_class_value);
				}

				if (/*error*/ ctx[14]) {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty[0] & /*error*/ 16384) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block_4$8(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(if_block2);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(if_block2);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div2);
					detach(t1);
					detach(if_block2_anchor);
				}

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].d();
				}

				if (~current_block_type_index_1) {
					if_blocks_1[current_block_type_index_1].d();
				}

				if (if_block2) if_block2.d(detaching);
			}
		};
	}

	// (117:38) 
	function create_if_block_9$2(ctx) {
		let div;
		let input;
		let current;

		input = new Input({
				props: {
					id: "zephr-form-promo-code",
					value: /*promoCode*/ ctx[11],
					placeholder: /*promoCodePlaceholder*/ ctx[5],
					maxlength: 50,
					hasError: /*error*/ ctx[14] != null,
					fill: true,
					isPaymentForm: true,
					onFocus: /*onFocus*/ ctx[27],
					onBlur: /*onBlur*/ ctx[28],
					$$slots: { default: [create_default_slot$3] },
					$$scope: { ctx }
				}
			});

		input.$on("change", /*change_handler*/ ctx[35]);

		return {
			c() {
				div = element("div");
				create_component(input.$$.fragment);
				attr(div, "class", "zephr-form-relative-container zephr-form-promo-input zephr-form-relative-container zephr-payment-form-promo-input");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(input, div, null);
				current = true;
			},
			p(ctx, dirty) {
				const input_changes = {};
				if (dirty[0] & /*promoCode*/ 2048) input_changes.value = /*promoCode*/ ctx[11];
				if (dirty[0] & /*promoCodePlaceholder*/ 32) input_changes.placeholder = /*promoCodePlaceholder*/ ctx[5];
				if (dirty[0] & /*error*/ 16384) input_changes.hasError = /*error*/ ctx[14] != null;
				if (dirty[0] & /*onFocus*/ 134217728) input_changes.onFocus = /*onFocus*/ ctx[27];
				if (dirty[0] & /*onBlur*/ 268435456) input_changes.onBlur = /*onBlur*/ ctx[28];

				if (dirty[0] & /*promoCodeValid, busy, error*/ 53248 | dirty[1] & /*$$scope*/ 16384) {
					input_changes.$$scope = { dirty, ctx };
				}

				input.$set(input_changes);
			},
			i(local) {
				if (current) return;
				transition_in(input.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(input.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(input);
			}
		};
	}

	// (113:10) {#if paymentProcessed && promoCode}
	function create_if_block_8$3(ctx) {
		let span;
		let t;

		return {
			c() {
				span = element("span");
				t = text(/*promoCode*/ ctx[11]);
				attr(span, "class", "zephr-form-summary-promo-middle zephr-payment-form-summary-promo-middle svelte-xf8v79");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*promoCode*/ 2048) set_data(t, /*promoCode*/ ctx[11]);
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (136:43) 
	function create_if_block_11$2(ctx) {
		let fa;
		let current;
		fa = new Fa({ props: { icon: faSpinner, spin: true } });

		return {
			c() {
				create_component(fa.$$.fragment);
			},
			m(target, anchor) {
				mount_component(fa, target, anchor);
				current = true;
			},
			i(local) {
				if (current) return;
				transition_in(fa.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(fa.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(fa, detaching);
			}
		};
	}

	// (134:18) {#if promoCodeValid}
	function create_if_block_10$2(ctx) {
		let fa;
		let current;
		fa = new Fa({ props: { icon: faCheck } });

		return {
			c() {
				create_component(fa.$$.fragment);
			},
			m(target, anchor) {
				mount_component(fa, target, anchor);
				current = true;
			},
			i(local) {
				if (current) return;
				transition_in(fa.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(fa.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(fa, detaching);
			}
		};
	}

	// (121:14) <Input                 id="zephr-form-promo-code"                 value={promoCode}                 placeholder={promoCodePlaceholder}                 maxlength={50}                 hasError={error != null}                 fill                 isPaymentForm                 on:change={({ detail }) => onChangePromoCode(detail)}                 onFocus={onFocus}                 onBlur={onBlur}               >
	function create_default_slot$3(ctx) {
		let div;
		let current_block_type_index;
		let if_block;
		let current;
		const if_block_creators = [create_if_block_10$2, create_if_block_11$2];
		const if_blocks = [];

		function select_block_type_1(ctx, dirty) {
			if (/*promoCodeValid*/ ctx[12]) return 0;
			if (/*busy*/ ctx[15] && !/*error*/ ctx[14]) return 1;
			return -1;
		}

		if (~(current_block_type_index = select_block_type_1(ctx))) {
			if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		}

		return {
			c() {
				div = element("div");
				if (if_block) if_block.c();
				attr(div, "class", "zephr-form-input-inner-text zephr-payment-form-input-inner-text zephr-form-input-inner-button");
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].m(div, null);
				}

				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx);

				if (current_block_type_index !== previous_block_index) {
					if (if_block) {
						group_outros();

						transition_out(if_blocks[previous_block_index], 1, 1, () => {
							if_blocks[previous_block_index] = null;
						});

						check_outros();
					}

					if (~current_block_type_index) {
						if_block = if_blocks[current_block_type_index];

						if (!if_block) {
							if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
							if_block.c();
						}

						transition_in(if_block, 1);
						if_block.m(div, null);
					} else {
						if_block = null;
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].d();
				}
			}
		};
	}

	// (155:38) 
	function create_if_block_7$3(ctx) {
		let button;
		let current;

		button = new Button({
				props: {
					disabled: /*promoCodeDisabled*/ ctx[16],
					text: /*promoCodeButtonText*/ ctx[6],
					onClick: /*verifyPromoCode*/ ctx[26],
					noMargin: true,
					inputHeight: true,
					isPaymentForm: true
				}
			});

		return {
			c() {
				create_component(button.$$.fragment);
			},
			m(target, anchor) {
				mount_component(button, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const button_changes = {};
				if (dirty[0] & /*promoCodeDisabled*/ 65536) button_changes.disabled = /*promoCodeDisabled*/ ctx[16];
				if (dirty[0] & /*promoCodeButtonText*/ 64) button_changes.text = /*promoCodeButtonText*/ ctx[6];
				if (dirty[0] & /*verifyPromoCode*/ 67108864) button_changes.onClick = /*verifyPromoCode*/ ctx[26];
				button.$set(button_changes);
			},
			i(local) {
				if (current) return;
				transition_in(button.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(button.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(button, detaching);
			}
		};
	}

	// (149:10) {#if promoCodeValid}
	function create_if_block_5$6(ctx) {
		let span;
		let if_block = /*showPromoCodeDiscountAmount*/ ctx[0] && create_if_block_6$6(ctx);

		return {
			c() {
				span = element("span");
				if (if_block) if_block.c();
				attr(span, "class", "zephr-form-summary-promo-middle zephr-payment-form-summary-promo-middle svelte-xf8v79");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},
			p(ctx, dirty) {
				if (/*showPromoCodeDiscountAmount*/ ctx[0]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block_6$6(ctx);
						if_block.c();
						if_block.m(span, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(span);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (151:14) {#if showPromoCodeDiscountAmount}
	function create_if_block_6$6(ctx) {
		let t0;
		let t1;

		return {
			c() {
				t0 = text("- ");
				t1 = text(/*discountAmount*/ ctx[13]);
			},
			m(target, anchor) {
				insert(target, t0, anchor);
				insert(target, t1, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*discountAmount*/ 8192) set_data(t1, /*discountAmount*/ ctx[13]);
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
				}
			}
		};
	}

	// (167:6) {#if error}
	function create_if_block_4$8(ctx) {
		let errormessage;
		let current;

		errormessage = new ErrorMessage({
				props: {
					error: /*error*/ ctx[14],
					isPaymentForm: true
				}
			});

		return {
			c() {
				create_component(errormessage.$$.fragment);
			},
			m(target, anchor) {
				mount_component(errormessage, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const errormessage_changes = {};
				if (dirty[0] & /*error*/ 16384) errormessage_changes.error = /*error*/ ctx[14];
				errormessage.$set(errormessage_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errormessage.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errormessage.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(errormessage, detaching);
			}
		};
	}

	// (180:2) {#if prorateDisclaimer}
	function create_if_block_1$m(ctx) {
		let div;
		let t;

		return {
			c() {
				div = element("div");
				t = text(/*prorateDisclaimer*/ ctx[10]);
				attr(div, "class", "zephr-form-summary-prorate-disclaimer zephr-payment-form-summary-prorate-disclaimer svelte-xf8v79");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*prorateDisclaimer*/ 1024) set_data(t, /*prorateDisclaimer*/ ctx[10]);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (185:2) {#if changeSubscriptionProrate}
	function create_if_block$v(ctx) {
		let div2;
		let div0;
		let t0_value = (/*prorateLabel*/ ctx[9] ?? "DUE TODAY") + "";
		let t0;
		let t1;
		let div1;
		let t2_value = /*changeSubscriptionProrate*/ ctx[20].totalPriceFormattedString + "";
		let t2;

		return {
			c() {
				div2 = element("div");
				div0 = element("div");
				t0 = text(t0_value);
				t1 = space();
				div1 = element("div");
				t2 = text(t2_value);
				attr(div0, "class", "zephr-form-summary-line-total-title zephr-payment-form-summary-line-total-title");
				attr(div1, "class", "zephr-form-summary-line-price zephr-payment-form-summary-line-price svelte-xf8v79");
				attr(div2, "class", "zephr-form-summary-line zephr-form-summary-price-line zephr-payment-form-summary-line zephr-payment-form-summary-price-line svelte-xf8v79");
			},
			m(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div0);
				append(div0, t0);
				append(div2, t1);
				append(div2, div1);
				append(div1, t2);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*prorateLabel*/ 512 && t0_value !== (t0_value = (/*prorateLabel*/ ctx[9] ?? "DUE TODAY") + "")) set_data(t0, t0_value);
				if (dirty[0] & /*changeSubscriptionProrate*/ 1048576 && t2_value !== (t2_value = /*changeSubscriptionProrate*/ ctx[20].totalPriceFormattedString + "")) set_data(t2, t2_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div2);
				}
			}
		};
	}

	function create_fragment$F(ctx) {
		let div7;
		let div0;
		let t0;
		let t1;
		let div3;
		let div1;
		let t2;
		let t3;
		let div2;
		let t4;
		let t5;
		let t6;
		let t7;
		let t8;
		let t9;
		let t10;
		let div6;
		let div4;
		let t11;
		let t12;
		let div5;
		let t13;
		let t14;
		let t15;
		let current;
		let each_value_2 = ensure_array_like(/*chargeItems*/ ctx[19]);
		let each_blocks_1 = [];

		for (let i = 0; i < each_value_2.length; i += 1) {
			each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
		}

		let if_block0 = /*paymentProvider*/ ctx[24] === 'braintree' && /*discounts*/ ctx[23].length > 0 && create_if_block_14$2(ctx);
		let if_block1 = /*tax*/ ctx[21] && create_if_block_13$2(ctx);
		let each_value = ensure_array_like(/*addons*/ ctx[18]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
		}

		let if_block2 = /*allowPromoCodes*/ ctx[3] && create_if_block_2$e(ctx);
		let if_block3 = /*prorateDisclaimer*/ ctx[10] && create_if_block_1$m(ctx);
		let if_block4 = /*changeSubscriptionProrate*/ ctx[20] && create_if_block$v(ctx);

		return {
			c() {
				div7 = element("div");
				div0 = element("div");
				t0 = text(/*title*/ ctx[7]);
				t1 = space();
				div3 = element("div");
				div1 = element("div");
				t2 = text(/*planTitle*/ ctx[1]);
				t3 = space();
				div2 = element("div");
				t4 = text(/*displayPrice*/ ctx[30]);
				t5 = space();

				for (let i = 0; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].c();
				}

				t6 = space();
				if (if_block0) if_block0.c();
				t7 = space();
				if (if_block1) if_block1.c();
				t8 = space();

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t9 = space();
				if (if_block2) if_block2.c();
				t10 = space();
				div6 = element("div");
				div4 = element("div");
				t11 = text(/*totalLabel*/ ctx[8]);
				t12 = space();
				div5 = element("div");
				t13 = text(/*totalPrice*/ ctx[2]);
				t14 = space();
				if (if_block3) if_block3.c();
				t15 = space();
				if (if_block4) if_block4.c();
				attr(div0, "class", "zephr-form-summary-title zephr-payment-form-summary-title svelte-xf8v79");
				attr(div1, "class", "zephr-form-summary-line-title zephr-payment-form-summary-line-title svelte-xf8v79");
				attr(div2, "class", "zephr-form-summary-line-price zephr-payment-form-summary-line-price svelte-xf8v79");
				attr(div3, "class", "zephr-form-summary-line zephr-payment-form-summary-line svelte-xf8v79");
				attr(div4, "class", "zephr-form-summary-line-total-title zephr-payment-form-summary-line-total-title");
				attr(div5, "class", "zephr-form-summary-line-price zephr-payment-form-summary-line-price svelte-xf8v79");
				attr(div6, "class", "zephr-form-summary-line zephr-form-summary-price-line zephr-form-summary-price-line-upper zephr-payment-form-summary-line zephr-payment-form-summary-price-line zephr-payment-form-summary-price-line-upper svelte-xf8v79");
				attr(div7, "class", "zephr-form-summary zephr-payment-form-summary svelte-xf8v79");
			},
			m(target, anchor) {
				insert(target, div7, anchor);
				append(div7, div0);
				append(div0, t0);
				append(div7, t1);
				append(div7, div3);
				append(div3, div1);
				append(div1, t2);
				append(div3, t3);
				append(div3, div2);
				append(div2, t4);
				append(div7, t5);

				for (let i = 0; i < each_blocks_1.length; i += 1) {
					if (each_blocks_1[i]) {
						each_blocks_1[i].m(div7, null);
					}
				}

				append(div7, t6);
				if (if_block0) if_block0.m(div7, null);
				append(div7, t7);
				if (if_block1) if_block1.m(div7, null);
				append(div7, t8);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div7, null);
					}
				}

				append(div7, t9);
				if (if_block2) if_block2.m(div7, null);
				append(div7, t10);
				append(div7, div6);
				append(div6, div4);
				append(div4, t11);
				append(div6, t12);
				append(div6, div5);
				append(div5, t13);
				append(div7, t14);
				if (if_block3) if_block3.m(div7, null);
				append(div7, t15);
				if (if_block4) if_block4.m(div7, null);
				current = true;
			},
			p(ctx, dirty) {
				if (!current || dirty[0] & /*title*/ 128) set_data(t0, /*title*/ ctx[7]);
				if (!current || dirty[0] & /*planTitle*/ 2) set_data(t2, /*planTitle*/ ctx[1]);
				if (!current || dirty[0] & /*displayPrice*/ 1073741824) set_data(t4, /*displayPrice*/ ctx[30]);

				if (dirty[0] & /*chargeItems*/ 524288) {
					each_value_2 = ensure_array_like(/*chargeItems*/ ctx[19]);
					let i;

					for (i = 0; i < each_value_2.length; i += 1) {
						const child_ctx = get_each_context_2(ctx, each_value_2, i);

						if (each_blocks_1[i]) {
							each_blocks_1[i].p(child_ctx, dirty);
						} else {
							each_blocks_1[i] = create_each_block_2(child_ctx);
							each_blocks_1[i].c();
							each_blocks_1[i].m(div7, t6);
						}
					}

					for (; i < each_blocks_1.length; i += 1) {
						each_blocks_1[i].d(1);
					}

					each_blocks_1.length = each_value_2.length;
				}

				if (/*paymentProvider*/ ctx[24] === 'braintree' && /*discounts*/ ctx[23].length > 0) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_14$2(ctx);
						if_block0.c();
						if_block0.m(div7, t7);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*tax*/ ctx[21]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_13$2(ctx);
						if_block1.c();
						if_block1.m(div7, t8);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (dirty[0] & /*addons*/ 262144) {
					each_value = ensure_array_like(/*addons*/ ctx[18]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$b(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$b(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(div7, t9);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}

				if (/*allowPromoCodes*/ ctx[3]) {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty[0] & /*allowPromoCodes*/ 8) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block_2$e(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(div7, t10);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}

				if (!current || dirty[0] & /*totalLabel*/ 256) set_data(t11, /*totalLabel*/ ctx[8]);
				if (!current || dirty[0] & /*totalPrice*/ 4) set_data(t13, /*totalPrice*/ ctx[2]);

				if (/*prorateDisclaimer*/ ctx[10]) {
					if (if_block3) {
						if_block3.p(ctx, dirty);
					} else {
						if_block3 = create_if_block_1$m(ctx);
						if_block3.c();
						if_block3.m(div7, t15);
					}
				} else if (if_block3) {
					if_block3.d(1);
					if_block3 = null;
				}

				if (/*changeSubscriptionProrate*/ ctx[20]) {
					if (if_block4) {
						if_block4.p(ctx, dirty);
					} else {
						if_block4 = create_if_block$v(ctx);
						if_block4.c();
						if_block4.m(div7, null);
					}
				} else if (if_block4) {
					if_block4.d(1);
					if_block4 = null;
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block2);
				current = true;
			},
			o(local) {
				transition_out(if_block2);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div7);
				}

				destroy_each(each_blocks_1, detaching);
				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				destroy_each(each_blocks, detaching);
				if (if_block2) if_block2.d();
				if (if_block3) if_block3.d();
				if (if_block4) if_block4.d();
			}
		};
	}

	function instance$F($$self, $$props, $$invalidate) {
		let displayPrice;
		let { showPromoCodeDiscountAmount = true } = $$props;
		let { planTitle } = $$props;
		let { price } = $$props;
		let { totalPrice } = $$props;
		let { allowPromoCodes } = $$props;
		let { promoCodeLinkText } = $$props;
		let { promoCodePlaceholder } = $$props;
		let { promoCodeButtonText } = $$props;
		let { title } = $$props;
		let { totalLabel } = $$props;
		let { prorateLabel } = $$props;
		let { prorateDisclaimer } = $$props;
		let { promoCode } = $$props;
		let { promoCodeValid } = $$props;
		let { discountAmount } = $$props;
		let { error = null } = $$props;
		let { busy } = $$props;
		let { promoCodeDisabled } = $$props;
		let { paymentProcessed } = $$props;
		let { addons } = $$props;
		let { chargeItems } = $$props;
		let { changeSubscriptionProrate } = $$props;
		let { tax } = $$props;
		let { taxLabel } = $$props;
		let { subTotal } = $$props;
		let { discounts = [] } = $$props;
		let { paymentProvider = '' } = $$props;
		let { onChangePromoCode } = $$props;
		let { verifyPromoCode } = $$props;
		let { onFocus } = $$props;
		let { onBlur } = $$props;
		let { logBeginCheckout } = $$props;
		let showPromoCode = false;
		logBeginCheckout();
		const click_handler = () => $$invalidate(29, showPromoCode = true);
		const change_handler = ({ detail }) => onChangePromoCode(detail);

		$$self.$$set = $$props => {
			if ('showPromoCodeDiscountAmount' in $$props) $$invalidate(0, showPromoCodeDiscountAmount = $$props.showPromoCodeDiscountAmount);
			if ('planTitle' in $$props) $$invalidate(1, planTitle = $$props.planTitle);
			if ('price' in $$props) $$invalidate(31, price = $$props.price);
			if ('totalPrice' in $$props) $$invalidate(2, totalPrice = $$props.totalPrice);
			if ('allowPromoCodes' in $$props) $$invalidate(3, allowPromoCodes = $$props.allowPromoCodes);
			if ('promoCodeLinkText' in $$props) $$invalidate(4, promoCodeLinkText = $$props.promoCodeLinkText);
			if ('promoCodePlaceholder' in $$props) $$invalidate(5, promoCodePlaceholder = $$props.promoCodePlaceholder);
			if ('promoCodeButtonText' in $$props) $$invalidate(6, promoCodeButtonText = $$props.promoCodeButtonText);
			if ('title' in $$props) $$invalidate(7, title = $$props.title);
			if ('totalLabel' in $$props) $$invalidate(8, totalLabel = $$props.totalLabel);
			if ('prorateLabel' in $$props) $$invalidate(9, prorateLabel = $$props.prorateLabel);
			if ('prorateDisclaimer' in $$props) $$invalidate(10, prorateDisclaimer = $$props.prorateDisclaimer);
			if ('promoCode' in $$props) $$invalidate(11, promoCode = $$props.promoCode);
			if ('promoCodeValid' in $$props) $$invalidate(12, promoCodeValid = $$props.promoCodeValid);
			if ('discountAmount' in $$props) $$invalidate(13, discountAmount = $$props.discountAmount);
			if ('error' in $$props) $$invalidate(14, error = $$props.error);
			if ('busy' in $$props) $$invalidate(15, busy = $$props.busy);
			if ('promoCodeDisabled' in $$props) $$invalidate(16, promoCodeDisabled = $$props.promoCodeDisabled);
			if ('paymentProcessed' in $$props) $$invalidate(17, paymentProcessed = $$props.paymentProcessed);
			if ('addons' in $$props) $$invalidate(18, addons = $$props.addons);
			if ('chargeItems' in $$props) $$invalidate(19, chargeItems = $$props.chargeItems);
			if ('changeSubscriptionProrate' in $$props) $$invalidate(20, changeSubscriptionProrate = $$props.changeSubscriptionProrate);
			if ('tax' in $$props) $$invalidate(21, tax = $$props.tax);
			if ('taxLabel' in $$props) $$invalidate(22, taxLabel = $$props.taxLabel);
			if ('subTotal' in $$props) $$invalidate(32, subTotal = $$props.subTotal);
			if ('discounts' in $$props) $$invalidate(23, discounts = $$props.discounts);
			if ('paymentProvider' in $$props) $$invalidate(24, paymentProvider = $$props.paymentProvider);
			if ('onChangePromoCode' in $$props) $$invalidate(25, onChangePromoCode = $$props.onChangePromoCode);
			if ('verifyPromoCode' in $$props) $$invalidate(26, verifyPromoCode = $$props.verifyPromoCode);
			if ('onFocus' in $$props) $$invalidate(27, onFocus = $$props.onFocus);
			if ('onBlur' in $$props) $$invalidate(28, onBlur = $$props.onBlur);
			if ('logBeginCheckout' in $$props) $$invalidate(33, logBeginCheckout = $$props.logBeginCheckout);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty[0] & /*chargeItems*/ 524288 | $$self.$$.dirty[1] & /*subTotal, price*/ 3) {
				$$invalidate(30, displayPrice = chargeItems.length ? "" : subTotal || price);
			}
		};

		return [
			showPromoCodeDiscountAmount,
			planTitle,
			totalPrice,
			allowPromoCodes,
			promoCodeLinkText,
			promoCodePlaceholder,
			promoCodeButtonText,
			title,
			totalLabel,
			prorateLabel,
			prorateDisclaimer,
			promoCode,
			promoCodeValid,
			discountAmount,
			error,
			busy,
			promoCodeDisabled,
			paymentProcessed,
			addons,
			chargeItems,
			changeSubscriptionProrate,
			tax,
			taxLabel,
			discounts,
			paymentProvider,
			onChangePromoCode,
			verifyPromoCode,
			onFocus,
			onBlur,
			showPromoCode,
			displayPrice,
			price,
			subTotal,
			logBeginCheckout,
			click_handler,
			change_handler
		];
	}

	class PaymentSummary extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$F,
				create_fragment$F,
				safe_not_equal,
				{
					showPromoCodeDiscountAmount: 0,
					planTitle: 1,
					price: 31,
					totalPrice: 2,
					allowPromoCodes: 3,
					promoCodeLinkText: 4,
					promoCodePlaceholder: 5,
					promoCodeButtonText: 6,
					title: 7,
					totalLabel: 8,
					prorateLabel: 9,
					prorateDisclaimer: 10,
					promoCode: 11,
					promoCodeValid: 12,
					discountAmount: 13,
					error: 14,
					busy: 15,
					promoCodeDisabled: 16,
					paymentProcessed: 17,
					addons: 18,
					chargeItems: 19,
					changeSubscriptionProrate: 20,
					tax: 21,
					taxLabel: 22,
					subTotal: 32,
					discounts: 23,
					paymentProvider: 24,
					onChangePromoCode: 25,
					verifyPromoCode: 26,
					onFocus: 27,
					onBlur: 28,
					logBeginCheckout: 33
				},
				null,
				[-1, -1]
			);
		}
	}

	const factory$d = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.PAYMENT_SUMMARY,
	    create: (form, formState, formActions, elementConfig) => {
	        const paymentProviderConfig = paymentProviderFor(form.organisationConfiguration.paymentProvider);
	        return {
	            component: PaymentSummary,
	            props: {
	                showPromoCodeDiscountAmount: !formConfigAs(form).dynamicOffer,
	                price: formState.paymentOptionPrices?.netPriceFormattedString ?? '-',
	                totalPrice: formState.paymentOptionPrices?.totalPriceFormattedString ?? '-',
	                tax: formState.paymentOptionPrices?.taxPriceFormattedString,
	                taxLabel: elementConfig.taxLabel ?? "Tax",
	                subTotal: formState.paymentOptionPrices?.netPriceFormattedString,
	                planTitle: formState.paymentOption.label,
	                paymentProvider: form.organisationConfiguration.paymentProvider,
	                // If we're using braintree we will need the full discounts array to display each discount
	                discounts: form.organisationConfiguration.paymentProvider === 'braintree' ?
	                    (formConfigAs(form).paymentOptions
	                        .find(opt => opt.productId === formState.paymentOption.productId && opt.slug === formState.paymentOption.slug)
	                        ?.discounts || [])
	                        .map(discount => ({
	                        description: discount.description || discount.name,
	                        formattedAmount: `- ${formatCurrency(discount.amount || 0, formState.paymentOption.currencyCode)}`
	                    })) : [],
	                allowPromoCodes: (formConfigAs(form).promoCodeConfig?.promoCodeAllowed
	                    || formConfigAs(form).dynamicOffer /* TODO temp just for customer demo */) && paymentProviderConfig.hasPromoCodes(form),
	                promoCodeLinkText: formConfigAs(form).promoCodeConfig?.promoCodeText,
	                promoCodePlaceholder: formConfigAs(form).promoCodeConfig?.promoCodePlaceholder,
	                promoCodeButtonText: formConfigAs(form).promoCodeConfig?.promoCodeButtonText,
	                totalLabel: elementConfig.total,
	                prorateLabel: elementConfig.prorateLabel,
	                prorateDisclaimer: (!formConfigAs(form).changeSubscriptionMode || paymentProviderConfig.changeSubscriptionProrateCalculator) ? null : elementConfig.prorateDisclaimer,
	                title: elementConfig.title,
	                promoCode: formState.promoCode,
	                busy: formState.isBusyByKey[verifyingPromoCodeBusyKey],
	                promoCodeDisabled: formState.isBusy || formState.promoCode?.length === 0,
	                paymentProcessed: formState.paymentProcessed,
	                discountAmount: formState.paymentOptionPrices?.discountPriceFormattedPrice ?? '-',
	                addons: addonsForPlan(formState)
	                    .map(addon => ({
	                    label: addon.label,
	                    addonPrice: formatCurrency(addon.addonPrice, formState.paymentOption.currencyCode)
	                })),
	                chargeItems: formState.paymentOptionPrices?.chargeItems ?? [],
	                promoCodeValid: formState.promoCodeValid,
	                changeSubscriptionProrate: formState.changeSubscriptionProrate,
	                onChangePromoCode: (value) => {
	                    let updateFormState = formActions.updateFormState({
	                        promoCode: value,
	                        promoCodeValid: undefined,
	                        discountedPlanPrices: []
	                    });
	                    // If we're going from a valid promo code -> incomplete promo code, the mobile payment button needs resetting
	                    if (formState.promoCodeValid) {
	                        if (formState.originalDynamicOfferResult) {
	                            updateFormState = formActions.updateFormState({
	                                dynamicOfferResult: formState.originalDynamicOfferResult
	                            });
	                        }
	                        void afterPromoCodeChange(form, updateFormState, formActions);
	                    }
	                    logDataLayerEvent(form, 'zephr_form_input_change', {
	                        inputName: 'zephr-form-promo-code',
	                        sectionId: formState.currentSection.type,
	                        field: 'promo-code'
	                    });
	                },
	                onFocus: () => logDataLayerEvent(form, 'zephr_form_input_focus', {
	                    inputName: 'zephr-form-promo-code',
	                    sectionId: formState.currentSection.type,
	                    field: 'promo-code'
	                }),
	                onBlur: () => logDataLayerEvent(form, 'zephr_form_input_blur', {
	                    inputName: 'zephr-form-promo-code',
	                    sectionId: formState.currentSection.type,
	                    field: 'promo-code'
	                }),
	                verifyPromoCode: () => {
	                    void validatePromoCode(form, formState, formActions);
	                },
	                logBeginCheckout: async () => {
	                    if (formState.currentPart.type === partTypes.PAYMENT.type) {
	                        if (form.organisationConfiguration.trackFormDataLayerEvents) {
	                            await calculatePrices(form, formState, formActions);
	                        }
	                        logDataLayerEvent(form, 'begin_checkout', {
	                            ecommerce: {
	                                currency: getRelevantCurrency(form, formState),
	                                value: formActions.getFormState().paymentOptionPrices?.totalPrice,
	                                items: [{
	                                        item_id: formState.paymentOption.slug,
	                                        item_name: formState.paymentOption.productId,
	                                        price: formActions.getFormState().paymentOptionPrices?.totalPrice,
	                                        quantity: 1
	                                    }]
	                            }
	                        });
	                    }
	                }
	            }
	        };
	    }
	};

	/* src/components/elements/divider/Divider.svelte generated by Svelte v4.2.12 */

	function create_if_block$u(ctx) {
		let div;
		let t0;
		let t1;
		let if_block0 = /*showLine*/ ctx[1] && create_if_block_3$9(ctx);
		let if_block1 = /*text*/ ctx[0] && create_if_block_2$d(ctx);
		let if_block2 = /*showLine*/ ctx[1] && /*text*/ ctx[0] && create_if_block_1$l(ctx);

		return {
			c() {
				div = element("div");
				if (if_block0) if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				attr(div, "class", "zephr-form-divider-container svelte-1jhhsfx");
				toggle_class(div, "zephr-payment-form-divider-container", /*isPaymentForm*/ ctx[3]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append(div, t0);
				if (if_block1) if_block1.m(div, null);
				append(div, t1);
				if (if_block2) if_block2.m(div, null);
			},
			p(ctx, dirty) {
				if (/*showLine*/ ctx[1]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_3$9(ctx);
						if_block0.c();
						if_block0.m(div, t0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*text*/ ctx[0]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_2$d(ctx);
						if_block1.c();
						if_block1.m(div, t1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (/*showLine*/ ctx[1] && /*text*/ ctx[0]) {
					if (if_block2) {
						if_block2.p(ctx, dirty);
					} else {
						if_block2 = create_if_block_1$l(ctx);
						if_block2.c();
						if_block2.m(div, null);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}

				if (dirty & /*isPaymentForm*/ 8) {
					toggle_class(div, "zephr-payment-form-divider-container", /*isPaymentForm*/ ctx[3]);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
			}
		};
	}

	// (12:4) {#if showLine}
	function create_if_block_3$9(ctx) {
		let if_block_anchor;

		function select_block_type(ctx, dirty) {
			if (/*text*/ ctx[0]) return create_if_block_4$7;
			return create_else_block$5;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				}
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_block.d(detaching);
			}
		};
	}

	// (18:8) {:else}
	function create_else_block$5(ctx) {
		let div;

		return {
			c() {
				div = element("div");
				attr(div, "class", "zephr-form-divider-line-complete svelte-1jhhsfx");
			},
			m(target, anchor) {
				insert(target, div, anchor);
			},
			p: noop,
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (13:6) {#if text}
	function create_if_block_4$7(ctx) {
		let div;

		return {
			c() {
				div = element("div");
				attr(div, "class", "zephr-form-divider-line svelte-1jhhsfx");
				toggle_class(div, "zephr-payment-form-divider-line", /*isPaymentForm*/ ctx[3]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*isPaymentForm*/ 8) {
					toggle_class(div, "zephr-payment-form-divider-line", /*isPaymentForm*/ ctx[3]);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (22:4) {#if text}
	function create_if_block_2$d(ctx) {
		let span;
		let t;

		return {
			c() {
				span = element("span");
				t = text(/*text*/ ctx[0]);
				attr(span, "class", "zephr-form-divider-text svelte-1jhhsfx");
				toggle_class(span, "zephr-payment-form-divider-text", /*isPaymentForm*/ ctx[3]);
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty & /*text*/ 1) set_data(t, /*text*/ ctx[0]);

				if (dirty & /*isPaymentForm*/ 8) {
					toggle_class(span, "zephr-payment-form-divider-text", /*isPaymentForm*/ ctx[3]);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (30:4) {#if showLine && text}
	function create_if_block_1$l(ctx) {
		let div;

		return {
			c() {
				div = element("div");
				attr(div, "class", "zephr-form-divider-line svelte-1jhhsfx");
				toggle_class(div, "zephr-payment-form-divider-line", /*isPaymentForm*/ ctx[3]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*isPaymentForm*/ 8) {
					toggle_class(div, "zephr-payment-form-divider-line", /*isPaymentForm*/ ctx[3]);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	function create_fragment$E(ctx) {
		let if_block_anchor;
		let if_block = /*show*/ ctx[2] && create_if_block$u(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, [dirty]) {
				if (/*show*/ ctx[2]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$u(ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	function instance$E($$self, $$props, $$invalidate) {
		let { text } = $$props;
		let { showLine } = $$props;
		let { show } = $$props;
		let { isPaymentForm = false } = $$props;

		$$self.$$set = $$props => {
			if ('text' in $$props) $$invalidate(0, text = $$props.text);
			if ('showLine' in $$props) $$invalidate(1, showLine = $$props.showLine);
			if ('show' in $$props) $$invalidate(2, show = $$props.show);
			if ('isPaymentForm' in $$props) $$invalidate(3, isPaymentForm = $$props.isPaymentForm);
		};

		return [text, showLine, show, isPaymentForm];
	}

	class Divider extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$E, create_fragment$E, safe_not_equal, {
				text: 0,
				showLine: 1,
				show: 2,
				isPaymentForm: 3
			});
		}
	}

	const factory$c = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.DIVIDER,
	    create: (form, formState, formActions, elementConfig) => ({
	        component: Divider,
	        props: {
	            text: elementConfig.text,
	            showLine: elementConfig.showLine,
	            show: elementConfig.show,
	            isPaymentForm: form.formType === FormType.PAYMENT,
	        }
	    })
	};

	/* src/components/elements/loginLink/LoginLink.svelte generated by Svelte v4.2.12 */

	function create_fragment$D(ctx) {
		let div;
		let t0;
		let t1;
		let a;
		let t2;

		return {
			c() {
				div = element("div");
				t0 = text(/*text*/ ctx[0]);
				t1 = space();
				a = element("a");
				t2 = text(/*linkText*/ ctx[1]);
				attr(a, "href", /*url*/ ctx[2]);
				attr(a, "class", "svelte-1jmemom");
				attr(div, "class", "zephr-form-login-link svelte-1jmemom");
				toggle_class(div, "zephr-payment-login-link", /*isPaymentForm*/ ctx[3]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t0);
				append(div, t1);
				append(div, a);
				append(a, t2);
			},
			p(ctx, [dirty]) {
				if (dirty & /*text*/ 1) set_data(t0, /*text*/ ctx[0]);
				if (dirty & /*linkText*/ 2) set_data(t2, /*linkText*/ ctx[1]);

				if (dirty & /*url*/ 4) {
					attr(a, "href", /*url*/ ctx[2]);
				}

				if (dirty & /*isPaymentForm*/ 8) {
					toggle_class(div, "zephr-payment-login-link", /*isPaymentForm*/ ctx[3]);
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	function instance$D($$self, $$props, $$invalidate) {
		let { text } = $$props;
		let { linkText } = $$props;
		let { url } = $$props;
		let { isPaymentForm = false } = $$props;

		$$self.$$set = $$props => {
			if ('text' in $$props) $$invalidate(0, text = $$props.text);
			if ('linkText' in $$props) $$invalidate(1, linkText = $$props.linkText);
			if ('url' in $$props) $$invalidate(2, url = $$props.url);
			if ('isPaymentForm' in $$props) $$invalidate(3, isPaymentForm = $$props.isPaymentForm);
		};

		return [text, linkText, url, isPaymentForm];
	}

	class LoginLink extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$D, create_fragment$D, safe_not_equal, {
				text: 0,
				linkText: 1,
				url: 2,
				isPaymentForm: 3
			});
		}
	}

	const factory$b = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.LOGIN_LINK,
	    create: (form, formState, formActions, elementConfig) => ({
	        component: LoginLink,
	        props: {
	            text: elementConfig.alreadyRegText,
	            linkText: elementConfig.loginText,
	            url: elementConfig.url,
	            isPaymentForm: form.formType === FormType.PAYMENT,
	        }
	    })
	};

	const factory$a = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.BUTTON && sectionElement.config.isLogin,
	    create: (form, formState, formActions, elementConfig) => ({
	        component: Button,
	        props: {
	            disabled: formState.isBusy,
	            text: elementConfig.text,
	            onClick: () => {
	                logDataLayerEvent(form, 'zephr_form_button_press', {
	                    sectionId: formState.currentSection.type,
	                    buttonType: 'SUBMIT'
	                });
	                formActions.updateFormState({
	                    forgotPassword: false,
	                });
	                formActions.jumpToPartStart(partTypes.ACCOUNT_VERIFICATION.type);
	            },
	            isPaymentForm: form.formType === FormType.PAYMENT,
	        }
	    })
	};

	const factory$9 = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.BUTTON && sectionElement.config.isCancel,
	    create: (form, formState, formActions, elementConfig) => ({
	        component: Button,
	        props: {
	            text: elementConfig.text,
	            onClick: () => {
	                logDataLayerEvent(form, 'zephr_form_button_press', {
	                    sectionId: formState.currentSection.type,
	                    buttonType: 'SUBMIT'
	                });
	                formActions.updateFormState({
	                    confirmCancel: true,
	                });
	                formActions.completeSection();
	            },
	        }
	    })
	};

	/* src/components/elements/accountMembershipCode/AccountMembershipCode.svelte generated by Svelte v4.2.12 */

	function create_if_block_1$k(ctx) {
		let link;
		let current;
		link = new Link({ props: { text: /*label*/ ctx[0] } });
		link.$on("linkClick", /*linkClick_handler*/ ctx[10]);

		return {
			c() {
				create_component(link.$$.fragment);
			},
			m(target, anchor) {
				mount_component(link, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const link_changes = {};
				if (dirty & /*label*/ 1) link_changes.text = /*label*/ ctx[0];
				link.$set(link_changes);
			},
			i(local) {
				if (current) return;
				transition_in(link.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(link.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(link, detaching);
			}
		};
	}

	// (23:2) {#if accountMembershipCode || showInput}
	function create_if_block$t(ctx) {
		let label_1;
		let t;
		let input;
		let current;

		label_1 = new Label({
				props: {
					forInput: /*id*/ ctx[8],
					label: /*label*/ ctx[0]
				}
			});

		input = new Input({
				props: {
					id: /*id*/ ctx[8],
					value: /*accountMembershipCode*/ ctx[2],
					errorMessage: /*error*/ ctx[3],
					placeholder: /*placeholder*/ ctx[1],
					onFocus: /*onFocus*/ ctx[5],
					onBlur: /*onBlur*/ ctx[6]
				}
			});

		input.$on("change", /*change_handler*/ ctx[11]);

		return {
			c() {
				create_component(label_1.$$.fragment);
				t = space();
				create_component(input.$$.fragment);
			},
			m(target, anchor) {
				mount_component(label_1, target, anchor);
				insert(target, t, anchor);
				mount_component(input, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const label_1_changes = {};
				if (dirty & /*label*/ 1) label_1_changes.label = /*label*/ ctx[0];
				label_1.$set(label_1_changes);
				const input_changes = {};
				if (dirty & /*accountMembershipCode*/ 4) input_changes.value = /*accountMembershipCode*/ ctx[2];
				if (dirty & /*error*/ 8) input_changes.errorMessage = /*error*/ ctx[3];
				if (dirty & /*placeholder*/ 2) input_changes.placeholder = /*placeholder*/ ctx[1];
				if (dirty & /*onFocus*/ 32) input_changes.onFocus = /*onFocus*/ ctx[5];
				if (dirty & /*onBlur*/ 64) input_changes.onBlur = /*onBlur*/ ctx[6];
				input.$set(input_changes);
			},
			i(local) {
				if (current) return;
				transition_in(label_1.$$.fragment, local);
				transition_in(input.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(label_1.$$.fragment, local);
				transition_out(input.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}

				destroy_component(label_1, detaching);
				destroy_component(input, detaching);
			}
		};
	}

	function create_fragment$C(ctx) {
		let div;
		let t;
		let current;
		let if_block0 = !/*showInput*/ ctx[7] && create_if_block_1$k(ctx);
		let if_block1 = (/*accountMembershipCode*/ ctx[2] || /*showInput*/ ctx[7]) && create_if_block$t(ctx);

		return {
			c() {
				div = element("div");
				if (if_block0) if_block0.c();
				t = space();
				if (if_block1) if_block1.c();
				attr(div, "class", "zephr-form-account-code-container svelte-1hhep92");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append(div, t);
				if (if_block1) if_block1.m(div, null);
				current = true;
			},
			p(ctx, [dirty]) {
				if (!/*showInput*/ ctx[7]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*showInput*/ 128) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_1$k(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div, t);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*accountMembershipCode*/ ctx[2] || /*showInput*/ ctx[7]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*accountMembershipCode, showInput*/ 132) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block$t(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div, null);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
			}
		};
	}

	function instance$C($$self, $$props, $$invalidate) {
		let { formKey } = $$props;
		let { label } = $$props;
		let { placeholder } = $$props;
		let { accountMembershipCode } = $$props;
		let { error = null } = $$props;
		let { onChange } = $$props;
		let { onFocus } = $$props;
		let { onBlur } = $$props;
		let showInput = false;
		const id = `zephr-form-account-code-${formKey}`;
		const linkClick_handler = () => $$invalidate(7, showInput = true);
		const change_handler = value => onChange(value.detail);

		$$self.$$set = $$props => {
			if ('formKey' in $$props) $$invalidate(9, formKey = $$props.formKey);
			if ('label' in $$props) $$invalidate(0, label = $$props.label);
			if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
			if ('accountMembershipCode' in $$props) $$invalidate(2, accountMembershipCode = $$props.accountMembershipCode);
			if ('error' in $$props) $$invalidate(3, error = $$props.error);
			if ('onChange' in $$props) $$invalidate(4, onChange = $$props.onChange);
			if ('onFocus' in $$props) $$invalidate(5, onFocus = $$props.onFocus);
			if ('onBlur' in $$props) $$invalidate(6, onBlur = $$props.onBlur);
		};

		return [
			label,
			placeholder,
			accountMembershipCode,
			error,
			onChange,
			onFocus,
			onBlur,
			showInput,
			id,
			formKey,
			linkClick_handler,
			change_handler
		];
	}

	class AccountMembershipCode extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$C, create_fragment$C, safe_not_equal, {
				formKey: 9,
				label: 0,
				placeholder: 1,
				accountMembershipCode: 2,
				error: 3,
				onChange: 4,
				onFocus: 5,
				onBlur: 6
			});
		}
	}

	const factory$8 = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.ACCOUNT_MEMBERSHIP_CODE,
	    create: (form, formState, formActions, elementConfig) => ({
	        component: AccountMembershipCode,
	        props: {
	            formKey: form.uniqueKey,
	            label: elementConfig.label,
	            placeholder: elementConfig.placeholder,
	            accountMembershipCode: formState.accountMembershipCode,
	            onChange: (value) => {
	                formActions.updateFormState({
	                    accountMembershipCode: value,
	                    serverErrors: [],
	                });
	                logDataLayerEvent(form, 'zephr_form_input_change', {
	                    inputName: `zephr-form-account-code-${form.uniqueKey}`,
	                    sectionId: formState.currentSection.type,
	                    field: 'account-code'
	                });
	            },
	            onFocus: () => logDataLayerEvent(form, 'zephr_form_input_focus', {
	                inputName: `zephr-form-account-code-${form.uniqueKey}`,
	                sectionId: formState.currentSection.type,
	                field: 'account-code'
	            }),
	            onBlur: () => logDataLayerEvent(form, 'zephr_form_input_blur', {
	                inputName: `zephr-form-account-code-${form.uniqueKey}`,
	                sectionId: formState.currentSection.type,
	                field: 'account-code'
	            }),
	        }
	    })
	};

	/* src/components/elements/invitation/Invitation.svelte generated by Svelte v4.2.12 */

	function create_if_block$s(ctx) {
		let div;
		let successmessage;
		let current;
		successmessage = new SuccessMessage({ props: { text: /*linkSentText*/ ctx[4] } });

		return {
			c() {
				div = element("div");
				create_component(successmessage.$$.fragment);
				attr(div, "class", "zephr-form-invitation-success-message svelte-1qkv7d3");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(successmessage, div, null);
				current = true;
			},
			p(ctx, dirty) {
				const successmessage_changes = {};
				if (dirty & /*linkSentText*/ 16) successmessage_changes.text = /*linkSentText*/ ctx[4];
				successmessage.$set(successmessage_changes);
			},
			i(local) {
				if (current) return;
				transition_in(successmessage.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(successmessage.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(successmessage);
			}
		};
	}

	function create_fragment$B(ctx) {
		let div4;
		let div0;
		let t0;
		let t1;
		let div1;
		let t2;
		let t3;
		let label_1;
		let t4;
		let div3;
		let div2;
		let input;
		let t5;
		let button;
		let t6;
		let current;

		label_1 = new Label({
				props: {
					forInput: /*id*/ ctx[14],
					label: /*label*/ ctx[2],
					isPaymentForm: /*isPaymentForm*/ ctx[11]
				}
			});

		input = new Input({
				props: {
					disabled: /*isBusy*/ ctx[10],
					required: true,
					id: /*id*/ ctx[14],
					value: /*invitationEmail*/ ctx[7] ?? '',
					errorMessage: /*error*/ ctx[9],
					isPaymentForm: /*isPaymentForm*/ ctx[11],
					onFocus: /*onFocus*/ ctx[12],
					onBlur: /*onBlur*/ ctx[13]
				}
			});

		input.$on("change", /*change_handler*/ ctx[16]);

		button = new Button({
				props: {
					disabled: !isValidEmail(/*invitationEmail*/ ctx[7]) || /*isBusy*/ ctx[10],
					text: /*btnText*/ ctx[3],
					onClick: /*onSendInviteClick*/ ctx[5],
					noMargin: true,
					inputHeight: true,
					aside: true,
					isPaymentForm: /*isPaymentForm*/ ctx[11]
				}
			});

		let if_block = /*invitationSent*/ ctx[8] && create_if_block$s(ctx);

		return {
			c() {
				div4 = element("div");
				div0 = element("div");
				t0 = text(/*title*/ ctx[0]);
				t1 = space();
				div1 = element("div");
				t2 = text(/*description*/ ctx[1]);
				t3 = space();
				create_component(label_1.$$.fragment);
				t4 = space();
				div3 = element("div");
				div2 = element("div");
				create_component(input.$$.fragment);
				t5 = space();
				create_component(button.$$.fragment);
				t6 = space();
				if (if_block) if_block.c();
				attr(div0, "class", "zephr-form-invitation-title svelte-1qkv7d3");
				attr(div1, "class", "zephr-form-invitation-description");
				attr(div2, "class", "zephr-form-invitation-input-container svelte-1qkv7d3");
				attr(div3, "class", "zephr-form-relative-container zephr-form-invitation-email svelte-1qkv7d3");
				toggle_class(div3, "zephr-payment-form-relative-container", /*isPaymentForm*/ ctx[11]);
				attr(div4, "class", "zephr-form-invitation-container svelte-1qkv7d3");
			},
			m(target, anchor) {
				insert(target, div4, anchor);
				append(div4, div0);
				append(div0, t0);
				append(div4, t1);
				append(div4, div1);
				append(div1, t2);
				append(div4, t3);
				mount_component(label_1, div4, null);
				append(div4, t4);
				append(div4, div3);
				append(div3, div2);
				mount_component(input, div2, null);
				append(div3, t5);
				mount_component(button, div3, null);
				append(div4, t6);
				if (if_block) if_block.m(div4, null);
				current = true;
			},
			p(ctx, [dirty]) {
				if (!current || dirty & /*title*/ 1) set_data(t0, /*title*/ ctx[0]);
				if (!current || dirty & /*description*/ 2) set_data(t2, /*description*/ ctx[1]);
				const label_1_changes = {};
				if (dirty & /*label*/ 4) label_1_changes.label = /*label*/ ctx[2];
				if (dirty & /*isPaymentForm*/ 2048) label_1_changes.isPaymentForm = /*isPaymentForm*/ ctx[11];
				label_1.$set(label_1_changes);
				const input_changes = {};
				if (dirty & /*isBusy*/ 1024) input_changes.disabled = /*isBusy*/ ctx[10];
				if (dirty & /*invitationEmail*/ 128) input_changes.value = /*invitationEmail*/ ctx[7] ?? '';
				if (dirty & /*error*/ 512) input_changes.errorMessage = /*error*/ ctx[9];
				if (dirty & /*isPaymentForm*/ 2048) input_changes.isPaymentForm = /*isPaymentForm*/ ctx[11];
				if (dirty & /*onFocus*/ 4096) input_changes.onFocus = /*onFocus*/ ctx[12];
				if (dirty & /*onBlur*/ 8192) input_changes.onBlur = /*onBlur*/ ctx[13];
				input.$set(input_changes);
				const button_changes = {};
				if (dirty & /*invitationEmail, isBusy*/ 1152) button_changes.disabled = !isValidEmail(/*invitationEmail*/ ctx[7]) || /*isBusy*/ ctx[10];
				if (dirty & /*btnText*/ 8) button_changes.text = /*btnText*/ ctx[3];
				if (dirty & /*onSendInviteClick*/ 32) button_changes.onClick = /*onSendInviteClick*/ ctx[5];
				if (dirty & /*isPaymentForm*/ 2048) button_changes.isPaymentForm = /*isPaymentForm*/ ctx[11];
				button.$set(button_changes);

				if (!current || dirty & /*isPaymentForm*/ 2048) {
					toggle_class(div3, "zephr-payment-form-relative-container", /*isPaymentForm*/ ctx[11]);
				}

				if (/*invitationSent*/ ctx[8]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*invitationSent*/ 256) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$s(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(div4, null);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(label_1.$$.fragment, local);
				transition_in(input.$$.fragment, local);
				transition_in(button.$$.fragment, local);
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(label_1.$$.fragment, local);
				transition_out(input.$$.fragment, local);
				transition_out(button.$$.fragment, local);
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div4);
				}

				destroy_component(label_1);
				destroy_component(input);
				destroy_component(button);
				if (if_block) if_block.d();
			}
		};
	}

	function instance$B($$self, $$props, $$invalidate) {
		let { formKey } = $$props;
		let { title } = $$props;
		let { description } = $$props;
		let { label } = $$props;
		let { btnText } = $$props;
		let { linkSentText } = $$props;
		let { onSendInviteClick } = $$props;
		let { onChange } = $$props;
		let { invitationEmail } = $$props;
		let { invitationSent } = $$props;
		let { error = null } = $$props;
		let { isBusy } = $$props;
		let { isPaymentForm = false } = $$props;
		let { onFocus } = $$props;
		let { onBlur } = $$props;
		const id = `zephr-form-invitation-email-${formKey}`;
		const change_handler = ({ detail }) => onChange(detail);

		$$self.$$set = $$props => {
			if ('formKey' in $$props) $$invalidate(15, formKey = $$props.formKey);
			if ('title' in $$props) $$invalidate(0, title = $$props.title);
			if ('description' in $$props) $$invalidate(1, description = $$props.description);
			if ('label' in $$props) $$invalidate(2, label = $$props.label);
			if ('btnText' in $$props) $$invalidate(3, btnText = $$props.btnText);
			if ('linkSentText' in $$props) $$invalidate(4, linkSentText = $$props.linkSentText);
			if ('onSendInviteClick' in $$props) $$invalidate(5, onSendInviteClick = $$props.onSendInviteClick);
			if ('onChange' in $$props) $$invalidate(6, onChange = $$props.onChange);
			if ('invitationEmail' in $$props) $$invalidate(7, invitationEmail = $$props.invitationEmail);
			if ('invitationSent' in $$props) $$invalidate(8, invitationSent = $$props.invitationSent);
			if ('error' in $$props) $$invalidate(9, error = $$props.error);
			if ('isBusy' in $$props) $$invalidate(10, isBusy = $$props.isBusy);
			if ('isPaymentForm' in $$props) $$invalidate(11, isPaymentForm = $$props.isPaymentForm);
			if ('onFocus' in $$props) $$invalidate(12, onFocus = $$props.onFocus);
			if ('onBlur' in $$props) $$invalidate(13, onBlur = $$props.onBlur);
		};

		return [
			title,
			description,
			label,
			btnText,
			linkSentText,
			onSendInviteClick,
			onChange,
			invitationEmail,
			invitationSent,
			error,
			isBusy,
			isPaymentForm,
			onFocus,
			onBlur,
			id,
			formKey,
			change_handler
		];
	}

	class Invitation extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$B, create_fragment$B, safe_not_equal, {
				formKey: 15,
				title: 0,
				description: 1,
				label: 2,
				btnText: 3,
				linkSentText: 4,
				onSendInviteClick: 5,
				onChange: 6,
				invitationEmail: 7,
				invitationSent: 8,
				error: 9,
				isBusy: 10,
				isPaymentForm: 11,
				onFocus: 12,
				onBlur: 13
			});
		}
	}

	const mapToError = (e) => {
	    if (e?.status === 403 && e?.message?.includes('you do not have access to')) {
	        return ServerError.INVITATION_FAILED_NO_PRODUCT_ACCESS;
	    }
	    if (e?.status === 400 && e?.message?.includes('Invalid recipient email')) {
	        return ServerError.INVITATION_FAILED_INVALID_EMAIL;
	    }
	    if (e?.status === 400 && e?.message?.includes('reached the configured limit')) {
	        return ServerError.INVITATION_FAILED_LIMIT_REACHED;
	    }
	    if (e?.status === 409) {
	        return ServerError.INVITATION_FAILED_DUPLICATE_EMAIL;
	    }
	    return ServerError.INVITATION_FAILED_UNKNOWN;
	};
	const getUserProfile = (formActions) => request('blaize/profile', {
	    method: "GET"
	}, formActions)
	    .then(response => response.json());
	const convertMapping = (mapping, profile) => (mapping ?? []).reduce((acc, curr) => {
	    const value = profile[curr.attrSlug];
	    return { ...acc, [curr.fieldName]: value };
	}, {});
	const sendInvitationEmail = async (form, formState, formActions) => {
	    let profile;
	    if (formState.userExists) {
	        profile = await getUserProfile(formActions);
	    }
	    else {
	        profile = formState.userAttributes;
	    }
	    const profileConverted = convertMapping(formConfigAs(form).invitationMetadata.mapping, profile);
	    const response = await request('zephr/public/products/v1/shares/invitations/emails', {
	        method: "POST",
	        bodyObject: {
	            product_id: formState.paymentOption.productId,
	            email_address: formState.invitationEmail,
	            base_url: formConfigAs(form).invitationMetadata.url,
	            meta_data: profileConverted,
	        }
	    }, formActions);
	    const responseJson = (await response.json());
	    if (response.ok) {
	        formActions.updateFormState({
	            invitationSent: true,
	            invitationEmail: '',
	        });
	        setTimeout(() => {
	            formActions.updateFormState({
	                invitationSent: false,
	            });
	        }, 3000);
	    }
	    else {
	        const serverError = mapToError(responseJson);
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[serverError],
	        });
	        formActions.updateFormState({
	            invitationSent: false,
	            serverErrors: [serverError],
	        });
	    }
	};

	const factory$7 = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.INVITATION,
	    create: (form, formState, formActions, elementConfig) => {
	        if (formState.paymentOption?.product_sharing_limit > 0) {
	            return {
	                component: Invitation,
	                props: {
	                    formKey: form.uniqueKey,
	                    title: elementConfig.title,
	                    description: elementConfig.description,
	                    label: elementConfig.label,
	                    btnText: elementConfig.btnText,
	                    linkSentText: elementConfig.linkSentText,
	                    onSendInviteClick: () => {
	                        logDataLayerEvent(form, 'zephr_form_button_press', {
	                            sectionId: formState.currentSection.type,
	                            buttonType: 'SUBMIT'
	                        });
	                        void sendInvitationEmail(form, formState, formActions);
	                    },
	                    onChange: (value) => {
	                        formActions.updateFormState({
	                            invitationEmail: value,
	                            serverErrors: [],
	                        });
	                        logDataLayerEvent(form, 'zephr_form_input_change', {
	                            inputName: `zephr-form-invitation-email-${form.uniqueKey}`,
	                            sectionId: formState.currentSection.type,
	                            field: 'invitation-email'
	                        });
	                    },
	                    onFocus: () => logDataLayerEvent(form, 'zephr_form_input_focus', {
	                        inputName: `zephr-form-invitation-email-${form.uniqueKey}`,
	                        sectionId: formState.currentSection.type,
	                        field: 'invitation-email'
	                    }),
	                    onBlur: () => logDataLayerEvent(form, 'zephr_form_input_blur', {
	                        inputName: `zephr-form-invitation-email-${form.uniqueKey}`,
	                        sectionId: formState.currentSection.type,
	                        field: 'invitation-email'
	                    }),
	                    invitationEmail: formState.invitationEmail,
	                    invitationSent: formState.invitationSent,
	                    isBusy: formState.isBusy,
	                    isPaymentForm: form.formType === FormType.PAYMENT,
	                }
	            };
	        }
	        return {
	            component: null,
	            props: {},
	        };
	    }
	};

	/* src/components/elements/payment/EmptyPreLoader.svelte generated by Svelte v4.2.12 */

	class EmptyPreLoader extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, null, null, safe_not_equal, {});
		}
	}

	const factory$6 = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.PAYMENT_PRE_LOADER,
	    create: (form, _, __) => {
	        const paymentProvider = paymentProviderFor(form.organisationConfiguration.paymentProvider);
	        if (paymentProvider.preLoaderComponent == null) {
	            return {
	                component: EmptyPreLoader,
	                props: {},
	            };
	        }
	        const component = paymentProvider.preLoaderComponent(formConfigAs(form).paymentProviderFormConfig);
	        return {
	            component,
	            props: {
	                onMountCallback: () => paymentProvider.preLoader()
	            },
	        };
	    }
	};

	/* src/components/elements/templateComponent/TemplateComponent.svelte generated by Svelte v4.2.12 */

	function create_fragment$A(ctx) {
		let div;

		return {
			c() {
				div = element("div");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				div.innerHTML = /*html*/ ctx[0];
			},
			p(ctx, [dirty]) {
				if (dirty & /*html*/ 1) div.innerHTML = /*html*/ ctx[0];		},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	function instance$A($$self, $$props, $$invalidate) {
		let { html } = $$props;

		$$self.$$set = $$props => {
			if ('html' in $$props) $$invalidate(0, html = $$props.html);
		};

		return [html];
	}

	class TemplateComponent extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$A, create_fragment$A, safe_not_equal, { html: 0 });
		}
	}

	const randomId = () => (Math.random() + 1).toString(36).substring(7);

	// Unique ID for this instance of this form being rendered.
	const formInstanceId = randomId();
	// Flatten the extra scope variables from DO and remove null values, as for null values the default
	// should be used
	const extractDoScopeVariables = (formState) => {
	    if (!formState.dynamicOfferResult) {
	        return {};
	    }
	    return Object.entries({
	        tagline: formState.dynamicOfferResult.tagline,
	        ...(formState.dynamicOfferResult.custom ?? {})
	    }).reduce((acc, [key, value]) => {
	        if (key && value != null) {
	            acc[key] = value;
	        }
	        return acc;
	    }, {});
	};
	const renderTemplateComponent = (form, formState, formActions, templateElement) => {
	    // Load the resolved template values
	    const templateContent = (form.resolvedComponentTemplates ?? []).find(c => c.id === templateElement.templateId);
	    if (!templateContent) {
	        console.warn(`No component template found for id '${templateElement.templateId}'`);
	        return '';
	    }
	    // Pre-render
	    const templateForm = prepareForm(form, formState, formActions, templateElement, templateContent);
	    const preRenderScope = {
	        ...(templateDefaultVariableScope(templateContent, false)),
	        ...(templateElement.templateValues ?? {}),
	        ...(extractDoScopeVariables(formState)),
	        zephrForm: templateForm,
	        zephrOutcomeId: form.outcomeId,
	        zephrRuleId: form.ruleId,
	    };
	    const scriptResult = runTemplateScript(form, formState, templateElement, templateForm, templateContent.preRenderScript, preRenderScope);
	    // Assemble pre-render results for template rendering
	    const scope = {
	        ...preRenderScope,
	        ...(scriptResult.scope ?? {})
	    };
	    templateForm.actions = scriptResult.actions ?? {};
	    attachFormRefToWindow(templateForm);
	    // Render the template
	    try {
	        const html = mustache.render(`
        ${templateContent.css ? `<style>${templateContent.css}</style>` : ''}
        ${templateContent.html ?? ""}
        `, scope);
	        return html;
	    }
	    catch (e) {
	        console.error('Error rendering mustache template', e);
	        return '';
	    }
	};
	const templateDefaultVariableScope = (template, paymentOptionLevel) => (template.templateVariables ?? []).reduce((prev, variable) => (variable.defaultValue == null || variable.paymentOptionLevel != paymentOptionLevel ? prev : {
	    ...prev,
	    [variable.key]: variable.defaultValue
	}), {});
	const attachFormRefToWindow = (templateForm) => {
	    if (!window.Zephr) {
	        window.Zephr = {};
	    }
	    if (!window.Zephr.forms) {
	        window.Zephr.forms = {};
	    }
	    window.Zephr.forms[templateForm.formInstanceId] = templateForm;
	};
	const runTemplateScript = (form, formState, templateElement, templateForm, script, scope) => {
	    if (!script) {
	        return {
	            scope: {},
	            actions: {}
	        };
	    }
	    try {
	        // eslint-disable-next-line @typescript-eslint/no-implied-eval
	        const templateScript = new Function('state', 'form', 'scope', script);
	        const customState = (formState.customComponentState ?? {})[templateElement.id ?? '_'];
	        const customStateWithDo = formState.dynamicOfferResult ? {
	            ...(customState ?? {}),
	            dynamicOfferResult: filterChangeSubDynamicOfferResponse(formState.dynamicOfferResult, form, formState)
	        } : customState;
	        return templateScript(customStateWithDo, templateForm, scope);
	    }
	    catch (e) {
	        console.error('Error evaluating pre-render script', e);
	        return {
	            scope: {
	                'error': e
	            },
	            actions: {}
	        };
	    }
	};
	const setState = (formState, formActions, elementId) => (state) => {
	    formActions.updateFormState({
	        customComponentState: {
	            ...(formState.customComponentState ?? {}),
	            [elementId]: {
	                ...((formState.customComponentState ?? {})[elementId] ?? {}),
	                ...(state ?? {})
	            }
	        }
	    });
	};
	const selectPaymentOption = (form, formActions, formState, isDynamicOffer) => (productId, slug) => {
	    let paymentOption;
	    if (isDynamicOffer) {
	        const product = formState
	            .dynamicOfferResult.products.find((prod) => prod.id === productId);
	        const paymentPlan = product
	            ?.paymentPlans.find(plan => plan.planId === slug);
	        paymentOption = {
	            slug: paymentPlan.planId,
	            productId: product.id,
	            label: product.label,
	            currencyCode: paymentPlan.charges[0].prices[0].currency,
	            terms: paymentPlan.additionalPlanData?.terms,
	            termsAndConditions: paymentPlan.additionalPlanData?.termsAndConditions,
	            triggerOffsets: paymentPlan.additionalPlanData?.triggerOffsets,
	            changeSubscriptionTriggerOffsets: paymentPlan.additionalPlanData?.changeSubscriptionTriggerOffsets,
	            autoRenewConfig: paymentPlan.additionalPlanData?.autoRenewConfig || 'auto_renew',
	            autoRenewToggleLabel: paymentPlan.additionalPlanData?.autoRenewToggleLabel
	        };
	    }
	    else {
	        paymentOption = formConfigAs(form)
	            .paymentOptions
	            ?.find(o => o.productId === productId && o.slug === slug);
	    }
	    if (!paymentOption) {
	        console.warn(`No payment option exists for ${productId} ${slug}.`);
	        return;
	    }
	    const paymentOptionKey = `${paymentOption.productId}-${paymentOption.slug}`;
	    const updateState = {
	        paymentOption: paymentOption,
	        serverErrors: [],
	        billingAddress: {
	            country: null,
	            postalCode: null,
	        }
	    };
	    // Only initialize auto-renew state for payment options with custom_toggle config
	    if (paymentOption.autoRenewConfig === 'custom_toggle') {
	        updateState.paymentOptionAutoRenew = {
	            ...formState.paymentOptionAutoRenew,
	            [paymentOptionKey]: paymentOption.terms?.autoRenew ?? false
	        };
	    }
	    formActions.updateFormState(updateState);
	    if (form.organisationConfiguration.trackFormDataLayerEvents) {
	        logDataLayerEvent(form, 'zephr_form_button_press', {
	            sectionId: formState.currentSection.type,
	            buttonType: 'SUBMIT'
	        });
	    }
	    formActions.completeSection();
	};
	const prepareForm = (form, formState, formActions, templateElement, template) => {
	    const isDynamicOffer = !!formConfigAs(form).dynamicOffer?.id;
	    const paymentOptions = (formConfigAs(form).paymentOptions ?? []).map((p, i) => ({
	        slug: p.slug,
	        productId: p.productId,
	        label: p.label,
	        price: p.price,
	        currencyCode: p.currencyCode,
	        formattedPrice: formatCurrency(p.price, p.currencyCode),
	        index: i,
	        ...(templateDefaultVariableScope(template, true)),
	        ...(p.templateValues ?? {}),
	    }));
	    return {
	        formId: form.id,
	        formInstanceId,
	        paymentOptions: paymentOptions,
	        ref: `window.Zephr.forms['${formInstanceId}']`,
	        setState: setState(formState, formActions, templateElement.id ?? '_'),
	        getState: () => formActions.getFormState(),
	        selectPaymentOption: selectPaymentOption(form, formActions, formState, isDynamicOffer)
	    };
	};

	const factory$5 = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.TEMPLATE_COMPONENT,
	    create: (form, formState, formActions, elementConfig) => {
	        const renderedHtml = renderTemplateComponent(form, formState, formActions, elementConfig);
	        return {
	            component: TemplateComponent,
	            props: {
	                html: renderedHtml
	            }
	        };
	    }
	};

	/* src/components/elements/subscriptionSelect/SubscriptionOption.svelte generated by Svelte v4.2.12 */

	function create_if_block_3$8(ctx) {
		let div;
		let h3;
		let t_value = /*subscription*/ ctx[0].planLabel + "";
		let t;

		return {
			c() {
				div = element("div");
				h3 = element("h3");
				t = text(t_value);
				attr(div, "class", "plan-label");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, h3);
				append(h3, t);
			},
			p(ctx, dirty) {
				if (dirty & /*subscription*/ 1 && t_value !== (t_value = /*subscription*/ ctx[0].planLabel + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (26:6) {#if subscription.amount && amountLabel}
	function create_if_block_2$c(ctx) {
		let hr;
		let t0;
		let div2;
		let div0;
		let t1;
		let t2;
		let div1;
		let t3_value = /*subscription*/ ctx[0].amount + "";
		let t3;

		return {
			c() {
				hr = element("hr");
				t0 = space();
				div2 = element("div");
				div0 = element("div");
				t1 = text(/*amountLabel*/ ctx[2]);
				t2 = space();
				div1 = element("div");
				t3 = text(t3_value);
				attr(hr, "class", "svelte-1gr56ov");
				attr(div0, "class", "info-label svelte-1gr56ov");
				attr(div1, "class", "info svelte-1gr56ov");
				attr(div2, "class", "info-row svelte-1gr56ov");
			},
			m(target, anchor) {
				insert(target, hr, anchor);
				insert(target, t0, anchor);
				insert(target, div2, anchor);
				append(div2, div0);
				append(div0, t1);
				append(div2, t2);
				append(div2, div1);
				append(div1, t3);
			},
			p(ctx, dirty) {
				if (dirty & /*amountLabel*/ 4) set_data(t1, /*amountLabel*/ ctx[2]);
				if (dirty & /*subscription*/ 1 && t3_value !== (t3_value = /*subscription*/ ctx[0].amount + "")) set_data(t3, t3_value);
			},
			d(detaching) {
				if (detaching) {
					detach(hr);
					detach(t0);
					detach(div2);
				}
			}
		};
	}

	// (37:4) {#if subscription.nextBillingTime && nextBillingDateLabel}
	function create_if_block_1$j(ctx) {
		let hr;
		let t0;
		let div2;
		let div0;
		let t1;
		let t2;
		let div1;
		let t3_value = /*subscription*/ ctx[0].nextBillingTime + "";
		let t3;

		return {
			c() {
				hr = element("hr");
				t0 = space();
				div2 = element("div");
				div0 = element("div");
				t1 = text(/*nextBillingDateLabel*/ ctx[3]);
				t2 = space();
				div1 = element("div");
				t3 = text(t3_value);
				attr(hr, "class", "svelte-1gr56ov");
				attr(div0, "class", "info-label svelte-1gr56ov");
				attr(div1, "class", "info svelte-1gr56ov");
				attr(div2, "class", "info-row svelte-1gr56ov");
			},
			m(target, anchor) {
				insert(target, hr, anchor);
				insert(target, t0, anchor);
				insert(target, div2, anchor);
				append(div2, div0);
				append(div0, t1);
				append(div2, t2);
				append(div2, div1);
				append(div1, t3);
			},
			p(ctx, dirty) {
				if (dirty & /*nextBillingDateLabel*/ 8) set_data(t1, /*nextBillingDateLabel*/ ctx[3]);
				if (dirty & /*subscription*/ 1 && t3_value !== (t3_value = /*subscription*/ ctx[0].nextBillingTime + "")) set_data(t3, t3_value);
			},
			d(detaching) {
				if (detaching) {
					detach(hr);
					detach(t0);
					detach(div2);
				}
			}
		};
	}

	// (53:6) {#if subscription.cannotBeChanged}
	function create_if_block$r(ctx) {
		let div;

		return {
			c() {
				div = element("div");
				attr(div, "class", "change-disabled-label svelte-1gr56ov");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				div.innerHTML = /*noChangePlanMappingMessage*/ ctx[4];
			},
			p(ctx, dirty) {
				if (dirty & /*noChangePlanMappingMessage*/ 16) div.innerHTML = /*noChangePlanMappingMessage*/ ctx[4];		},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	function create_fragment$z(ctx) {
		let div3;
		let div2;
		let div1;
		let div0;
		let h2;
		let t0_value = /*subscription*/ ctx[0].productLabel + "";
		let t0;
		let t1;
		let t2;
		let t3;
		let t4;
		let button;
		let t5;
		let div2_style_value;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*subscription*/ ctx[0].planLabel && create_if_block_3$8(ctx);
		let if_block1 = /*subscription*/ ctx[0].amount && /*amountLabel*/ ctx[2] && create_if_block_2$c(ctx);
		let if_block2 = /*subscription*/ ctx[0].nextBillingTime && /*nextBillingDateLabel*/ ctx[3] && create_if_block_1$j(ctx);

		button = new Button({
				props: {
					disabled: /*subscription*/ ctx[0].cannotBeChanged,
					text: /*selectButtonText*/ ctx[1] ?? "Select",
					onClick: /*onSelect*/ ctx[5]
				}
			});

		let if_block3 = /*subscription*/ ctx[0].cannotBeChanged && create_if_block$r(ctx);

		return {
			c() {
				div3 = element("div");
				div2 = element("div");
				div1 = element("div");
				div0 = element("div");
				h2 = element("h2");
				t0 = text(t0_value);
				t1 = space();
				if (if_block0) if_block0.c();
				t2 = space();
				if (if_block1) if_block1.c();
				t3 = space();
				if (if_block2) if_block2.c();
				t4 = space();
				create_component(button.$$.fragment);
				t5 = space();
				if (if_block3) if_block3.c();
				attr(div0, "class", "subscription-option-product-label");
				attr(div1, "class", "inner-box svelte-1gr56ov");
				attr(div2, "class", "subscription-option-box");
				attr(div2, "aria-hidden", "true");

				attr(div2, "style", div2_style_value = /*subscription*/ ctx[0].cannotBeChanged
				? ""
				: "cursor: pointer;");

				attr(div3, "class", "subscription-option-wrapper svelte-1gr56ov");
			},
			m(target, anchor) {
				insert(target, div3, anchor);
				append(div3, div2);
				append(div2, div1);
				append(div1, div0);
				append(div0, h2);
				append(h2, t0);
				append(div1, t1);
				if (if_block0) if_block0.m(div1, null);
				append(div1, t2);
				if (if_block1) if_block1.m(div1, null);
				append(div1, t3);
				if (if_block2) if_block2.m(div1, null);
				append(div1, t4);
				mount_component(button, div1, null);
				append(div1, t5);
				if (if_block3) if_block3.m(div1, null);
				current = true;

				if (!mounted) {
					dispose = listen(div2, "click", self(prevent_default(function () {
						if (is_function(/*onSelect*/ ctx[5])) /*onSelect*/ ctx[5].apply(this, arguments);
					})));

					mounted = true;
				}
			},
			p(new_ctx, [dirty]) {
				ctx = new_ctx;
				if ((!current || dirty & /*subscription*/ 1) && t0_value !== (t0_value = /*subscription*/ ctx[0].productLabel + "")) set_data(t0, t0_value);

				if (/*subscription*/ ctx[0].planLabel) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_3$8(ctx);
						if_block0.c();
						if_block0.m(div1, t2);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*subscription*/ ctx[0].amount && /*amountLabel*/ ctx[2]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_2$c(ctx);
						if_block1.c();
						if_block1.m(div1, t3);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (/*subscription*/ ctx[0].nextBillingTime && /*nextBillingDateLabel*/ ctx[3]) {
					if (if_block2) {
						if_block2.p(ctx, dirty);
					} else {
						if_block2 = create_if_block_1$j(ctx);
						if_block2.c();
						if_block2.m(div1, t4);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}

				const button_changes = {};
				if (dirty & /*subscription*/ 1) button_changes.disabled = /*subscription*/ ctx[0].cannotBeChanged;
				if (dirty & /*selectButtonText*/ 2) button_changes.text = /*selectButtonText*/ ctx[1] ?? "Select";
				if (dirty & /*onSelect*/ 32) button_changes.onClick = /*onSelect*/ ctx[5];
				button.$set(button_changes);

				if (/*subscription*/ ctx[0].cannotBeChanged) {
					if (if_block3) {
						if_block3.p(ctx, dirty);
					} else {
						if_block3 = create_if_block$r(ctx);
						if_block3.c();
						if_block3.m(div1, null);
					}
				} else if (if_block3) {
					if_block3.d(1);
					if_block3 = null;
				}

				if (!current || dirty & /*subscription*/ 1 && div2_style_value !== (div2_style_value = /*subscription*/ ctx[0].cannotBeChanged
				? ""
				: "cursor: pointer;")) {
					attr(div2, "style", div2_style_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(button.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(button.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div3);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
				destroy_component(button);
				if (if_block3) if_block3.d();
				mounted = false;
				dispose();
			}
		};
	}

	function instance$z($$self, $$props, $$invalidate) {
		let { subscription } = $$props;
		let { selectButtonText } = $$props;
		let { amountLabel } = $$props;
		let { nextBillingDateLabel } = $$props;
		let { noChangePlanMappingMessage } = $$props;
		let { onSelect } = $$props;

		$$self.$$set = $$props => {
			if ('subscription' in $$props) $$invalidate(0, subscription = $$props.subscription);
			if ('selectButtonText' in $$props) $$invalidate(1, selectButtonText = $$props.selectButtonText);
			if ('amountLabel' in $$props) $$invalidate(2, amountLabel = $$props.amountLabel);
			if ('nextBillingDateLabel' in $$props) $$invalidate(3, nextBillingDateLabel = $$props.nextBillingDateLabel);
			if ('noChangePlanMappingMessage' in $$props) $$invalidate(4, noChangePlanMappingMessage = $$props.noChangePlanMappingMessage);
			if ('onSelect' in $$props) $$invalidate(5, onSelect = $$props.onSelect);
		};

		return [
			subscription,
			selectButtonText,
			amountLabel,
			nextBillingDateLabel,
			noChangePlanMappingMessage,
			onSelect
		];
	}

	class SubscriptionOption extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$z, create_fragment$z, safe_not_equal, {
				subscription: 0,
				selectButtonText: 1,
				amountLabel: 2,
				nextBillingDateLabel: 3,
				noChangePlanMappingMessage: 4,
				onSelect: 5
			});
		}
	}

	/* src/components/elements/subscriptionSelect/SubscriptionSelect.svelte generated by Svelte v4.2.12 */

	function get_each_context$a(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[8] = list[i];
		return child_ctx;
	}

	// (13:2) {#if subscriptions == null}
	function create_if_block_1$i(ctx) {
		let spinner;
		let current;
		spinner = new Spinner({});

		return {
			c() {
				create_component(spinner.$$.fragment);
			},
			m(target, anchor) {
				mount_component(spinner, target, anchor);
				current = true;
			},
			i(local) {
				if (current) return;
				transition_in(spinner.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(spinner.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(spinner, detaching);
			}
		};
	}

	// (16:2) {#if subscriptions != null && !subscriptions.length}
	function create_if_block$q(ctx) {
		let div;

		return {
			c() {
				div = element("div");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				div.innerHTML = /*noSubscriptionsMessage*/ ctx[0];
			},
			p(ctx, dirty) {
				if (dirty & /*noSubscriptionsMessage*/ 1) div.innerHTML = /*noSubscriptionsMessage*/ ctx[0];		},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (21:2) {#each subscriptions ?? [] as subscription}
	function create_each_block$a(ctx) {
		let subscriptionoption;
		let current;

		function func() {
			return /*func*/ ctx[7](/*subscription*/ ctx[8]);
		}

		subscriptionoption = new SubscriptionOption({
				props: {
					subscription: /*subscription*/ ctx[8],
					selectButtonText: /*selectButtonText*/ ctx[5],
					noChangePlanMappingMessage: /*noChangePlanMappingMessage*/ ctx[1],
					amountLabel: /*amountLabel*/ ctx[3],
					nextBillingDateLabel: /*nextBillingDateLabel*/ ctx[4],
					onSelect: func
				}
			});

		return {
			c() {
				create_component(subscriptionoption.$$.fragment);
			},
			m(target, anchor) {
				mount_component(subscriptionoption, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				const subscriptionoption_changes = {};
				if (dirty & /*subscriptions*/ 4) subscriptionoption_changes.subscription = /*subscription*/ ctx[8];
				if (dirty & /*selectButtonText*/ 32) subscriptionoption_changes.selectButtonText = /*selectButtonText*/ ctx[5];
				if (dirty & /*noChangePlanMappingMessage*/ 2) subscriptionoption_changes.noChangePlanMappingMessage = /*noChangePlanMappingMessage*/ ctx[1];
				if (dirty & /*amountLabel*/ 8) subscriptionoption_changes.amountLabel = /*amountLabel*/ ctx[3];
				if (dirty & /*nextBillingDateLabel*/ 16) subscriptionoption_changes.nextBillingDateLabel = /*nextBillingDateLabel*/ ctx[4];
				if (dirty & /*onSelect, subscriptions*/ 68) subscriptionoption_changes.onSelect = func;
				subscriptionoption.$set(subscriptionoption_changes);
			},
			i(local) {
				if (current) return;
				transition_in(subscriptionoption.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(subscriptionoption.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(subscriptionoption, detaching);
			}
		};
	}

	function create_fragment$y(ctx) {
		let div;
		let t0;
		let t1;
		let current;
		let if_block0 = /*subscriptions*/ ctx[2] == null && create_if_block_1$i();
		let if_block1 = /*subscriptions*/ ctx[2] != null && !/*subscriptions*/ ctx[2].length && create_if_block$q(ctx);
		let each_value = ensure_array_like(/*subscriptions*/ ctx[2] ?? []);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				div = element("div");
				if (if_block0) if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(div, "class", "subscription-options-container svelte-bnxnvq");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append(div, t0);
				if (if_block1) if_block1.m(div, null);
				append(div, t1);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div, null);
					}
				}

				current = true;
			},
			p(ctx, [dirty]) {
				if (/*subscriptions*/ ctx[2] == null) {
					if (if_block0) {
						if (dirty & /*subscriptions*/ 4) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_1$i();
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div, t0);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*subscriptions*/ ctx[2] != null && !/*subscriptions*/ ctx[2].length) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block$q(ctx);
						if_block1.c();
						if_block1.m(div, t1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (dirty & /*subscriptions, selectButtonText, noChangePlanMappingMessage, amountLabel, nextBillingDateLabel, onSelect*/ 126) {
					each_value = ensure_array_like(/*subscriptions*/ ctx[2] ?? []);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$a(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$a(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				transition_out(if_block0);
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				destroy_each(each_blocks, detaching);
			}
		};
	}

	function instance$y($$self, $$props, $$invalidate) {
		let { noSubscriptionsMessage } = $$props;
		let { noChangePlanMappingMessage } = $$props;
		let { subscriptions } = $$props;
		let { amountLabel } = $$props;
		let { nextBillingDateLabel } = $$props;
		let { selectButtonText } = $$props;
		let { onSelect } = $$props;
		const func = subscription => onSelect(subscription);

		$$self.$$set = $$props => {
			if ('noSubscriptionsMessage' in $$props) $$invalidate(0, noSubscriptionsMessage = $$props.noSubscriptionsMessage);
			if ('noChangePlanMappingMessage' in $$props) $$invalidate(1, noChangePlanMappingMessage = $$props.noChangePlanMappingMessage);
			if ('subscriptions' in $$props) $$invalidate(2, subscriptions = $$props.subscriptions);
			if ('amountLabel' in $$props) $$invalidate(3, amountLabel = $$props.amountLabel);
			if ('nextBillingDateLabel' in $$props) $$invalidate(4, nextBillingDateLabel = $$props.nextBillingDateLabel);
			if ('selectButtonText' in $$props) $$invalidate(5, selectButtonText = $$props.selectButtonText);
			if ('onSelect' in $$props) $$invalidate(6, onSelect = $$props.onSelect);
		};

		return [
			noSubscriptionsMessage,
			noChangePlanMappingMessage,
			subscriptions,
			amountLabel,
			nextBillingDateLabel,
			selectButtonText,
			onSelect,
			func
		];
	}

	class SubscriptionSelect extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$y, create_fragment$y, safe_not_equal, {
				noSubscriptionsMessage: 0,
				noChangePlanMappingMessage: 1,
				subscriptions: 2,
				amountLabel: 3,
				nextBillingDateLabel: 4,
				selectButtonText: 5,
				onSelect: 6
			});
		}
	}

	const subscriptionSelectFactory = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.SUBSCRIPTION_SELECT,
	    create: (form, formState, formActions, elementConfig) => ({
	        component: SubscriptionSelect,
	        props: {
	            noSubscriptionsMessage: elementConfig.noSubscriptionsMessage,
	            selectButtonText: elementConfig.selectButtonText,
	            noChangePlanMappingMessage: elementConfig.noChangePlanMappingMessage,
	            amountLabel: elementConfig.amountLabel,
	            nextBillingDateLabel: elementConfig.nextBillingDateLabel,
	            subscriptions: formState.existingSubscriptions
	                ? formState.existingSubscriptions.filter(s => s.status !== 'inactive')
	                : null,
	            onSelect: (subscription) => {
	                formActions.updateFormState({
	                    selectedSubscription: subscription
	                });
	                logDataLayerEvent(form, 'zephr_form_button_press', {
	                    sectionId: formState.currentSection.type,
	                    buttonType: 'SUBMIT'
	                });
	                formActions.completeSection();
	            }
	        }
	    })
	};

	/* src/components/elements/subscriptionsList/SubscriptionsListItem.svelte generated by Svelte v4.2.12 */

	function create_if_block_4$6(ctx) {
		let span;
		let t;

		return {
			c() {
				span = element("span");
				t = text(/*giftPillText*/ ctx[7]);
				attr(span, "class", "gift-pill svelte-1qhs7yc");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty & /*giftPillText*/ 128) set_data(t, /*giftPillText*/ ctx[7]);
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (23:4) {#if showBillingHistory}
	function create_if_block_2$b(ctx) {
		let div1;
		let div0;
		let t0;
		let t1;
		let t2;
		let hr;
		let current;
		let if_block = /*billingHistoryLink*/ ctx[4] && create_if_block_3$7(ctx);

		return {
			c() {
				div1 = element("div");
				div0 = element("div");
				t0 = text(/*billingHistoryText*/ ctx[3]);
				t1 = space();
				if (if_block) if_block.c();
				t2 = space();
				hr = element("hr");
				attr(div0, "class", "information");
				attr(div1, "class", "section");
				attr(hr, "class", "svelte-1qhs7yc");
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, div0);
				append(div0, t0);
				append(div0, t1);
				if (if_block) if_block.m(div0, null);
				insert(target, t2, anchor);
				insert(target, hr, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (!current || dirty & /*billingHistoryText*/ 8) set_data(t0, /*billingHistoryText*/ ctx[3]);

				if (/*billingHistoryLink*/ ctx[4]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*billingHistoryLink*/ 16) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_3$7(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(div0, null);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
					detach(t2);
					detach(hr);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (27:10) {#if billingHistoryLink}
	function create_if_block_3$7(ctx) {
		let link;
		let current;

		link = new Link({
				props: { text: /*billingHistoryLink*/ ctx[4] }
			});

		link.$on("linkClick", /*linkClick_handler*/ ctx[8]);

		return {
			c() {
				create_component(link.$$.fragment);
			},
			m(target, anchor) {
				mount_component(link, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const link_changes = {};
				if (dirty & /*billingHistoryLink*/ 16) link_changes.text = /*billingHistoryLink*/ ctx[4];
				link.$set(link_changes);
			},
			i(local) {
				if (current) return;
				transition_in(link.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(link.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(link, detaching);
			}
		};
	}

	// (34:4) {#if subscription.status === 'active' && subscription.nextBillingTime}
	function create_if_block_1$h(ctx) {
		let div1;
		let h3;
		let t0;
		let t1;
		let div0;
		let t2_value = /*subscription*/ ctx[0].nextBillingTime + "";
		let t2;
		let t3;
		let hr;

		return {
			c() {
				div1 = element("div");
				h3 = element("h3");
				t0 = text(/*nextPaymentDateText*/ ctx[1]);
				t1 = space();
				div0 = element("div");
				t2 = text(t2_value);
				t3 = space();
				hr = element("hr");
				attr(h3, "class", "svelte-1qhs7yc");
				attr(div0, "class", "information");
				attr(div1, "class", "section");
				attr(hr, "class", "svelte-1qhs7yc");
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, h3);
				append(h3, t0);
				append(div1, t1);
				append(div1, div0);
				append(div0, t2);
				insert(target, t3, anchor);
				insert(target, hr, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*nextPaymentDateText*/ 2) set_data(t0, /*nextPaymentDateText*/ ctx[1]);
				if (dirty & /*subscription*/ 1 && t2_value !== (t2_value = /*subscription*/ ctx[0].nextBillingTime + "")) set_data(t2, t2_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
					detach(t3);
					detach(hr);
				}
			}
		};
	}

	// (41:4) {#if subscription.amount}
	function create_if_block$p(ctx) {
		let div1;
		let h3;
		let t0;
		let t1;
		let div0;
		let t2_value = /*subscription*/ ctx[0].amount + "";
		let t2;
		let t3;
		let hr;

		return {
			c() {
				div1 = element("div");
				h3 = element("h3");
				t0 = text(/*subscriptionRateText*/ ctx[2]);
				t1 = space();
				div0 = element("div");
				t2 = text(t2_value);
				t3 = space();
				hr = element("hr");
				attr(h3, "class", "svelte-1qhs7yc");
				attr(div0, "class", "information");
				attr(div1, "class", "section");
				attr(hr, "class", "svelte-1qhs7yc");
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, h3);
				append(h3, t0);
				append(div1, t1);
				append(div1, div0);
				append(div0, t2);
				insert(target, t3, anchor);
				insert(target, hr, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*subscriptionRateText*/ 4) set_data(t0, /*subscriptionRateText*/ ctx[2]);
				if (dirty & /*subscription*/ 1 && t2_value !== (t2_value = /*subscription*/ ctx[0].amount + "")) set_data(t2, t2_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
					detach(t3);
					detach(hr);
				}
			}
		};
	}

	function create_fragment$x(ctx) {
		let div2;
		let div1;
		let div0;
		let h2;
		let t0_value = /*subscription*/ ctx[0].productLabel + "";
		let t0;
		let t1;
		let h2_class_value;
		let t2;
		let hr;
		let t3;
		let t4;
		let t5;
		let current;
		let if_block0 = /*subscription*/ ctx[0].isGift && create_if_block_4$6(ctx);
		let if_block1 = /*showBillingHistory*/ ctx[6] && create_if_block_2$b(ctx);
		let if_block2 = /*subscription*/ ctx[0].status === 'active' && /*subscription*/ ctx[0].nextBillingTime && create_if_block_1$h(ctx);
		let if_block3 = /*subscription*/ ctx[0].amount && create_if_block$p(ctx);

		return {
			c() {
				div2 = element("div");
				div1 = element("div");
				div0 = element("div");
				h2 = element("h2");
				t0 = text(t0_value);
				t1 = space();
				if (if_block0) if_block0.c();
				t2 = space();
				hr = element("hr");
				t3 = space();
				if (if_block1) if_block1.c();
				t4 = space();
				if (if_block2) if_block2.c();
				t5 = space();
				if (if_block3) if_block3.c();

				attr(h2, "class", h2_class_value = "" + (null_to_empty(/*subscription*/ ctx[0].status === 'inactive'
				? 'inactive'
				: '') + " svelte-1qhs7yc"));

				attr(div0, "class", "section");
				attr(hr, "class", "svelte-1qhs7yc");
				attr(div1, "class", "inner-box svelte-1qhs7yc");
				attr(div2, "class", "subscription-list-item svelte-1qhs7yc");
			},
			m(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div1);
				append(div1, div0);
				append(div0, h2);
				append(h2, t0);
				append(h2, t1);
				if (if_block0) if_block0.m(h2, null);
				append(div1, t2);
				append(div1, hr);
				append(div1, t3);
				if (if_block1) if_block1.m(div1, null);
				append(div1, t4);
				if (if_block2) if_block2.m(div1, null);
				append(div1, t5);
				if (if_block3) if_block3.m(div1, null);
				current = true;
			},
			p(ctx, [dirty]) {
				if ((!current || dirty & /*subscription*/ 1) && t0_value !== (t0_value = /*subscription*/ ctx[0].productLabel + "")) set_data(t0, t0_value);

				if (/*subscription*/ ctx[0].isGift) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_4$6(ctx);
						if_block0.c();
						if_block0.m(h2, null);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (!current || dirty & /*subscription*/ 1 && h2_class_value !== (h2_class_value = "" + (null_to_empty(/*subscription*/ ctx[0].status === 'inactive'
				? 'inactive'
				: '') + " svelte-1qhs7yc"))) {
					attr(h2, "class", h2_class_value);
				}

				if (/*showBillingHistory*/ ctx[6]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*showBillingHistory*/ 64) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_2$b(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div1, t4);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (/*subscription*/ ctx[0].status === 'active' && /*subscription*/ ctx[0].nextBillingTime) {
					if (if_block2) {
						if_block2.p(ctx, dirty);
					} else {
						if_block2 = create_if_block_1$h(ctx);
						if_block2.c();
						if_block2.m(div1, t5);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}

				if (/*subscription*/ ctx[0].amount) {
					if (if_block3) {
						if_block3.p(ctx, dirty);
					} else {
						if_block3 = create_if_block$p(ctx);
						if_block3.c();
						if_block3.m(div1, null);
					}
				} else if (if_block3) {
					if_block3.d(1);
					if_block3 = null;
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div2);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
				if (if_block3) if_block3.d();
			}
		};
	}

	function instance$x($$self, $$props, $$invalidate) {
		let { subscription } = $$props;
		let { nextPaymentDateText } = $$props;
		let { subscriptionRateText } = $$props;
		let { billingHistoryText } = $$props;
		let { billingHistoryLink } = $$props;
		let { onViewHistory } = $$props;
		let { showBillingHistory } = $$props;
		let { giftPillText = 'Gift' } = $$props;
		const linkClick_handler = () => onViewHistory(subscription);

		$$self.$$set = $$props => {
			if ('subscription' in $$props) $$invalidate(0, subscription = $$props.subscription);
			if ('nextPaymentDateText' in $$props) $$invalidate(1, nextPaymentDateText = $$props.nextPaymentDateText);
			if ('subscriptionRateText' in $$props) $$invalidate(2, subscriptionRateText = $$props.subscriptionRateText);
			if ('billingHistoryText' in $$props) $$invalidate(3, billingHistoryText = $$props.billingHistoryText);
			if ('billingHistoryLink' in $$props) $$invalidate(4, billingHistoryLink = $$props.billingHistoryLink);
			if ('onViewHistory' in $$props) $$invalidate(5, onViewHistory = $$props.onViewHistory);
			if ('showBillingHistory' in $$props) $$invalidate(6, showBillingHistory = $$props.showBillingHistory);
			if ('giftPillText' in $$props) $$invalidate(7, giftPillText = $$props.giftPillText);
		};

		return [
			subscription,
			nextPaymentDateText,
			subscriptionRateText,
			billingHistoryText,
			billingHistoryLink,
			onViewHistory,
			showBillingHistory,
			giftPillText,
			linkClick_handler
		];
	}

	class SubscriptionsListItem extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$x, create_fragment$x, safe_not_equal, {
				subscription: 0,
				nextPaymentDateText: 1,
				subscriptionRateText: 2,
				billingHistoryText: 3,
				billingHistoryLink: 4,
				onViewHistory: 5,
				showBillingHistory: 6,
				giftPillText: 7
			});
		}
	}

	/* src/components/elements/Tablink.svelte generated by Svelte v4.2.12 */

	function create_fragment$w(ctx) {
		let a;
		let span;
		let t0;
		let t1;
		let svg;
		let path_1;
		let a_href_value;
		let mounted;
		let dispose;

		return {
			c() {
				a = element("a");
				span = element("span");
				t0 = text(/*text*/ ctx[0]);
				t1 = space();
				svg = svg_element("svg");
				path_1 = svg_element("path");
				attr(path_1, "fill", "currentColor");
				attr(path_1, "d", "M305 239c9.4 9.4 9.4 24.6 0 33.9L113 465c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l175-175L79 81c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0L305 239z");
				attr(svg, "aria-hidden", "true");
				attr(svg, "focusable", "false");
				attr(svg, "data-prefix", "far");
				attr(svg, "data-icon", "chevron-right");
				attr(svg, "class", "svg-inline--fa fa-chevron-right sc-egTsrv kzAurc");
				attr(svg, "role", "img");
				attr(svg, "xmlns", "http://www.w3.org/2000/svg");
				attr(svg, "viewBox", "0 0 320 512");
				attr(svg, "width", "16");
				attr(svg, "height", "16");
				attr(a, "class", "zephr-form-tablink svelte-py0ruk");

				attr(a, "href", a_href_value = /*path*/ ctx[1] && (!window.Zephr || !window.Zephr.isCustomPage || !/*path*/ ctx[1].startsWith(window.Zephr.customPagePath))
				? /*path*/ ctx[1]
				: "javascript: void(0)");
			},
			m(target, anchor) {
				insert(target, a, anchor);
				append(a, span);
				append(span, t0);
				append(a, t1);
				append(a, svg);
				append(svg, path_1);

				if (!mounted) {
					dispose = listen(a, "click", /*click_handler*/ ctx[4]);
					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (dirty & /*text*/ 1) set_data(t0, /*text*/ ctx[0]);

				if (dirty & /*path*/ 2 && a_href_value !== (a_href_value = /*path*/ ctx[1] && (!window.Zephr || !window.Zephr.isCustomPage || !/*path*/ ctx[1].startsWith(window.Zephr.customPagePath))
				? /*path*/ ctx[1]
				: "javascript: void(0)")) {
					attr(a, "href", a_href_value);
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(a);
				}

				mounted = false;
				dispose();
			}
		};
	}

	function instance$w($$self, $$props, $$invalidate) {
		let { text } = $$props;
		let { path = '' } = $$props;

		let { onClick = () => {
			
		} } = $$props;

		let { logDlEvent = () => {
			
		} } = $$props;

		const click_handler = () => {
			logDlEvent?.();

			if (window.Zephr && window.Zephr.isCustomPage && path.startsWith(window.Zephr.customPagePath)) {
				window.history.pushState({}, '', path);
			} else {
				onClick();
			}
		};

		$$self.$$set = $$props => {
			if ('text' in $$props) $$invalidate(0, text = $$props.text);
			if ('path' in $$props) $$invalidate(1, path = $$props.path);
			if ('onClick' in $$props) $$invalidate(2, onClick = $$props.onClick);
			if ('logDlEvent' in $$props) $$invalidate(3, logDlEvent = $$props.logDlEvent);
		};

		return [text, path, onClick, logDlEvent, click_handler];
	}

	class Tablink extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$w, create_fragment$w, safe_not_equal, {
				text: 0,
				path: 1,
				onClick: 2,
				logDlEvent: 3
			});
		}
	}

	/* src/components/elements/subscriptionsList/SubscriptionsListBoxItem.svelte generated by Svelte v4.2.12 */

	function get_each_context$9(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[48] = list[i];
		child_ctx[50] = i;
		return child_ctx;
	}

	function get_each_context_1$2(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[51] = list[i];
		return child_ctx;
	}

	// (123:8) {#if subscription.isGift}
	function create_if_block_23(ctx) {
		let span;
		let t;

		return {
			c() {
				span = element("span");
				t = text(/*giftPillText*/ ctx[24]);
				attr(span, "class", "gift-pill svelte-xxnasy");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*giftPillText*/ 16777216) set_data(t, /*giftPillText*/ ctx[24]);
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (135:4) {:else}
	function create_else_block$4(ctx) {
		let each_1_anchor;
		let current;
		let each_value = ensure_array_like(/*elementsOrder*/ ctx[21]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty[0] & /*elementsOrder, updateBillToContactText, updateBillToContactPath, subscription, logUpdateBillToContact, elementsHide, paymentProvider, subscriptionCustomFieldsText, onUpdateSubscriptionCustomFields, suspendResumeSubscriptionText, suspendResumeSubscriptionPath, logSuspendResumeSubscription, cancelSubscriptionText, cancelSubscriptionPath, logCancelSubscription, changeSubscriptionText, changeSubscriptionPath, logChangeSubscription, changePaymentMethodText, onChangePayment, billingHistoryLink, onViewHistory, statusType, statusMessage, isUpdatingAutoRenew, autoRenewToggleText, autoRenewToggleEnabled, nextPaymentDateText, subscriptionRateText*/ 2122317823 | dirty[1] & /*displayedFields, withSubscriptionParam, autoRenewValue, handleAutoRenewChange*/ 15) {
					each_value = ensure_array_like(/*elementsOrder*/ ctx[21]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$9(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$9(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (128:4) {#if isInactive}
	function create_if_block$o(ctx) {
		let if_block_anchor;
		let if_block = /*subscription*/ ctx[0].amount && create_if_block_1$g(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, dirty) {
				if (/*subscription*/ ctx[0].amount) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block_1$g(ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (137:8) {#if element === 'subscription_information' && !elementsHide.subscriptionInformation}
	function create_if_block_20(ctx) {
		let t;
		let if_block1_anchor;
		let if_block0 = /*subscription*/ ctx[0].amount && create_if_block_22(ctx);
		let if_block1 = /*subscription*/ ctx[0].status === 'active' && /*subscription*/ ctx[0].nextBillingTime && create_if_block_21(ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);
			},
			p(ctx, dirty) {
				if (/*subscription*/ ctx[0].amount) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_22(ctx);
						if_block0.c();
						if_block0.m(t.parentNode, t);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*subscription*/ ctx[0].status === 'active' && /*subscription*/ ctx[0].nextBillingTime) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_21(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
			}
		};
	}

	// (138:10) {#if subscription.amount}
	function create_if_block_22(ctx) {
		let div1;
		let span;
		let t0;
		let t1;
		let div0;
		let t2_value = /*subscription*/ ctx[0].amount + "";
		let t2;

		return {
			c() {
				div1 = element("div");
				span = element("span");
				t0 = text(/*subscriptionRateText*/ ctx[2]);
				t1 = space();
				div0 = element("div");
				t2 = text(t2_value);
				attr(span, "class", "svelte-xxnasy");
				attr(div0, "class", "zephr-box-item-information svelte-xxnasy");
				attr(div1, "class", "zephr-section svelte-xxnasy");
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, span);
				append(span, t0);
				append(div1, t1);
				append(div1, div0);
				append(div0, t2);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*subscriptionRateText*/ 4) set_data(t0, /*subscriptionRateText*/ ctx[2]);
				if (dirty[0] & /*subscription*/ 1 && t2_value !== (t2_value = /*subscription*/ ctx[0].amount + "")) set_data(t2, t2_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
				}
			}
		};
	}

	// (146:10) {#if subscription.status === 'active' && subscription.nextBillingTime}
	function create_if_block_21(ctx) {
		let div1;
		let span;
		let t0;
		let t1;
		let div0;
		let t2_value = /*subscription*/ ctx[0].nextBillingTime + "";
		let t2;

		return {
			c() {
				div1 = element("div");
				span = element("span");
				t0 = text(/*nextPaymentDateText*/ ctx[1]);
				t1 = space();
				div0 = element("div");
				t2 = text(t2_value);
				attr(span, "class", "svelte-xxnasy");
				attr(div0, "class", "zephr-box-item-information svelte-xxnasy");
				attr(div1, "class", "zephr-section svelte-xxnasy");
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, span);
				append(span, t0);
				append(div1, t1);
				append(div1, div0);
				append(div0, t2);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*nextPaymentDateText*/ 2) set_data(t0, /*nextPaymentDateText*/ ctx[1]);
				if (dirty[0] & /*subscription*/ 1 && t2_value !== (t2_value = /*subscription*/ ctx[0].nextBillingTime + "")) set_data(t2, t2_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
				}
			}
		};
	}

	// (155:8) {#if element === 'payment_auto_renew_toggle' && autoRenewToggleEnabled && paymentProvider === 'zuora-billing' && subscription.status === 'active' && !subscription.isGift && subscription.termType === 'TERMED'}
	function create_if_block_17(ctx) {
		let div1;
		let div0;
		let checkbox;
		let t0;
		let t1;
		let current;

		checkbox = new Checkbox({
				props: {
					id: "auto-renew-" + /*subscription*/ ctx[0].externalId,
					label: /*autoRenewToggleText*/ ctx[27],
					value: "auto-renew",
					checked: /*autoRenewValue*/ ctx[31],
					disabled: /*isUpdatingAutoRenew*/ ctx[28]
				}
			});

		checkbox.$on("change", /*handleAutoRenewChange*/ ctx[34]);
		let if_block0 = /*isUpdatingAutoRenew*/ ctx[28] && create_if_block_19();
		let if_block1 = /*statusMessage*/ ctx[29] && create_if_block_18(ctx);

		return {
			c() {
				div1 = element("div");
				div0 = element("div");
				create_component(checkbox.$$.fragment);
				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				attr(div0, "class", "auto-renew-toggle-container svelte-xxnasy");
				attr(div1, "class", "zephr-section svelte-xxnasy");
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, div0);
				mount_component(checkbox, div0, null);
				append(div0, t0);
				if (if_block0) if_block0.m(div0, null);
				append(div1, t1);
				if (if_block1) if_block1.m(div1, null);
				current = true;
			},
			p(ctx, dirty) {
				const checkbox_changes = {};
				if (dirty[0] & /*subscription*/ 1) checkbox_changes.id = "auto-renew-" + /*subscription*/ ctx[0].externalId;
				if (dirty[0] & /*autoRenewToggleText*/ 134217728) checkbox_changes.label = /*autoRenewToggleText*/ ctx[27];
				if (dirty[1] & /*autoRenewValue*/ 1) checkbox_changes.checked = /*autoRenewValue*/ ctx[31];
				if (dirty[0] & /*isUpdatingAutoRenew*/ 268435456) checkbox_changes.disabled = /*isUpdatingAutoRenew*/ ctx[28];
				checkbox.$set(checkbox_changes);

				if (/*isUpdatingAutoRenew*/ ctx[28]) {
					if (if_block0) ; else {
						if_block0 = create_if_block_19();
						if_block0.c();
						if_block0.m(div0, null);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*statusMessage*/ ctx[29]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_18(ctx);
						if_block1.c();
						if_block1.m(div1, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			i(local) {
				if (current) return;
				transition_in(checkbox.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(checkbox.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
				}

				destroy_component(checkbox);
				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
			}
		};
	}

	// (166:14) {#if isUpdatingAutoRenew}
	function create_if_block_19(ctx) {
		let span;

		return {
			c() {
				span = element("span");
				span.textContent = "Updating...";
				attr(span, "class", "updating-indicator svelte-xxnasy");
			},
			m(target, anchor) {
				insert(target, span, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (170:12) {#if statusMessage}
	function create_if_block_18(ctx) {
		let div;
		let t;
		let div_class_value;

		return {
			c() {
				div = element("div");
				t = text(/*statusMessage*/ ctx[29]);
				attr(div, "class", div_class_value = "status-message " + /*statusType*/ ctx[30] + " svelte-xxnasy");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*statusMessage*/ 536870912) set_data(t, /*statusMessage*/ ctx[29]);

				if (dirty[0] & /*statusType*/ 1073741824 && div_class_value !== (div_class_value = "status-message " + /*statusType*/ ctx[30] + " svelte-xxnasy")) {
					attr(div, "class", div_class_value);
				}
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (177:8) {#if element === 'billing_history' && !elementsHide.billingHistory}
	function create_if_block_15(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*billingHistoryLink*/ ctx[3] && create_if_block_16(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*billingHistoryLink*/ ctx[3]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty[0] & /*billingHistoryLink*/ 8) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_16(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (178:10) {#if billingHistoryLink}
	function create_if_block_16(ctx) {
		let tablink;
		let current;

		tablink = new Tablink({
				props: {
					text: /*billingHistoryLink*/ ctx[3],
					onClick: /*func*/ ctx[39]
				}
			});

		return {
			c() {
				create_component(tablink.$$.fragment);
			},
			m(target, anchor) {
				mount_component(tablink, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const tablink_changes = {};
				if (dirty[0] & /*billingHistoryLink*/ 8) tablink_changes.text = /*billingHistoryLink*/ ctx[3];
				if (dirty[0] & /*onViewHistory, subscription*/ 17) tablink_changes.onClick = /*func*/ ctx[39];
				tablink.$set(tablink_changes);
			},
			i(local) {
				if (current) return;
				transition_in(tablink.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(tablink.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(tablink, detaching);
			}
		};
	}

	// (185:8) {#if element === 'change_payment' && !elementsHide.changePayment}
	function create_if_block_13$1(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*changePaymentMethodText*/ ctx[10] && create_if_block_14$1(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*changePaymentMethodText*/ ctx[10]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty[0] & /*changePaymentMethodText*/ 1024) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_14$1(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (186:10) {#if changePaymentMethodText}
	function create_if_block_14$1(ctx) {
		let tablink;
		let current;

		tablink = new Tablink({
				props: {
					text: /*changePaymentMethodText*/ ctx[10],
					onClick: /*func_1*/ ctx[40]
				}
			});

		return {
			c() {
				create_component(tablink.$$.fragment);
			},
			m(target, anchor) {
				mount_component(tablink, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const tablink_changes = {};
				if (dirty[0] & /*changePaymentMethodText*/ 1024) tablink_changes.text = /*changePaymentMethodText*/ ctx[10];
				if (dirty[0] & /*onChangePayment, subscription*/ 33) tablink_changes.onClick = /*func_1*/ ctx[40];
				tablink.$set(tablink_changes);
			},
			i(local) {
				if (current) return;
				transition_in(tablink.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(tablink.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(tablink, detaching);
			}
		};
	}

	// (193:8) {#if element === 'change_subscription' && !elementsHide.changeSubscription}
	function create_if_block_11$1(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*changeSubscriptionText*/ ctx[11] && create_if_block_12$1(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*changeSubscriptionText*/ ctx[11]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty[0] & /*changeSubscriptionText*/ 2048) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_12$1(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (194:10) {#if changeSubscriptionText}
	function create_if_block_12$1(ctx) {
		let tablink;
		let current;

		tablink = new Tablink({
				props: {
					text: /*changeSubscriptionText*/ ctx[11],
					path: /*withSubscriptionParam*/ ctx[33](/*changeSubscriptionPath*/ ctx[13], /*subscription*/ ctx[0].externalId),
					logDlEvent: /*func_2*/ ctx[41]
				}
			});

		return {
			c() {
				create_component(tablink.$$.fragment);
			},
			m(target, anchor) {
				mount_component(tablink, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const tablink_changes = {};
				if (dirty[0] & /*changeSubscriptionText*/ 2048) tablink_changes.text = /*changeSubscriptionText*/ ctx[11];
				if (dirty[0] & /*changeSubscriptionPath, subscription*/ 8193) tablink_changes.path = /*withSubscriptionParam*/ ctx[33](/*changeSubscriptionPath*/ ctx[13], /*subscription*/ ctx[0].externalId);
				if (dirty[0] & /*logChangeSubscription, subscription*/ 65) tablink_changes.logDlEvent = /*func_2*/ ctx[41];
				tablink.$set(tablink_changes);
			},
			i(local) {
				if (current) return;
				transition_in(tablink.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(tablink.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(tablink, detaching);
			}
		};
	}

	// (202:8) {#if element === 'cancel_subscription' && !elementsHide.cancelSubscription}
	function create_if_block_9$1(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*cancelSubscriptionText*/ ctx[12] && create_if_block_10$1(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*cancelSubscriptionText*/ ctx[12]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty[0] & /*cancelSubscriptionText*/ 4096) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_10$1(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (203:10) {#if cancelSubscriptionText}
	function create_if_block_10$1(ctx) {
		let tablink;
		let current;

		tablink = new Tablink({
				props: {
					text: /*cancelSubscriptionText*/ ctx[12],
					path: /*withSubscriptionParam*/ ctx[33](/*cancelSubscriptionPath*/ ctx[14], /*subscription*/ ctx[0].externalId),
					logDlEvent: /*func_3*/ ctx[42]
				}
			});

		return {
			c() {
				create_component(tablink.$$.fragment);
			},
			m(target, anchor) {
				mount_component(tablink, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const tablink_changes = {};
				if (dirty[0] & /*cancelSubscriptionText*/ 4096) tablink_changes.text = /*cancelSubscriptionText*/ ctx[12];
				if (dirty[0] & /*cancelSubscriptionPath, subscription*/ 16385) tablink_changes.path = /*withSubscriptionParam*/ ctx[33](/*cancelSubscriptionPath*/ ctx[14], /*subscription*/ ctx[0].externalId);
				if (dirty[0] & /*logCancelSubscription, subscription*/ 129) tablink_changes.logDlEvent = /*func_3*/ ctx[42];
				tablink.$set(tablink_changes);
			},
			i(local) {
				if (current) return;
				transition_in(tablink.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(tablink.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(tablink, detaching);
			}
		};
	}

	// (211:8) {#if element === 'suspend_resume_subscription' && !elementsHide.suspendResumeSubscription && paymentProvider === 'zuora-billing'}
	function create_if_block_7$2(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*suspendResumeSubscriptionText*/ ctx[15] && create_if_block_8$2(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*suspendResumeSubscriptionText*/ ctx[15]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty[0] & /*suspendResumeSubscriptionText*/ 32768) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_8$2(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (212:10) {#if suspendResumeSubscriptionText}
	function create_if_block_8$2(ctx) {
		let tablink;
		let current;

		tablink = new Tablink({
				props: {
					text: /*suspendResumeSubscriptionText*/ ctx[15],
					path: /*withSubscriptionParam*/ ctx[33](/*suspendResumeSubscriptionPath*/ ctx[16], /*subscription*/ ctx[0].externalId),
					logDlEvent: /*func_4*/ ctx[43]
				}
			});

		return {
			c() {
				create_component(tablink.$$.fragment);
			},
			m(target, anchor) {
				mount_component(tablink, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const tablink_changes = {};
				if (dirty[0] & /*suspendResumeSubscriptionText*/ 32768) tablink_changes.text = /*suspendResumeSubscriptionText*/ ctx[15];
				if (dirty[0] & /*suspendResumeSubscriptionPath, subscription*/ 65537) tablink_changes.path = /*withSubscriptionParam*/ ctx[33](/*suspendResumeSubscriptionPath*/ ctx[16], /*subscription*/ ctx[0].externalId);
				if (dirty[0] & /*logSuspendResumeSubscription, subscription*/ 257) tablink_changes.logDlEvent = /*func_4*/ ctx[43];
				tablink.$set(tablink_changes);
			},
			i(local) {
				if (current) return;
				transition_in(tablink.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(tablink.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(tablink, detaching);
			}
		};
	}

	// (220:8) {#if element === 'subscription_custom_fields_list' && !elementsHide.subscriptionCustomFields}
	function create_if_block_5$5(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*subscriptionCustomFieldsText*/ ctx[17] && create_if_block_6$5(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*subscriptionCustomFieldsText*/ ctx[17]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty[0] & /*subscriptionCustomFieldsText*/ 131072) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_6$5(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (221:10) {#if subscriptionCustomFieldsText}
	function create_if_block_6$5(ctx) {
		let tablink;
		let current;

		tablink = new Tablink({
				props: {
					text: /*subscriptionCustomFieldsText*/ ctx[17],
					onClick: /*func_5*/ ctx[44]
				}
			});

		return {
			c() {
				create_component(tablink.$$.fragment);
			},
			m(target, anchor) {
				mount_component(tablink, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const tablink_changes = {};
				if (dirty[0] & /*subscriptionCustomFieldsText*/ 131072) tablink_changes.text = /*subscriptionCustomFieldsText*/ ctx[17];
				if (dirty[0] & /*onUpdateSubscriptionCustomFields, subscription*/ 262145) tablink_changes.onClick = /*func_5*/ ctx[44];
				tablink.$set(tablink_changes);
			},
			i(local) {
				if (current) return;
				transition_in(tablink.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(tablink.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(tablink, detaching);
			}
		};
	}

	// (228:8) {#if element === 'bill_to_contact' && !elementsHide.updateBillToContact && paymentProvider === 'zuora-billing'}
	function create_if_block_3$6(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*updateBillToContactText*/ ctx[19] && create_if_block_4$5(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*updateBillToContactText*/ ctx[19]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty[0] & /*updateBillToContactText*/ 524288) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_4$5(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (229:10) {#if updateBillToContactText}
	function create_if_block_4$5(ctx) {
		let tablink;
		let current;

		tablink = new Tablink({
				props: {
					text: /*updateBillToContactText*/ ctx[19],
					path: /*withSubscriptionParam*/ ctx[33](/*updateBillToContactPath*/ ctx[20], /*subscription*/ ctx[0].externalId),
					logDlEvent: /*func_6*/ ctx[45]
				}
			});

		return {
			c() {
				create_component(tablink.$$.fragment);
			},
			m(target, anchor) {
				mount_component(tablink, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const tablink_changes = {};
				if (dirty[0] & /*updateBillToContactText*/ 524288) tablink_changes.text = /*updateBillToContactText*/ ctx[19];
				if (dirty[0] & /*updateBillToContactPath, subscription*/ 1048577) tablink_changes.path = /*withSubscriptionParam*/ ctx[33](/*updateBillToContactPath*/ ctx[20], /*subscription*/ ctx[0].externalId);
				if (dirty[0] & /*logUpdateBillToContact, subscription*/ 513) tablink_changes.logDlEvent = /*func_6*/ ctx[45];
				tablink.$set(tablink_changes);
			},
			i(local) {
				if (current) return;
				transition_in(tablink.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(tablink.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(tablink, detaching);
			}
		};
	}

	// (237:8) {#if element === 'subscription_custom_fields_list' && displayedFields.length > 0}
	function create_if_block_2$a(ctx) {
		let each_1_anchor;
		let each_value_1 = ensure_array_like(/*displayedFields*/ ctx[32]);
		let each_blocks = [];

		for (let i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
		}

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
			},
			p(ctx, dirty) {
				if (dirty[1] & /*displayedFields*/ 2) {
					each_value_1 = ensure_array_like(/*displayedFields*/ ctx[32]);
					let i;

					for (i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block_1$2(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value_1.length;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (238:10) {#each displayedFields as field}
	function create_each_block_1$2(ctx) {
		let div1;
		let span;
		let t0_value = /*field*/ ctx[51].label + "";
		let t0;
		let t1;
		let div0;
		let t2_value = /*field*/ ctx[51].value + "";
		let t2;
		let t3;

		return {
			c() {
				div1 = element("div");
				span = element("span");
				t0 = text(t0_value);
				t1 = space();
				div0 = element("div");
				t2 = text(t2_value);
				t3 = space();
				attr(span, "class", "svelte-xxnasy");
				attr(div0, "class", "zephr-box-item-information svelte-xxnasy");
				attr(div1, "class", "zephr-section svelte-xxnasy");
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, span);
				append(span, t0);
				append(div1, t1);
				append(div1, div0);
				append(div0, t2);
				append(div1, t3);
			},
			p(ctx, dirty) {
				if (dirty[1] & /*displayedFields*/ 2 && t0_value !== (t0_value = /*field*/ ctx[51].label + "")) set_data(t0, t0_value);
				if (dirty[1] & /*displayedFields*/ 2 && t2_value !== (t2_value = /*field*/ ctx[51].value + "")) set_data(t2, t2_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
				}
			}
		};
	}

	// (136:6) {#each elementsOrder as element, _index}
	function create_each_block$9(ctx) {
		let t0;
		let t1;
		let t2;
		let t3;
		let t4;
		let t5;
		let t6;
		let t7;
		let t8;
		let if_block9_anchor;
		let current;
		let if_block0 = /*element*/ ctx[48] === 'subscription_information' && !/*elementsHide*/ ctx[22].subscriptionInformation && create_if_block_20(ctx);
		let if_block1 = /*element*/ ctx[48] === 'payment_auto_renew_toggle' && /*autoRenewToggleEnabled*/ ctx[26] && /*paymentProvider*/ ctx[25] === 'zuora-billing' && /*subscription*/ ctx[0].status === 'active' && !/*subscription*/ ctx[0].isGift && /*subscription*/ ctx[0].termType === 'TERMED' && create_if_block_17(ctx);
		let if_block2 = /*element*/ ctx[48] === 'billing_history' && !/*elementsHide*/ ctx[22].billingHistory && create_if_block_15(ctx);
		let if_block3 = /*element*/ ctx[48] === 'change_payment' && !/*elementsHide*/ ctx[22].changePayment && create_if_block_13$1(ctx);
		let if_block4 = /*element*/ ctx[48] === 'change_subscription' && !/*elementsHide*/ ctx[22].changeSubscription && create_if_block_11$1(ctx);
		let if_block5 = /*element*/ ctx[48] === 'cancel_subscription' && !/*elementsHide*/ ctx[22].cancelSubscription && create_if_block_9$1(ctx);
		let if_block6 = /*element*/ ctx[48] === 'suspend_resume_subscription' && !/*elementsHide*/ ctx[22].suspendResumeSubscription && /*paymentProvider*/ ctx[25] === 'zuora-billing' && create_if_block_7$2(ctx);
		let if_block7 = /*element*/ ctx[48] === 'subscription_custom_fields_list' && !/*elementsHide*/ ctx[22].subscriptionCustomFields && create_if_block_5$5(ctx);
		let if_block8 = /*element*/ ctx[48] === 'bill_to_contact' && !/*elementsHide*/ ctx[22].updateBillToContact && /*paymentProvider*/ ctx[25] === 'zuora-billing' && create_if_block_3$6(ctx);
		let if_block9 = /*element*/ ctx[48] === 'subscription_custom_fields_list' && /*displayedFields*/ ctx[32].length > 0 && create_if_block_2$a(ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				t2 = space();
				if (if_block3) if_block3.c();
				t3 = space();
				if (if_block4) if_block4.c();
				t4 = space();
				if (if_block5) if_block5.c();
				t5 = space();
				if (if_block6) if_block6.c();
				t6 = space();
				if (if_block7) if_block7.c();
				t7 = space();
				if (if_block8) if_block8.c();
				t8 = space();
				if (if_block9) if_block9.c();
				if_block9_anchor = empty();
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t0, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, t2, anchor);
				if (if_block3) if_block3.m(target, anchor);
				insert(target, t3, anchor);
				if (if_block4) if_block4.m(target, anchor);
				insert(target, t4, anchor);
				if (if_block5) if_block5.m(target, anchor);
				insert(target, t5, anchor);
				if (if_block6) if_block6.m(target, anchor);
				insert(target, t6, anchor);
				if (if_block7) if_block7.m(target, anchor);
				insert(target, t7, anchor);
				if (if_block8) if_block8.m(target, anchor);
				insert(target, t8, anchor);
				if (if_block9) if_block9.m(target, anchor);
				insert(target, if_block9_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*element*/ ctx[48] === 'subscription_information' && !/*elementsHide*/ ctx[22].subscriptionInformation) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_20(ctx);
						if_block0.c();
						if_block0.m(t0.parentNode, t0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*element*/ ctx[48] === 'payment_auto_renew_toggle' && /*autoRenewToggleEnabled*/ ctx[26] && /*paymentProvider*/ ctx[25] === 'zuora-billing' && /*subscription*/ ctx[0].status === 'active' && !/*subscription*/ ctx[0].isGift && /*subscription*/ ctx[0].termType === 'TERMED') {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty[0] & /*elementsOrder, autoRenewToggleEnabled, paymentProvider, subscription*/ 102760449) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_17(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(t1.parentNode, t1);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (/*element*/ ctx[48] === 'billing_history' && !/*elementsHide*/ ctx[22].billingHistory) {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty[0] & /*elementsOrder, elementsHide*/ 6291456) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block_15(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(t2.parentNode, t2);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}

				if (/*element*/ ctx[48] === 'change_payment' && !/*elementsHide*/ ctx[22].changePayment) {
					if (if_block3) {
						if_block3.p(ctx, dirty);

						if (dirty[0] & /*elementsOrder, elementsHide*/ 6291456) {
							transition_in(if_block3, 1);
						}
					} else {
						if_block3 = create_if_block_13$1(ctx);
						if_block3.c();
						transition_in(if_block3, 1);
						if_block3.m(t3.parentNode, t3);
					}
				} else if (if_block3) {
					group_outros();

					transition_out(if_block3, 1, 1, () => {
						if_block3 = null;
					});

					check_outros();
				}

				if (/*element*/ ctx[48] === 'change_subscription' && !/*elementsHide*/ ctx[22].changeSubscription) {
					if (if_block4) {
						if_block4.p(ctx, dirty);

						if (dirty[0] & /*elementsOrder, elementsHide*/ 6291456) {
							transition_in(if_block4, 1);
						}
					} else {
						if_block4 = create_if_block_11$1(ctx);
						if_block4.c();
						transition_in(if_block4, 1);
						if_block4.m(t4.parentNode, t4);
					}
				} else if (if_block4) {
					group_outros();

					transition_out(if_block4, 1, 1, () => {
						if_block4 = null;
					});

					check_outros();
				}

				if (/*element*/ ctx[48] === 'cancel_subscription' && !/*elementsHide*/ ctx[22].cancelSubscription) {
					if (if_block5) {
						if_block5.p(ctx, dirty);

						if (dirty[0] & /*elementsOrder, elementsHide*/ 6291456) {
							transition_in(if_block5, 1);
						}
					} else {
						if_block5 = create_if_block_9$1(ctx);
						if_block5.c();
						transition_in(if_block5, 1);
						if_block5.m(t5.parentNode, t5);
					}
				} else if (if_block5) {
					group_outros();

					transition_out(if_block5, 1, 1, () => {
						if_block5 = null;
					});

					check_outros();
				}

				if (/*element*/ ctx[48] === 'suspend_resume_subscription' && !/*elementsHide*/ ctx[22].suspendResumeSubscription && /*paymentProvider*/ ctx[25] === 'zuora-billing') {
					if (if_block6) {
						if_block6.p(ctx, dirty);

						if (dirty[0] & /*elementsOrder, elementsHide, paymentProvider*/ 39845888) {
							transition_in(if_block6, 1);
						}
					} else {
						if_block6 = create_if_block_7$2(ctx);
						if_block6.c();
						transition_in(if_block6, 1);
						if_block6.m(t6.parentNode, t6);
					}
				} else if (if_block6) {
					group_outros();

					transition_out(if_block6, 1, 1, () => {
						if_block6 = null;
					});

					check_outros();
				}

				if (/*element*/ ctx[48] === 'subscription_custom_fields_list' && !/*elementsHide*/ ctx[22].subscriptionCustomFields) {
					if (if_block7) {
						if_block7.p(ctx, dirty);

						if (dirty[0] & /*elementsOrder, elementsHide*/ 6291456) {
							transition_in(if_block7, 1);
						}
					} else {
						if_block7 = create_if_block_5$5(ctx);
						if_block7.c();
						transition_in(if_block7, 1);
						if_block7.m(t7.parentNode, t7);
					}
				} else if (if_block7) {
					group_outros();

					transition_out(if_block7, 1, 1, () => {
						if_block7 = null;
					});

					check_outros();
				}

				if (/*element*/ ctx[48] === 'bill_to_contact' && !/*elementsHide*/ ctx[22].updateBillToContact && /*paymentProvider*/ ctx[25] === 'zuora-billing') {
					if (if_block8) {
						if_block8.p(ctx, dirty);

						if (dirty[0] & /*elementsOrder, elementsHide, paymentProvider*/ 39845888) {
							transition_in(if_block8, 1);
						}
					} else {
						if_block8 = create_if_block_3$6(ctx);
						if_block8.c();
						transition_in(if_block8, 1);
						if_block8.m(t8.parentNode, t8);
					}
				} else if (if_block8) {
					group_outros();

					transition_out(if_block8, 1, 1, () => {
						if_block8 = null;
					});

					check_outros();
				}

				if (/*element*/ ctx[48] === 'subscription_custom_fields_list' && /*displayedFields*/ ctx[32].length > 0) {
					if (if_block9) {
						if_block9.p(ctx, dirty);
					} else {
						if_block9 = create_if_block_2$a(ctx);
						if_block9.c();
						if_block9.m(if_block9_anchor.parentNode, if_block9_anchor);
					}
				} else if (if_block9) {
					if_block9.d(1);
					if_block9 = null;
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block1);
				transition_in(if_block2);
				transition_in(if_block3);
				transition_in(if_block4);
				transition_in(if_block5);
				transition_in(if_block6);
				transition_in(if_block7);
				transition_in(if_block8);
				current = true;
			},
			o(local) {
				transition_out(if_block1);
				transition_out(if_block2);
				transition_out(if_block3);
				transition_out(if_block4);
				transition_out(if_block5);
				transition_out(if_block6);
				transition_out(if_block7);
				transition_out(if_block8);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
					detach(t2);
					detach(t3);
					detach(t4);
					detach(t5);
					detach(t6);
					detach(t7);
					detach(t8);
					detach(if_block9_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				if (if_block2) if_block2.d(detaching);
				if (if_block3) if_block3.d(detaching);
				if (if_block4) if_block4.d(detaching);
				if (if_block5) if_block5.d(detaching);
				if (if_block6) if_block6.d(detaching);
				if (if_block7) if_block7.d(detaching);
				if (if_block8) if_block8.d(detaching);
				if (if_block9) if_block9.d(detaching);
			}
		};
	}

	// (129:6) {#if subscription.amount}
	function create_if_block_1$g(ctx) {
		let div1;
		let span;
		let t0;
		let t1;
		let div0;
		let t2_value = /*subscription*/ ctx[0].amount + "";
		let t2;

		return {
			c() {
				div1 = element("div");
				span = element("span");
				t0 = text(/*subscriptionRateText*/ ctx[2]);
				t1 = space();
				div0 = element("div");
				t2 = text(t2_value);
				attr(span, "class", "svelte-xxnasy");
				attr(div0, "class", "zephr-box-item-information svelte-xxnasy");
				attr(div1, "class", "zephr-section svelte-xxnasy");
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, span);
				append(span, t0);
				append(div1, t1);
				append(div1, div0);
				append(div0, t2);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*subscriptionRateText*/ 4) set_data(t0, /*subscriptionRateText*/ ctx[2]);
				if (dirty[0] & /*subscription*/ 1 && t2_value !== (t2_value = /*subscription*/ ctx[0].amount + "")) set_data(t2, t2_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
				}
			}
		};
	}

	function create_fragment$v(ctx) {
		let div2;
		let div1;
		let div0;
		let h2;
		let t0_value = /*subscription*/ ctx[0].productLabel + "";
		let t0;
		let t1;
		let t2;
		let current_block_type_index;
		let if_block1;
		let current;
		let if_block0 = /*subscription*/ ctx[0].isGift && create_if_block_23(ctx);
		const if_block_creators = [create_if_block$o, create_else_block$4];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*isInactive*/ ctx[23]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				div2 = element("div");
				div1 = element("div");
				div0 = element("div");
				h2 = element("h2");
				t0 = text(t0_value);
				t1 = space();
				if (if_block0) if_block0.c();
				t2 = space();
				if_block1.c();
				attr(h2, "class", "svelte-xxnasy");
				attr(div0, "class", "zephr-section svelte-xxnasy");
				attr(div1, "class", "zephr-inner-box svelte-xxnasy");
				attr(div2, "class", "zephr-subscription-list-box-item svelte-xxnasy");
			},
			m(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div1);
				append(div1, div0);
				append(div0, h2);
				append(h2, t0);
				append(h2, t1);
				if (if_block0) if_block0.m(h2, null);
				append(div1, t2);
				if_blocks[current_block_type_index].m(div1, null);
				current = true;
			},
			p(ctx, dirty) {
				if ((!current || dirty[0] & /*subscription*/ 1) && t0_value !== (t0_value = /*subscription*/ ctx[0].productLabel + "")) set_data(t0, t0_value);

				if (/*subscription*/ ctx[0].isGift) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_23(ctx);
						if_block0.c();
						if_block0.m(h2, null);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					} else {
						if_block1.p(ctx, dirty);
					}

					transition_in(if_block1, 1);
					if_block1.m(div1, null);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div2);
				}

				if (if_block0) if_block0.d();
				if_blocks[current_block_type_index].d();
			}
		};
	}

	function instance$v($$self, $$props, $$invalidate) {
		let displayedFields;
		let { subscription } = $$props;
		let { nextPaymentDateText = '' } = $$props;
		let { subscriptionRateText } = $$props;
		let { billingHistoryLink = '' } = $$props;

		let { onViewHistory = () => {
			
		} } = $$props;

		let { onChangePayment = () => {
			
		} } = $$props;

		let { logChangeSubscription = () => {
			
		} } = $$props;

		let { logCancelSubscription = () => {
			
		} } = $$props;

		let { logSuspendResumeSubscription = () => {
			
		} } = $$props;

		let { logUpdateBillToContact = () => {
			
		} } = $$props;

		let { changePaymentMethodText = '' } = $$props;
		let { changeSubscriptionText = '' } = $$props;
		let { cancelSubscriptionText = '' } = $$props;
		let { changeSubscriptionPath = '' } = $$props;
		let { cancelSubscriptionPath = '' } = $$props;
		let { suspendResumeSubscriptionText = '' } = $$props;
		let { suspendResumeSubscriptionPath = '' } = $$props;
		let { subscriptionCustomFieldsText } = $$props;
		let { onUpdateSubscriptionCustomFields } = $$props;
		let { updateBillToContactText } = $$props;
		let { updateBillToContactPath } = $$props;
		let { elementsOrder = [] } = $$props;

		let { elementsHide = {
			subscriptionInformation: false,
			changePayment: true,
			changeSubscription: true,
			cancelSubscription: true,
			billingHistory: true,
			suspendResumeSubscription: true,
			subscriptionCustomFields: true,
			updateBillToContact: true
		} } = $$props;

		let { isInactive = false } = $$props;
		let { displayedCustomFields = {} } = $$props;
		let { giftPillText = 'Gift' } = $$props;
		let { paymentProvider = '' } = $$props;
		let { autoRenewToggleEnabled = false } = $$props;
		let { autoRenewToggleText = 'Auto-renew subscription' } = $$props;
		let { autoRenewSuccessMessage = 'Preferences updated' } = $$props;
		let { autoRenewErrorMessage = 'Something went wrong. Please try again later' } = $$props;
		let { onAutoRenewToggle = async () => ({ success: false }) } = $$props;
		let isUpdatingAutoRenew = false;
		let statusMessage = '';
		let statusType = '';
		let statusTimeout = null;
		let autoRenewValue = subscription.autoRenew ?? false; // Local checkbox state

		// Ensures we append the subscription id correctly whether or not the base path already has query params
		const withSubscriptionParam = (basePath, subscriptionId) => {
			if (!basePath) return '';
			const hasQuery = basePath.includes('?');
			const separator = hasQuery ? '&' : '?';
			return `${basePath}${separator}subscription=${encodeURIComponent(subscriptionId)}`;
		};

		const handleAutoRenewChange = async event => {
			const newAutoRenewValue = event.detail;

			// Clear any existing status message
			clearStatusMessage();

			// Revert checkbox to previous state immediately (will update on success)
			$$invalidate(31, autoRenewValue = subscription.autoRenew ?? false);

			$$invalidate(28, isUpdatingAutoRenew = true);

			try {
				const result = await onAutoRenewToggle(subscription, newAutoRenewValue);

				if (result.success) {
					// Update local subscription state (this will trigger checkbox update via reactive statement)
					$$invalidate(0, subscription.autoRenew = newAutoRenewValue, subscription);

					// Show success message for 5 seconds
					$$invalidate(29, statusMessage = autoRenewSuccessMessage);

					$$invalidate(30, statusType = 'success');

					statusTimeout = setTimeout(
						() => {
							clearStatusMessage();
						},
						5000
					);
				} else {
					// Show error message persistently (checkbox already reverted)
					$$invalidate(29, statusMessage = autoRenewErrorMessage);

					$$invalidate(30, statusType = 'error');
				}
			} catch(error) {
				console.error('Failed to update auto-renewal:', error);

				// Show error message persistently (checkbox already reverted)
				$$invalidate(29, statusMessage = autoRenewErrorMessage);

				$$invalidate(30, statusType = 'error');
			} finally {
				$$invalidate(28, isUpdatingAutoRenew = false);
			}
		};

		const clearStatusMessage = () => {
			if (statusTimeout) {
				clearTimeout(statusTimeout);
				statusTimeout = null;
			}

			$$invalidate(29, statusMessage = '');
			$$invalidate(30, statusType = '');
		};

		// Clean up timeout on component destroy
		onDestroy(() => {
			if (statusTimeout) {
				clearTimeout(statusTimeout);
			}
		});

		const func = () => onViewHistory(subscription);
		const func_1 = () => onChangePayment(subscription);
		const func_2 = () => logChangeSubscription(subscription);
		const func_3 = () => logCancelSubscription(subscription);
		const func_4 = () => logSuspendResumeSubscription(subscription);
		const func_5 = () => onUpdateSubscriptionCustomFields(subscription);
		const func_6 = () => logUpdateBillToContact(subscription);

		$$self.$$set = $$props => {
			if ('subscription' in $$props) $$invalidate(0, subscription = $$props.subscription);
			if ('nextPaymentDateText' in $$props) $$invalidate(1, nextPaymentDateText = $$props.nextPaymentDateText);
			if ('subscriptionRateText' in $$props) $$invalidate(2, subscriptionRateText = $$props.subscriptionRateText);
			if ('billingHistoryLink' in $$props) $$invalidate(3, billingHistoryLink = $$props.billingHistoryLink);
			if ('onViewHistory' in $$props) $$invalidate(4, onViewHistory = $$props.onViewHistory);
			if ('onChangePayment' in $$props) $$invalidate(5, onChangePayment = $$props.onChangePayment);
			if ('logChangeSubscription' in $$props) $$invalidate(6, logChangeSubscription = $$props.logChangeSubscription);
			if ('logCancelSubscription' in $$props) $$invalidate(7, logCancelSubscription = $$props.logCancelSubscription);
			if ('logSuspendResumeSubscription' in $$props) $$invalidate(8, logSuspendResumeSubscription = $$props.logSuspendResumeSubscription);
			if ('logUpdateBillToContact' in $$props) $$invalidate(9, logUpdateBillToContact = $$props.logUpdateBillToContact);
			if ('changePaymentMethodText' in $$props) $$invalidate(10, changePaymentMethodText = $$props.changePaymentMethodText);
			if ('changeSubscriptionText' in $$props) $$invalidate(11, changeSubscriptionText = $$props.changeSubscriptionText);
			if ('cancelSubscriptionText' in $$props) $$invalidate(12, cancelSubscriptionText = $$props.cancelSubscriptionText);
			if ('changeSubscriptionPath' in $$props) $$invalidate(13, changeSubscriptionPath = $$props.changeSubscriptionPath);
			if ('cancelSubscriptionPath' in $$props) $$invalidate(14, cancelSubscriptionPath = $$props.cancelSubscriptionPath);
			if ('suspendResumeSubscriptionText' in $$props) $$invalidate(15, suspendResumeSubscriptionText = $$props.suspendResumeSubscriptionText);
			if ('suspendResumeSubscriptionPath' in $$props) $$invalidate(16, suspendResumeSubscriptionPath = $$props.suspendResumeSubscriptionPath);
			if ('subscriptionCustomFieldsText' in $$props) $$invalidate(17, subscriptionCustomFieldsText = $$props.subscriptionCustomFieldsText);
			if ('onUpdateSubscriptionCustomFields' in $$props) $$invalidate(18, onUpdateSubscriptionCustomFields = $$props.onUpdateSubscriptionCustomFields);
			if ('updateBillToContactText' in $$props) $$invalidate(19, updateBillToContactText = $$props.updateBillToContactText);
			if ('updateBillToContactPath' in $$props) $$invalidate(20, updateBillToContactPath = $$props.updateBillToContactPath);
			if ('elementsOrder' in $$props) $$invalidate(21, elementsOrder = $$props.elementsOrder);
			if ('elementsHide' in $$props) $$invalidate(22, elementsHide = $$props.elementsHide);
			if ('isInactive' in $$props) $$invalidate(23, isInactive = $$props.isInactive);
			if ('displayedCustomFields' in $$props) $$invalidate(35, displayedCustomFields = $$props.displayedCustomFields);
			if ('giftPillText' in $$props) $$invalidate(24, giftPillText = $$props.giftPillText);
			if ('paymentProvider' in $$props) $$invalidate(25, paymentProvider = $$props.paymentProvider);
			if ('autoRenewToggleEnabled' in $$props) $$invalidate(26, autoRenewToggleEnabled = $$props.autoRenewToggleEnabled);
			if ('autoRenewToggleText' in $$props) $$invalidate(27, autoRenewToggleText = $$props.autoRenewToggleText);
			if ('autoRenewSuccessMessage' in $$props) $$invalidate(36, autoRenewSuccessMessage = $$props.autoRenewSuccessMessage);
			if ('autoRenewErrorMessage' in $$props) $$invalidate(37, autoRenewErrorMessage = $$props.autoRenewErrorMessage);
			if ('onAutoRenewToggle' in $$props) $$invalidate(38, onAutoRenewToggle = $$props.onAutoRenewToggle);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty[0] & /*subscription*/ 1 | $$self.$$.dirty[1] & /*displayedCustomFields*/ 16) {
				// Compute displayed custom fields
				$$invalidate(32, displayedFields = Object.entries(displayedCustomFields).filter(([fieldId, fieldConfig]) => fieldConfig.enabled && subscription[fieldId]).map(([fieldId, fieldConfig]) => ({
					label: fieldConfig.label,
					value: subscription[fieldId]
				})));
			}

			if ($$self.$$.dirty[0] & /*subscription*/ 1) {
				// Update local checkbox state when subscription changes
				$$invalidate(31, autoRenewValue = subscription.autoRenew ?? false);
			}
		};

		return [
			subscription,
			nextPaymentDateText,
			subscriptionRateText,
			billingHistoryLink,
			onViewHistory,
			onChangePayment,
			logChangeSubscription,
			logCancelSubscription,
			logSuspendResumeSubscription,
			logUpdateBillToContact,
			changePaymentMethodText,
			changeSubscriptionText,
			cancelSubscriptionText,
			changeSubscriptionPath,
			cancelSubscriptionPath,
			suspendResumeSubscriptionText,
			suspendResumeSubscriptionPath,
			subscriptionCustomFieldsText,
			onUpdateSubscriptionCustomFields,
			updateBillToContactText,
			updateBillToContactPath,
			elementsOrder,
			elementsHide,
			isInactive,
			giftPillText,
			paymentProvider,
			autoRenewToggleEnabled,
			autoRenewToggleText,
			isUpdatingAutoRenew,
			statusMessage,
			statusType,
			autoRenewValue,
			displayedFields,
			withSubscriptionParam,
			handleAutoRenewChange,
			displayedCustomFields,
			autoRenewSuccessMessage,
			autoRenewErrorMessage,
			onAutoRenewToggle,
			func,
			func_1,
			func_2,
			func_3,
			func_4,
			func_5,
			func_6
		];
	}

	class SubscriptionsListBoxItem extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$v,
				create_fragment$v,
				safe_not_equal,
				{
					subscription: 0,
					nextPaymentDateText: 1,
					subscriptionRateText: 2,
					billingHistoryLink: 3,
					onViewHistory: 4,
					onChangePayment: 5,
					logChangeSubscription: 6,
					logCancelSubscription: 7,
					logSuspendResumeSubscription: 8,
					logUpdateBillToContact: 9,
					changePaymentMethodText: 10,
					changeSubscriptionText: 11,
					cancelSubscriptionText: 12,
					changeSubscriptionPath: 13,
					cancelSubscriptionPath: 14,
					suspendResumeSubscriptionText: 15,
					suspendResumeSubscriptionPath: 16,
					subscriptionCustomFieldsText: 17,
					onUpdateSubscriptionCustomFields: 18,
					updateBillToContactText: 19,
					updateBillToContactPath: 20,
					elementsOrder: 21,
					elementsHide: 22,
					isInactive: 23,
					displayedCustomFields: 35,
					giftPillText: 24,
					paymentProvider: 25,
					autoRenewToggleEnabled: 26,
					autoRenewToggleText: 27,
					autoRenewSuccessMessage: 36,
					autoRenewErrorMessage: 37,
					onAutoRenewToggle: 38
				},
				null,
				[-1, -1]
			);
		}
	}

	/* src/components/elements/subscriptionsList/SubscriptionsList.svelte generated by Svelte v4.2.12 */

	function get_each_context$8(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[34] = list[i];
		return child_ctx;
	}

	function get_each_context_1$1(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[34] = list[i];
		return child_ctx;
	}

	// (44:2) {#if loading}
	function create_if_block_6$4(ctx) {
		let spinner;
		let current;
		spinner = new Spinner({});

		return {
			c() {
				create_component(spinner.$$.fragment);
			},
			m(target, anchor) {
				mount_component(spinner, target, anchor);
				current = true;
			},
			i(local) {
				if (current) return;
				transition_in(spinner.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(spinner.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(spinner, detaching);
			}
		};
	}

	// (47:2) {#if !isPastSubscriptions}
	function create_if_block_2$9(ctx) {
		let t;
		let each_1_anchor;
		let current;
		let if_block = !/*loading*/ ctx[10] && !/*subscriptions*/ ctx[6].length && create_if_block_5$4(ctx);
		let each_value_1 = ensure_array_like(/*subscriptions*/ ctx[6]);
		let each_blocks = [];

		for (let i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				if (if_block) if_block.c();
				t = space();

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, t, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (!/*loading*/ ctx[10] && !/*subscriptions*/ ctx[6].length) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block_5$4(ctx);
						if_block.c();
						if_block.m(t.parentNode, t);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (dirty[0] & /*subscriptions, nextPaymentDateText, subscriptionRateText, billingHistoryLink, onViewHistory, onChangePayment, logChangeSubscription, logCancelSubscription, logSuspendResumeSubscription, changePaymentMethodText, changeSubscriptionText, cancelSubscriptionText, changeSubscriptionPath, cancelSubscriptionPath, suspendResumeSubscriptionText, suspendResumeSubscriptionPath, subscriptionCustomFieldsText, onUpdateSubscriptionCustomFields, updateBillToContactText, updateBillToContactPath, elementsOrder, elementsHide, giftPillText, paymentProvider, autoRenewToggleEnabled, autoRenewToggleText, billingHistoryText*/ 2147482492 | dirty[1] & /*onAutoRenewToggle, displayedCustomFields*/ 3) {
					each_value_1 = ensure_array_like(/*subscriptions*/ ctx[6]);
					let i;

					for (i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block_1$1(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					group_outros();

					for (i = each_value_1.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value_1.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(each_1_anchor);
				}

				if (if_block) if_block.d(detaching);
				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (48:4) {#if !loading && !subscriptions.length}
	function create_if_block_5$4(ctx) {
		let div;

		return {
			c() {
				div = element("div");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				div.innerHTML = /*noSubscriptionsMessage*/ ctx[1];
			},
			p(ctx, dirty) {
				if (dirty[0] & /*noSubscriptionsMessage*/ 2) div.innerHTML = /*noSubscriptionsMessage*/ ctx[1];		},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (85:6) {:else}
	function create_else_block$3(ctx) {
		let subscriptionslistitem;
		let t;
		let if_block_anchor;
		let current;

		subscriptionslistitem = new SubscriptionsListItem({
				props: {
					subscription: /*subscription*/ ctx[34],
					nextPaymentDateText: /*nextPaymentDateText*/ ctx[4],
					subscriptionRateText: /*subscriptionRateText*/ ctx[5],
					billingHistoryText: /*billingHistoryText*/ ctx[2],
					billingHistoryLink: /*billingHistoryLink*/ ctx[3],
					onViewHistory: /*onViewHistory*/ ctx[15],
					showBillingHistory: /*paymentProvider*/ ctx[8] !== "zuora-billing",
					giftPillText: /*giftPillText*/ ctx[28]
				}
			});

		let if_block = /*paymentProvider*/ ctx[8] !== "zuora-billing" && /*subscription*/ ctx[34].status === "active" && create_if_block_4$4(ctx);

		return {
			c() {
				create_component(subscriptionslistitem.$$.fragment);
				t = space();
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				mount_component(subscriptionslistitem, target, anchor);
				insert(target, t, anchor);
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const subscriptionslistitem_changes = {};
				if (dirty[0] & /*subscriptions*/ 64) subscriptionslistitem_changes.subscription = /*subscription*/ ctx[34];
				if (dirty[0] & /*nextPaymentDateText*/ 16) subscriptionslistitem_changes.nextPaymentDateText = /*nextPaymentDateText*/ ctx[4];
				if (dirty[0] & /*subscriptionRateText*/ 32) subscriptionslistitem_changes.subscriptionRateText = /*subscriptionRateText*/ ctx[5];
				if (dirty[0] & /*billingHistoryText*/ 4) subscriptionslistitem_changes.billingHistoryText = /*billingHistoryText*/ ctx[2];
				if (dirty[0] & /*billingHistoryLink*/ 8) subscriptionslistitem_changes.billingHistoryLink = /*billingHistoryLink*/ ctx[3];
				if (dirty[0] & /*onViewHistory*/ 32768) subscriptionslistitem_changes.onViewHistory = /*onViewHistory*/ ctx[15];
				if (dirty[0] & /*paymentProvider*/ 256) subscriptionslistitem_changes.showBillingHistory = /*paymentProvider*/ ctx[8] !== "zuora-billing";
				if (dirty[0] & /*giftPillText*/ 268435456) subscriptionslistitem_changes.giftPillText = /*giftPillText*/ ctx[28];
				subscriptionslistitem.$set(subscriptionslistitem_changes);

				if (/*paymentProvider*/ ctx[8] !== "zuora-billing" && /*subscription*/ ctx[34].status === "active") {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty[0] & /*paymentProvider, subscriptions*/ 320) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_4$4(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(subscriptionslistitem.$$.fragment, local);
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(subscriptionslistitem.$$.fragment, local);
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(if_block_anchor);
				}

				destroy_component(subscriptionslistitem, detaching);
				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (54:6) {#if elementsOrder}
	function create_if_block_3$5(ctx) {
		let subscriptionslistboxitem;
		let current;

		subscriptionslistboxitem = new SubscriptionsListBoxItem({
				props: {
					subscription: /*subscription*/ ctx[34],
					nextPaymentDateText: /*nextPaymentDateText*/ ctx[4],
					subscriptionRateText: /*subscriptionRateText*/ ctx[5],
					billingHistoryLink: /*billingHistoryLink*/ ctx[3],
					onViewHistory: /*onViewHistory*/ ctx[15],
					onChangePayment: /*onChangePayment*/ ctx[11],
					logChangeSubscription: /*logChangeSubscription*/ ctx[12],
					logCancelSubscription: /*logCancelSubscription*/ ctx[13],
					logSuspendResumeSubscription: /*logSuspendResumeSubscription*/ ctx[14],
					changePaymentMethodText: /*changePaymentMethodText*/ ctx[9],
					changeSubscriptionText: /*changeSubscriptionText*/ ctx[16],
					cancelSubscriptionText: /*cancelSubscriptionText*/ ctx[17],
					changeSubscriptionPath: /*changeSubscriptionPath*/ ctx[18],
					cancelSubscriptionPath: /*cancelSubscriptionPath*/ ctx[19],
					suspendResumeSubscriptionText: /*suspendResumeSubscriptionText*/ ctx[20],
					suspendResumeSubscriptionPath: /*suspendResumeSubscriptionPath*/ ctx[21],
					subscriptionCustomFieldsText: /*subscriptionCustomFieldsText*/ ctx[22],
					onUpdateSubscriptionCustomFields: /*onUpdateSubscriptionCustomFields*/ ctx[23],
					updateBillToContactText: /*updateBillToContactText*/ ctx[24],
					updateBillToContactPath: /*updateBillToContactPath*/ ctx[25],
					elementsOrder: /*elementsOrder*/ ctx[26],
					elementsHide: /*elementsHide*/ ctx[27],
					giftPillText: /*giftPillText*/ ctx[28],
					paymentProvider: /*paymentProvider*/ ctx[8],
					autoRenewToggleEnabled: /*autoRenewToggleEnabled*/ ctx[29],
					autoRenewToggleText: /*autoRenewToggleText*/ ctx[30],
					onAutoRenewToggle: /*onAutoRenewToggle*/ ctx[31],
					displayedCustomFields: /*displayedCustomFields*/ ctx[32]
				}
			});

		return {
			c() {
				create_component(subscriptionslistboxitem.$$.fragment);
			},
			m(target, anchor) {
				mount_component(subscriptionslistboxitem, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const subscriptionslistboxitem_changes = {};
				if (dirty[0] & /*subscriptions*/ 64) subscriptionslistboxitem_changes.subscription = /*subscription*/ ctx[34];
				if (dirty[0] & /*nextPaymentDateText*/ 16) subscriptionslistboxitem_changes.nextPaymentDateText = /*nextPaymentDateText*/ ctx[4];
				if (dirty[0] & /*subscriptionRateText*/ 32) subscriptionslistboxitem_changes.subscriptionRateText = /*subscriptionRateText*/ ctx[5];
				if (dirty[0] & /*billingHistoryLink*/ 8) subscriptionslistboxitem_changes.billingHistoryLink = /*billingHistoryLink*/ ctx[3];
				if (dirty[0] & /*onViewHistory*/ 32768) subscriptionslistboxitem_changes.onViewHistory = /*onViewHistory*/ ctx[15];
				if (dirty[0] & /*onChangePayment*/ 2048) subscriptionslistboxitem_changes.onChangePayment = /*onChangePayment*/ ctx[11];
				if (dirty[0] & /*logChangeSubscription*/ 4096) subscriptionslistboxitem_changes.logChangeSubscription = /*logChangeSubscription*/ ctx[12];
				if (dirty[0] & /*logCancelSubscription*/ 8192) subscriptionslistboxitem_changes.logCancelSubscription = /*logCancelSubscription*/ ctx[13];
				if (dirty[0] & /*logSuspendResumeSubscription*/ 16384) subscriptionslistboxitem_changes.logSuspendResumeSubscription = /*logSuspendResumeSubscription*/ ctx[14];
				if (dirty[0] & /*changePaymentMethodText*/ 512) subscriptionslistboxitem_changes.changePaymentMethodText = /*changePaymentMethodText*/ ctx[9];
				if (dirty[0] & /*changeSubscriptionText*/ 65536) subscriptionslistboxitem_changes.changeSubscriptionText = /*changeSubscriptionText*/ ctx[16];
				if (dirty[0] & /*cancelSubscriptionText*/ 131072) subscriptionslistboxitem_changes.cancelSubscriptionText = /*cancelSubscriptionText*/ ctx[17];
				if (dirty[0] & /*changeSubscriptionPath*/ 262144) subscriptionslistboxitem_changes.changeSubscriptionPath = /*changeSubscriptionPath*/ ctx[18];
				if (dirty[0] & /*cancelSubscriptionPath*/ 524288) subscriptionslistboxitem_changes.cancelSubscriptionPath = /*cancelSubscriptionPath*/ ctx[19];
				if (dirty[0] & /*suspendResumeSubscriptionText*/ 1048576) subscriptionslistboxitem_changes.suspendResumeSubscriptionText = /*suspendResumeSubscriptionText*/ ctx[20];
				if (dirty[0] & /*suspendResumeSubscriptionPath*/ 2097152) subscriptionslistboxitem_changes.suspendResumeSubscriptionPath = /*suspendResumeSubscriptionPath*/ ctx[21];
				if (dirty[0] & /*subscriptionCustomFieldsText*/ 4194304) subscriptionslistboxitem_changes.subscriptionCustomFieldsText = /*subscriptionCustomFieldsText*/ ctx[22];
				if (dirty[0] & /*onUpdateSubscriptionCustomFields*/ 8388608) subscriptionslistboxitem_changes.onUpdateSubscriptionCustomFields = /*onUpdateSubscriptionCustomFields*/ ctx[23];
				if (dirty[0] & /*updateBillToContactText*/ 16777216) subscriptionslistboxitem_changes.updateBillToContactText = /*updateBillToContactText*/ ctx[24];
				if (dirty[0] & /*updateBillToContactPath*/ 33554432) subscriptionslistboxitem_changes.updateBillToContactPath = /*updateBillToContactPath*/ ctx[25];
				if (dirty[0] & /*elementsOrder*/ 67108864) subscriptionslistboxitem_changes.elementsOrder = /*elementsOrder*/ ctx[26];
				if (dirty[0] & /*elementsHide*/ 134217728) subscriptionslistboxitem_changes.elementsHide = /*elementsHide*/ ctx[27];
				if (dirty[0] & /*giftPillText*/ 268435456) subscriptionslistboxitem_changes.giftPillText = /*giftPillText*/ ctx[28];
				if (dirty[0] & /*paymentProvider*/ 256) subscriptionslistboxitem_changes.paymentProvider = /*paymentProvider*/ ctx[8];
				if (dirty[0] & /*autoRenewToggleEnabled*/ 536870912) subscriptionslistboxitem_changes.autoRenewToggleEnabled = /*autoRenewToggleEnabled*/ ctx[29];
				if (dirty[0] & /*autoRenewToggleText*/ 1073741824) subscriptionslistboxitem_changes.autoRenewToggleText = /*autoRenewToggleText*/ ctx[30];
				if (dirty[1] & /*onAutoRenewToggle*/ 1) subscriptionslistboxitem_changes.onAutoRenewToggle = /*onAutoRenewToggle*/ ctx[31];
				if (dirty[1] & /*displayedCustomFields*/ 2) subscriptionslistboxitem_changes.displayedCustomFields = /*displayedCustomFields*/ ctx[32];
				subscriptionslistboxitem.$set(subscriptionslistboxitem_changes);
			},
			i(local) {
				if (current) return;
				transition_in(subscriptionslistboxitem.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(subscriptionslistboxitem.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(subscriptionslistboxitem, detaching);
			}
		};
	}

	// (96:8) {#if paymentProvider !== "zuora-billing" && subscription.status === "active"}
	function create_if_block_4$4(ctx) {
		let button;
		let current;

		function func() {
			return /*func*/ ctx[33](/*subscription*/ ctx[34]);
		}

		button = new Button({
				props: {
					disabled: false,
					text: /*changePaymentMethodText*/ ctx[9],
					onClick: func,
					noMargin: true
				}
			});

		return {
			c() {
				create_component(button.$$.fragment);
			},
			m(target, anchor) {
				mount_component(button, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				const button_changes = {};
				if (dirty[0] & /*changePaymentMethodText*/ 512) button_changes.text = /*changePaymentMethodText*/ ctx[9];
				if (dirty[0] & /*onChangePayment, subscriptions*/ 2112) button_changes.onClick = func;
				button.$set(button_changes);
			},
			i(local) {
				if (current) return;
				transition_in(button.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(button.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(button, detaching);
			}
		};
	}

	// (53:4) {#each subscriptions as subscription}
	function create_each_block_1$1(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_3$5, create_else_block$3];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*elementsOrder*/ ctx[26]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	// (107:2) {#if isPastSubscriptions}
	function create_if_block$n(ctx) {
		let t;
		let each_1_anchor;
		let current;
		let if_block = !/*loading*/ ctx[10] && !/*inactiveSubscriptions*/ ctx[7].length && create_if_block_1$f(ctx);
		let each_value = ensure_array_like(/*inactiveSubscriptions*/ ctx[7]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				if (if_block) if_block.c();
				t = space();

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, t, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (!/*loading*/ ctx[10] && !/*inactiveSubscriptions*/ ctx[7].length) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block_1$f(ctx);
						if_block.c();
						if_block.m(t.parentNode, t);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (dirty[0] & /*inactiveSubscriptions, subscriptionRateText, giftPillText*/ 268435616 | dirty[1] & /*displayedCustomFields*/ 2) {
					each_value = ensure_array_like(/*inactiveSubscriptions*/ ctx[7]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$8(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$8(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(each_1_anchor);
				}

				if (if_block) if_block.d(detaching);
				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (108:4) {#if !loading && !inactiveSubscriptions.length}
	function create_if_block_1$f(ctx) {
		let div;

		return {
			c() {
				div = element("div");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				div.innerHTML = /*noSubscriptionsMessage*/ ctx[1];
			},
			p(ctx, dirty) {
				if (dirty[0] & /*noSubscriptionsMessage*/ 2) div.innerHTML = /*noSubscriptionsMessage*/ ctx[1];		},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (113:4) {#each inactiveSubscriptions as subscription}
	function create_each_block$8(ctx) {
		let subscriptionslistboxitem;
		let current;

		subscriptionslistboxitem = new SubscriptionsListBoxItem({
				props: {
					subscription: /*subscription*/ ctx[34],
					isInactive: true,
					subscriptionRateText: /*subscriptionRateText*/ ctx[5],
					giftPillText: /*giftPillText*/ ctx[28],
					displayedCustomFields: /*displayedCustomFields*/ ctx[32],
					subscriptionCustomFieldsText: "",
					onUpdateSubscriptionCustomFields: func_1$1,
					updateBillToContactText: "",
					updateBillToContactPath: ""
				}
			});

		return {
			c() {
				create_component(subscriptionslistboxitem.$$.fragment);
			},
			m(target, anchor) {
				mount_component(subscriptionslistboxitem, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const subscriptionslistboxitem_changes = {};
				if (dirty[0] & /*inactiveSubscriptions*/ 128) subscriptionslistboxitem_changes.subscription = /*subscription*/ ctx[34];
				if (dirty[0] & /*subscriptionRateText*/ 32) subscriptionslistboxitem_changes.subscriptionRateText = /*subscriptionRateText*/ ctx[5];
				if (dirty[0] & /*giftPillText*/ 268435456) subscriptionslistboxitem_changes.giftPillText = /*giftPillText*/ ctx[28];
				if (dirty[1] & /*displayedCustomFields*/ 2) subscriptionslistboxitem_changes.displayedCustomFields = /*displayedCustomFields*/ ctx[32];
				subscriptionslistboxitem.$set(subscriptionslistboxitem_changes);
			},
			i(local) {
				if (current) return;
				transition_in(subscriptionslistboxitem.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(subscriptionslistboxitem.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(subscriptionslistboxitem, detaching);
			}
		};
	}

	function create_fragment$u(ctx) {
		let div;
		let t0;
		let t1;
		let current;
		let if_block0 = /*loading*/ ctx[10] && create_if_block_6$4();
		let if_block1 = !/*isPastSubscriptions*/ ctx[0] && create_if_block_2$9(ctx);
		let if_block2 = /*isPastSubscriptions*/ ctx[0] && create_if_block$n(ctx);

		return {
			c() {
				div = element("div");
				if (if_block0) if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				attr(div, "class", "subscriptions-list-container svelte-ldb1rq");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append(div, t0);
				if (if_block1) if_block1.m(div, null);
				append(div, t1);
				if (if_block2) if_block2.m(div, null);
				current = true;
			},
			p(ctx, dirty) {
				if (/*loading*/ ctx[10]) {
					if (if_block0) {
						if (dirty[0] & /*loading*/ 1024) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_6$4();
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div, t0);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (!/*isPastSubscriptions*/ ctx[0]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty[0] & /*isPastSubscriptions*/ 1) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_2$9(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div, t1);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (/*isPastSubscriptions*/ ctx[0]) {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty[0] & /*isPastSubscriptions*/ 1) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block$n(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(div, null);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(if_block2);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(if_block2);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
			}
		};
	}

	const func_1$1 = () => {
		
	};

	function instance$u($$self, $$props, $$invalidate) {
		let { isPastSubscriptions } = $$props;
		let { noSubscriptionsMessage } = $$props;
		let { billingHistoryText } = $$props;
		let { billingHistoryLink } = $$props;
		let { nextPaymentDateText } = $$props;
		let { subscriptionRateText } = $$props;
		let { subscriptions } = $$props;
		let { inactiveSubscriptions } = $$props;
		let { paymentProvider } = $$props;
		let { changePaymentMethodText } = $$props;
		let { loading } = $$props;
		let { onChangePayment } = $$props;
		let { logChangeSubscription } = $$props;
		let { logCancelSubscription } = $$props;
		let { logSuspendResumeSubscription } = $$props;
		let { onViewHistory } = $$props;
		let { changeSubscriptionText } = $$props;
		let { cancelSubscriptionText } = $$props;
		let { changeSubscriptionPath } = $$props;
		let { cancelSubscriptionPath } = $$props;
		let { suspendResumeSubscriptionText } = $$props;
		let { suspendResumeSubscriptionPath } = $$props;
		let { subscriptionCustomFieldsText } = $$props;
		let { onUpdateSubscriptionCustomFields } = $$props;
		let { updateBillToContactText } = $$props;
		let { updateBillToContactPath } = $$props;
		let { elementsOrder } = $$props;
		let { elementsHide } = $$props;
		let { giftPillText = 'Gift' } = $$props;
		let { autoRenewToggleEnabled = false } = $$props;
		let { autoRenewToggleText = 'Auto-renew subscription' } = $$props;
		let { onAutoRenewToggle = async () => ({ success: false }) } = $$props;
		let { displayedCustomFields = {} } = $$props;

		onMount(() => {
			
		});

		const func = subscription => onChangePayment(subscription);

		$$self.$$set = $$props => {
			if ('isPastSubscriptions' in $$props) $$invalidate(0, isPastSubscriptions = $$props.isPastSubscriptions);
			if ('noSubscriptionsMessage' in $$props) $$invalidate(1, noSubscriptionsMessage = $$props.noSubscriptionsMessage);
			if ('billingHistoryText' in $$props) $$invalidate(2, billingHistoryText = $$props.billingHistoryText);
			if ('billingHistoryLink' in $$props) $$invalidate(3, billingHistoryLink = $$props.billingHistoryLink);
			if ('nextPaymentDateText' in $$props) $$invalidate(4, nextPaymentDateText = $$props.nextPaymentDateText);
			if ('subscriptionRateText' in $$props) $$invalidate(5, subscriptionRateText = $$props.subscriptionRateText);
			if ('subscriptions' in $$props) $$invalidate(6, subscriptions = $$props.subscriptions);
			if ('inactiveSubscriptions' in $$props) $$invalidate(7, inactiveSubscriptions = $$props.inactiveSubscriptions);
			if ('paymentProvider' in $$props) $$invalidate(8, paymentProvider = $$props.paymentProvider);
			if ('changePaymentMethodText' in $$props) $$invalidate(9, changePaymentMethodText = $$props.changePaymentMethodText);
			if ('loading' in $$props) $$invalidate(10, loading = $$props.loading);
			if ('onChangePayment' in $$props) $$invalidate(11, onChangePayment = $$props.onChangePayment);
			if ('logChangeSubscription' in $$props) $$invalidate(12, logChangeSubscription = $$props.logChangeSubscription);
			if ('logCancelSubscription' in $$props) $$invalidate(13, logCancelSubscription = $$props.logCancelSubscription);
			if ('logSuspendResumeSubscription' in $$props) $$invalidate(14, logSuspendResumeSubscription = $$props.logSuspendResumeSubscription);
			if ('onViewHistory' in $$props) $$invalidate(15, onViewHistory = $$props.onViewHistory);
			if ('changeSubscriptionText' in $$props) $$invalidate(16, changeSubscriptionText = $$props.changeSubscriptionText);
			if ('cancelSubscriptionText' in $$props) $$invalidate(17, cancelSubscriptionText = $$props.cancelSubscriptionText);
			if ('changeSubscriptionPath' in $$props) $$invalidate(18, changeSubscriptionPath = $$props.changeSubscriptionPath);
			if ('cancelSubscriptionPath' in $$props) $$invalidate(19, cancelSubscriptionPath = $$props.cancelSubscriptionPath);
			if ('suspendResumeSubscriptionText' in $$props) $$invalidate(20, suspendResumeSubscriptionText = $$props.suspendResumeSubscriptionText);
			if ('suspendResumeSubscriptionPath' in $$props) $$invalidate(21, suspendResumeSubscriptionPath = $$props.suspendResumeSubscriptionPath);
			if ('subscriptionCustomFieldsText' in $$props) $$invalidate(22, subscriptionCustomFieldsText = $$props.subscriptionCustomFieldsText);
			if ('onUpdateSubscriptionCustomFields' in $$props) $$invalidate(23, onUpdateSubscriptionCustomFields = $$props.onUpdateSubscriptionCustomFields);
			if ('updateBillToContactText' in $$props) $$invalidate(24, updateBillToContactText = $$props.updateBillToContactText);
			if ('updateBillToContactPath' in $$props) $$invalidate(25, updateBillToContactPath = $$props.updateBillToContactPath);
			if ('elementsOrder' in $$props) $$invalidate(26, elementsOrder = $$props.elementsOrder);
			if ('elementsHide' in $$props) $$invalidate(27, elementsHide = $$props.elementsHide);
			if ('giftPillText' in $$props) $$invalidate(28, giftPillText = $$props.giftPillText);
			if ('autoRenewToggleEnabled' in $$props) $$invalidate(29, autoRenewToggleEnabled = $$props.autoRenewToggleEnabled);
			if ('autoRenewToggleText' in $$props) $$invalidate(30, autoRenewToggleText = $$props.autoRenewToggleText);
			if ('onAutoRenewToggle' in $$props) $$invalidate(31, onAutoRenewToggle = $$props.onAutoRenewToggle);
			if ('displayedCustomFields' in $$props) $$invalidate(32, displayedCustomFields = $$props.displayedCustomFields);
		};

		return [
			isPastSubscriptions,
			noSubscriptionsMessage,
			billingHistoryText,
			billingHistoryLink,
			nextPaymentDateText,
			subscriptionRateText,
			subscriptions,
			inactiveSubscriptions,
			paymentProvider,
			changePaymentMethodText,
			loading,
			onChangePayment,
			logChangeSubscription,
			logCancelSubscription,
			logSuspendResumeSubscription,
			onViewHistory,
			changeSubscriptionText,
			cancelSubscriptionText,
			changeSubscriptionPath,
			cancelSubscriptionPath,
			suspendResumeSubscriptionText,
			suspendResumeSubscriptionPath,
			subscriptionCustomFieldsText,
			onUpdateSubscriptionCustomFields,
			updateBillToContactText,
			updateBillToContactPath,
			elementsOrder,
			elementsHide,
			giftPillText,
			autoRenewToggleEnabled,
			autoRenewToggleText,
			onAutoRenewToggle,
			displayedCustomFields,
			func
		];
	}

	class SubscriptionsList extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$u,
				create_fragment$u,
				safe_not_equal,
				{
					isPastSubscriptions: 0,
					noSubscriptionsMessage: 1,
					billingHistoryText: 2,
					billingHistoryLink: 3,
					nextPaymentDateText: 4,
					subscriptionRateText: 5,
					subscriptions: 6,
					inactiveSubscriptions: 7,
					paymentProvider: 8,
					changePaymentMethodText: 9,
					loading: 10,
					onChangePayment: 11,
					logChangeSubscription: 12,
					logCancelSubscription: 13,
					logSuspendResumeSubscription: 14,
					onViewHistory: 15,
					changeSubscriptionText: 16,
					cancelSubscriptionText: 17,
					changeSubscriptionPath: 18,
					cancelSubscriptionPath: 19,
					suspendResumeSubscriptionText: 20,
					suspendResumeSubscriptionPath: 21,
					subscriptionCustomFieldsText: 22,
					onUpdateSubscriptionCustomFields: 23,
					updateBillToContactText: 24,
					updateBillToContactPath: 25,
					elementsOrder: 26,
					elementsHide: 27,
					giftPillText: 28,
					autoRenewToggleEnabled: 29,
					autoRenewToggleText: 30,
					onAutoRenewToggle: 31,
					displayedCustomFields: 32
				},
				null,
				[-1, -1]
			);
		}
	}

	const updateZuoraSubscriptionAutoRenew = async (subscription, autoRenew, formActions) => {
	    try {
	        const order = {
	            subscription: {
	                orderActions: [{
	                        type: "TermsAndConditions",
	                        termsAndConditions: {
	                            autoRenew
	                        }
	                    }]
	            }
	        };
	        const requestBody = {
	            vendor_fields: {
	                order: JSON.stringify(order)
	            }
	        };
	        const response = await request(`zephr/subscriptions/${subscription.externalId}/manage`, {
	            method: 'POST',
	            bodyObject: requestBody
	        }, formActions);
	        if (!response?.ok) {
	            const errorText = await response?.text() || 'Unknown error occurred';
	            console.error('Error updating subscription auto-renewal:', response);
	            return {
	                success: false,
	                error: `HTTP ${response?.status}: ${errorText}`
	            };
	        }
	        const result = await response.json();
	        if (result.error) {
	            console.error('API error updating subscription auto-renewal:', result.error);
	            return {
	                success: false,
	                error: result.error
	            };
	        }
	        return {
	            success: true,
	            message: 'Settings updated'
	        };
	    }
	    catch (error) {
	        console.error('Exception updating subscription auto-renewal:', error);
	        return {
	            success: false,
	            error: error instanceof Error ? error.message : 'An unexpected error occurred'
	        };
	    }
	};

	const subscriptionsListFactory = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.SUBSCRIPTIONS_LIST,
	    create: (form, formState, formActions, elementConfig) => {
	        // Get existing regular subscriptions and gift subscriptions
	        const existingSubscriptions = formState.existingSubscriptions || [];
	        const giftSubscriptions = formState.giftSubscriptions || [];
	        // Default gift pill settings if not provided in config
	        const giftPillText = elementConfig.giftPillText || 'Gift';
	        // Convert received gift subscriptions to ExistingSubscription format for display
	        // Only include gift subscriptions where the current user is the recipient (is_recipient === true)
	        const receivedGiftSubscriptions = giftSubscriptions
	            .filter(gift => gift.is_recipient === true)
	            .map(gift => {
	            return {
	                externalId: gift.subscription_number || gift.gift_code || '',
	                productId: gift.subscription_type || 'gift',
	                productLabel: gift.subscription_type || 'Subscription',
	                planId: gift.subscription_number || gift.gift_code || '',
	                planLabel: `Valid until ${gift.subscription_end_date || 'N/A'}`,
	                status: gift.status === 'REDEEMED' ? 'active' : 'pending',
	                ...gift,
	                // Add a flag to identify this as a gift subscription
	                isGift: true
	            };
	        });
	        // Combine regular subscriptions with received gift subscriptions
	        const allActiveSubscriptions = [
	            ...existingSubscriptions.filter(s => s.status === 'active'),
	            ...receivedGiftSubscriptions.filter(s => s.status === 'active')
	        ];
	        const allInactiveSubscriptions = [
	            ...existingSubscriptions.filter(s => s.status !== 'active'),
	            ...receivedGiftSubscriptions.filter(s => s.status !== 'active')
	        ];
	        // Auto-renew toggle handler for Zuora billing subscriptions
	        const onAutoRenewToggle = async (subscription, autoRenew) => {
	            try {
	                let result;
	                // Mock API call in preview mode
	                if (form.environment?.previewMode) {
	                    // Simulate API delay
	                    await new Promise(resolve => setTimeout(resolve, 1000));
	                    // Mock successful response (you could add logic to simulate failures occasionally)
	                    result = {
	                        success: true,
	                        message: 'Preferences updated'
	                    };
	                }
	                else {
	                    result = await updateZuoraSubscriptionAutoRenew(subscription, autoRenew, formActions);
	                }
	                if (result.success) {
	                    // Update the subscription in the local state
	                    const updatedSubscriptions = existingSubscriptions.map(sub => sub.externalId === subscription.externalId
	                        ? { ...sub, autoRenew }
	                        : sub);
	                    formActions.updateFormState({
	                        existingSubscriptions: updatedSubscriptions
	                    });
	                    // Log the change
	                    logDataLayerEvent(form, 'zephr_form_button_press', {
	                        sectionId: formState.currentSection.type,
	                        buttonType: 'AUTO_RENEW_TOGGLE'
	                    });
	                    return { success: true, message: result.message };
	                }
	                else {
	                    return { success: false, error: result.error };
	                }
	            }
	            catch (error) {
	                console.error('Error updating auto-renewal:', error);
	                return {
	                    success: false,
	                    error: error instanceof Error ? error.message : 'An unexpected error occurred'
	                };
	            }
	        };
	        return {
	            component: SubscriptionsList,
	            props: {
	                isPastSubscriptions: elementConfig.isPastSubscriptions,
	                subscriptionTitle: elementConfig.subscriptionTitle,
	                billingHistoryText: elementConfig.billingHistoryText,
	                billingHistoryLink: elementConfig.billingHistoryLink,
	                noSubscriptionsMessage: elementConfig.noSubscriptionsMessage,
	                nextPaymentDateText: elementConfig.nextPaymentDateText,
	                subscriptionRateText: elementConfig.subscriptionRateText,
	                loading: (!formState.existingSubscriptions || formState.loadingSubscriptions) ||
	                    (!formState.giftSubscriptions && formState.loadingGiftSubscriptions),
	                subscriptions: allActiveSubscriptions,
	                inactiveSubscriptions: allInactiveSubscriptions,
	                paymentProvider: form.organisationConfiguration.paymentProvider,
	                changePaymentMethodText: elementConfig.changePaymentMethodText,
	                onChangePayment: (subscription) => {
	                    formActions.updateFormState({
	                        selectedSubscription: subscription
	                    });
	                    logDataLayerEvent(form, 'zephr_form_button_press', {
	                        sectionId: formState.currentSection.type,
	                        buttonType: 'SUBMIT'
	                    });
	                    formActions.completeSection();
	                },
	                onViewHistory: (subscription) => {
	                    formActions.updateFormState({
	                        selectedSubscription: subscription
	                    });
	                    formActions.jumpToPartStart('billing-history');
	                    logDataLayerEvent(form, 'zephr_form_billing_history_view', null);
	                },
	                logChangeSubscription: (subscription) => {
	                    logDataLayerEvent(form, 'zephr_form_subscription_change_clicked', {
	                        productId: subscription.productId,
	                        planId: subscription.externalId
	                    });
	                },
	                logCancelSubscription: (subscription) => {
	                    logDataLayerEvent(form, 'zephr_form_cancel_subscription_clicked', {
	                        productId: subscription.productId,
	                        planId: subscription.externalId
	                    });
	                },
	                logSuspendResumeSubscription: (subscription) => {
	                    logDataLayerEvent(form, 'zephr_form_suspend_resume_subscription_clicked', {
	                        productId: subscription.productId,
	                        planId: subscription.externalId,
	                        status: subscription.status
	                    });
	                },
	                changeSubscriptionText: elementConfig.changeSubscriptionText,
	                cancelSubscriptionText: elementConfig.cancelSubscriptionText,
	                changeSubscriptionPath: elementConfig.changeSubscriptionPath,
	                cancelSubscriptionPath: elementConfig.cancelSubscriptionPath,
	                suspendResumeSubscriptionText: elementConfig.suspendResumeSubscriptionText,
	                suspendResumeSubscriptionPath: elementConfig.suspendResumeSubscriptionPath,
	                updateBillToContactText: elementConfig.updateBillToContactText,
	                updateBillToContactPath: elementConfig.updateBillToContactPath,
	                elementsOrder: elementConfig.elementsOrder,
	                subscriptionCustomFieldsText: elementConfig.subscriptionCustomFieldsText || 'Update subscription details',
	                onUpdateSubscriptionCustomFields: (subscription) => {
	                    formActions.updateFormState({
	                        selectedSubscription: subscription
	                    });
	                    formActions.jumpToPartStart('subscription-custom-fields');
	                    logDataLayerEvent(form, 'zephr_form_subscription_custom_fields_clicked', {
	                        productId: subscription.productId,
	                        planId: subscription.externalId
	                    });
	                },
	                elementsHide: {
	                    subscriptionInformation: elementConfig?.hideSubscriptionInformation,
	                    changePayment: elementConfig?.hideChangePayment,
	                    changeSubscription: elementConfig?.hideChangeSubscription,
	                    cancelSubscription: elementConfig?.hideCancelSubscription,
	                    billingHistory: elementConfig?.hideBillingHistory,
	                    suspendResumeSubscription: elementConfig?.hideSuspendResumeSubscription,
	                    subscriptionCustomFields: elementConfig?.hideSubscriptionCustomFields,
	                    updateBillToContact: elementConfig?.hideUpdateBillToContact
	                },
	                giftPillText,
	                autoRenewToggleEnabled: elementConfig.autoRenewToggleEnabled || false,
	                autoRenewToggleText: elementConfig.autoRenewToggleText || 'Auto-renew subscription',
	                onAutoRenewToggle: onAutoRenewToggle,
	                displayedCustomFields: elementConfig.displayedCustomFields || {}
	            }
	        };
	    }
	};

	/* src/components/elements/pastSubscriptionsLink/PastSubscriptionsLink.svelte generated by Svelte v4.2.12 */

	function create_if_block$m(ctx) {
		let div;
		let link;
		let current;
		link = new Link({ props: { text: /*linkText*/ ctx[2] } });

		link.$on("linkClick", function () {
			if (is_function(/*onClick*/ ctx[3])) /*onClick*/ ctx[3].apply(this, arguments);
		});

		return {
			c() {
				div = element("div");
				create_component(link.$$.fragment);
				attr(div, "class", "past-subscriptions-link-wrapper svelte-zpa2t");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(link, div, null);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				const link_changes = {};
				if (dirty & /*linkText*/ 4) link_changes.text = /*linkText*/ ctx[2];
				link.$set(link_changes);
			},
			i(local) {
				if (current) return;
				transition_in(link.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(link.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(link);
			}
		};
	}

	function create_fragment$t(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*show*/ ctx[1] && !/*loading*/ ctx[0] && create_if_block$m(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (/*show*/ ctx[1] && !/*loading*/ ctx[0]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*show, loading*/ 3) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$m(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	function instance$t($$self, $$props, $$invalidate) {
		let { loading } = $$props;
		let { show } = $$props;
		let { linkText } = $$props;
		let { onClick } = $$props;

		$$self.$$set = $$props => {
			if ('loading' in $$props) $$invalidate(0, loading = $$props.loading);
			if ('show' in $$props) $$invalidate(1, show = $$props.show);
			if ('linkText' in $$props) $$invalidate(2, linkText = $$props.linkText);
			if ('onClick' in $$props) $$invalidate(3, onClick = $$props.onClick);
		};

		return [loading, show, linkText, onClick];
	}

	class PastSubscriptionsLink extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$t, create_fragment$t, safe_not_equal, {
				loading: 0,
				show: 1,
				linkText: 2,
				onClick: 3
			});
		}
	}

	const pastSubscriptionsLinkFactory = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.PAST_SUBSCRIPTIONS_LINK,
	    create: (form, formState, formActions, elementConfig) => ({
	        component: PastSubscriptionsLink,
	        props: {
	            loading: !formState.existingSubscriptions || formState.loadingSubscriptions,
	            show: elementConfig.show,
	            linkText: elementConfig.linkText,
	            onClick: () => {
	                formActions.jumpToPartStart('past-subscriptions');
	            }
	        }
	    })
	};

	/* src/components/elements/changePaymentMethodButton/ChangePaymentMethodButton.svelte generated by Svelte v4.2.12 */

	function create_fragment$s(ctx) {
		let div;
		let button;
		let current;

		button = new Button({
				props: {
					disabled: false,
					text: /*text*/ ctx[0],
					onClick: /*func*/ ctx[2]
				}
			});

		return {
			c() {
				div = element("div");
				create_component(button.$$.fragment);
				attr(div, "class", "change-payment-method-button-container");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(button, div, null);
				current = true;
			},
			p(ctx, [dirty]) {
				const button_changes = {};
				if (dirty & /*text*/ 1) button_changes.text = /*text*/ ctx[0];
				if (dirty & /*onChangePayment*/ 2) button_changes.onClick = /*func*/ ctx[2];
				button.$set(button_changes);
			},
			i(local) {
				if (current) return;
				transition_in(button.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(button.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(button);
			}
		};
	}

	function instance$s($$self, $$props, $$invalidate) {
		let { text } = $$props;
		let { onChangePayment } = $$props;
		const func = () => onChangePayment();

		$$self.$$set = $$props => {
			if ('text' in $$props) $$invalidate(0, text = $$props.text);
			if ('onChangePayment' in $$props) $$invalidate(1, onChangePayment = $$props.onChangePayment);
		};

		return [text, onChangePayment, func];
	}

	class ChangePaymentMethodButton extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$s, create_fragment$s, safe_not_equal, { text: 0, onChangePayment: 1 });
		}
	}

	const changePaymentMethodButtonFactory = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.CHNAGE_PAYMENT_METHOD_BUTTON,
	    create: (form, formState, formActions, elementConfig) => ({
	        component: ChangePaymentMethodButton,
	        props: {
	            text: elementConfig.text,
	            onChangePayment: () => {
	                logDataLayerEvent(form, 'zephr_form_button_press', {
	                    sectionId: formState.currentSection.type,
	                    buttonType: 'SUBMIT'
	                });
	                formActions.completeSection();
	            }
	        }
	    })
	};

	/* src/components/elements/eventLink/EventLink.svelte generated by Svelte v4.2.12 */

	function create_fragment$r(ctx) {
		let div;
		let link;
		let div_class_value;
		let current;

		link = new Link({
				props: {
					text: /*text*/ ctx[0],
					onClick: /*onClick*/ ctx[2]
				}
			});

		link.$on("linkClick", function () {
			if (is_function(/*onClick*/ ctx[2])) /*onClick*/ ctx[2].apply(this, arguments);
		});

		return {
			c() {
				div = element("div");
				create_component(link.$$.fragment);
				attr(div, "class", div_class_value = "" + (null_to_empty(`event-link-wrapper ${/*floatRight*/ ctx[1] ? "float-right" : ""}`) + " svelte-3cxpfz"));
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(link, div, null);
				current = true;
			},
			p(new_ctx, [dirty]) {
				ctx = new_ctx;
				const link_changes = {};
				if (dirty & /*text*/ 1) link_changes.text = /*text*/ ctx[0];
				if (dirty & /*onClick*/ 4) link_changes.onClick = /*onClick*/ ctx[2];
				link.$set(link_changes);

				if (!current || dirty & /*floatRight*/ 2 && div_class_value !== (div_class_value = "" + (null_to_empty(`event-link-wrapper ${/*floatRight*/ ctx[1] ? "float-right" : ""}`) + " svelte-3cxpfz"))) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(link.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(link.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(link);
			}
		};
	}

	function instance$r($$self, $$props, $$invalidate) {
		let { text } = $$props;
		let { floatRight } = $$props;
		let { onClick } = $$props;

		$$self.$$set = $$props => {
			if ('text' in $$props) $$invalidate(0, text = $$props.text);
			if ('floatRight' in $$props) $$invalidate(1, floatRight = $$props.floatRight);
			if ('onClick' in $$props) $$invalidate(2, onClick = $$props.onClick);
		};

		return [text, floatRight, onClick];
	}

	class EventLink extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$r, create_fragment$r, safe_not_equal, { text: 0, floatRight: 1, onClick: 2 });
		}
	}

	const eventLinkFactory = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.EVENT_LINK,
	    create: (form, formState, formActions, elementConfig) => ({
	        component: EventLink,
	        props: {
	            text: elementConfig.text,
	            floatRight: elementConfig.floatRight,
	            onClick: () => {
	                formActions.onEvent(elementConfig.event);
	            }
	        }
	    })
	};

	/* src/components/elements/email/ReadOnlyEmailAddress.svelte generated by Svelte v4.2.12 */

	function create_if_block$l(ctx) {
		let link;
		let current;
		link = new Link({ props: { text: /*updateLabel*/ ctx[2] } });

		link.$on("linkClick", function () {
			if (is_function(/*onUpdate*/ ctx[4])) /*onUpdate*/ ctx[4].apply(this, arguments);
		});

		return {
			c() {
				create_component(link.$$.fragment);
			},
			m(target, anchor) {
				mount_component(link, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				const link_changes = {};
				if (dirty & /*updateLabel*/ 4) link_changes.text = /*updateLabel*/ ctx[2];
				link.$set(link_changes);
			},
			i(local) {
				if (current) return;
				transition_in(link.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(link.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(link, detaching);
			}
		};
	}

	function create_fragment$q(ctx) {
		let div0;
		let label_1;
		let t0;
		let div1;
		let input;
		let t1;
		let current;

		label_1 = new Label({
				props: {
					forInput: /*id*/ ctx[5],
					label: /*label*/ ctx[0]
				}
			});

		let if_block = /*updateEnabled*/ ctx[3] && create_if_block$l(ctx);

		return {
			c() {
				div0 = element("div");
				create_component(label_1.$$.fragment);
				t0 = space();
				div1 = element("div");
				input = element("input");
				t1 = space();
				if (if_block) if_block.c();
				attr(div0, "class", "bold-label svelte-nx4w5y");
				attr(input, "id", /*id*/ ctx[5]);
				attr(input, "type", "email");
				attr(input, "name", "email");
				input.value = /*emailAddress*/ ctx[1];
				input.readOnly = true;
				attr(input, "class", "read-only-input svelte-nx4w5y");
				attr(div1, "class", "zephr-form-relative-container svelte-nx4w5y");
			},
			m(target, anchor) {
				insert(target, div0, anchor);
				mount_component(label_1, div0, null);
				insert(target, t0, anchor);
				insert(target, div1, anchor);
				append(div1, input);
				append(div1, t1);
				if (if_block) if_block.m(div1, null);
				current = true;
			},
			p(ctx, [dirty]) {
				const label_1_changes = {};
				if (dirty & /*label*/ 1) label_1_changes.label = /*label*/ ctx[0];
				label_1.$set(label_1_changes);

				if (!current || dirty & /*emailAddress*/ 2 && input.value !== /*emailAddress*/ ctx[1]) {
					input.value = /*emailAddress*/ ctx[1];
				}

				if (/*updateEnabled*/ ctx[3]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*updateEnabled*/ 8) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$l(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(div1, null);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(label_1.$$.fragment, local);
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(label_1.$$.fragment, local);
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div0);
					detach(t0);
					detach(div1);
				}

				destroy_component(label_1);
				if (if_block) if_block.d();
			}
		};
	}

	function instance$q($$self, $$props, $$invalidate) {
		let { formKey } = $$props;
		let { label } = $$props;
		let { emailAddress } = $$props;
		let { updateLabel } = $$props;
		let { updateEnabled } = $$props;
		let { onUpdate } = $$props;
		const id = `zephr-form-read-only-email-address-${formKey}`;

		$$self.$$set = $$props => {
			if ('formKey' in $$props) $$invalidate(6, formKey = $$props.formKey);
			if ('label' in $$props) $$invalidate(0, label = $$props.label);
			if ('emailAddress' in $$props) $$invalidate(1, emailAddress = $$props.emailAddress);
			if ('updateLabel' in $$props) $$invalidate(2, updateLabel = $$props.updateLabel);
			if ('updateEnabled' in $$props) $$invalidate(3, updateEnabled = $$props.updateEnabled);
			if ('onUpdate' in $$props) $$invalidate(4, onUpdate = $$props.onUpdate);
		};

		return [label, emailAddress, updateLabel, updateEnabled, onUpdate, id, formKey];
	}

	class ReadOnlyEmailAddress extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$q, create_fragment$q, safe_not_equal, {
				formKey: 6,
				label: 0,
				emailAddress: 1,
				updateLabel: 2,
				updateEnabled: 3,
				onUpdate: 4
			});
		}
	}

	const factory$4 = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.READ_ONLY_EMAIL_ADDRESS,
	    create: (form, formState, formActions, elementConfig) => {
	        return {
	            component: ReadOnlyEmailAddress,
	            props: {
	                formKey: form.uniqueKey,
	                emailAddress: formState.readOnlyEmail ?? '',
	                label: elementConfig.label,
	                updateLabel: elementConfig.updateLinkLabel,
	                updateEnabled: elementConfig.updateLinkEnabled,
	                onUpdate: () => formActions.jumpToPartStart('email-update')
	            }
	        };
	    }
	};

	/* src/components/elements/password/ReadOnlyPassword.svelte generated by Svelte v4.2.12 */

	function create_if_block$k(ctx) {
		let link;
		let current;
		link = new Link({ props: { text: /*updateLabel*/ ctx[1] } });

		link.$on("linkClick", function () {
			if (is_function(/*onUpdate*/ ctx[3])) /*onUpdate*/ ctx[3].apply(this, arguments);
		});

		return {
			c() {
				create_component(link.$$.fragment);
			},
			m(target, anchor) {
				mount_component(link, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				const link_changes = {};
				if (dirty & /*updateLabel*/ 2) link_changes.text = /*updateLabel*/ ctx[1];
				link.$set(link_changes);
			},
			i(local) {
				if (current) return;
				transition_in(link.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(link.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(link, detaching);
			}
		};
	}

	function create_fragment$p(ctx) {
		let div0;
		let label_1;
		let t0;
		let div1;
		let input;
		let t1;
		let current;

		label_1 = new Label({
				props: {
					forInput: /*id*/ ctx[4],
					label: /*label*/ ctx[0]
				}
			});

		let if_block = /*updateEnabled*/ ctx[2] && create_if_block$k(ctx);

		return {
			c() {
				div0 = element("div");
				create_component(label_1.$$.fragment);
				t0 = space();
				div1 = element("div");
				input = element("input");
				t1 = space();
				if (if_block) if_block.c();
				attr(div0, "class", "bold-label svelte-nx4w5y");
				attr(input, "id", /*id*/ ctx[4]);
				attr(input, "type", "password");
				input.value = "••••••••••••••••";
				input.readOnly = true;
				attr(input, "class", "read-only-input svelte-nx4w5y");
				attr(div1, "class", "zephr-form-relative-container svelte-nx4w5y");
			},
			m(target, anchor) {
				insert(target, div0, anchor);
				mount_component(label_1, div0, null);
				insert(target, t0, anchor);
				insert(target, div1, anchor);
				append(div1, input);
				append(div1, t1);
				if (if_block) if_block.m(div1, null);
				current = true;
			},
			p(ctx, [dirty]) {
				const label_1_changes = {};
				if (dirty & /*label*/ 1) label_1_changes.label = /*label*/ ctx[0];
				label_1.$set(label_1_changes);

				if (/*updateEnabled*/ ctx[2]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*updateEnabled*/ 4) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$k(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(div1, null);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(label_1.$$.fragment, local);
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(label_1.$$.fragment, local);
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div0);
					detach(t0);
					detach(div1);
				}

				destroy_component(label_1);
				if (if_block) if_block.d();
			}
		};
	}

	function instance$p($$self, $$props, $$invalidate) {
		let { formKey } = $$props;
		let { label } = $$props;
		let { updateLabel } = $$props;
		let { updateEnabled } = $$props;
		let { onUpdate } = $$props;
		const id = `zephr-form-read-only-password-${formKey}`;

		$$self.$$set = $$props => {
			if ('formKey' in $$props) $$invalidate(5, formKey = $$props.formKey);
			if ('label' in $$props) $$invalidate(0, label = $$props.label);
			if ('updateLabel' in $$props) $$invalidate(1, updateLabel = $$props.updateLabel);
			if ('updateEnabled' in $$props) $$invalidate(2, updateEnabled = $$props.updateEnabled);
			if ('onUpdate' in $$props) $$invalidate(3, onUpdate = $$props.onUpdate);
		};

		return [label, updateLabel, updateEnabled, onUpdate, id, formKey];
	}

	class ReadOnlyPassword extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$p, create_fragment$p, safe_not_equal, {
				formKey: 5,
				label: 0,
				updateLabel: 1,
				updateEnabled: 2,
				onUpdate: 3
			});
		}
	}

	const factory$3 = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.READ_ONLY_PASSWORD,
	    create: (form, formState, formActions, elementConfig) => {
	        return {
	            component: ReadOnlyPassword,
	            props: {
	                formKey: form.uniqueKey,
	                label: elementConfig.label,
	                updateLabel: elementConfig.updateLinkLabel,
	                updateEnabled: elementConfig.updateLinkEnabled,
	                onUpdate: () => formActions.jumpToPartStart('password-update')
	            }
	        };
	    }
	};

	/* src/components/elements/userAttribute/ReadOnlyUserAttribute.svelte generated by Svelte v4.2.12 */

	function create_else_block$2(ctx) {
		let div2;
		let div0;
		let t0;
		let t1;
		let div1;
		let t2;

		return {
			c() {
				div2 = element("div");
				div0 = element("div");
				t0 = text(/*label*/ ctx[3]);
				t1 = space();
				div1 = element("div");
				t2 = text(/*value*/ ctx[2]);
				attr(div0, "class", "zephr-form-ro-attribute-label");
				attr(div1, "class", "zephr-form-ro-attribute-value");
				attr(div2, "class", "zephr-form-ro-attribute");
			},
			m(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div0);
				append(div0, t0);
				append(div2, t1);
				append(div2, div1);
				append(div1, t2);
			},
			p(ctx, dirty) {
				if (dirty & /*label*/ 8) set_data(t0, /*label*/ ctx[3]);
				if (dirty & /*value*/ 4) set_data(t2, /*value*/ ctx[2]);
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(div2);
				}
			}
		};
	}

	// (8:0) {#if isCheckbox}
	function create_if_block$j(ctx) {
		let div;
		let checkbox;
		let current;

		checkbox = new Checkbox({
				props: {
					id: `zephr-form-ro-checkbox-${/*slug*/ ctx[1]}`,
					name: /*slug*/ ctx[1],
					label: /*label*/ ctx[3],
					required: false,
					value: /*value*/ ctx[2],
					checked: /*value*/ ctx[2],
					disabled: true
				}
			});

		return {
			c() {
				div = element("div");
				create_component(checkbox.$$.fragment);
				attr(div, "class", "zephr-form-ro-attribute");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(checkbox, div, null);
				current = true;
			},
			p(ctx, dirty) {
				const checkbox_changes = {};
				if (dirty & /*slug*/ 2) checkbox_changes.id = `zephr-form-ro-checkbox-${/*slug*/ ctx[1]}`;
				if (dirty & /*slug*/ 2) checkbox_changes.name = /*slug*/ ctx[1];
				if (dirty & /*label*/ 8) checkbox_changes.label = /*label*/ ctx[3];
				if (dirty & /*value*/ 4) checkbox_changes.value = /*value*/ ctx[2];
				if (dirty & /*value*/ 4) checkbox_changes.checked = /*value*/ ctx[2];
				checkbox.$set(checkbox_changes);
			},
			i(local) {
				if (current) return;
				transition_in(checkbox.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(checkbox.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(checkbox);
			}
		};
	}

	function create_fragment$o(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$j, create_else_block$2];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*isCheckbox*/ ctx[0]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if_blocks[current_block_type_index].d(detaching);
			}
		};
	}

	function instance$o($$self, $$props, $$invalidate) {
		let { isCheckbox } = $$props;
		let { slug } = $$props;
		let { value } = $$props;
		let { label } = $$props;

		$$self.$$set = $$props => {
			if ('isCheckbox' in $$props) $$invalidate(0, isCheckbox = $$props.isCheckbox);
			if ('slug' in $$props) $$invalidate(1, slug = $$props.slug);
			if ('value' in $$props) $$invalidate(2, value = $$props.value);
			if ('label' in $$props) $$invalidate(3, label = $$props.label);
		};

		return [isCheckbox, slug, value, label];
	}

	class ReadOnlyUserAttribute extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$o, create_fragment$o, safe_not_equal, {
				isCheckbox: 0,
				slug: 1,
				value: 2,
				label: 3
			});
		}
	}

	const selectAttributeTypes = ['radio', 'select'];
	const readOnlyUserAttributeFactory = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.READ_ONLY_USER_ATTRIBUTE,
	    create: (form, formState, _, elementConfig) => {
	        const attributeSchema = form.organisationConfiguration.schemaFields.find(s => s.slug === elementConfig.slug);
	        let value = (formState.readOnlyAttributeValues ?? {})[elementConfig.slug] ?? '';
	        if (value && selectAttributeTypes.includes(attributeSchema?.["input-type"])) {
	            value = (attributeSchema?.["select-options"] ?? []).find(o => o.value === value)?.label ?? value;
	        }
	        const isCheckbox = attributeSchema?.["input-type"] === 'checkbox';
	        return {
	            component: ReadOnlyUserAttribute,
	            props: {
	                value,
	                slug: elementConfig.slug,
	                label: elementConfig.label,
	                isCheckbox,
	            }
	        };
	    }
	};

	/* src/components/elements/devices/DeviceSessionWrapper.svelte generated by Svelte v4.2.12 */

	function create_if_block_1$e(ctx) {
		let span;
		let t;

		return {
			c() {
				span = element("span");
				t = text(/*currentDeviceLabel*/ ctx[2]);
				attr(span, "class", "current-device svelte-jmotet");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty & /*currentDeviceLabel*/ 4) set_data(t, /*currentDeviceLabel*/ ctx[2]);
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (22:4) {#if !deviceSession.requestingSession}
	function create_if_block$i(ctx) {
		let button;
		let current;

		button = new Button({
				props: {
					disabled: false,
					text: /*signOutLabel*/ ctx[4],
					onClick: /*func*/ ctx[5]
				}
			});

		return {
			c() {
				create_component(button.$$.fragment);
			},
			m(target, anchor) {
				mount_component(button, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const button_changes = {};
				if (dirty & /*signOutLabel*/ 16) button_changes.text = /*signOutLabel*/ ctx[4];
				if (dirty & /*onDeviceSignOut, deviceSession*/ 3) button_changes.onClick = /*func*/ ctx[5];
				button.$set(button_changes);
			},
			i(local) {
				if (current) return;
				transition_in(button.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(button.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(button, detaching);
			}
		};
	}

	function create_fragment$n(ctx) {
		let div4;
		let div0;
		let t0_value = /*deviceSession*/ ctx[0].deviceName + "";
		let t0;
		let t1;
		let t2;
		let div1;
		let t3;
		let t4;
		let t5_value = /*deviceSession*/ ctx[0].startDate + "";
		let t5;
		let t6;
		let div2;
		let t7_value = /*deviceSession*/ ctx[0].browser + "";
		let t7;
		let t8;
		let div3;
		let t9_value = /*deviceSession*/ ctx[0].country + "";
		let t9;
		let t10;
		let t11;
		let hr;
		let current;
		let if_block0 = /*deviceSession*/ ctx[0].requestingSession && create_if_block_1$e(ctx);
		let if_block1 = !/*deviceSession*/ ctx[0].requestingSession && create_if_block$i(ctx);

		return {
			c() {
				div4 = element("div");
				div0 = element("div");
				t0 = text(t0_value);
				t1 = space();
				if (if_block0) if_block0.c();
				t2 = space();
				div1 = element("div");
				t3 = text(/*loginTimeLabel*/ ctx[3]);
				t4 = text(": ");
				t5 = text(t5_value);
				t6 = space();
				div2 = element("div");
				t7 = text(t7_value);
				t8 = space();
				div3 = element("div");
				t9 = text(t9_value);
				t10 = space();
				if (if_block1) if_block1.c();
				t11 = space();
				hr = element("hr");
				attr(div0, "class", "device-title svelte-jmotet");
				attr(div1, "class", "login-time svelte-jmotet");
				attr(div2, "class", "browser svelte-jmotet");
				attr(div3, "class", "country svelte-jmotet");
				attr(hr, "class", "svelte-jmotet");
				attr(div4, "class", "session-container svelte-jmotet");
			},
			m(target, anchor) {
				insert(target, div4, anchor);
				append(div4, div0);
				append(div0, t0);
				append(div0, t1);
				if (if_block0) if_block0.m(div0, null);
				append(div4, t2);
				append(div4, div1);
				append(div1, t3);
				append(div1, t4);
				append(div1, t5);
				append(div4, t6);
				append(div4, div2);
				append(div2, t7);
				append(div4, t8);
				append(div4, div3);
				append(div3, t9);
				append(div4, t10);
				if (if_block1) if_block1.m(div4, null);
				append(div4, t11);
				append(div4, hr);
				current = true;
			},
			p(ctx, [dirty]) {
				if ((!current || dirty & /*deviceSession*/ 1) && t0_value !== (t0_value = /*deviceSession*/ ctx[0].deviceName + "")) set_data(t0, t0_value);

				if (/*deviceSession*/ ctx[0].requestingSession) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_1$e(ctx);
						if_block0.c();
						if_block0.m(div0, null);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (!current || dirty & /*loginTimeLabel*/ 8) set_data(t3, /*loginTimeLabel*/ ctx[3]);
				if ((!current || dirty & /*deviceSession*/ 1) && t5_value !== (t5_value = /*deviceSession*/ ctx[0].startDate + "")) set_data(t5, t5_value);
				if ((!current || dirty & /*deviceSession*/ 1) && t7_value !== (t7_value = /*deviceSession*/ ctx[0].browser + "")) set_data(t7, t7_value);
				if ((!current || dirty & /*deviceSession*/ 1) && t9_value !== (t9_value = /*deviceSession*/ ctx[0].country + "")) set_data(t9, t9_value);

				if (!/*deviceSession*/ ctx[0].requestingSession) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*deviceSession*/ 1) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block$i(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div4, t11);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div4);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
			}
		};
	}

	function instance$n($$self, $$props, $$invalidate) {
		let { deviceSession } = $$props;
		let { onDeviceSignOut } = $$props;
		let { currentDeviceLabel } = $$props;
		let { loginTimeLabel } = $$props;
		let { signOutLabel } = $$props;
		const func = () => onDeviceSignOut(deviceSession.id);

		$$self.$$set = $$props => {
			if ('deviceSession' in $$props) $$invalidate(0, deviceSession = $$props.deviceSession);
			if ('onDeviceSignOut' in $$props) $$invalidate(1, onDeviceSignOut = $$props.onDeviceSignOut);
			if ('currentDeviceLabel' in $$props) $$invalidate(2, currentDeviceLabel = $$props.currentDeviceLabel);
			if ('loginTimeLabel' in $$props) $$invalidate(3, loginTimeLabel = $$props.loginTimeLabel);
			if ('signOutLabel' in $$props) $$invalidate(4, signOutLabel = $$props.signOutLabel);
		};

		return [
			deviceSession,
			onDeviceSignOut,
			currentDeviceLabel,
			loginTimeLabel,
			signOutLabel,
			func
		];
	}

	class DeviceSessionWrapper extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$n, create_fragment$n, safe_not_equal, {
				deviceSession: 0,
				onDeviceSignOut: 1,
				currentDeviceLabel: 2,
				loginTimeLabel: 3,
				signOutLabel: 4
			});
		}
	}

	/* src/components/elements/devices/DevicesSessionList.svelte generated by Svelte v4.2.12 */

	function get_each_context$7(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[7] = list[i];
		return child_ctx;
	}

	// (33:4) {#if devicesSessions == null}
	function create_if_block_1$d(ctx) {
		let fa;
		let current;

		fa = new Fa({
				props: { icon: faSpinner, spin: true, size: "lg" }
			});

		return {
			c() {
				create_component(fa.$$.fragment);
			},
			m(target, anchor) {
				mount_component(fa, target, anchor);
				current = true;
			},
			i(local) {
				if (current) return;
				transition_in(fa.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(fa.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(fa, detaching);
			}
		};
	}

	// (36:4) {#if devicesSessions != null && !devicesSessions.length}
	function create_if_block$h(ctx) {
		let div;

		return {
			c() {
				div = element("div");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				div.innerHTML = /*noDeviceSessionsMessage*/ ctx[1];
			},
			p(ctx, dirty) {
				if (dirty & /*noDeviceSessionsMessage*/ 2) div.innerHTML = /*noDeviceSessionsMessage*/ ctx[1];		},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (41:4) {#each devicesSessions ?? [] as deviceSession}
	function create_each_block$7(ctx) {
		let devicesessionwrapper;
		let current;

		devicesessionwrapper = new DeviceSessionWrapper({
				props: {
					deviceSession: /*deviceSession*/ ctx[7],
					currentDeviceLabel: /*currentDeviceLabel*/ ctx[3],
					loginTimeLabel: /*loginTimeLabel*/ ctx[4],
					signOutLabel: /*signOutLabel*/ ctx[5],
					onDeviceSignOut: /*onDeviceSignOut*/ ctx[6]
				}
			});

		return {
			c() {
				create_component(devicesessionwrapper.$$.fragment);
			},
			m(target, anchor) {
				mount_component(devicesessionwrapper, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const devicesessionwrapper_changes = {};
				if (dirty & /*devicesSessions*/ 1) devicesessionwrapper_changes.deviceSession = /*deviceSession*/ ctx[7];
				if (dirty & /*currentDeviceLabel*/ 8) devicesessionwrapper_changes.currentDeviceLabel = /*currentDeviceLabel*/ ctx[3];
				if (dirty & /*loginTimeLabel*/ 16) devicesessionwrapper_changes.loginTimeLabel = /*loginTimeLabel*/ ctx[4];
				if (dirty & /*signOutLabel*/ 32) devicesessionwrapper_changes.signOutLabel = /*signOutLabel*/ ctx[5];
				if (dirty & /*onDeviceSignOut*/ 64) devicesessionwrapper_changes.onDeviceSignOut = /*onDeviceSignOut*/ ctx[6];
				devicesessionwrapper.$set(devicesessionwrapper_changes);
			},
			i(local) {
				if (current) return;
				transition_in(devicesessionwrapper.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(devicesessionwrapper.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(devicesessionwrapper, detaching);
			}
		};
	}

	function create_fragment$m(ctx) {
		let div1;
		let div0;
		let h1;
		let t0;
		let t1;
		let t2;
		let t3;
		let current;
		let if_block0 = /*devicesSessions*/ ctx[0] == null && create_if_block_1$d();
		let if_block1 = /*devicesSessions*/ ctx[0] != null && !/*devicesSessions*/ ctx[0].length && create_if_block$h(ctx);
		let each_value = ensure_array_like(/*devicesSessions*/ ctx[0] ?? []);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				div1 = element("div");
				div0 = element("div");
				h1 = element("h1");
				t0 = text(/*yourDevicesLabel*/ ctx[2]);
				t1 = space();
				if (if_block0) if_block0.c();
				t2 = space();
				if (if_block1) if_block1.c();
				t3 = space();

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(h1, "class", "current-device");
				attr(div0, "class", "your-devices");
				attr(div1, "class", "devices-sessions-container");
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, div0);
				append(div0, h1);
				append(h1, t0);
				append(div1, t1);
				if (if_block0) if_block0.m(div1, null);
				append(div1, t2);
				if (if_block1) if_block1.m(div1, null);
				append(div1, t3);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div1, null);
					}
				}

				current = true;
			},
			p(ctx, [dirty]) {
				if (!current || dirty & /*yourDevicesLabel*/ 4) set_data(t0, /*yourDevicesLabel*/ ctx[2]);

				if (/*devicesSessions*/ ctx[0] == null) {
					if (if_block0) {
						if (dirty & /*devicesSessions*/ 1) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_1$d();
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div1, t2);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*devicesSessions*/ ctx[0] != null && !/*devicesSessions*/ ctx[0].length) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block$h(ctx);
						if_block1.c();
						if_block1.m(div1, t3);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (dirty & /*devicesSessions, currentDeviceLabel, loginTimeLabel, signOutLabel, onDeviceSignOut*/ 121) {
					each_value = ensure_array_like(/*devicesSessions*/ ctx[0] ?? []);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$7(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$7(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div1, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				transition_out(if_block0);
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				destroy_each(each_blocks, detaching);
			}
		};
	}

	function instance$m($$self, $$props, $$invalidate) {
		let { devicesSessions } = $$props;
		let { noDeviceSessionsMessage } = $$props;
		let { yourDevicesLabel } = $$props;
		let { currentDeviceLabel } = $$props;
		let { loginTimeLabel } = $$props;
		let { signOutLabel } = $$props;
		let { onDeviceSignOut } = $$props;

		$$self.$$set = $$props => {
			if ('devicesSessions' in $$props) $$invalidate(0, devicesSessions = $$props.devicesSessions);
			if ('noDeviceSessionsMessage' in $$props) $$invalidate(1, noDeviceSessionsMessage = $$props.noDeviceSessionsMessage);
			if ('yourDevicesLabel' in $$props) $$invalidate(2, yourDevicesLabel = $$props.yourDevicesLabel);
			if ('currentDeviceLabel' in $$props) $$invalidate(3, currentDeviceLabel = $$props.currentDeviceLabel);
			if ('loginTimeLabel' in $$props) $$invalidate(4, loginTimeLabel = $$props.loginTimeLabel);
			if ('signOutLabel' in $$props) $$invalidate(5, signOutLabel = $$props.signOutLabel);
			if ('onDeviceSignOut' in $$props) $$invalidate(6, onDeviceSignOut = $$props.onDeviceSignOut);
		};

		return [
			devicesSessions,
			noDeviceSessionsMessage,
			yourDevicesLabel,
			currentDeviceLabel,
			loginTimeLabel,
			signOutLabel,
			onDeviceSignOut
		];
	}

	class DevicesSessionList extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$m, create_fragment$m, safe_not_equal, {
				devicesSessions: 0,
				noDeviceSessionsMessage: 1,
				yourDevicesLabel: 2,
				currentDeviceLabel: 3,
				loginTimeLabel: 4,
				signOutLabel: 5,
				onDeviceSignOut: 6
			});
		}
	}

	const loadDeviceSessions = async (form, formState, formActions) => {
	    const availableDeviceSessions = await getAvailableDeviceSessions(form, formState, formActions);
	    formActions.updateFormState({
	        availableDeviceSessions
	    });
	    return availableDeviceSessions;
	};
	const getAvailableDeviceSessions = (form, _, formActions) => {
	    return request(`zephr/public/sessions/v1/sessions`, {
	        method: "GET"
	    }, formActions, null, true)
	        .then(response => response.ok ? response.json() : [])
	        .then(sessions => sessions
	        .map(session => ({
	        tenantId: session['tenantId'],
	        userId: session['userId'],
	        id: session['id'],
	        startDate: new Date(session['startDate']).toLocaleString(resolveLanguagePackLocale(form), {
	            year: 'numeric',
	            month: 'long',
	            day: 'numeric',
	            hour: '2-digit',
	            minute: '2-digit',
	            second: '2-digit',
	            hour12: true
	        }),
	        deviceName: session['deviceName'],
	        browser: session['browser'],
	        requestingSession: session['requestingSession'],
	        city: session['city'] ?? null,
	        country: session['country'] ?? null,
	        geoState: session['geoState'] ?? null,
	        ipAddress: session['ipAddress'] ?? null,
	    })));
	};

	const signOutSingleDevice = async (form, formState, formActions, deviceId) => {
	    const success = await signOutDevice(form, formState, formActions, deviceId);
	    if (success) {
	        console.log("Successfully signed out device.");
	        return loadDeviceSessions(form, formState, formActions);
	    }
	    else {
	        console.error("Failed to sign out device.");
	    }
	};
	const signOutDevice = async (form, formState, formActions, deviceId) => {
	    try {
	        const response = await request(`zephr/public/sessions/v1/sessions/${deviceId}`, {
	            method: "DELETE"
	        }, formActions, null, true);
	        return response.status === 200;
	    }
	    catch (error) {
	        console.error("Error occurred while signing out device:", error);
	        return false;
	    }
	};

	const deviceSessionsFactory = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.DEVICES_SESSIONS_LIST,
	    create: (form, formState, formActions, elementConfig) => ({
	        component: DevicesSessionList,
	        props: {
	            yourDevicesLabel: elementConfig.yourDevicesLabel,
	            noDeviceSessionsMessage: elementConfig.noDeviceSessionsMessage,
	            devicesSessions: formState.availableDeviceSessions,
	            currentDeviceLabel: elementConfig.currentDeviceLabel,
	            loginTimeLabel: elementConfig.loginTimeLabel,
	            signOutLabel: elementConfig.signOutLabel,
	            onDeviceSignOut: (value) => {
	                logDataLayerEvent(form, 'zephr_form_button_press', {
	                    sectionId: formState.currentSection.type,
	                    buttonType: 'SUBMIT'
	                });
	                logDataLayerEvent(form, 'zephr_form_device_logout', { deviceId: value });
	                void signOutSingleDevice(form, formState, formActions, value);
	            }
	        }
	    })
	};

	/* src/components/elements/devices/DeviceSessionsSignOutAllWrapper.svelte generated by Svelte v4.2.12 */

	function create_if_block$g(ctx) {
		let div;
		let t;
		let mounted;
		let dispose;

		return {
			c() {
				div = element("div");
				t = text(/*text*/ ctx[2]);
				attr(div, "class", "sign-out-all svelte-1ogdv39");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);

				if (!mounted) {
					dispose = listen(div, "click", function () {
						if (is_function(/*onSignOutAllDevices*/ ctx[0])) /*onSignOutAllDevices*/ ctx[0].apply(this, arguments);
					});

					mounted = true;
				}
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				if (dirty & /*text*/ 4) set_data(t, /*text*/ ctx[2]);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				mounted = false;
				dispose();
			}
		};
	}

	function create_fragment$l(ctx) {
		let if_block_anchor;
		let if_block = !/*hidden*/ ctx[1] && create_if_block$g(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, [dirty]) {
				if (!/*hidden*/ ctx[1]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$g(ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	function instance$l($$self, $$props, $$invalidate) {
		let { onSignOutAllDevices } = $$props;
		let { hidden } = $$props;
		let { text } = $$props;

		$$self.$$set = $$props => {
			if ('onSignOutAllDevices' in $$props) $$invalidate(0, onSignOutAllDevices = $$props.onSignOutAllDevices);
			if ('hidden' in $$props) $$invalidate(1, hidden = $$props.hidden);
			if ('text' in $$props) $$invalidate(2, text = $$props.text);
		};

		return [onSignOutAllDevices, hidden, text];
	}

	class DeviceSessionsSignOutAllWrapper extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$l, create_fragment$l, safe_not_equal, {
				onSignOutAllDevices: 0,
				hidden: 1,
				text: 2
			});
		}
	}

	const signOutOfAllDevices = async (form, formState, formActions) => {
	    const success = await signOutDevices(form, formState, formActions);
	    if (success) {
	        console.log("Successfully signed out of all devices.");
	        return loadDeviceSessions(form, formState, formActions);
	    }
	    else {
	        console.error("Failed to sign out of all devices.");
	    }
	};
	const signOutDevices = async (form, _, formActions) => {
	    try {
	        const response = await request(`zephr/public/sessions/v1/sessions?except-current`, {
	            method: "DELETE"
	        }, formActions, null, true);
	        return response.status === 200;
	    }
	    catch (error) {
	        console.error("Error occurred while signing out devices:", error);
	        return false;
	    }
	};

	const deviceSessionsSignOutAll = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.SIGN_OUT_ALL_OTHER_DEVICES,
	    create: (form, formState, formActions, elementConfig) => ({
	        component: DeviceSessionsSignOutAllWrapper,
	        props: {
	            hidden: formState.availableDeviceSessions?.length <= 1,
	            text: elementConfig.text,
	            onSignOutAllDevices: () => {
	                logDataLayerEvent(form, 'zephr_form_sign_out_all_devices', null);
	                void signOutOfAllDevices(form, formState, formActions);
	            }
	        }
	    })
	};

	/* src/components/elements/billingHistory/BillingHistory.svelte generated by Svelte v4.2.12 */

	function get_each_context$6(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[5] = list[i];
		return child_ctx;
	}

	// (30:10) {#if e.subtotal}
	function create_if_block_1$c(ctx) {
		let t0_value = /*e*/ ctx[5].currency + "";
		let t0;
		let t1;
		let t2_value = /*e*/ ctx[5].subtotal + "";
		let t2;
		let t3;
		let if_block_anchor;
		let if_block = /*e*/ ctx[5].taxes && create_if_block_2$8(ctx);

		return {
			c() {
				t0 = text(t0_value);
				t1 = space();
				t2 = text(t2_value);
				t3 = space();
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				insert(target, t0, anchor);
				insert(target, t1, anchor);
				insert(target, t2, anchor);
				insert(target, t3, anchor);
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*historyItems*/ 1 && t0_value !== (t0_value = /*e*/ ctx[5].currency + "")) set_data(t0, t0_value);
				if (dirty & /*historyItems*/ 1 && t2_value !== (t2_value = /*e*/ ctx[5].subtotal + "")) set_data(t2, t2_value);

				if (/*e*/ ctx[5].taxes) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block_2$8(ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
					detach(t2);
					detach(t3);
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (32:12) {#if e.taxes}
	function create_if_block_2$8(ctx) {
		let span;
		let t_value = ` ${/*e*/ ctx[5].taxes}` + "";
		let t;

		return {
			c() {
				span = element("span");
				t = text(t_value);
				attr(span, "class", "taxes svelte-7sscau");
			},
			m(target, anchor) {
				insert(target, span, anchor);
				append(span, t);
			},
			p(ctx, dirty) {
				if (dirty & /*historyItems*/ 1 && t_value !== (t_value = ` ${/*e*/ ctx[5].taxes}` + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (38:10) {#if e.total}
	function create_if_block$f(ctx) {
		let t0_value = /*e*/ ctx[5].currency + "";
		let t0;
		let t1;
		let t2_value = /*e*/ ctx[5].total + "";
		let t2;

		return {
			c() {
				t0 = text(t0_value);
				t1 = space();
				t2 = text(t2_value);
			},
			m(target, anchor) {
				insert(target, t0, anchor);
				insert(target, t1, anchor);
				insert(target, t2, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*historyItems*/ 1 && t0_value !== (t0_value = /*e*/ ctx[5].currency + "")) set_data(t0, t0_value);
				if (dirty & /*historyItems*/ 1 && t2_value !== (t2_value = /*e*/ ctx[5].total + "")) set_data(t2, t2_value);
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
					detach(t2);
				}
			}
		};
	}

	// (25:4) {#each historyItems ?? [] as e}
	function create_each_block$6(ctx) {
		let div4;
		let div0;
		let t0_value = /*e*/ ctx[5].date + "";
		let t0;
		let t1;
		let div1;
		let t2_value = /*e*/ ctx[5].period + "";
		let t2;
		let t3;
		let div2;
		let t4;
		let div3;
		let t5;
		let if_block0 = /*e*/ ctx[5].subtotal && create_if_block_1$c(ctx);
		let if_block1 = /*e*/ ctx[5].total && create_if_block$f(ctx);

		return {
			c() {
				div4 = element("div");
				div0 = element("div");
				t0 = text(t0_value);
				t1 = space();
				div1 = element("div");
				t2 = text(t2_value);
				t3 = space();
				div2 = element("div");
				if (if_block0) if_block0.c();
				t4 = space();
				div3 = element("div");
				if (if_block1) if_block1.c();
				t5 = space();
				attr(div0, "class", "svelte-7sscau");
				attr(div1, "class", "svelte-7sscau");
				attr(div2, "class", "svelte-7sscau");
				attr(div3, "class", "svelte-7sscau");
				attr(div4, "class", "table-row svelte-7sscau");
			},
			m(target, anchor) {
				insert(target, div4, anchor);
				append(div4, div0);
				append(div0, t0);
				append(div4, t1);
				append(div4, div1);
				append(div1, t2);
				append(div4, t3);
				append(div4, div2);
				if (if_block0) if_block0.m(div2, null);
				append(div4, t4);
				append(div4, div3);
				if (if_block1) if_block1.m(div3, null);
				append(div4, t5);
			},
			p(ctx, dirty) {
				if (dirty & /*historyItems*/ 1 && t0_value !== (t0_value = /*e*/ ctx[5].date + "")) set_data(t0, t0_value);
				if (dirty & /*historyItems*/ 1 && t2_value !== (t2_value = /*e*/ ctx[5].period + "")) set_data(t2, t2_value);

				if (/*e*/ ctx[5].subtotal) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_1$c(ctx);
						if_block0.c();
						if_block0.m(div2, null);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*e*/ ctx[5].total) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block$f(ctx);
						if_block1.c();
						if_block1.m(div3, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(div4);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
			}
		};
	}

	function create_fragment$k(ctx) {
		let div6;
		let div5;
		let div4;
		let div0;
		let t0;
		let t1;
		let div1;
		let t2;
		let t3;
		let div2;
		let t4;
		let t5;
		let div3;
		let t6;
		let t7;
		let each_value = ensure_array_like(/*historyItems*/ ctx[0] ?? []);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
		}

		return {
			c() {
				div6 = element("div");
				div5 = element("div");
				div4 = element("div");
				div0 = element("div");
				t0 = text(/*dateLabel*/ ctx[1]);
				t1 = space();
				div1 = element("div");
				t2 = text(/*periodLabel*/ ctx[2]);
				t3 = space();
				div2 = element("div");
				t4 = text(/*subtotalLabel*/ ctx[3]);
				t5 = space();
				div3 = element("div");
				t6 = text(/*totalLabel*/ ctx[4]);
				t7 = space();

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(div0, "class", "svelte-7sscau");
				attr(div1, "class", "svelte-7sscau");
				attr(div2, "class", "svelte-7sscau");
				attr(div3, "class", "svelte-7sscau");
				attr(div4, "class", "table-head svelte-7sscau");
				attr(div5, "class", "table svelte-7sscau");
				attr(div6, "class", "billing-history-container");
			},
			m(target, anchor) {
				insert(target, div6, anchor);
				append(div6, div5);
				append(div5, div4);
				append(div4, div0);
				append(div0, t0);
				append(div4, t1);
				append(div4, div1);
				append(div1, t2);
				append(div4, t3);
				append(div4, div2);
				append(div2, t4);
				append(div4, t5);
				append(div4, div3);
				append(div3, t6);
				append(div5, t7);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div5, null);
					}
				}
			},
			p(ctx, [dirty]) {
				if (dirty & /*dateLabel*/ 2) set_data(t0, /*dateLabel*/ ctx[1]);
				if (dirty & /*periodLabel*/ 4) set_data(t2, /*periodLabel*/ ctx[2]);
				if (dirty & /*subtotalLabel*/ 8) set_data(t4, /*subtotalLabel*/ ctx[3]);
				if (dirty & /*totalLabel*/ 16) set_data(t6, /*totalLabel*/ ctx[4]);

				if (dirty & /*historyItems*/ 1) {
					each_value = ensure_array_like(/*historyItems*/ ctx[0] ?? []);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$6(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$6(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(div5, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(div6);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	function instance$k($$self, $$props, $$invalidate) {
		let { historyItems } = $$props;
		let { dateLabel } = $$props;
		let { periodLabel } = $$props;
		let { subtotalLabel } = $$props;
		let { totalLabel } = $$props;

		$$self.$$set = $$props => {
			if ('historyItems' in $$props) $$invalidate(0, historyItems = $$props.historyItems);
			if ('dateLabel' in $$props) $$invalidate(1, dateLabel = $$props.dateLabel);
			if ('periodLabel' in $$props) $$invalidate(2, periodLabel = $$props.periodLabel);
			if ('subtotalLabel' in $$props) $$invalidate(3, subtotalLabel = $$props.subtotalLabel);
			if ('totalLabel' in $$props) $$invalidate(4, totalLabel = $$props.totalLabel);
		};

		return [historyItems, dateLabel, periodLabel, subtotalLabel, totalLabel];
	}

	class BillingHistory extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$k, create_fragment$k, safe_not_equal, {
				historyItems: 0,
				dateLabel: 1,
				periodLabel: 2,
				subtotalLabel: 3,
				totalLabel: 4
			});
		}
	}

	const billingHistoryFactory = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.BILLING_HISTORY,
	    create: (form, formState, __) => ({
	        component: BillingHistory,
	        props: {
	            historyItems: formState.selectedSubscription?.transactionHistory,
	            dateLabel: resolveLanguagePackKeyTyped(form, 'forms.billing.history.date', 'Date'),
	            periodLabel: resolveLanguagePackKeyTyped(form, 'forms.billing.history.period', 'Period'),
	            subtotalLabel: resolveLanguagePackKeyTyped(form, 'forms.billing.history.subtotal', 'Subtotal'),
	            totalLabel: resolveLanguagePackKeyTyped(form, 'forms.billing.history.total', 'Total'),
	        }
	    })
	};

	/* src/components/elements/buttonGroup/ButtonGroup.svelte generated by Svelte v4.2.12 */

	function create_if_block$e(ctx) {
		let button;
		let t;
		let mounted;
		let dispose;

		return {
			c() {
				button = element("button");
				t = text(/*backText*/ ctx[1]);
				attr(button, "class", "zephr-form-back-button svelte-5uv9ua");
				attr(button, "type", "submit");
			},
			m(target, anchor) {
				insert(target, button, anchor);
				append(button, t);

				if (!mounted) {
					dispose = listen(button, "click", prevent_default(function () {
						if (is_function(/*onBack*/ ctx[3])) /*onBack*/ ctx[3].apply(this, arguments);
					}));

					mounted = true;
				}
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				if (dirty & /*backText*/ 2) set_data(t, /*backText*/ ctx[1]);
			},
			d(detaching) {
				if (detaching) {
					detach(button);
				}

				mounted = false;
				dispose();
			}
		};
	}

	function create_fragment$j(ctx) {
		let div;
		let t0;
		let button;
		let t1;
		let mounted;
		let dispose;
		let if_block = /*backEnabled*/ ctx[2] && create_if_block$e(ctx);

		return {
			c() {
				div = element("div");
				if (if_block) if_block.c();
				t0 = space();
				button = element("button");
				t1 = text(/*continueText*/ ctx[0]);
				attr(button, "class", "zephr-form-continue-button svelte-5uv9ua");
				attr(button, "type", "submit");
				attr(div, "class", "zephr-form-button-group zephr-form-max-width svelte-5uv9ua");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if (if_block) if_block.m(div, null);
				append(div, t0);
				append(div, button);
				append(button, t1);

				if (!mounted) {
					dispose = listen(button, "click", prevent_default(function () {
						if (is_function(/*onClick*/ ctx[4])) /*onClick*/ ctx[4].apply(this, arguments);
					}));

					mounted = true;
				}
			},
			p(new_ctx, [dirty]) {
				ctx = new_ctx;

				if (/*backEnabled*/ ctx[2]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$e(ctx);
						if_block.c();
						if_block.m(div, t0);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (dirty & /*continueText*/ 1) set_data(t1, /*continueText*/ ctx[0]);
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (if_block) if_block.d();
				mounted = false;
				dispose();
			}
		};
	}

	function instance$j($$self, $$props, $$invalidate) {
		let { continueText } = $$props;
		let { backText } = $$props;
		let { backEnabled } = $$props;
		let { onBack } = $$props;
		let { onClick } = $$props;

		$$self.$$set = $$props => {
			if ('continueText' in $$props) $$invalidate(0, continueText = $$props.continueText);
			if ('backText' in $$props) $$invalidate(1, backText = $$props.backText);
			if ('backEnabled' in $$props) $$invalidate(2, backEnabled = $$props.backEnabled);
			if ('onBack' in $$props) $$invalidate(3, onBack = $$props.onBack);
			if ('onClick' in $$props) $$invalidate(4, onClick = $$props.onClick);
		};

		return [continueText, backText, backEnabled, onBack, onClick];
	}

	class ButtonGroup extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$j, create_fragment$j, safe_not_equal, {
				continueText: 0,
				backText: 1,
				backEnabled: 2,
				onBack: 3,
				onClick: 4
			});
		}
	}

	const factory$2 = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.BUTTON_GROUP,
	    create: (form, formState, formActions, elementConfig) => ({
	        component: ButtonGroup,
	        props: {
	            continueText: elementConfig.continueText,
	            backText: elementConfig.backText,
	            backEnabled: elementConfig.backEnabled,
	            onClick: () => {
	                if (elementConfig.isCancel) {
	                    formActions.updateFormState({
	                        confirmCancel: true,
	                    });
	                }
	                formActions.updateFormState({
	                    isExternalReferrer: false,
	                });
	                formActions.attemptCompleteSection();
	            },
	            onBack: () => {
	                if (elementConfig.backToURL) {
	                    window.location.pathname = elementConfig.backURL;
	                }
	                else if (formState.isExternalReferrer) {
	                    window.history.back();
	                }
	                else {
	                    formActions.onEvent(elementConfig.event);
	                }
	            }
	        }
	    })
	};

	/* src/components/elements/linkButton/LinkButton.svelte generated by Svelte v4.2.12 */

	function create_fragment$i(ctx) {
		let a;
		let t;

		return {
			c() {
				a = element("a");
				t = text(/*text*/ ctx[0]);
				attr(a, "class", "zephr-form-button zephr-form-button-top-margin svelte-1uaz0r");
				attr(a, "href", /*href*/ ctx[1]);
			},
			m(target, anchor) {
				insert(target, a, anchor);
				append(a, t);
			},
			p(ctx, [dirty]) {
				if (dirty & /*text*/ 1) set_data(t, /*text*/ ctx[0]);

				if (dirty & /*href*/ 2) {
					attr(a, "href", /*href*/ ctx[1]);
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(a);
				}
			}
		};
	}

	function instance$i($$self, $$props, $$invalidate) {
		let { text } = $$props;
		let { href } = $$props;

		$$self.$$set = $$props => {
			if ('text' in $$props) $$invalidate(0, text = $$props.text);
			if ('href' in $$props) $$invalidate(1, href = $$props.href);
		};

		return [text, href];
	}

	class LinkButton extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$i, create_fragment$i, safe_not_equal, { text: 0, href: 1 });
		}
	}

	const factory$1 = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.LINK_BUTTON,
	    create: (form, formState, formActions, elementConfig) => ({
	        component: LinkButton,
	        props: {
	            text: elementConfig.text,
	            href: elementConfig.href,
	        },
	    })
	};

	/* src/components/elements/recipientName/RecipientName.svelte generated by Svelte v4.2.12 */

	function create_if_block_1$b(ctx) {
		let div;
		let t;

		return {
			c() {
				div = element("div");
				t = text(/*firstNameError*/ ctx[3]);
				attr(div, "class", "error-text svelte-hvl7z2");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty & /*firstNameError*/ 8) set_data(t, /*firstNameError*/ ctx[3]);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (71:4) {#if lastNameError}
	function create_if_block$d(ctx) {
		let div;
		let t;

		return {
			c() {
				div = element("div");
				t = text(/*lastNameError*/ ctx[4]);
				attr(div, "class", "error-text svelte-hvl7z2");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty & /*lastNameError*/ 16) set_data(t, /*lastNameError*/ ctx[4]);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	function create_fragment$h(ctx) {
		let div2;
		let div0;
		let label0;
		let t0_value = /*config*/ ctx[0].firstNameLabel + "";
		let t0;
		let t1;
		let input0;
		let input0_placeholder_value;
		let t2;
		let t3;
		let div1;
		let label1;
		let t4_value = /*config*/ ctx[0].lastNameLabel + "";
		let t4;
		let t5;
		let input1;
		let input1_placeholder_value;
		let t6;
		let mounted;
		let dispose;
		let if_block0 = /*firstNameError*/ ctx[3] && create_if_block_1$b(ctx);
		let if_block1 = /*lastNameError*/ ctx[4] && create_if_block$d(ctx);

		return {
			c() {
				div2 = element("div");
				div0 = element("div");
				label0 = element("label");
				t0 = text(t0_value);
				t1 = space();
				input0 = element("input");
				t2 = space();
				if (if_block0) if_block0.c();
				t3 = space();
				div1 = element("div");
				label1 = element("label");
				t4 = text(t4_value);
				t5 = space();
				input1 = element("input");
				t6 = space();
				if (if_block1) if_block1.c();
				attr(label0, "for", "firstName");
				attr(label0, "class", "svelte-hvl7z2");
				attr(input0, "id", "firstName");
				attr(input0, "type", "text");
				input0.required = true;
				attr(input0, "placeholder", input0_placeholder_value = /*config*/ ctx[0].firstNamePlaceholder);
				attr(input0, "class", "svelte-hvl7z2");
				toggle_class(input0, "error", !!/*firstNameError*/ ctx[3]);
				attr(div0, "class", "field svelte-hvl7z2");
				attr(label1, "for", "lastName");
				attr(label1, "class", "svelte-hvl7z2");
				attr(input1, "id", "lastName");
				attr(input1, "type", "text");
				input1.required = true;
				attr(input1, "placeholder", input1_placeholder_value = /*config*/ ctx[0].lastNamePlaceholder);
				attr(input1, "class", "svelte-hvl7z2");
				toggle_class(input1, "error", !!/*lastNameError*/ ctx[4]);
				attr(div1, "class", "field svelte-hvl7z2");
				attr(div2, "class", "recipient-name-section svelte-hvl7z2");
			},
			m(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div0);
				append(div0, label0);
				append(label0, t0);
				append(div0, t1);
				append(div0, input0);
				set_input_value(input0, /*firstName*/ ctx[1]);
				append(div0, t2);
				if (if_block0) if_block0.m(div0, null);
				append(div2, t3);
				append(div2, div1);
				append(div1, label1);
				append(label1, t4);
				append(div1, t5);
				append(div1, input1);
				set_input_value(input1, /*lastName*/ ctx[2]);
				append(div1, t6);
				if (if_block1) if_block1.m(div1, null);

				if (!mounted) {
					dispose = [
						listen(input0, "input", /*input0_input_handler*/ ctx[8]),
						listen(input0, "input", /*updateGiftRecipient*/ ctx[5]),
						listen(input1, "input", /*input1_input_handler*/ ctx[9]),
						listen(input1, "input", /*updateGiftRecipient*/ ctx[5])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (dirty & /*config*/ 1 && t0_value !== (t0_value = /*config*/ ctx[0].firstNameLabel + "")) set_data(t0, t0_value);

				if (dirty & /*config*/ 1 && input0_placeholder_value !== (input0_placeholder_value = /*config*/ ctx[0].firstNamePlaceholder)) {
					attr(input0, "placeholder", input0_placeholder_value);
				}

				if (dirty & /*firstName*/ 2 && input0.value !== /*firstName*/ ctx[1]) {
					set_input_value(input0, /*firstName*/ ctx[1]);
				}

				if (dirty & /*firstNameError*/ 8) {
					toggle_class(input0, "error", !!/*firstNameError*/ ctx[3]);
				}

				if (/*firstNameError*/ ctx[3]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_1$b(ctx);
						if_block0.c();
						if_block0.m(div0, null);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (dirty & /*config*/ 1 && t4_value !== (t4_value = /*config*/ ctx[0].lastNameLabel + "")) set_data(t4, t4_value);

				if (dirty & /*config*/ 1 && input1_placeholder_value !== (input1_placeholder_value = /*config*/ ctx[0].lastNamePlaceholder)) {
					attr(input1, "placeholder", input1_placeholder_value);
				}

				if (dirty & /*lastName*/ 4 && input1.value !== /*lastName*/ ctx[2]) {
					set_input_value(input1, /*lastName*/ ctx[2]);
				}

				if (dirty & /*lastNameError*/ 16) {
					toggle_class(input1, "error", !!/*lastNameError*/ ctx[4]);
				}

				if (/*lastNameError*/ ctx[4]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block$d(ctx);
						if_block1.c();
						if_block1.m(div1, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(div2);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$h($$self, $$props, $$invalidate) {
		let { formState } = $$props;
		let { formActions } = $$props;
		let { config } = $$props;
		const dispatch = createEventDispatcher();
		let firstName = formState.giftRecipient?.firstName || '';
		let lastName = formState.giftRecipient?.lastName || '';
		let firstNameError = '';
		let lastNameError = '';

		// Update form state when input changes
		const updateGiftRecipient = () => {
			const updatedGiftRecipient = {
				...formState.giftRecipient || {},
				firstName,
				lastName
			};

			formActions.updateFormState({ giftRecipient: updatedGiftRecipient });
			validateForm();
		};

		const validateForm = () => {
			const hasValidFirstName = !!firstName.trim();
			const hasValidLastName = !!lastName.trim();

			if (!hasValidFirstName) {
				$$invalidate(3, firstNameError = 'First name is required');
			} else {
				$$invalidate(3, firstNameError = '');
			}

			if (!hasValidLastName) {
				$$invalidate(4, lastNameError = 'Last name is required');
			} else {
				$$invalidate(4, lastNameError = '');
			}

			// Dispatch event for form validity
			dispatch('validity', {
				isValid: hasValidFirstName && hasValidLastName
			});
		};

		function input0_input_handler() {
			firstName = this.value;
			$$invalidate(1, firstName);
		}

		function input1_input_handler() {
			lastName = this.value;
			$$invalidate(2, lastName);
		}

		$$self.$$set = $$props => {
			if ('formState' in $$props) $$invalidate(6, formState = $$props.formState);
			if ('formActions' in $$props) $$invalidate(7, formActions = $$props.formActions);
			if ('config' in $$props) $$invalidate(0, config = $$props.config);
		};

		return [
			config,
			firstName,
			lastName,
			firstNameError,
			lastNameError,
			updateGiftRecipient,
			formState,
			formActions,
			input0_input_handler,
			input1_input_handler
		];
	}

	class RecipientName extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$h, create_fragment$h, safe_not_equal, { formState: 6, formActions: 7, config: 0 });
		}
	}

	const recipientNameFactory = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.RECIPIENT_NAME,
	    create: (form, formState, formActions, elementConfig) => {
	        // Resolve all labels through language pack service
	        const resolvedConfig = {
	            firstNameLabel: resolveLanguagePackKeyTyped(form, 'forms.gift.recipient-first-name', elementConfig.firstNameLabel),
	            lastNameLabel: resolveLanguagePackKeyTyped(form, 'forms.gift.recipient-last-name', elementConfig.lastNameLabel),
	            firstNamePlaceholder: resolveLanguagePackKeyTyped(form, 'forms.gift.first-name-placeholder', elementConfig.firstNamePlaceholder),
	            lastNamePlaceholder: resolveLanguagePackKeyTyped(form, 'forms.gift.last-name-placeholder', elementConfig.lastNamePlaceholder),
	        };
	        // Determine if the input is valid
	        const giftRecipient = (formState.giftRecipient || {});
	        const hasValidFirstName = !!giftRecipient.firstName?.trim();
	        const hasValidLastName = !!giftRecipient.lastName?.trim();
	        const isValid = hasValidFirstName && hasValidLastName;
	        return {
	            component: RecipientName,
	            props: {
	                config: resolvedConfig,
	                form,
	                formState,
	                formActions,
	            },
	            isValid
	        };
	    }
	};

	/* src/components/elements/recipientEmail/RecipientEmail.svelte generated by Svelte v4.2.12 */

	function create_if_block$c(ctx) {
		let div;
		let t;

		return {
			c() {
				div = element("div");
				t = text(/*emailError*/ ctx[2]);
				attr(div, "class", "error-text svelte-1odylgp");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty & /*emailError*/ 4) set_data(t, /*emailError*/ ctx[2]);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	function create_fragment$g(ctx) {
		let div1;
		let div0;
		let label;
		let t0_value = /*config*/ ctx[0].emailLabel + "";
		let t0;
		let t1;
		let input;
		let input_placeholder_value;
		let t2;
		let mounted;
		let dispose;
		let if_block = /*emailError*/ ctx[2] && create_if_block$c(ctx);

		return {
			c() {
				div1 = element("div");
				div0 = element("div");
				label = element("label");
				t0 = text(t0_value);
				t1 = space();
				input = element("input");
				t2 = space();
				if (if_block) if_block.c();
				attr(label, "for", "recipientEmail");
				attr(label, "class", "svelte-1odylgp");
				attr(input, "id", "recipientEmail");
				attr(input, "type", "email");
				input.required = true;
				attr(input, "placeholder", input_placeholder_value = /*config*/ ctx[0].emailPlaceholder);
				attr(input, "class", "svelte-1odylgp");
				toggle_class(input, "error", !!/*emailError*/ ctx[2]);
				attr(div0, "class", "field svelte-1odylgp");
				attr(div1, "class", "recipient-email-section svelte-1odylgp");
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, div0);
				append(div0, label);
				append(label, t0);
				append(div0, t1);
				append(div0, input);
				set_input_value(input, /*recipientEmail*/ ctx[1]);
				append(div0, t2);
				if (if_block) if_block.m(div0, null);

				if (!mounted) {
					dispose = [
						listen(input, "input", /*input_input_handler*/ ctx[7]),
						listen(input, "input", /*updateGiftRecipient*/ ctx[3])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (dirty & /*config*/ 1 && t0_value !== (t0_value = /*config*/ ctx[0].emailLabel + "")) set_data(t0, t0_value);

				if (dirty & /*config*/ 1 && input_placeholder_value !== (input_placeholder_value = /*config*/ ctx[0].emailPlaceholder)) {
					attr(input, "placeholder", input_placeholder_value);
				}

				if (dirty & /*recipientEmail*/ 2 && input.value !== /*recipientEmail*/ ctx[1]) {
					set_input_value(input, /*recipientEmail*/ ctx[1]);
				}

				if (dirty & /*emailError*/ 4) {
					toggle_class(input, "error", !!/*emailError*/ ctx[2]);
				}

				if (/*emailError*/ ctx[2]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$c(ctx);
						if_block.c();
						if_block.m(div0, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(div1);
				}

				if (if_block) if_block.d();
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$g($$self, $$props, $$invalidate) {
		let { formState } = $$props;
		let { formActions } = $$props;
		let { config } = $$props;
		let { form } = $$props;
		const dispatch = createEventDispatcher();
		let recipientEmail = formState.giftRecipient?.email || '';
		let emailError = '';

		// Update form state when input changes
		const updateGiftRecipient = () => {
			const updatedGiftRecipient = {
				...formState.giftRecipient || {},
				email: recipientEmail
			};

			formActions.updateFormState({ giftRecipient: updatedGiftRecipient });
			validateForm();
		};

		const validateForm = () => {
			const hasValidEmail = isValidEmail(recipientEmail);

			if (recipientEmail && !hasValidEmail) {
				$$invalidate(2, emailError = resolveLanguagePackKeyTyped(form, 'forms.errors.email-invalid', 'Please enter a valid email address'));
			} else if (!recipientEmail) {
				$$invalidate(2, emailError = 'Recipient email is required');
			} else {
				$$invalidate(2, emailError = '');
			}

			// Dispatch event for form validity
			dispatch('validity', { isValid: hasValidEmail });
		};

		function input_input_handler() {
			recipientEmail = this.value;
			$$invalidate(1, recipientEmail);
		}

		$$self.$$set = $$props => {
			if ('formState' in $$props) $$invalidate(4, formState = $$props.formState);
			if ('formActions' in $$props) $$invalidate(5, formActions = $$props.formActions);
			if ('config' in $$props) $$invalidate(0, config = $$props.config);
			if ('form' in $$props) $$invalidate(6, form = $$props.form);
		};

		return [
			config,
			recipientEmail,
			emailError,
			updateGiftRecipient,
			formState,
			formActions,
			form,
			input_input_handler
		];
	}

	class RecipientEmail extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$g, create_fragment$g, safe_not_equal, {
				formState: 4,
				formActions: 5,
				config: 0,
				form: 6
			});
		}
	}

	const recipientEmailFactory = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.RECIPIENT_EMAIL,
	    create: (form, formState, formActions, elementConfig) => {
	        // Resolve all labels through language pack service
	        const resolvedConfig = {
	            emailLabel: resolveLanguagePackKeyTyped(form, 'forms.gift.recipient-email', elementConfig.emailLabel),
	            emailPlaceholder: resolveLanguagePackKeyTyped(form, 'forms.gift.email-placeholder', elementConfig.emailPlaceholder),
	        };
	        // Determine if the input is valid
	        const giftRecipient = (formState.giftRecipient || {});
	        const hasValidEmail = isValidEmail(giftRecipient.email);
	        const isValid = hasValidEmail;
	        return {
	            component: RecipientEmail,
	            props: {
	                config: resolvedConfig,
	                form,
	                formState,
	                formActions,
	            },
	            isValid
	        };
	    }
	};

	/* src/components/elements/recipientAddress/RecipientAddress.svelte generated by Svelte v4.2.12 */

	function create_if_block$b(ctx) {
		let div7;
		let label0;
		let t0_value = /*config*/ ctx[0].label + "";
		let t0;
		let t1;
		let div6;
		let div0;
		let label1;
		let t2_value = /*config*/ ctx[0].addressLine1Label + "";
		let t2;
		let t3;
		let input0;
		let input0_placeholder_value;
		let t4;
		let div1;
		let label2;
		let t5_value = /*config*/ ctx[0].addressLine2Label + "";
		let t5;
		let t6;
		let input1;
		let input1_placeholder_value;
		let t7;
		let div2;
		let label3;
		let t8_value = /*config*/ ctx[0].cityLabel + "";
		let t8;
		let t9;
		let input2;
		let input2_placeholder_value;
		let t10;
		let div3;
		let label4;
		let t11_value = /*config*/ ctx[0].stateLabel + "";
		let t11;
		let t12;
		let input3;
		let input3_placeholder_value;
		let t13;
		let div4;
		let label5;
		let t14_value = /*config*/ ctx[0].countryLabel + "";
		let t14;
		let t15;
		let input4;
		let input4_placeholder_value;
		let t16;
		let div5;
		let label6;
		let t17_value = /*config*/ ctx[0].postalCodeLabel + "";
		let t17;
		let t18;
		let input5;
		let input5_placeholder_value;
		let t19;
		let mounted;
		let dispose;
		let if_block = /*addressError*/ ctx[1] && create_if_block_1$a(ctx);

		return {
			c() {
				div7 = element("div");
				label0 = element("label");
				t0 = text(t0_value);
				t1 = space();
				div6 = element("div");
				div0 = element("div");
				label1 = element("label");
				t2 = text(t2_value);
				t3 = space();
				input0 = element("input");
				t4 = space();
				div1 = element("div");
				label2 = element("label");
				t5 = text(t5_value);
				t6 = space();
				input1 = element("input");
				t7 = space();
				div2 = element("div");
				label3 = element("label");
				t8 = text(t8_value);
				t9 = space();
				input2 = element("input");
				t10 = space();
				div3 = element("div");
				label4 = element("label");
				t11 = text(t11_value);
				t12 = space();
				input3 = element("input");
				t13 = space();
				div4 = element("div");
				label5 = element("label");
				t14 = text(t14_value);
				t15 = space();
				input4 = element("input");
				t16 = space();
				div5 = element("div");
				label6 = element("label");
				t17 = text(t17_value);
				t18 = space();
				input5 = element("input");
				t19 = space();
				if (if_block) if_block.c();
				attr(label0, "class", "address-main-label svelte-iu0vdb");
				attr(label1, "for", "addressLine1");
				attr(label1, "class", "svelte-iu0vdb");
				attr(input0, "id", "addressLine1");
				attr(input0, "type", "text");
				input0.required = /*requires_address*/ ctx[3];
				attr(input0, "placeholder", input0_placeholder_value = /*config*/ ctx[0].addressLine1Placeholder);
				attr(input0, "class", "svelte-iu0vdb");
				attr(div0, "class", "field full-width svelte-iu0vdb");
				attr(label2, "for", "addressLine2");
				attr(label2, "class", "svelte-iu0vdb");
				attr(input1, "id", "addressLine2");
				attr(input1, "type", "text");
				attr(input1, "placeholder", input1_placeholder_value = /*config*/ ctx[0].addressLine2Placeholder);
				attr(input1, "class", "svelte-iu0vdb");
				attr(div1, "class", "field full-width svelte-iu0vdb");
				attr(label3, "for", "city");
				attr(label3, "class", "svelte-iu0vdb");
				attr(input2, "id", "city");
				attr(input2, "type", "text");
				input2.required = /*requires_address*/ ctx[3];
				attr(input2, "placeholder", input2_placeholder_value = /*config*/ ctx[0].cityPlaceholder);
				attr(input2, "class", "svelte-iu0vdb");
				attr(div2, "class", "field svelte-iu0vdb");
				attr(label4, "for", "state");
				attr(label4, "class", "svelte-iu0vdb");
				attr(input3, "id", "state");
				attr(input3, "type", "text");
				attr(input3, "placeholder", input3_placeholder_value = /*config*/ ctx[0].statePlaceholder);
				attr(input3, "class", "svelte-iu0vdb");
				attr(div3, "class", "field svelte-iu0vdb");
				attr(label5, "for", "country");
				attr(label5, "class", "svelte-iu0vdb");
				attr(input4, "id", "country");
				attr(input4, "type", "text");
				input4.required = /*requires_address*/ ctx[3];
				attr(input4, "placeholder", input4_placeholder_value = /*config*/ ctx[0].countryPlaceholder);
				attr(input4, "class", "svelte-iu0vdb");
				attr(div4, "class", "field svelte-iu0vdb");
				attr(label6, "for", "postalCode");
				attr(label6, "class", "svelte-iu0vdb");
				attr(input5, "id", "postalCode");
				attr(input5, "type", "text");
				input5.required = /*requires_address*/ ctx[3];
				attr(input5, "placeholder", input5_placeholder_value = /*config*/ ctx[0].postalCodePlaceholder);
				attr(input5, "class", "svelte-iu0vdb");
				attr(div5, "class", "field svelte-iu0vdb");
				attr(div6, "class", "address-fields svelte-iu0vdb");
				attr(div7, "class", "recipient-address-section svelte-iu0vdb");
			},
			m(target, anchor) {
				insert(target, div7, anchor);
				append(div7, label0);
				append(label0, t0);
				append(div7, t1);
				append(div7, div6);
				append(div6, div0);
				append(div0, label1);
				append(label1, t2);
				append(div0, t3);
				append(div0, input0);
				set_input_value(input0, /*recipientAddress*/ ctx[2].addressLine1);
				append(div6, t4);
				append(div6, div1);
				append(div1, label2);
				append(label2, t5);
				append(div1, t6);
				append(div1, input1);
				set_input_value(input1, /*recipientAddress*/ ctx[2].addressLine2);
				append(div6, t7);
				append(div6, div2);
				append(div2, label3);
				append(label3, t8);
				append(div2, t9);
				append(div2, input2);
				set_input_value(input2, /*recipientAddress*/ ctx[2].city);
				append(div6, t10);
				append(div6, div3);
				append(div3, label4);
				append(label4, t11);
				append(div3, t12);
				append(div3, input3);
				set_input_value(input3, /*recipientAddress*/ ctx[2].state);
				append(div6, t13);
				append(div6, div4);
				append(div4, label5);
				append(label5, t14);
				append(div4, t15);
				append(div4, input4);
				set_input_value(input4, /*recipientAddress*/ ctx[2].country);
				append(div6, t16);
				append(div6, div5);
				append(div5, label6);
				append(label6, t17);
				append(div5, t18);
				append(div5, input5);
				set_input_value(input5, /*recipientAddress*/ ctx[2].postalCode);
				append(div7, t19);
				if (if_block) if_block.m(div7, null);

				if (!mounted) {
					dispose = [
						listen(input0, "input", /*input0_input_handler*/ ctx[8]),
						listen(input0, "input", /*updateGiftRecipient*/ ctx[4]),
						listen(input1, "input", /*input1_input_handler*/ ctx[9]),
						listen(input1, "input", /*updateGiftRecipient*/ ctx[4]),
						listen(input2, "input", /*input2_input_handler*/ ctx[10]),
						listen(input2, "input", /*updateGiftRecipient*/ ctx[4]),
						listen(input3, "input", /*input3_input_handler*/ ctx[11]),
						listen(input3, "input", /*updateGiftRecipient*/ ctx[4]),
						listen(input4, "input", /*input4_input_handler*/ ctx[12]),
						listen(input4, "input", /*updateGiftRecipient*/ ctx[4]),
						listen(input5, "input", /*input5_input_handler*/ ctx[13]),
						listen(input5, "input", /*updateGiftRecipient*/ ctx[4])
					];

					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*config*/ 1 && t0_value !== (t0_value = /*config*/ ctx[0].label + "")) set_data(t0, t0_value);
				if (dirty & /*config*/ 1 && t2_value !== (t2_value = /*config*/ ctx[0].addressLine1Label + "")) set_data(t2, t2_value);

				if (dirty & /*requires_address*/ 8) {
					input0.required = /*requires_address*/ ctx[3];
				}

				if (dirty & /*config*/ 1 && input0_placeholder_value !== (input0_placeholder_value = /*config*/ ctx[0].addressLine1Placeholder)) {
					attr(input0, "placeholder", input0_placeholder_value);
				}

				if (dirty & /*recipientAddress*/ 4 && input0.value !== /*recipientAddress*/ ctx[2].addressLine1) {
					set_input_value(input0, /*recipientAddress*/ ctx[2].addressLine1);
				}

				if (dirty & /*config*/ 1 && t5_value !== (t5_value = /*config*/ ctx[0].addressLine2Label + "")) set_data(t5, t5_value);

				if (dirty & /*config*/ 1 && input1_placeholder_value !== (input1_placeholder_value = /*config*/ ctx[0].addressLine2Placeholder)) {
					attr(input1, "placeholder", input1_placeholder_value);
				}

				if (dirty & /*recipientAddress*/ 4 && input1.value !== /*recipientAddress*/ ctx[2].addressLine2) {
					set_input_value(input1, /*recipientAddress*/ ctx[2].addressLine2);
				}

				if (dirty & /*config*/ 1 && t8_value !== (t8_value = /*config*/ ctx[0].cityLabel + "")) set_data(t8, t8_value);

				if (dirty & /*requires_address*/ 8) {
					input2.required = /*requires_address*/ ctx[3];
				}

				if (dirty & /*config*/ 1 && input2_placeholder_value !== (input2_placeholder_value = /*config*/ ctx[0].cityPlaceholder)) {
					attr(input2, "placeholder", input2_placeholder_value);
				}

				if (dirty & /*recipientAddress*/ 4 && input2.value !== /*recipientAddress*/ ctx[2].city) {
					set_input_value(input2, /*recipientAddress*/ ctx[2].city);
				}

				if (dirty & /*config*/ 1 && t11_value !== (t11_value = /*config*/ ctx[0].stateLabel + "")) set_data(t11, t11_value);

				if (dirty & /*config*/ 1 && input3_placeholder_value !== (input3_placeholder_value = /*config*/ ctx[0].statePlaceholder)) {
					attr(input3, "placeholder", input3_placeholder_value);
				}

				if (dirty & /*recipientAddress*/ 4 && input3.value !== /*recipientAddress*/ ctx[2].state) {
					set_input_value(input3, /*recipientAddress*/ ctx[2].state);
				}

				if (dirty & /*config*/ 1 && t14_value !== (t14_value = /*config*/ ctx[0].countryLabel + "")) set_data(t14, t14_value);

				if (dirty & /*requires_address*/ 8) {
					input4.required = /*requires_address*/ ctx[3];
				}

				if (dirty & /*config*/ 1 && input4_placeholder_value !== (input4_placeholder_value = /*config*/ ctx[0].countryPlaceholder)) {
					attr(input4, "placeholder", input4_placeholder_value);
				}

				if (dirty & /*recipientAddress*/ 4 && input4.value !== /*recipientAddress*/ ctx[2].country) {
					set_input_value(input4, /*recipientAddress*/ ctx[2].country);
				}

				if (dirty & /*config*/ 1 && t17_value !== (t17_value = /*config*/ ctx[0].postalCodeLabel + "")) set_data(t17, t17_value);

				if (dirty & /*requires_address*/ 8) {
					input5.required = /*requires_address*/ ctx[3];
				}

				if (dirty & /*config*/ 1 && input5_placeholder_value !== (input5_placeholder_value = /*config*/ ctx[0].postalCodePlaceholder)) {
					attr(input5, "placeholder", input5_placeholder_value);
				}

				if (dirty & /*recipientAddress*/ 4 && input5.value !== /*recipientAddress*/ ctx[2].postalCode) {
					set_input_value(input5, /*recipientAddress*/ ctx[2].postalCode);
				}

				if (/*addressError*/ ctx[1]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block_1$a(ctx);
						if_block.c();
						if_block.m(div7, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(div7);
				}

				if (if_block) if_block.d();
				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (131:4) {#if addressError}
	function create_if_block_1$a(ctx) {
		let div;
		let t;

		return {
			c() {
				div = element("div");
				t = text(/*addressError*/ ctx[1]);
				attr(div, "class", "error-text svelte-iu0vdb");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty & /*addressError*/ 2) set_data(t, /*addressError*/ ctx[1]);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	function create_fragment$f(ctx) {
		let if_block_anchor;
		let if_block = /*requires_address*/ ctx[3] && create_if_block$b(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},
			p(ctx, [dirty]) {
				if (/*requires_address*/ ctx[3]) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$b(ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	function instance$f($$self, $$props, $$invalidate) {
		let { formState } = $$props;
		let { formActions } = $$props;
		let { config } = $$props;
		let { form } = $$props;
		const dispatch = createEventDispatcher();
		let addressError = '';

		// Initialize recipient address fields
		let recipientAddress = {
			addressLine1: formState.giftRecipient?.recipientAddress?.addressLine1 || '',
			addressLine2: formState.giftRecipient?.recipientAddress?.addressLine2 || '',
			city: formState.giftRecipient?.recipientAddress?.city || '',
			state: formState.giftRecipient?.recipientAddress?.state || '',
			country: formState.giftRecipient?.recipientAddress?.country || '',
			postalCode: formState.giftRecipient?.recipientAddress?.postalCode || ''
		};

		// Get requires_address from form configuration
		let requires_address = false;

		if (form?.typeConfiguration?.requires_address) {
			requires_address = true;
		}

		// Update form state when inputs change
		const updateGiftRecipient = () => {
			const updatedGiftRecipient = {
				...formState.giftRecipient || {},
				recipientAddress
			};

			formActions.updateFormState({ giftRecipient: updatedGiftRecipient });
			validateForm();
		};

		const validateForm = () => {
			// If address isn't required, it's automatically valid
			if (!requires_address) {
				dispatch('validity', { isValid: true });
				$$invalidate(1, addressError = '');
				return;
			}

			const hasValidAddress = !!recipientAddress.addressLine1.trim() && !!recipientAddress.city.trim() && !!recipientAddress.country.trim() && !!recipientAddress.postalCode.trim();

			if (!hasValidAddress) {
				$$invalidate(1, addressError = config.addressRequiredError);
			} else {
				$$invalidate(1, addressError = '');
			}

			// Dispatch event for form validity
			dispatch('validity', { isValid: hasValidAddress });
		};

		function input0_input_handler() {
			recipientAddress.addressLine1 = this.value;
			$$invalidate(2, recipientAddress);
		}

		function input1_input_handler() {
			recipientAddress.addressLine2 = this.value;
			$$invalidate(2, recipientAddress);
		}

		function input2_input_handler() {
			recipientAddress.city = this.value;
			$$invalidate(2, recipientAddress);
		}

		function input3_input_handler() {
			recipientAddress.state = this.value;
			$$invalidate(2, recipientAddress);
		}

		function input4_input_handler() {
			recipientAddress.country = this.value;
			$$invalidate(2, recipientAddress);
		}

		function input5_input_handler() {
			recipientAddress.postalCode = this.value;
			$$invalidate(2, recipientAddress);
		}

		$$self.$$set = $$props => {
			if ('formState' in $$props) $$invalidate(5, formState = $$props.formState);
			if ('formActions' in $$props) $$invalidate(6, formActions = $$props.formActions);
			if ('config' in $$props) $$invalidate(0, config = $$props.config);
			if ('form' in $$props) $$invalidate(7, form = $$props.form);
		};

		return [
			config,
			addressError,
			recipientAddress,
			requires_address,
			updateGiftRecipient,
			formState,
			formActions,
			form,
			input0_input_handler,
			input1_input_handler,
			input2_input_handler,
			input3_input_handler,
			input4_input_handler,
			input5_input_handler
		];
	}

	class RecipientAddress extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$f, create_fragment$f, safe_not_equal, {
				formState: 5,
				formActions: 6,
				config: 0,
				form: 7
			});
		}
	}

	const recipientAddressFactory = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.RECIPIENT_ADDRESS,
	    create: (form, formState, formActions, elementConfig) => {
	        // Determine if address is required from form configuration
	        const typeConfiguration = formConfigAs(form);
	        const requires_address = typeConfiguration.requires_address;
	        // If requires_address is false, don't render the component at all
	        if (requires_address === false) {
	            return {
	                component: null,
	                props: {},
	                isValid: true
	            };
	        }
	        // Resolve all labels through language pack service
	        const resolvedConfig = {
	            label: resolveLanguagePackKeyTyped(form, 'forms.gift.recipient-address', elementConfig.label),
	            addressLine1Label: resolveLanguagePackKeyTyped(form, 'forms.gift.address-line1', elementConfig.addressLine1Label),
	            addressLine2Label: resolveLanguagePackKeyTyped(form, 'forms.gift.address-line2', elementConfig.addressLine2Label),
	            cityLabel: resolveLanguagePackKeyTyped(form, 'forms.gift.city', elementConfig.cityLabel),
	            stateLabel: resolveLanguagePackKeyTyped(form, 'forms.gift.state', elementConfig.stateLabel),
	            countryLabel: resolveLanguagePackKeyTyped(form, 'forms.gift.country', elementConfig.countryLabel),
	            postalCodeLabel: resolveLanguagePackKeyTyped(form, 'forms.gift.postal-code', elementConfig.postalCodeLabel),
	            addressRequiredError: resolveLanguagePackKeyTyped(form, 'forms.gift.address-required', elementConfig.addressRequiredError),
	            addressLine1Placeholder: resolveLanguagePackKeyTyped(form, 'forms.gift.address-line1-placeholder', elementConfig.addressLine1Placeholder),
	            addressLine2Placeholder: resolveLanguagePackKeyTyped(form, 'forms.gift.address-line2-placeholder', elementConfig.addressLine2Placeholder),
	            cityPlaceholder: resolveLanguagePackKeyTyped(form, 'forms.gift.city-placeholder', elementConfig.cityPlaceholder),
	            statePlaceholder: resolveLanguagePackKeyTyped(form, 'forms.gift.state-placeholder', elementConfig.statePlaceholder),
	            countryPlaceholder: resolveLanguagePackKeyTyped(form, 'forms.gift.country-placeholder', elementConfig.countryPlaceholder),
	            postalCodePlaceholder: resolveLanguagePackKeyTyped(form, 'forms.gift.postal-code-placeholder', elementConfig.postalCodePlaceholder),
	        };
	        // Determine if the input is valid
	        const giftRecipient = (formState.giftRecipient || {});
	        const recipientAddress = giftRecipient.recipientAddress || {};
	        const hasValidAddress = !requires_address || (!!recipientAddress.addressLine1.trim() &&
	            !!recipientAddress.city.trim() &&
	            !!recipientAddress.country.trim() &&
	            !!recipientAddress.postalCode.trim());
	        const isValid = hasValidAddress;
	        return {
	            component: RecipientAddress,
	            props: {
	                config: resolvedConfig,
	                form,
	                formState,
	                formActions,
	            },
	            isValid
	        };
	    }
	};

	/* src/components/elements/recipientMessage/RecipientMessage.svelte generated by Svelte v4.2.12 */

	function create_fragment$e(ctx) {
		let div1;
		let div0;
		let label;
		let t0_value = /*config*/ ctx[0].messageLabel + "";
		let t0;
		let t1;
		let textarea;
		let textarea_placeholder_value;
		let mounted;
		let dispose;

		return {
			c() {
				div1 = element("div");
				div0 = element("div");
				label = element("label");
				t0 = text(t0_value);
				t1 = space();
				textarea = element("textarea");
				attr(label, "for", "customMessage");
				attr(label, "class", "svelte-h6tpk7");
				attr(textarea, "id", "customMessage");
				attr(textarea, "placeholder", textarea_placeholder_value = /*config*/ ctx[0].messagePlaceholder);
				attr(textarea, "class", "svelte-h6tpk7");
				attr(div0, "class", "field svelte-h6tpk7");
				attr(div1, "class", "recipient-message-section svelte-h6tpk7");
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, div0);
				append(div0, label);
				append(label, t0);
				append(div0, t1);
				append(div0, textarea);
				set_input_value(textarea, /*customMessage*/ ctx[1]);

				if (!mounted) {
					dispose = [
						listen(textarea, "input", /*textarea_input_handler*/ ctx[5]),
						listen(textarea, "input", /*updateGiftRecipient*/ ctx[2])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (dirty & /*config*/ 1 && t0_value !== (t0_value = /*config*/ ctx[0].messageLabel + "")) set_data(t0, t0_value);

				if (dirty & /*config*/ 1 && textarea_placeholder_value !== (textarea_placeholder_value = /*config*/ ctx[0].messagePlaceholder)) {
					attr(textarea, "placeholder", textarea_placeholder_value);
				}

				if (dirty & /*customMessage*/ 2) {
					set_input_value(textarea, /*customMessage*/ ctx[1]);
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(div1);
				}

				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$e($$self, $$props, $$invalidate) {
		let { formState } = $$props;
		let { formActions } = $$props;
		let { config } = $$props;
		const dispatch = createEventDispatcher();
		let customMessage = formState.giftRecipient?.customMessage || '';

		// Update form state when input changes
		const updateGiftRecipient = () => {
			const updatedGiftRecipient = {
				...formState.giftRecipient || {},
				customMessage
			};

			formActions.updateFormState({ giftRecipient: updatedGiftRecipient });
		};

		// Initial validation
		onMount(() => {
			// Message is always valid as it's optional
			dispatch('validity', { isValid: true });
		});

		function textarea_input_handler() {
			customMessage = this.value;
			$$invalidate(1, customMessage);
		}

		$$self.$$set = $$props => {
			if ('formState' in $$props) $$invalidate(3, formState = $$props.formState);
			if ('formActions' in $$props) $$invalidate(4, formActions = $$props.formActions);
			if ('config' in $$props) $$invalidate(0, config = $$props.config);
		};

		return [
			config,
			customMessage,
			updateGiftRecipient,
			formState,
			formActions,
			textarea_input_handler
		];
	}

	class RecipientMessage extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$e, create_fragment$e, safe_not_equal, { formState: 3, formActions: 4, config: 0 });
		}
	}

	const recipientMessageFactory = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.RECIPIENT_MESSAGE,
	    create: (form, formState, formActions, elementConfig) => {
	        // Resolve all labels through language pack service
	        const resolvedConfig = {
	            messageLabel: resolveLanguagePackKeyTyped(form, 'forms.gift.custom-message', elementConfig.messageLabel),
	            messagePlaceholder: resolveLanguagePackKeyTyped(form, 'forms.gift.message-placeholder', elementConfig.messagePlaceholder),
	        };
	        // Message is always valid as it's optional
	        const isValid = true;
	        return {
	            component: RecipientMessage,
	            props: {
	                config: resolvedConfig,
	                form,
	                formState,
	                formActions,
	            },
	            isValid
	        };
	    }
	};

	/* src/components/elements/giftCode/GiftCode.svelte generated by Svelte v4.2.12 */

	function create_if_block_1$9(ctx) {
		let label_1;
		let t0;
		let t1;
		let if_block = /*required*/ ctx[3] && create_if_block_2$7();

		return {
			c() {
				label_1 = element("label");
				t0 = text(/*label*/ ctx[1]);
				t1 = space();
				if (if_block) if_block.c();
				attr(label_1, "for", "zephr-form-gift-code");
				attr(label_1, "class", "svelte-764k6k");
			},
			m(target, anchor) {
				insert(target, label_1, anchor);
				append(label_1, t0);
				append(label_1, t1);
				if (if_block) if_block.m(label_1, null);
			},
			p(ctx, dirty) {
				if (dirty & /*label*/ 2) set_data(t0, /*label*/ ctx[1]);

				if (/*required*/ ctx[3]) {
					if (if_block) ; else {
						if_block = create_if_block_2$7();
						if_block.c();
						if_block.m(label_1, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(label_1);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (22:6) {#if required}
	function create_if_block_2$7(ctx) {
		let span;

		return {
			c() {
				span = element("span");
				span.textContent = "*";
				attr(span, "class", "required svelte-764k6k");
			},
			m(target, anchor) {
				insert(target, span, anchor);
			},
			d(detaching) {
				if (detaching) {
					detach(span);
				}
			}
		};
	}

	// (40:2) {#if errorMessage}
	function create_if_block$a(ctx) {
		let div;
		let t;

		return {
			c() {
				div = element("div");
				t = text(/*errorMessage*/ ctx[7]);
				attr(div, "class", "error-message svelte-764k6k");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty & /*errorMessage*/ 128) set_data(t, /*errorMessage*/ ctx[7]);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	function create_fragment$d(ctx) {
		let div;
		let t0;
		let input;
		let t1;
		let mounted;
		let dispose;
		let if_block0 = /*label*/ ctx[1] && create_if_block_1$9(ctx);
		let if_block1 = /*errorMessage*/ ctx[7] && create_if_block$a(ctx);

		return {
			c() {
				div = element("div");
				if (if_block0) if_block0.c();
				t0 = space();
				input = element("input");
				t1 = space();
				if (if_block1) if_block1.c();
				attr(input, "id", "zephr-form-gift-code");
				attr(input, "type", "text");
				attr(input, "placeholder", /*placeholder*/ ctx[2]);
				input.disabled = /*disabled*/ ctx[4];
				input.required = /*required*/ ctx[3];
				input.value = /*value*/ ctx[0];
				attr(input, "maxlength", "16");
				attr(input, "class", "svelte-764k6k");
				toggle_class(input, "error", !!/*errorMessage*/ ctx[7]);
				attr(div, "class", "zephr-form-input-wrapper svelte-764k6k");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append(div, t0);
				append(div, input);
				append(div, t1);
				if (if_block1) if_block1.m(div, null);

				if (!mounted) {
					dispose = [
						listen(input, "input", /*handleChange*/ ctx[8]),
						listen(input, "focus", function () {
							if (is_function(/*onFocus*/ ctx[5])) /*onFocus*/ ctx[5].apply(this, arguments);
						}),
						listen(input, "blur", function () {
							if (is_function(/*onBlur*/ ctx[6])) /*onBlur*/ ctx[6].apply(this, arguments);
						})
					];

					mounted = true;
				}
			},
			p(new_ctx, [dirty]) {
				ctx = new_ctx;

				if (/*label*/ ctx[1]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_1$9(ctx);
						if_block0.c();
						if_block0.m(div, t0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (dirty & /*placeholder*/ 4) {
					attr(input, "placeholder", /*placeholder*/ ctx[2]);
				}

				if (dirty & /*disabled*/ 16) {
					input.disabled = /*disabled*/ ctx[4];
				}

				if (dirty & /*required*/ 8) {
					input.required = /*required*/ ctx[3];
				}

				if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
					input.value = /*value*/ ctx[0];
				}

				if (dirty & /*errorMessage*/ 128) {
					toggle_class(input, "error", !!/*errorMessage*/ ctx[7]);
				}

				if (/*errorMessage*/ ctx[7]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block$a(ctx);
						if_block1.c();
						if_block1.m(div, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$d($$self, $$props, $$invalidate) {
		let errorMessage;
		let { value = "" } = $$props;
		let { label = "" } = $$props;
		let { placeholder = "" } = $$props;
		let { required = false } = $$props;
		let { disabled = false } = $$props;
		let { hasError = false } = $$props;
		let { error = false } = $$props;

		let { onChange = _value => {
			
		} } = $$props;

		let { onFocus = () => {
			
		} } = $$props;

		let { onBlur = () => {
			
		} } = $$props;

		const handleChange = event => {
			const newValue = event.target.value;
			onChange(newValue);
		};

		$$self.$$set = $$props => {
			if ('value' in $$props) $$invalidate(0, value = $$props.value);
			if ('label' in $$props) $$invalidate(1, label = $$props.label);
			if ('placeholder' in $$props) $$invalidate(2, placeholder = $$props.placeholder);
			if ('required' in $$props) $$invalidate(3, required = $$props.required);
			if ('disabled' in $$props) $$invalidate(4, disabled = $$props.disabled);
			if ('hasError' in $$props) $$invalidate(9, hasError = $$props.hasError);
			if ('error' in $$props) $$invalidate(10, error = $$props.error);
			if ('onChange' in $$props) $$invalidate(11, onChange = $$props.onChange);
			if ('onFocus' in $$props) $$invalidate(5, onFocus = $$props.onFocus);
			if ('onBlur' in $$props) $$invalidate(6, onBlur = $$props.onBlur);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*hasError, error*/ 1536) {
				$$invalidate(7, errorMessage = hasError || error);
			}
		};

		return [
			value,
			label,
			placeholder,
			required,
			disabled,
			onFocus,
			onBlur,
			errorMessage,
			handleChange,
			hasError,
			error,
			onChange
		];
	}

	class GiftCode extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$d, create_fragment$d, safe_not_equal, {
				value: 0,
				label: 1,
				placeholder: 2,
				required: 3,
				disabled: 4,
				hasError: 9,
				error: 10,
				onChange: 11,
				onFocus: 5,
				onBlur: 6
			});
		}
	}

	const factory = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.GIFT_CODE,
	    create: (form, formState, formActions, config) => {
	        const { disabled, label, placeholder, required } = config;
	        const error = serverErrorForElement(elementTypes.GIFT_CODE, formState);
	        const onChange = (value) => {
	            formActions.updateFormState({
	                giftCode: value,
	                giftCodeError: undefined,
	            });
	            logDataLayerEvent(form, 'zephr_form_input_change', {
	                field: 'gift-code',
	                inputName: `zephr-form-gift-code-${form.uniqueKey}`,
	                sectionId: formState.currentSection.type,
	            });
	        };
	        const onFocus = () => logDataLayerEvent(form, 'zephr_form_input_focus', {
	            field: 'gift-code',
	            inputName: `zephr-form-gift-code-${form.uniqueKey}`,
	            sectionId: formState.currentSection.type,
	        });
	        const onBlur = () => logDataLayerEvent(form, 'zephr_form_input_blur', {
	            field: 'gift-code',
	            inputName: `zephr-form-gift-code-${form.uniqueKey}`,
	            sectionId: formState.currentSection.type,
	        });
	        const giftCode = formState.giftCode || '';
	        const isValid = (!required || !!giftCode) && giftCode.length === 16;
	        const errorMessage = error
	            ? resolveErrorLanguagePackKey(form, error)
	            : formState.giftCodeError;
	        return {
	            component: GiftCode,
	            props: {
	                hasError: errorMessage,
	                label,
	                placeholder,
	                required,
	                disabled,
	                onChange,
	                onFocus,
	                onBlur,
	                value: formState.giftCode || '',
	            },
	            isValid,
	        };
	    },
	};

	/* src/components/elements/giftSubscriptionsList/GiftSubscriptionsListBoxItem.svelte generated by Svelte v4.2.12 */

	function get_each_context$5(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[25] = list[i];
		return child_ctx;
	}

	// (30:39) 
	function create_if_block_14(ctx) {
		let div;
		let t;

		return {
			c() {
				div = element("div");
				t = text(/*redeemedBannerText*/ ctx[5]);
				attr(div, "class", "zephr-banner-top svelte-srvimy");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty & /*redeemedBannerText*/ 32) set_data(t, /*redeemedBannerText*/ ctx[5]);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (26:2) {#if gift.status === 'PENDING'}
	function create_if_block_13(ctx) {
		let div;
		let t0;
		let t1;
		let t2_value = /*gift*/ ctx[0].subscriptionStartDate + "";
		let t2;

		return {
			c() {
				div = element("div");
				t0 = text(/*pendingBannerText*/ ctx[4]);
				t1 = space();
				t2 = text(t2_value);
				attr(div, "class", "zephr-banner-top svelte-srvimy");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t0);
				append(div, t1);
				append(div, t2);
			},
			p(ctx, dirty) {
				if (dirty & /*pendingBannerText*/ 16) set_data(t0, /*pendingBannerText*/ ctx[4]);
				if (dirty & /*gift*/ 1 && t2_value !== (t2_value = /*gift*/ ctx[0].subscriptionStartDate + "")) set_data(t2, t2_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (38:6) {#if element === 'subscription_information' && !elementsHide.subscriptionInformation}
	function create_if_block_8$1(ctx) {
		let t0;
		let t1;
		let t2;
		let if_block3_anchor;
		let if_block0 = (/*gift*/ ctx[0].recipientFirstName || /*gift*/ ctx[0].recipientLastName || /*gift*/ ctx[0].is_recipient) && create_if_block_12(ctx);
		let if_block1 = /*gift*/ ctx[0].subscriptionType && create_if_block_11(ctx);
		let if_block2 = /*gift*/ ctx[0].subscriptionStartDate && create_if_block_10(ctx);
		let if_block3 = /*gift*/ ctx[0].subscriptionEndDate && create_if_block_9(ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				t2 = space();
				if (if_block3) if_block3.c();
				if_block3_anchor = empty();
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t0, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, t2, anchor);
				if (if_block3) if_block3.m(target, anchor);
				insert(target, if_block3_anchor, anchor);
			},
			p(ctx, dirty) {
				if (/*gift*/ ctx[0].recipientFirstName || /*gift*/ ctx[0].recipientLastName || /*gift*/ ctx[0].is_recipient) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_12(ctx);
						if_block0.c();
						if_block0.m(t0.parentNode, t0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*gift*/ ctx[0].subscriptionType) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_11(ctx);
						if_block1.c();
						if_block1.m(t1.parentNode, t1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (/*gift*/ ctx[0].subscriptionStartDate) {
					if (if_block2) {
						if_block2.p(ctx, dirty);
					} else {
						if_block2 = create_if_block_10(ctx);
						if_block2.c();
						if_block2.m(t2.parentNode, t2);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}

				if (/*gift*/ ctx[0].subscriptionEndDate) {
					if (if_block3) {
						if_block3.p(ctx, dirty);
					} else {
						if_block3 = create_if_block_9(ctx);
						if_block3.c();
						if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
					}
				} else if (if_block3) {
					if_block3.d(1);
					if_block3 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
					detach(t2);
					detach(if_block3_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				if (if_block2) if_block2.d(detaching);
				if (if_block3) if_block3.d(detaching);
			}
		};
	}

	// (39:8) {#if gift.recipientFirstName || gift.recipientLastName || gift.is_recipient}
	function create_if_block_12(ctx) {
		let div2;
		let span;
		let t0;
		let t1;
		let div0;
		let t2_value = (/*gift*/ ctx[0].recipientFirstName || '') + "";
		let t2;
		let t3;
		let t4_value = (/*gift*/ ctx[0].recipientLastName || '') + "";
		let t4;
		let t5;
		let div1;

		let t6_value = (/*gift*/ ctx[0].status === 'REDEEMED'
		? /*activeStatusText*/ ctx[6]
		: /*pendingStatusText*/ ctx[7]) + "";

		let t6;

		return {
			c() {
				div2 = element("div");
				span = element("span");
				t0 = text(/*giftRecipientText*/ ctx[1]);
				t1 = space();
				div0 = element("div");
				t2 = text(t2_value);
				t3 = space();
				t4 = text(t4_value);
				t5 = space();
				div1 = element("div");
				t6 = text(t6_value);
				attr(span, "class", "svelte-srvimy");
				attr(div0, "class", "zephr-box-item-information svelte-srvimy");
				attr(div1, "class", "zephr-status-pill svelte-srvimy");
				attr(div2, "class", "zephr-section zephr-header-section svelte-srvimy");
			},
			m(target, anchor) {
				insert(target, div2, anchor);
				append(div2, span);
				append(span, t0);
				append(div2, t1);
				append(div2, div0);
				append(div0, t2);
				append(div0, t3);
				append(div0, t4);
				append(div2, t5);
				append(div2, div1);
				append(div1, t6);
			},
			p(ctx, dirty) {
				if (dirty & /*giftRecipientText*/ 2) set_data(t0, /*giftRecipientText*/ ctx[1]);
				if (dirty & /*gift*/ 1 && t2_value !== (t2_value = (/*gift*/ ctx[0].recipientFirstName || '') + "")) set_data(t2, t2_value);
				if (dirty & /*gift*/ 1 && t4_value !== (t4_value = (/*gift*/ ctx[0].recipientLastName || '') + "")) set_data(t4, t4_value);

				if (dirty & /*gift, activeStatusText, pendingStatusText*/ 193 && t6_value !== (t6_value = (/*gift*/ ctx[0].status === 'REDEEMED'
				? /*activeStatusText*/ ctx[6]
				: /*pendingStatusText*/ ctx[7]) + "")) set_data(t6, t6_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div2);
				}
			}
		};
	}

	// (51:8) {#if gift.subscriptionType}
	function create_if_block_11(ctx) {
		let div1;
		let span;
		let t0;
		let t1;
		let div0;
		let t2_value = /*gift*/ ctx[0].subscriptionType + "";
		let t2;

		return {
			c() {
				div1 = element("div");
				span = element("span");
				t0 = text(/*subscriptionTypeText*/ ctx[13]);
				t1 = space();
				div0 = element("div");
				t2 = text(t2_value);
				attr(span, "class", "svelte-srvimy");
				attr(div0, "class", "");
				attr(div1, "class", "zephr-section svelte-srvimy");
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, span);
				append(span, t0);
				append(div1, t1);
				append(div1, div0);
				append(div0, t2);
			},
			p(ctx, dirty) {
				if (dirty & /*subscriptionTypeText*/ 8192) set_data(t0, /*subscriptionTypeText*/ ctx[13]);
				if (dirty & /*gift*/ 1 && t2_value !== (t2_value = /*gift*/ ctx[0].subscriptionType + "")) set_data(t2, t2_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
				}
			}
		};
	}

	// (60:8) {#if gift.subscriptionStartDate}
	function create_if_block_10(ctx) {
		let div1;
		let span;
		let t0;
		let t1;
		let div0;
		let t2_value = /*gift*/ ctx[0].subscriptionStartDate + "";
		let t2;

		return {
			c() {
				div1 = element("div");
				span = element("span");
				t0 = text(/*startDateText*/ ctx[2]);
				t1 = space();
				div0 = element("div");
				t2 = text(t2_value);
				attr(span, "class", "svelte-srvimy");
				attr(div0, "class", "");
				attr(div1, "class", "zephr-section svelte-srvimy");
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, span);
				append(span, t0);
				append(div1, t1);
				append(div1, div0);
				append(div0, t2);
			},
			p(ctx, dirty) {
				if (dirty & /*startDateText*/ 4) set_data(t0, /*startDateText*/ ctx[2]);
				if (dirty & /*gift*/ 1 && t2_value !== (t2_value = /*gift*/ ctx[0].subscriptionStartDate + "")) set_data(t2, t2_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
				}
			}
		};
	}

	// (69:8) {#if gift.subscriptionEndDate}
	function create_if_block_9(ctx) {
		let div1;
		let span;
		let t0;
		let t1;
		let div0;
		let t2_value = /*gift*/ ctx[0].subscriptionEndDate + "";
		let t2;

		return {
			c() {
				div1 = element("div");
				span = element("span");
				t0 = text(/*endDateText*/ ctx[3]);
				t1 = space();
				div0 = element("div");
				t2 = text(t2_value);
				attr(span, "class", "svelte-srvimy");
				attr(div0, "class", "");
				attr(div1, "class", "zephr-section svelte-srvimy");
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, span);
				append(span, t0);
				append(div1, t1);
				append(div1, div0);
				append(div0, t2);
			},
			p(ctx, dirty) {
				if (dirty & /*endDateText*/ 8) set_data(t0, /*endDateText*/ ctx[3]);
				if (dirty & /*gift*/ 1 && t2_value !== (t2_value = /*gift*/ ctx[0].subscriptionEndDate + "")) set_data(t2, t2_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
				}
			}
		};
	}

	// (78:6) {#if element === 'billing_history' && !elementsHide.billingHistory && gift.status === "PENDING"}
	function create_if_block_6$3(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*billingHistoryLink*/ ctx[16] && create_if_block_7$1(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*billingHistoryLink*/ ctx[16]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*billingHistoryLink*/ 65536) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_7$1(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (79:6) {#if billingHistoryLink}
	function create_if_block_7$1(ctx) {
		let tablink;
		let current;

		tablink = new Tablink({
				props: {
					text: /*billingHistoryLink*/ ctx[16],
					onClick: /*func*/ ctx[21]
				}
			});

		return {
			c() {
				create_component(tablink.$$.fragment);
			},
			m(target, anchor) {
				mount_component(tablink, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const tablink_changes = {};
				if (dirty & /*billingHistoryLink*/ 65536) tablink_changes.text = /*billingHistoryLink*/ ctx[16];
				if (dirty & /*onViewHistory, gift*/ 131073) tablink_changes.onClick = /*func*/ ctx[21];
				tablink.$set(tablink_changes);
			},
			i(local) {
				if (current) return;
				transition_in(tablink.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(tablink.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(tablink, detaching);
			}
		};
	}

	// (83:4) {#if element === 'change_payment' && !elementsHide.changePayment && gift.status === "PENDING"}
	function create_if_block_4$3(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*changePaymentMethodText*/ ctx[9] && create_if_block_5$3(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*changePaymentMethodText*/ ctx[9]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*changePaymentMethodText*/ 512) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_5$3(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (84:6) {#if changePaymentMethodText}
	function create_if_block_5$3(ctx) {
		let tablink;
		let current;

		tablink = new Tablink({
				props: {
					text: /*changePaymentMethodText*/ ctx[9],
					onClick: /*func_1*/ ctx[22]
				}
			});

		return {
			c() {
				create_component(tablink.$$.fragment);
			},
			m(target, anchor) {
				mount_component(tablink, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const tablink_changes = {};
				if (dirty & /*changePaymentMethodText*/ 512) tablink_changes.text = /*changePaymentMethodText*/ ctx[9];
				if (dirty & /*onChangePayment, gift*/ 262145) tablink_changes.onClick = /*func_1*/ ctx[22];
				tablink.$set(tablink_changes);
			},
			i(local) {
				if (current) return;
				transition_in(tablink.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(tablink.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(tablink, detaching);
			}
		};
	}

	// (88:4) {#if element === 'change_subscription' && !elementsHide.changeSubscription && gift.status === "PENDING"}
	function create_if_block_2$6(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*changeSubscriptionText*/ ctx[10] && create_if_block_3$4(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*changeSubscriptionText*/ ctx[10]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*changeSubscriptionText*/ 1024) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_3$4(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (89:6) {#if changeSubscriptionText}
	function create_if_block_3$4(ctx) {
		let tablink;
		let current;

		tablink = new Tablink({
				props: {
					text: /*changeSubscriptionText*/ ctx[10],
					path: `${/*changeSubscriptionPath*/ ctx[8]}?subscription=${/*gift*/ ctx[0].externalId}`,
					logDlEvent: /*func_2*/ ctx[23]
				}
			});

		return {
			c() {
				create_component(tablink.$$.fragment);
			},
			m(target, anchor) {
				mount_component(tablink, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const tablink_changes = {};
				if (dirty & /*changeSubscriptionText*/ 1024) tablink_changes.text = /*changeSubscriptionText*/ ctx[10];
				if (dirty & /*changeSubscriptionPath, gift*/ 257) tablink_changes.path = `${/*changeSubscriptionPath*/ ctx[8]}?subscription=${/*gift*/ ctx[0].externalId}`;
				if (dirty & /*logChangeSubscription, gift*/ 524289) tablink_changes.logDlEvent = /*func_2*/ ctx[23];
				tablink.$set(tablink_changes);
			},
			i(local) {
				if (current) return;
				transition_in(tablink.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(tablink.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(tablink, detaching);
			}
		};
	}

	// (93:4) {#if element === 'cancel_subscription' && !elementsHide.cancelSubscription && gift.status === "PENDING"}
	function create_if_block$9(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*cancelSubscriptionText*/ ctx[11] && create_if_block_1$8(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*cancelSubscriptionText*/ ctx[11]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*cancelSubscriptionText*/ 2048) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_1$8(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (94:6) {#if cancelSubscriptionText}
	function create_if_block_1$8(ctx) {
		let tablink;
		let current;

		tablink = new Tablink({
				props: {
					text: /*cancelSubscriptionText*/ ctx[11],
					path: `${/*cancelSubscriptionPath*/ ctx[12]}?subscription=${/*gift*/ ctx[0].externalId}`,
					logDlEvent: /*func_3*/ ctx[24]
				}
			});

		return {
			c() {
				create_component(tablink.$$.fragment);
			},
			m(target, anchor) {
				mount_component(tablink, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const tablink_changes = {};
				if (dirty & /*cancelSubscriptionText*/ 2048) tablink_changes.text = /*cancelSubscriptionText*/ ctx[11];
				if (dirty & /*cancelSubscriptionPath, gift*/ 4097) tablink_changes.path = `${/*cancelSubscriptionPath*/ ctx[12]}?subscription=${/*gift*/ ctx[0].externalId}`;
				if (dirty & /*logCancelSubscription, gift*/ 1048577) tablink_changes.logDlEvent = /*func_3*/ ctx[24];
				tablink.$set(tablink_changes);
			},
			i(local) {
				if (current) return;
				transition_in(tablink.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(tablink.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(tablink, detaching);
			}
		};
	}

	// (37:4) {#each elementsOrder as element}
	function create_each_block$5(ctx) {
		let t0;
		let t1;
		let t2;
		let t3;
		let if_block4_anchor;
		let current;
		let if_block0 = /*element*/ ctx[25] === 'subscription_information' && !/*elementsHide*/ ctx[14].subscriptionInformation && create_if_block_8$1(ctx);
		let if_block1 = /*element*/ ctx[25] === 'billing_history' && !/*elementsHide*/ ctx[14].billingHistory && /*gift*/ ctx[0].status === "PENDING" && create_if_block_6$3(ctx);
		let if_block2 = /*element*/ ctx[25] === 'change_payment' && !/*elementsHide*/ ctx[14].changePayment && /*gift*/ ctx[0].status === "PENDING" && create_if_block_4$3(ctx);
		let if_block3 = /*element*/ ctx[25] === 'change_subscription' && !/*elementsHide*/ ctx[14].changeSubscription && /*gift*/ ctx[0].status === "PENDING" && create_if_block_2$6(ctx);
		let if_block4 = /*element*/ ctx[25] === 'cancel_subscription' && !/*elementsHide*/ ctx[14].cancelSubscription && /*gift*/ ctx[0].status === "PENDING" && create_if_block$9(ctx);

		return {
			c() {
				if (if_block0) if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				t2 = space();
				if (if_block3) if_block3.c();
				t3 = space();
				if (if_block4) if_block4.c();
				if_block4_anchor = empty();
			},
			m(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, t0, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, t1, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, t2, anchor);
				if (if_block3) if_block3.m(target, anchor);
				insert(target, t3, anchor);
				if (if_block4) if_block4.m(target, anchor);
				insert(target, if_block4_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (/*element*/ ctx[25] === 'subscription_information' && !/*elementsHide*/ ctx[14].subscriptionInformation) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_8$1(ctx);
						if_block0.c();
						if_block0.m(t0.parentNode, t0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*element*/ ctx[25] === 'billing_history' && !/*elementsHide*/ ctx[14].billingHistory && /*gift*/ ctx[0].status === "PENDING") {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*elementsOrder, elementsHide, gift*/ 49153) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_6$3(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(t1.parentNode, t1);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (/*element*/ ctx[25] === 'change_payment' && !/*elementsHide*/ ctx[14].changePayment && /*gift*/ ctx[0].status === "PENDING") {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty & /*elementsOrder, elementsHide, gift*/ 49153) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block_4$3(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(t2.parentNode, t2);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}

				if (/*element*/ ctx[25] === 'change_subscription' && !/*elementsHide*/ ctx[14].changeSubscription && /*gift*/ ctx[0].status === "PENDING") {
					if (if_block3) {
						if_block3.p(ctx, dirty);

						if (dirty & /*elementsOrder, elementsHide, gift*/ 49153) {
							transition_in(if_block3, 1);
						}
					} else {
						if_block3 = create_if_block_2$6(ctx);
						if_block3.c();
						transition_in(if_block3, 1);
						if_block3.m(t3.parentNode, t3);
					}
				} else if (if_block3) {
					group_outros();

					transition_out(if_block3, 1, 1, () => {
						if_block3 = null;
					});

					check_outros();
				}

				if (/*element*/ ctx[25] === 'cancel_subscription' && !/*elementsHide*/ ctx[14].cancelSubscription && /*gift*/ ctx[0].status === "PENDING") {
					if (if_block4) {
						if_block4.p(ctx, dirty);

						if (dirty & /*elementsOrder, elementsHide, gift*/ 49153) {
							transition_in(if_block4, 1);
						}
					} else {
						if_block4 = create_if_block$9(ctx);
						if_block4.c();
						transition_in(if_block4, 1);
						if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
					}
				} else if (if_block4) {
					group_outros();

					transition_out(if_block4, 1, 1, () => {
						if_block4 = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block1);
				transition_in(if_block2);
				transition_in(if_block3);
				transition_in(if_block4);
				current = true;
			},
			o(local) {
				transition_out(if_block1);
				transition_out(if_block2);
				transition_out(if_block3);
				transition_out(if_block4);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(t1);
					detach(t2);
					detach(t3);
					detach(if_block4_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				if (if_block2) if_block2.d(detaching);
				if (if_block3) if_block3.d(detaching);
				if (if_block4) if_block4.d(detaching);
			}
		};
	}

	function create_fragment$c(ctx) {
		let div1;
		let t;
		let div0;
		let current;

		function select_block_type(ctx, dirty) {
			if (/*gift*/ ctx[0].status === 'PENDING') return create_if_block_13;
			if (/*gift*/ ctx[0].status === 'REDEEMED') return create_if_block_14;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type && current_block_type(ctx);
		let each_value = ensure_array_like(/*elementsOrder*/ ctx[15]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				div1 = element("div");
				if (if_block) if_block.c();
				t = space();
				div0 = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(div0, "class", "zephr-inner-box svelte-srvimy");
				attr(div1, "class", "zephr-gift-list-box-item svelte-srvimy");
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				if (if_block) if_block.m(div1, null);
				append(div1, t);
				append(div1, div0);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div0, null);
					}
				}

				current = true;
			},
			p(ctx, [dirty]) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(div1, t);
					}
				}

				if (dirty & /*cancelSubscriptionText, cancelSubscriptionPath, gift, logCancelSubscription, elementsOrder, elementsHide, changeSubscriptionText, changeSubscriptionPath, logChangeSubscription, changePaymentMethodText, onChangePayment, billingHistoryLink, onViewHistory, endDateText, startDateText, subscriptionTypeText, activeStatusText, pendingStatusText, giftRecipientText*/ 2097103) {
					each_value = ensure_array_like(/*elementsOrder*/ ctx[15]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$5(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$5(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div0, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
				}

				if (if_block) {
					if_block.d();
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	function instance$c($$self, $$props, $$invalidate) {
		let { gift } = $$props;
		let { giftRecipientText } = $$props;
		let { startDateText } = $$props;
		let { endDateText } = $$props;
		let { pendingBannerText } = $$props;
		let { redeemedBannerText } = $$props;
		let { activeStatusText } = $$props;
		let { pendingStatusText } = $$props;
		let { changeSubscriptionPath } = $$props;
		let { changePaymentMethodText } = $$props;
		let { changeSubscriptionText } = $$props;
		let { cancelSubscriptionText } = $$props;
		let { cancelSubscriptionPath } = $$props;
		let { subscriptionTypeText } = $$props;
		let { elementsHide } = $$props;
		let { elementsOrder = [] } = $$props;
		let { billingHistoryLink } = $$props;
		let { onViewHistory } = $$props;
		let { onChangePayment } = $$props;
		let { logChangeSubscription } = $$props;
		let { logCancelSubscription } = $$props;
		const func = () => onViewHistory(gift);
		const func_1 = () => onChangePayment(gift);
		const func_2 = () => logChangeSubscription(gift);
		const func_3 = () => logCancelSubscription(gift);

		$$self.$$set = $$props => {
			if ('gift' in $$props) $$invalidate(0, gift = $$props.gift);
			if ('giftRecipientText' in $$props) $$invalidate(1, giftRecipientText = $$props.giftRecipientText);
			if ('startDateText' in $$props) $$invalidate(2, startDateText = $$props.startDateText);
			if ('endDateText' in $$props) $$invalidate(3, endDateText = $$props.endDateText);
			if ('pendingBannerText' in $$props) $$invalidate(4, pendingBannerText = $$props.pendingBannerText);
			if ('redeemedBannerText' in $$props) $$invalidate(5, redeemedBannerText = $$props.redeemedBannerText);
			if ('activeStatusText' in $$props) $$invalidate(6, activeStatusText = $$props.activeStatusText);
			if ('pendingStatusText' in $$props) $$invalidate(7, pendingStatusText = $$props.pendingStatusText);
			if ('changeSubscriptionPath' in $$props) $$invalidate(8, changeSubscriptionPath = $$props.changeSubscriptionPath);
			if ('changePaymentMethodText' in $$props) $$invalidate(9, changePaymentMethodText = $$props.changePaymentMethodText);
			if ('changeSubscriptionText' in $$props) $$invalidate(10, changeSubscriptionText = $$props.changeSubscriptionText);
			if ('cancelSubscriptionText' in $$props) $$invalidate(11, cancelSubscriptionText = $$props.cancelSubscriptionText);
			if ('cancelSubscriptionPath' in $$props) $$invalidate(12, cancelSubscriptionPath = $$props.cancelSubscriptionPath);
			if ('subscriptionTypeText' in $$props) $$invalidate(13, subscriptionTypeText = $$props.subscriptionTypeText);
			if ('elementsHide' in $$props) $$invalidate(14, elementsHide = $$props.elementsHide);
			if ('elementsOrder' in $$props) $$invalidate(15, elementsOrder = $$props.elementsOrder);
			if ('billingHistoryLink' in $$props) $$invalidate(16, billingHistoryLink = $$props.billingHistoryLink);
			if ('onViewHistory' in $$props) $$invalidate(17, onViewHistory = $$props.onViewHistory);
			if ('onChangePayment' in $$props) $$invalidate(18, onChangePayment = $$props.onChangePayment);
			if ('logChangeSubscription' in $$props) $$invalidate(19, logChangeSubscription = $$props.logChangeSubscription);
			if ('logCancelSubscription' in $$props) $$invalidate(20, logCancelSubscription = $$props.logCancelSubscription);
		};

		return [
			gift,
			giftRecipientText,
			startDateText,
			endDateText,
			pendingBannerText,
			redeemedBannerText,
			activeStatusText,
			pendingStatusText,
			changeSubscriptionPath,
			changePaymentMethodText,
			changeSubscriptionText,
			cancelSubscriptionText,
			cancelSubscriptionPath,
			subscriptionTypeText,
			elementsHide,
			elementsOrder,
			billingHistoryLink,
			onViewHistory,
			onChangePayment,
			logChangeSubscription,
			logCancelSubscription,
			func,
			func_1,
			func_2,
			func_3
		];
	}

	class GiftSubscriptionsListBoxItem extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$c, create_fragment$c, safe_not_equal, {
				gift: 0,
				giftRecipientText: 1,
				startDateText: 2,
				endDateText: 3,
				pendingBannerText: 4,
				redeemedBannerText: 5,
				activeStatusText: 6,
				pendingStatusText: 7,
				changeSubscriptionPath: 8,
				changePaymentMethodText: 9,
				changeSubscriptionText: 10,
				cancelSubscriptionText: 11,
				cancelSubscriptionPath: 12,
				subscriptionTypeText: 13,
				elementsHide: 14,
				elementsOrder: 15,
				billingHistoryLink: 16,
				onViewHistory: 17,
				onChangePayment: 18,
				logChangeSubscription: 19,
				logCancelSubscription: 20
			});
		}
	}

	/* src/components/elements/giftSubscriptionsList/GiftSubscriptionsList.svelte generated by Svelte v4.2.12 */

	function get_each_context$4(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[24] = list[i];
		return child_ctx;
	}

	// (36:2) {#if loading}
	function create_if_block_2$5(ctx) {
		let spinner;
		let current;
		spinner = new Spinner({});

		return {
			c() {
				create_component(spinner.$$.fragment);
			},
			m(target, anchor) {
				mount_component(spinner, target, anchor);
				current = true;
			},
			i(local) {
				if (current) return;
				transition_in(spinner.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(spinner.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(spinner, detaching);
			}
		};
	}

	// (40:2) {#if !loading && !gifts.length}
	function create_if_block_1$7(ctx) {
		let div;
		let raw_value = (/*noSubscriptionsMessage*/ ctx[1] || /*emptyMessage*/ ctx[0]) + "";

		return {
			c() {
				div = element("div");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				div.innerHTML = raw_value;
			},
			p(ctx, dirty) {
				if (dirty & /*noSubscriptionsMessage, emptyMessage*/ 3 && raw_value !== (raw_value = (/*noSubscriptionsMessage*/ ctx[1] || /*emptyMessage*/ ctx[0]) + "")) div.innerHTML = raw_value;		},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (46:2) {#if !loading && gifts.length > 0}
	function create_if_block$8(ctx) {
		let each_1_anchor;
		let current;
		let each_value = ensure_array_like(/*gifts*/ ctx[3]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert(target, each_1_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*gifts, giftRecipientText, startDateText, endDateText, pendingBannerText, redeemedBannerText, activeStatusText, pendingStatusText, onChangePayment, logChangeSubscription, logCancelSubscription, onViewHistory, changePaymentMethodText, changeSubscriptionText, cancelSubscriptionText, changeSubscriptionPath, cancelSubscriptionPath, elementsHide, subscriptionTypeText, elementsOrder, billingHistoryLink*/ 16777208) {
					each_value = ensure_array_like(/*gifts*/ ctx[3]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$4(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$4(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (47:4) {#each gifts as gift}
	function create_each_block$4(ctx) {
		let giftsubscriptionslistboxitem;
		let current;

		giftsubscriptionslistboxitem = new GiftSubscriptionsListBoxItem({
				props: {
					gift: /*gift*/ ctx[24],
					giftRecipientText: /*giftRecipientText*/ ctx[14],
					startDateText: /*startDateText*/ ctx[15],
					endDateText: /*endDateText*/ ctx[16],
					pendingBannerText: /*pendingBannerText*/ ctx[18],
					redeemedBannerText: /*redeemedBannerText*/ ctx[19],
					activeStatusText: /*activeStatusText*/ ctx[20],
					pendingStatusText: /*pendingStatusText*/ ctx[21],
					onChangePayment: /*onChangePayment*/ ctx[6],
					logChangeSubscription: /*logChangeSubscription*/ ctx[7],
					logCancelSubscription: /*logCancelSubscription*/ ctx[8],
					onViewHistory: /*onViewHistory*/ ctx[9],
					changePaymentMethodText: /*changePaymentMethodText*/ ctx[10],
					changeSubscriptionText: /*changeSubscriptionText*/ ctx[11],
					cancelSubscriptionText: /*cancelSubscriptionText*/ ctx[12],
					changeSubscriptionPath: /*changeSubscriptionPath*/ ctx[5],
					cancelSubscriptionPath: /*cancelSubscriptionPath*/ ctx[4],
					elementsHide: /*elementsHide*/ ctx[23],
					subscriptionTypeText: /*subscriptionTypeText*/ ctx[17],
					elementsOrder: /*elementsOrder*/ ctx[22],
					billingHistoryLink: /*billingHistoryLink*/ ctx[13]
				}
			});

		return {
			c() {
				create_component(giftsubscriptionslistboxitem.$$.fragment);
			},
			m(target, anchor) {
				mount_component(giftsubscriptionslistboxitem, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const giftsubscriptionslistboxitem_changes = {};
				if (dirty & /*gifts*/ 8) giftsubscriptionslistboxitem_changes.gift = /*gift*/ ctx[24];
				if (dirty & /*giftRecipientText*/ 16384) giftsubscriptionslistboxitem_changes.giftRecipientText = /*giftRecipientText*/ ctx[14];
				if (dirty & /*startDateText*/ 32768) giftsubscriptionslistboxitem_changes.startDateText = /*startDateText*/ ctx[15];
				if (dirty & /*endDateText*/ 65536) giftsubscriptionslistboxitem_changes.endDateText = /*endDateText*/ ctx[16];
				if (dirty & /*pendingBannerText*/ 262144) giftsubscriptionslistboxitem_changes.pendingBannerText = /*pendingBannerText*/ ctx[18];
				if (dirty & /*redeemedBannerText*/ 524288) giftsubscriptionslistboxitem_changes.redeemedBannerText = /*redeemedBannerText*/ ctx[19];
				if (dirty & /*activeStatusText*/ 1048576) giftsubscriptionslistboxitem_changes.activeStatusText = /*activeStatusText*/ ctx[20];
				if (dirty & /*pendingStatusText*/ 2097152) giftsubscriptionslistboxitem_changes.pendingStatusText = /*pendingStatusText*/ ctx[21];
				if (dirty & /*onChangePayment*/ 64) giftsubscriptionslistboxitem_changes.onChangePayment = /*onChangePayment*/ ctx[6];
				if (dirty & /*logChangeSubscription*/ 128) giftsubscriptionslistboxitem_changes.logChangeSubscription = /*logChangeSubscription*/ ctx[7];
				if (dirty & /*logCancelSubscription*/ 256) giftsubscriptionslistboxitem_changes.logCancelSubscription = /*logCancelSubscription*/ ctx[8];
				if (dirty & /*onViewHistory*/ 512) giftsubscriptionslistboxitem_changes.onViewHistory = /*onViewHistory*/ ctx[9];
				if (dirty & /*changePaymentMethodText*/ 1024) giftsubscriptionslistboxitem_changes.changePaymentMethodText = /*changePaymentMethodText*/ ctx[10];
				if (dirty & /*changeSubscriptionText*/ 2048) giftsubscriptionslistboxitem_changes.changeSubscriptionText = /*changeSubscriptionText*/ ctx[11];
				if (dirty & /*cancelSubscriptionText*/ 4096) giftsubscriptionslistboxitem_changes.cancelSubscriptionText = /*cancelSubscriptionText*/ ctx[12];
				if (dirty & /*changeSubscriptionPath*/ 32) giftsubscriptionslistboxitem_changes.changeSubscriptionPath = /*changeSubscriptionPath*/ ctx[5];
				if (dirty & /*cancelSubscriptionPath*/ 16) giftsubscriptionslistboxitem_changes.cancelSubscriptionPath = /*cancelSubscriptionPath*/ ctx[4];
				if (dirty & /*elementsHide*/ 8388608) giftsubscriptionslistboxitem_changes.elementsHide = /*elementsHide*/ ctx[23];
				if (dirty & /*subscriptionTypeText*/ 131072) giftsubscriptionslistboxitem_changes.subscriptionTypeText = /*subscriptionTypeText*/ ctx[17];
				if (dirty & /*elementsOrder*/ 4194304) giftsubscriptionslistboxitem_changes.elementsOrder = /*elementsOrder*/ ctx[22];
				if (dirty & /*billingHistoryLink*/ 8192) giftsubscriptionslistboxitem_changes.billingHistoryLink = /*billingHistoryLink*/ ctx[13];
				giftsubscriptionslistboxitem.$set(giftsubscriptionslistboxitem_changes);
			},
			i(local) {
				if (current) return;
				transition_in(giftsubscriptionslistboxitem.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(giftsubscriptionslistboxitem.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(giftsubscriptionslistboxitem, detaching);
			}
		};
	}

	function create_fragment$b(ctx) {
		let div;
		let t0;
		let t1;
		let current;
		let if_block0 = /*loading*/ ctx[2] && create_if_block_2$5();
		let if_block1 = !/*loading*/ ctx[2] && !/*gifts*/ ctx[3].length && create_if_block_1$7(ctx);
		let if_block2 = !/*loading*/ ctx[2] && /*gifts*/ ctx[3].length > 0 && create_if_block$8(ctx);

		return {
			c() {
				div = element("div");
				if (if_block0) if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				attr(div, "class", "subscriptions-list-container svelte-ldb1rq");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append(div, t0);
				if (if_block1) if_block1.m(div, null);
				append(div, t1);
				if (if_block2) if_block2.m(div, null);
				current = true;
			},
			p(ctx, [dirty]) {
				if (/*loading*/ ctx[2]) {
					if (if_block0) {
						if (dirty & /*loading*/ 4) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_2$5();
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div, t0);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (!/*loading*/ ctx[2] && !/*gifts*/ ctx[3].length) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_1$7(ctx);
						if_block1.c();
						if_block1.m(div, t1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (!/*loading*/ ctx[2] && /*gifts*/ ctx[3].length > 0) {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty & /*loading, gifts*/ 12) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block$8(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(div, null);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block2);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block2);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
			}
		};
	}

	function instance$b($$self, $$props, $$invalidate) {
		let { emptyMessage } = $$props;
		let { noSubscriptionsMessage } = $$props;
		let { loading } = $$props;
		let { gifts = [] } = $$props;
		let { cancelSubscriptionPath } = $$props;
		let { changeSubscriptionPath } = $$props;
		let { onChangePayment } = $$props;
		let { logChangeSubscription } = $$props;
		let { logCancelSubscription } = $$props;
		let { onViewHistory } = $$props;
		let { changePaymentMethodText } = $$props;
		let { changeSubscriptionText } = $$props;
		let { cancelSubscriptionText } = $$props;
		let { billingHistoryLink } = $$props;
		let { giftRecipientText } = $$props;
		let { startDateText } = $$props;
		let { endDateText } = $$props;
		let { subscriptionTypeText } = $$props;
		let { pendingBannerText } = $$props;
		let { redeemedBannerText } = $$props;
		let { activeStatusText } = $$props;
		let { pendingStatusText } = $$props;
		let { elementsOrder = [] } = $$props;

		let { elementsHide = {
			subscriptionInformation: undefined,
			changePayment: undefined,
			changeSubscription: undefined,
			cancelSubscription: undefined,
			billingHistory: undefined
		} } = $$props;

		$$self.$$set = $$props => {
			if ('emptyMessage' in $$props) $$invalidate(0, emptyMessage = $$props.emptyMessage);
			if ('noSubscriptionsMessage' in $$props) $$invalidate(1, noSubscriptionsMessage = $$props.noSubscriptionsMessage);
			if ('loading' in $$props) $$invalidate(2, loading = $$props.loading);
			if ('gifts' in $$props) $$invalidate(3, gifts = $$props.gifts);
			if ('cancelSubscriptionPath' in $$props) $$invalidate(4, cancelSubscriptionPath = $$props.cancelSubscriptionPath);
			if ('changeSubscriptionPath' in $$props) $$invalidate(5, changeSubscriptionPath = $$props.changeSubscriptionPath);
			if ('onChangePayment' in $$props) $$invalidate(6, onChangePayment = $$props.onChangePayment);
			if ('logChangeSubscription' in $$props) $$invalidate(7, logChangeSubscription = $$props.logChangeSubscription);
			if ('logCancelSubscription' in $$props) $$invalidate(8, logCancelSubscription = $$props.logCancelSubscription);
			if ('onViewHistory' in $$props) $$invalidate(9, onViewHistory = $$props.onViewHistory);
			if ('changePaymentMethodText' in $$props) $$invalidate(10, changePaymentMethodText = $$props.changePaymentMethodText);
			if ('changeSubscriptionText' in $$props) $$invalidate(11, changeSubscriptionText = $$props.changeSubscriptionText);
			if ('cancelSubscriptionText' in $$props) $$invalidate(12, cancelSubscriptionText = $$props.cancelSubscriptionText);
			if ('billingHistoryLink' in $$props) $$invalidate(13, billingHistoryLink = $$props.billingHistoryLink);
			if ('giftRecipientText' in $$props) $$invalidate(14, giftRecipientText = $$props.giftRecipientText);
			if ('startDateText' in $$props) $$invalidate(15, startDateText = $$props.startDateText);
			if ('endDateText' in $$props) $$invalidate(16, endDateText = $$props.endDateText);
			if ('subscriptionTypeText' in $$props) $$invalidate(17, subscriptionTypeText = $$props.subscriptionTypeText);
			if ('pendingBannerText' in $$props) $$invalidate(18, pendingBannerText = $$props.pendingBannerText);
			if ('redeemedBannerText' in $$props) $$invalidate(19, redeemedBannerText = $$props.redeemedBannerText);
			if ('activeStatusText' in $$props) $$invalidate(20, activeStatusText = $$props.activeStatusText);
			if ('pendingStatusText' in $$props) $$invalidate(21, pendingStatusText = $$props.pendingStatusText);
			if ('elementsOrder' in $$props) $$invalidate(22, elementsOrder = $$props.elementsOrder);
			if ('elementsHide' in $$props) $$invalidate(23, elementsHide = $$props.elementsHide);
		};

		return [
			emptyMessage,
			noSubscriptionsMessage,
			loading,
			gifts,
			cancelSubscriptionPath,
			changeSubscriptionPath,
			onChangePayment,
			logChangeSubscription,
			logCancelSubscription,
			onViewHistory,
			changePaymentMethodText,
			changeSubscriptionText,
			cancelSubscriptionText,
			billingHistoryLink,
			giftRecipientText,
			startDateText,
			endDateText,
			subscriptionTypeText,
			pendingBannerText,
			redeemedBannerText,
			activeStatusText,
			pendingStatusText,
			elementsOrder,
			elementsHide
		];
	}

	class GiftSubscriptionsList extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$b, create_fragment$b, safe_not_equal, {
				emptyMessage: 0,
				noSubscriptionsMessage: 1,
				loading: 2,
				gifts: 3,
				cancelSubscriptionPath: 4,
				changeSubscriptionPath: 5,
				onChangePayment: 6,
				logChangeSubscription: 7,
				logCancelSubscription: 8,
				onViewHistory: 9,
				changePaymentMethodText: 10,
				changeSubscriptionText: 11,
				cancelSubscriptionText: 12,
				billingHistoryLink: 13,
				giftRecipientText: 14,
				startDateText: 15,
				endDateText: 16,
				subscriptionTypeText: 17,
				pendingBannerText: 18,
				redeemedBannerText: 19,
				activeStatusText: 20,
				pendingStatusText: 21,
				elementsOrder: 22,
				elementsHide: 23
			});
		}
	}

	const giftSubscriptionsListFactory = {
	    matches: (sectionElement, _form, _currentPart, _currentSection) => sectionElement.type === elementTypes.GIFT_SUBSCRIPTIONS_LIST,
	    create: (form, formState, formActions, elementConfig) => {
	        // Get all gift subscriptions from form state 
	        const giftSubscriptions = formState.giftSubscriptions || [];
	        // filter to only show sent gifts (where user is purchaser)
	        const activeGifts = giftSubscriptions.filter(gift => gift.is_purchaser === true);
	        const logEditSubscription = (gift) => {
	            logDataLayerEvent(form, 'zephr_form_subscription_change_clicked', {
	                productId: gift.subscription_type || 'gift',
	                planId: gift.subscription_number || gift.gift_code || ''
	            });
	        };
	        const logCancelSubscription = (gift) => {
	            logDataLayerEvent(form, 'zephr_form_cancel_subscription_clicked', {
	                productId: gift.subscription_type || 'gift',
	                planId: gift.subscription_number || gift.gift_code || ''
	            });
	        };
	        // Create elements hide object to match SubscriptionElementsHide
	        const elementsHide = {
	            subscriptionInformation: elementConfig?.hideSubscriptionInformation,
	            changePayment: elementConfig?.hideChangePayment,
	            changeSubscription: elementConfig?.hideChangeSubscription,
	            cancelSubscription: elementConfig?.hideCancelSubscription,
	            suspendResumeSubscription: elementConfig?.hideSuspendResumeSubscription,
	            billingHistory: elementConfig?.hideBillingHistory,
	            subscriptionCustomFields: elementConfig?.hideSubscriptionCustomFields,
	            updateBillToContact: elementConfig?.hideUpdateBillToContact
	        };
	        const cancelSubscriptionPath = elementConfig.cancelSubscriptionPath || '';
	        const changePaymentPath = ''; // Default empty string if not available in config
	        return {
	            component: GiftSubscriptionsList,
	            props: {
	                isPastSubscriptions: elementConfig.isPastSubscriptions,
	                billingHistoryText: elementConfig.billingHistoryText,
	                billingHistoryLink: elementConfig.billingHistoryLink,
	                changeSubscriptionPath: elementConfig.changeSubscriptionPath,
	                noSubscriptionsMessage: elementConfig.noSubscriptionsMessage || elementConfig.emptyMessage,
	                emptyMessage: elementConfig.emptyMessage,
	                loading: !formState.giftSubscriptions || formState.loadingGiftSubscriptions,
	                gifts: activeGifts,
	                changePaymentPath,
	                cancelSubscriptionPath,
	                changePaymentMethodText: elementConfig.changePaymentMethodText,
	                changeSubscriptionText: elementConfig.changeSubscriptionText,
	                cancelSubscriptionText: elementConfig.cancelSubscriptionText,
	                giftRecipientText: elementConfig.giftRecipientText,
	                startDateText: elementConfig.startDateText,
	                endDateText: elementConfig.endDateText,
	                pendingBannerText: elementConfig.pendingBannerText,
	                redeemedBannerText: elementConfig.redeemedBannerText,
	                activeStatusText: elementConfig.activeStatusText,
	                pendingStatusText: elementConfig.pendingStatusText,
	                subscriptionTypeText: elementConfig.subscriptionTypeText,
	                elementsOrder: elementConfig.elementsOrder,
	                elementsHide,
	                onSelectGift: (gift) => {
	                    formActions.updateFormState({
	                        selectedGiftSubscription: gift
	                    });
	                    formActions.jumpToPartStart('gift-details');
	                },
	                onEditSubscription: logEditSubscription,
	                onViewHistory: (subscription) => {
	                    formActions.updateFormState({
	                        selectedSubscription: subscription,
	                        selectedGiftSubscription: subscription
	                    });
	                    formActions.jumpToPartStart('billing-history');
	                    logDataLayerEvent(form, 'zephr_form_billing_history_view', null);
	                },
	                onCancelSubscription: logCancelSubscription,
	                onChangePayment: (subscription) => {
	                    formActions.updateFormState({
	                        selectedSubscription: subscription,
	                        selectedGiftSubscription: subscription
	                    });
	                    logDataLayerEvent(form, 'zephr_form_button_press', {
	                        sectionId: formState.currentSection.type,
	                        buttonType: 'SUBMIT'
	                    });
	                    formActions.completeSection();
	                },
	                logChangeSubscription: (subscription) => {
	                    logDataLayerEvent(form, 'zephr_form_subscription_change_clicked', {
	                        productId: subscription.productId,
	                        planId: subscription.externalId
	                    });
	                },
	                logCancelSubscription: (subscription) => {
	                    logDataLayerEvent(form, 'zephr_form_cancel_subscription_clicked', {
	                        productId: subscription.productId,
	                        planId: subscription.externalId
	                    });
	                },
	            }
	        };
	    }
	};

	/* src/components/elements/giftToggle/GiftToggle.svelte generated by Svelte v4.2.12 */

	function create_fragment$a(ctx) {
		let div;
		let checkbox;
		let current;

		checkbox = new Checkbox({
				props: {
					id: "gift-toggle-checkbox",
					name: "gift-toggle",
					label: /*config*/ ctx[0]?.label || '',
					value: "true",
					checked: /*checked*/ ctx[1],
					disabled: /*disabled*/ ctx[2],
					required: false
				}
			});

		checkbox.$on("change", /*handleChange*/ ctx[3]);

		return {
			c() {
				div = element("div");
				create_component(checkbox.$$.fragment);
				attr(div, "class", "zephr-form-gift-toggle svelte-93167f");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(checkbox, div, null);
				current = true;
			},
			p(ctx, [dirty]) {
				const checkbox_changes = {};
				if (dirty & /*config*/ 1) checkbox_changes.label = /*config*/ ctx[0]?.label || '';
				if (dirty & /*checked*/ 2) checkbox_changes.checked = /*checked*/ ctx[1];
				if (dirty & /*disabled*/ 4) checkbox_changes.disabled = /*disabled*/ ctx[2];
				checkbox.$set(checkbox_changes);
			},
			i(local) {
				if (current) return;
				transition_in(checkbox.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(checkbox.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(checkbox);
			}
		};
	}

	function instance$a($$self, $$props, $$invalidate) {
		let { config } = $$props;
		let { checked = false } = $$props;
		let { disabled = false } = $$props;
		let { onChange } = $$props;

		const handleChange = event => {
			const isChecked = event.detail;
			onChange(isChecked);
		};

		$$self.$$set = $$props => {
			if ('config' in $$props) $$invalidate(0, config = $$props.config);
			if ('checked' in $$props) $$invalidate(1, checked = $$props.checked);
			if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
			if ('onChange' in $$props) $$invalidate(4, onChange = $$props.onChange);
		};

		return [config, checked, disabled, handleChange, onChange];
	}

	class GiftToggle extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$a, create_fragment$a, safe_not_equal, {
				config: 0,
				checked: 1,
				disabled: 2,
				onChange: 4
			});
		}
	}

	const giftToggleFactory = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.GIFT_TOGGLE,
	    create: (form, formState, formActions, elementConfig) => {
	        // Only show if enabled
	        if (!elementConfig.enabled) {
	            return null;
	        }
	        const handleToggleChange = (isChecked) => {
	            const previousIsGiftForm = formState.isGiftForm;
	            formActions.updateFormState({
	                isGiftForm: isChecked
	            });
	            if (!isChecked && previousIsGiftForm) {
	                // When deselecting gift mode, only navigate if we're on gift-specific sections
	                if (formState.currentSection.type === 'recipient_details' && formState.giftTogglePreviousSection) {
	                    // If on recipient details, go back to where they were before enabling gift mode
	                    formActions.jumpToSection(formState.giftTogglePreviousSection);
	                }
	                // If on any other section (email, password, payment), stay on current section
	                // Clear the stored section
	                formActions.updateFormState({
	                    giftTogglePreviousSection: undefined
	                });
	            }
	            else if (isChecked && !previousIsGiftForm) {
	                // When enabling gift mode, always store current section (update it each time)
	                formActions.updateFormState({
	                    giftTogglePreviousSection: formState.currentSection.type
	                });
	                // Check if recipient details are valid before jumping
	                const recipientDetailsElementTypes = [
	                    elementTypes.RECIPIENT_NAME,
	                    elementTypes.RECIPIENT_EMAIL,
	                    elementTypes.RECIPIENT_ADDRESS,
	                    elementTypes.RECIPIENT_MESSAGE
	                ];
	                // Check if all recipient details elements are valid
	                const recipientDetailsValid = recipientDetailsElementTypes.every(elementType => {
	                    const elementValidity = formState.elementValidity.find(e => e.elementType === elementType &&
	                        e.sectionType === 'recipient_details');
	                    return elementValidity ? elementValidity.isValid : false;
	                });
	                // Only jump to recipient details if they are not valid
	                if (!recipientDetailsValid) {
	                    formActions.jumpToSection('recipient_details');
	                }
	                // If recipient details are valid, stay on current step
	            }
	            logDataLayerEvent(form, 'zephr_form_input_change', {
	                field: 'gift-toggle',
	                inputName: 'gift-toggle-checkbox',
	                sectionId: formState.currentSection.type,
	            });
	        };
	        return {
	            component: GiftToggle,
	            props: {
	                config: elementConfig,
	                checked: formState.isGiftForm || false,
	                disabled: formState.isBusy || formState.paymentProviderFormBusy || false,
	                onChange: handleToggleChange,
	            },
	            isValid: true,
	        };
	    },
	};

	/* src/components/elements/giftFutureDateToggle/GiftFutureDateToggle.svelte generated by Svelte v4.2.12 */

	function create_if_block$7(ctx) {
		let p;
		let t_value = /*config*/ ctx[0].description + "";
		let t;

		return {
			c() {
				p = element("p");
				t = text(t_value);
				attr(p, "class", "zephr-form-gift-future-date-toggle-description svelte-c9nudz");
			},
			m(target, anchor) {
				insert(target, p, anchor);
				append(p, t);
			},
			p(ctx, dirty) {
				if (dirty & /*config*/ 1 && t_value !== (t_value = /*config*/ ctx[0].description + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}
			}
		};
	}

	function create_fragment$9(ctx) {
		let div;
		let checkbox;
		let t;
		let current;

		checkbox = new Checkbox({
				props: {
					id: "gift-future-date-toggle-checkbox",
					name: "gift-future-date-toggle",
					label: /*config*/ ctx[0]?.label || '',
					value: "true",
					checked: /*checked*/ ctx[1],
					disabled: /*disabled*/ ctx[2],
					required: false
				}
			});

		checkbox.$on("change", /*handleChange*/ ctx[3]);
		let if_block = /*config*/ ctx[0]?.description && create_if_block$7(ctx);

		return {
			c() {
				div = element("div");
				create_component(checkbox.$$.fragment);
				t = space();
				if (if_block) if_block.c();
				attr(div, "class", "zephr-form-gift-future-date-toggle svelte-c9nudz");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(checkbox, div, null);
				append(div, t);
				if (if_block) if_block.m(div, null);
				current = true;
			},
			p(ctx, [dirty]) {
				const checkbox_changes = {};
				if (dirty & /*config*/ 1) checkbox_changes.label = /*config*/ ctx[0]?.label || '';
				if (dirty & /*checked*/ 2) checkbox_changes.checked = /*checked*/ ctx[1];
				if (dirty & /*disabled*/ 4) checkbox_changes.disabled = /*disabled*/ ctx[2];
				checkbox.$set(checkbox_changes);

				if (/*config*/ ctx[0]?.description) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block$7(ctx);
						if_block.c();
						if_block.m(div, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			i(local) {
				if (current) return;
				transition_in(checkbox.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(checkbox.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(checkbox);
				if (if_block) if_block.d();
			}
		};
	}

	function instance$9($$self, $$props, $$invalidate) {
		let { config } = $$props;
		let { checked = false } = $$props;
		let { disabled = false } = $$props;
		let { onChange } = $$props;

		const handleChange = event => {
			const isChecked = event.detail;
			onChange(isChecked);
		};

		$$self.$$set = $$props => {
			if ('config' in $$props) $$invalidate(0, config = $$props.config);
			if ('checked' in $$props) $$invalidate(1, checked = $$props.checked);
			if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
			if ('onChange' in $$props) $$invalidate(4, onChange = $$props.onChange);
		};

		return [config, checked, disabled, handleChange, onChange];
	}

	class GiftFutureDateToggle extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$9, create_fragment$9, safe_not_equal, {
				config: 0,
				checked: 1,
				disabled: 2,
				onChange: 4
			});
		}
	}

	const giftFutureDateToggleFactory = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.GIFT_FUTURE_DATE_TOGGLE,
	    create: (form, formState, formActions, elementConfig) => {
	        // Only show if enabled and in gift mode
	        if (!elementConfig.enabled || !formState.isGiftForm) {
	            return null;
	        }
	        const handleToggleChange = (isChecked) => {
	            formActions.updateFormState({
	                giftRecipient: {
	                    ...formState.giftRecipient,
	                    futureDeliveryEnabled: isChecked,
	                    // Clear the date if toggling off
	                    futureDeliveryDate: isChecked ? formState.giftRecipient?.futureDeliveryDate || '' : ''
	                }
	            });
	            logDataLayerEvent(form, 'zephr_form_input_change', {
	                field: 'gift-future-date-toggle',
	                inputName: 'gift-future-date-toggle-checkbox',
	                sectionId: formState.currentSection.type,
	            });
	        };
	        return {
	            component: GiftFutureDateToggle,
	            props: {
	                config: elementConfig,
	                checked: formState.giftRecipient?.futureDeliveryEnabled || false,
	                disabled: formState.isBusy || formState.paymentProviderFormBusy || false,
	                onChange: handleToggleChange,
	            },
	            isValid: true,
	        };
	    },
	};

	/* src/components/elements/giftFutureDateInput/GiftFutureDateInput.svelte generated by Svelte v4.2.12 */

	function create_if_block_1$6(ctx) {
		let label;
		let current;

		label = new Label({
				props: {
					for: "gift-future-date-input",
					required: /*config*/ ctx[0].required || false,
					$$slots: { default: [create_default_slot$2] },
					$$scope: { ctx }
				}
			});

		return {
			c() {
				create_component(label.$$.fragment);
			},
			m(target, anchor) {
				mount_component(label, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const label_changes = {};
				if (dirty & /*config*/ 1) label_changes.required = /*config*/ ctx[0].required || false;

				if (dirty & /*$$scope, config*/ 513) {
					label_changes.$$scope = { dirty, ctx };
				}

				label.$set(label_changes);
			},
			i(local) {
				if (current) return;
				transition_in(label.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(label.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(label, detaching);
			}
		};
	}

	// (25:4) <Label        for="gift-future-date-input"       required={config.required || false}     >
	function create_default_slot$2(ctx) {
		let t_value = /*config*/ ctx[0].label + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty & /*config*/ 1 && t_value !== (t_value = /*config*/ ctx[0].label + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (47:2) {#if config?.description}
	function create_if_block$6(ctx) {
		let p;
		let t_value = /*config*/ ctx[0].description + "";
		let t;

		return {
			c() {
				p = element("p");
				t = text(t_value);
				attr(p, "class", "zephr-form-gift-future-date-input-description svelte-1vykgtl");
			},
			m(target, anchor) {
				insert(target, p, anchor);
				append(p, t);
			},
			p(ctx, dirty) {
				if (dirty & /*config*/ 1 && t_value !== (t_value = /*config*/ ctx[0].description + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}
			}
		};
	}

	function create_fragment$8(ctx) {
		let div;
		let t0;
		let input;
		let t1;
		let current;
		let if_block0 = /*config*/ ctx[0]?.label && create_if_block_1$6(ctx);

		input = new Input({
				props: {
					id: "gift-future-date-input",
					name: "gift-future-date",
					type: "date",
					value: /*value*/ ctx[1],
					disabled: /*disabled*/ ctx[2],
					hasError: /*hasError*/ ctx[3],
					errorMessage: /*errorMessage*/ ctx[4],
					placeholder: /*config*/ ctx[0]?.placeholder || '',
					required: /*config*/ ctx[0]?.required || false,
					min: /*minDate*/ ctx[6]
				}
			});

		input.$on("change", /*handleChange*/ ctx[5]);
		let if_block1 = /*config*/ ctx[0]?.description && create_if_block$6(ctx);

		return {
			c() {
				div = element("div");
				if (if_block0) if_block0.c();
				t0 = space();
				create_component(input.$$.fragment);
				t1 = space();
				if (if_block1) if_block1.c();
				attr(div, "class", "zephr-form-gift-future-date-input svelte-1vykgtl");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append(div, t0);
				mount_component(input, div, null);
				append(div, t1);
				if (if_block1) if_block1.m(div, null);
				current = true;
			},
			p(ctx, [dirty]) {
				if (/*config*/ ctx[0]?.label) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*config*/ 1) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_1$6(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div, t0);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				const input_changes = {};
				if (dirty & /*value*/ 2) input_changes.value = /*value*/ ctx[1];
				if (dirty & /*disabled*/ 4) input_changes.disabled = /*disabled*/ ctx[2];
				if (dirty & /*hasError*/ 8) input_changes.hasError = /*hasError*/ ctx[3];
				if (dirty & /*errorMessage*/ 16) input_changes.errorMessage = /*errorMessage*/ ctx[4];
				if (dirty & /*config*/ 1) input_changes.placeholder = /*config*/ ctx[0]?.placeholder || '';
				if (dirty & /*config*/ 1) input_changes.required = /*config*/ ctx[0]?.required || false;
				input.$set(input_changes);

				if (/*config*/ ctx[0]?.description) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block$6(ctx);
						if_block1.c();
						if_block1.m(div, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(input.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(input.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (if_block0) if_block0.d();
				destroy_component(input);
				if (if_block1) if_block1.d();
			}
		};
	}

	function instance$8($$self, $$props, $$invalidate) {
		let { config } = $$props;
		let { value = '' } = $$props;
		let { disabled = false } = $$props;
		let { hasError = false } = $$props;
		let { errorMessage = '' } = $$props;
		let { onChange } = $$props;

		// Calculate tomorrow's date in YYYY-MM-DD format
		const getTomorrowDate = () => {
			const tomorrow = new Date();
			tomorrow.setDate(tomorrow.getDate() + 1);
			return tomorrow.toISOString().split('T')[0];
		};

		const handleChange = event => {
			const inputValue = event.detail;
			onChange(inputValue);
		};

		// Set minimum date to tomorrow
		const minDate = getTomorrowDate();

		$$self.$$set = $$props => {
			if ('config' in $$props) $$invalidate(0, config = $$props.config);
			if ('value' in $$props) $$invalidate(1, value = $$props.value);
			if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
			if ('hasError' in $$props) $$invalidate(3, hasError = $$props.hasError);
			if ('errorMessage' in $$props) $$invalidate(4, errorMessage = $$props.errorMessage);
			if ('onChange' in $$props) $$invalidate(7, onChange = $$props.onChange);
		};

		return [
			config,
			value,
			disabled,
			hasError,
			errorMessage,
			handleChange,
			minDate,
			onChange
		];
	}

	class GiftFutureDateInput extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$8, create_fragment$8, safe_not_equal, {
				config: 0,
				value: 1,
				disabled: 2,
				hasError: 3,
				errorMessage: 4,
				onChange: 7
			});
		}
	}

	const giftFutureDateInputFactory = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.GIFT_FUTURE_DATE_INPUT,
	    create: (form, formState, formActions, elementConfig) => {
	        // Only show if enabled, in gift mode, and future delivery is enabled
	        if (!elementConfig.enabled || !formState.isGiftForm || !formState.giftRecipient?.futureDeliveryEnabled) {
	            return null;
	        }
	        // Validation function
	        const validateDate = (value) => {
	            if (!value) {
	                return resolveLanguagePackKeyTyped(form, 'forms.errors.future-delivery-date-required', 'Please select a future delivery date');
	            }
	            if (value) {
	                const selectedDate = new Date(value);
	                const tomorrow = new Date();
	                tomorrow.setDate(tomorrow.getDate() + 1);
	                tomorrow.setHours(0, 0, 0, 0); // Reset time for date comparison
	                if (selectedDate < tomorrow) {
	                    return resolveLanguagePackKeyTyped(form, 'forms.errors.future-delivery-date-too-early', 'Delivery date must be at least 24 hours in the future');
	                }
	            }
	            return null;
	        };
	        const handleChange = (value) => {
	            formActions.updateFormState({
	                giftRecipient: {
	                    ...formState.giftRecipient,
	                    futureDeliveryDate: value
	                }
	            });
	            logDataLayerEvent(form, 'zephr_form_input_change', {
	                field: 'gift-future-date',
	                inputName: 'gift-future-date-input',
	                sectionId: formState.currentSection.type,
	            });
	        };
	        const currentValue = formState.giftRecipient?.futureDeliveryDate || '';
	        const errorMessage = validateDate(currentValue);
	        const isValid = !errorMessage;
	        return {
	            component: GiftFutureDateInput,
	            props: {
	                config: elementConfig,
	                value: currentValue,
	                disabled: formState.isBusy || formState.paymentProviderFormBusy || false,
	                hasError: !isValid,
	                errorMessage: errorMessage || '',
	                onChange: handleChange,
	            },
	            isValid,
	        };
	    },
	};

	/* src/components/elements/suspendResumeSubscription/SuspendResumeSubscription.svelte generated by Svelte v4.2.12 */

	function create_if_block_2$4(ctx) {
		let div;
		let t;

		return {
			c() {
				div = element("div");
				t = text(/*suspensionDateError*/ ctx[3]);
				attr(div, "class", "error-text svelte-1hog2jr");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty & /*suspensionDateError*/ 8) set_data(t, /*suspensionDateError*/ ctx[3]);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (88:6) {#if resumeDateError}
	function create_if_block_1$5(ctx) {
		let div;
		let t;

		return {
			c() {
				div = element("div");
				t = text(/*resumeDateError*/ ctx[4]);
				attr(div, "class", "error-text svelte-1hog2jr");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty & /*resumeDateError*/ 16) set_data(t, /*resumeDateError*/ ctx[4]);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (92:4) {#if generalError}
	function create_if_block$5(ctx) {
		let div;
		let t;

		return {
			c() {
				div = element("div");
				t = text(/*generalError*/ ctx[5]);
				attr(div, "class", "error-text svelte-1hog2jr");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty & /*generalError*/ 32) set_data(t, /*generalError*/ ctx[5]);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	function create_fragment$7(ctx) {
		let div2;
		let div0;
		let label0;
		let t0_value = /*config*/ ctx[0].suspensionDateLabel + "";
		let t0;
		let t1;
		let input0;
		let t2;
		let t3;
		let div1;
		let label1;
		let t4_value = /*config*/ ctx[0].resumeDateLabel + "";
		let t4;
		let t5;
		let input1;
		let t6;
		let t7;
		let mounted;
		let dispose;
		let if_block0 = /*suspensionDateError*/ ctx[3] && create_if_block_2$4(ctx);
		let if_block1 = /*resumeDateError*/ ctx[4] && create_if_block_1$5(ctx);
		let if_block2 = /*generalError*/ ctx[5] && create_if_block$5(ctx);

		return {
			c() {
				div2 = element("div");
				div0 = element("div");
				label0 = element("label");
				t0 = text(t0_value);
				t1 = space();
				input0 = element("input");
				t2 = space();
				if (if_block0) if_block0.c();
				t3 = space();
				div1 = element("div");
				label1 = element("label");
				t4 = text(t4_value);
				t5 = space();
				input1 = element("input");
				t6 = space();
				if (if_block1) if_block1.c();
				t7 = space();
				if (if_block2) if_block2.c();
				attr(label0, "for", "suspensionDate");
				attr(label0, "class", "svelte-1hog2jr");
				attr(input0, "id", "suspensionDate");
				attr(input0, "type", "date");
				input0.required = true;
				attr(input0, "class", "svelte-1hog2jr");
				toggle_class(input0, "error", !!/*suspensionDateError*/ ctx[3]);
				attr(div0, "class", "field svelte-1hog2jr");
				attr(label1, "for", "resumeDate");
				attr(label1, "class", "svelte-1hog2jr");
				attr(input1, "id", "resumeDate");
				attr(input1, "type", "date");
				input1.required = true;
				attr(input1, "class", "svelte-1hog2jr");
				toggle_class(input1, "error", !!/*resumeDateError*/ ctx[4]);
				attr(div1, "class", "field svelte-1hog2jr");
				attr(div2, "class", "suspend-resume-subscription-section svelte-1hog2jr");
			},
			m(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div0);
				append(div0, label0);
				append(label0, t0);
				append(div0, t1);
				append(div0, input0);
				set_input_value(input0, /*suspensionDate*/ ctx[1]);
				append(div0, t2);
				if (if_block0) if_block0.m(div0, null);
				append(div2, t3);
				append(div2, div1);
				append(div1, label1);
				append(label1, t4);
				append(div1, t5);
				append(div1, input1);
				set_input_value(input1, /*resumeDate*/ ctx[2]);
				append(div1, t6);
				if (if_block1) if_block1.m(div1, null);
				append(div2, t7);
				if (if_block2) if_block2.m(div2, null);

				if (!mounted) {
					dispose = [
						listen(input0, "input", /*input0_input_handler*/ ctx[9]),
						listen(input0, "input", /*updateSuspendResumeSubscription*/ ctx[6]),
						listen(input1, "input", /*input1_input_handler*/ ctx[10]),
						listen(input1, "input", /*updateSuspendResumeSubscription*/ ctx[6])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (dirty & /*config*/ 1 && t0_value !== (t0_value = /*config*/ ctx[0].suspensionDateLabel + "")) set_data(t0, t0_value);

				if (dirty & /*suspensionDate*/ 2) {
					set_input_value(input0, /*suspensionDate*/ ctx[1]);
				}

				if (dirty & /*suspensionDateError*/ 8) {
					toggle_class(input0, "error", !!/*suspensionDateError*/ ctx[3]);
				}

				if (/*suspensionDateError*/ ctx[3]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_2$4(ctx);
						if_block0.c();
						if_block0.m(div0, null);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (dirty & /*config*/ 1 && t4_value !== (t4_value = /*config*/ ctx[0].resumeDateLabel + "")) set_data(t4, t4_value);

				if (dirty & /*resumeDate*/ 4) {
					set_input_value(input1, /*resumeDate*/ ctx[2]);
				}

				if (dirty & /*resumeDateError*/ 16) {
					toggle_class(input1, "error", !!/*resumeDateError*/ ctx[4]);
				}

				if (/*resumeDateError*/ ctx[4]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_1$5(ctx);
						if_block1.c();
						if_block1.m(div1, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (/*generalError*/ ctx[5]) {
					if (if_block2) {
						if_block2.p(ctx, dirty);
					} else {
						if_block2 = create_if_block$5(ctx);
						if_block2.c();
						if_block2.m(div2, null);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(div2);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$7($$self, $$props, $$invalidate) {
		let { formState } = $$props;
		let { formActions } = $$props;
		let { config } = $$props;
		const dispatch = createEventDispatcher();
		let suspensionDate = formState.suspendResumeSubscription?.suspensionDate || '';
		let resumeDate = formState.suspendResumeSubscription?.resumeDate || '';
		let suspensionDateError = '';
		let resumeDateError = '';
		let generalError = '';

		// Update form state when input changes
		const updateSuspendResumeSubscription = () => {
			const updatedSuspendResumeSubscription = {
				...formState.suspendResumeSubscription || {},
				suspensionDate,
				resumeDate
			};

			formActions.updateFormState({
				suspendResumeSubscription: updatedSuspendResumeSubscription
			});

			validateForm();
		};

		const validateForm = () => {
			const hasValidSuspensionDate = !!suspensionDate.trim();
			const hasValidResumeDate = !!resumeDate.trim();
			const today = new Date();
			today.setHours(0, 0, 0, 0); // Reset time to start of day for accurate comparison
			const suspensionDateObj = new Date(suspensionDate);
			const resumeDateObj = new Date(resumeDate);
			const isSuspensionDateInPast = hasValidSuspensionDate && suspensionDateObj < today;
			const isSuspensionDateBeforeResumeDate = hasValidSuspensionDate && hasValidResumeDate && suspensionDateObj < resumeDateObj;

			// Reset errors
			$$invalidate(3, suspensionDateError = '');

			$$invalidate(4, resumeDateError = '');
			$$invalidate(5, generalError = '');

			if (!hasValidSuspensionDate) {
				$$invalidate(3, suspensionDateError = 'Suspension date is required');
			} else if (isSuspensionDateInPast) {
				$$invalidate(3, suspensionDateError = 'Suspension date cannot be in the past');
			}

			if (!hasValidResumeDate) {
				$$invalidate(4, resumeDateError = 'Resume date is required');
			}

			if (hasValidSuspensionDate && hasValidResumeDate && !isSuspensionDateBeforeResumeDate) {
				$$invalidate(5, generalError = 'Resume date must be after suspension date');
			}

			// Dispatch event for form validity
			const isValid = hasValidSuspensionDate && hasValidResumeDate && !isSuspensionDateInPast && isSuspensionDateBeforeResumeDate;

			dispatch('validity', { isValid });
		};

		// Run validation on mount to ensure initial state is validated
		onMount(() => {
			validateForm();
		});

		function input0_input_handler() {
			suspensionDate = this.value;
			$$invalidate(1, suspensionDate);
		}

		function input1_input_handler() {
			resumeDate = this.value;
			$$invalidate(2, resumeDate);
		}

		$$self.$$set = $$props => {
			if ('formState' in $$props) $$invalidate(7, formState = $$props.formState);
			if ('formActions' in $$props) $$invalidate(8, formActions = $$props.formActions);
			if ('config' in $$props) $$invalidate(0, config = $$props.config);
		};

		return [
			config,
			suspensionDate,
			resumeDate,
			suspensionDateError,
			resumeDateError,
			generalError,
			updateSuspendResumeSubscription,
			formState,
			formActions,
			input0_input_handler,
			input1_input_handler
		];
	}

	class SuspendResumeSubscription extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$7, create_fragment$7, safe_not_equal, { formState: 7, formActions: 8, config: 0 });
		}
	}

	const suspendResumeSubscriptionFactory = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.SUSPEND_RESUME_SUBSCRIPTION,
	    create: (form, formState, formActions, elementConfig) => {
	        // Resolve all labels through language pack service
	        const resolvedConfig = {
	            suspensionDateLabel: resolveLanguagePackKeyTyped(form, 'forms.suspend-resume-subscription.suspension-date-label', elementConfig.suspensionDateLabel),
	            resumeDateLabel: resolveLanguagePackKeyTyped(form, 'forms.suspend-resume-subscription.resume-date-label', elementConfig.resumeDateLabel),
	        };
	        // Determine if the input is valid
	        const suspendResumeSubscription = (formState.suspendResumeSubscription || {});
	        const hasValidSuspensionDate = !!suspendResumeSubscription.suspensionDate?.trim();
	        const hasValidResumeDate = !!suspendResumeSubscription.resumeDate?.trim();
	        // Check if suspension date is in the past
	        const today = new Date();
	        today.setHours(0, 0, 0, 0); // Reset time to start of day for accurate comparison
	        const suspensionDateObj = new Date(suspendResumeSubscription.suspensionDate);
	        const isSuspensionDateInPast = hasValidSuspensionDate && suspensionDateObj < today;
	        const resumeDateObj = new Date(suspendResumeSubscription.resumeDate);
	        const isSuspensionDateBeforeResumeDate = hasValidSuspensionDate && hasValidResumeDate && suspensionDateObj < resumeDateObj;
	        const isValid = hasValidSuspensionDate &&
	            hasValidResumeDate &&
	            !isSuspensionDateInPast &&
	            isSuspensionDateBeforeResumeDate;
	        return {
	            component: SuspendResumeSubscription,
	            props: {
	                config: resolvedConfig,
	                form,
	                formState,
	                formActions,
	            },
	            isValid
	        };
	    }
	};

	/* src/components/elements/subscriptionCustomFieldsUpdate/SubscriptionCustomFieldsUpdate.svelte generated by Svelte v4.2.12 */

	function get_each_context$3(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[30] = list[i];
		child_ctx[31] = list;
		child_ctx[32] = i;
		return child_ctx;
	}

	// (140:2) {#if title}
	function create_if_block_8(ctx) {
		let h3;
		let t;

		return {
			c() {
				h3 = element("h3");
				t = text(/*title*/ ctx[0]);
				attr(h3, "class", "title svelte-t6s0pv");
			},
			m(target, anchor) {
				insert(target, h3, anchor);
				append(h3, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*title*/ 1) set_data(t, /*title*/ ctx[0]);
			},
			d(detaching) {
				if (detaching) {
					detach(h3);
				}
			}
		};
	}

	// (144:2) {#if description}
	function create_if_block_7(ctx) {
		let p;
		let t;

		return {
			c() {
				p = element("p");
				t = text(/*description*/ ctx[1]);
				attr(p, "class", "description svelte-t6s0pv");
			},
			m(target, anchor) {
				insert(target, p, anchor);
				append(p, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*description*/ 2) set_data(t, /*description*/ ctx[1]);
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}
			}
		};
	}

	// (148:2) {#if selectedSubscription}
	function create_if_block_6$2(ctx) {
		let div;
		let p;
		let strong;
		let t1;
		let t2_value = (/*selectedSubscription*/ ctx[9].productLabel || /*selectedSubscription*/ ctx[9].externalId) + "";
		let t2;

		return {
			c() {
				div = element("div");
				p = element("p");
				strong = element("strong");
				strong.textContent = "Subscription:";
				t1 = space();
				t2 = text(t2_value);
				attr(div, "class", "subscription-info svelte-t6s0pv");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, p);
				append(p, strong);
				append(p, t1);
				append(p, t2);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*selectedSubscription*/ 512 && t2_value !== (t2_value = (/*selectedSubscription*/ ctx[9].productLabel || /*selectedSubscription*/ ctx[9].externalId) + "")) set_data(t2, t2_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (157:8) <Label forInput={fieldConfig.fieldName}>
	function create_default_slot$1(ctx) {
		let t_value = /*fieldConfig*/ ctx[30].label + "";
		let t;

		return {
			c() {
				t = text(t_value);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*customFields*/ 64 && t_value !== (t_value = /*fieldConfig*/ ctx[30].label + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (173:8) {:else}
	function create_else_block_1(ctx) {
		let input;
		let current;

		function change_handler(...args) {
			return /*change_handler*/ ctx[24](/*fieldConfig*/ ctx[30], ...args);
		}

		function blur_handler_1() {
			return /*blur_handler_1*/ ctx[25](/*fieldConfig*/ ctx[30]);
		}

		input = new Input({
				props: {
					id: /*fieldConfig*/ ctx[30].fieldName,
					name: /*fieldConfig*/ ctx[30].fieldName,
					type: /*fieldConfig*/ ctx[30].fieldType || 'text',
					placeholder: /*fieldConfig*/ ctx[30].placeholder || '',
					value: /*formValues*/ ctx[11][/*fieldConfig*/ ctx[30].fieldName] || '',
					disabled: /*isLoading*/ ctx[8],
					maxlength: /*fieldConfig*/ ctx[30].maxLength,
					hasError: !!/*formErrors*/ ctx[12][/*fieldConfig*/ ctx[30].fieldName],
					onFocus: func,
					onBlur: func_1
				}
			});

		input.$on("change", change_handler);
		input.$on("blur", blur_handler_1);

		return {
			c() {
				create_component(input.$$.fragment);
			},
			m(target, anchor) {
				mount_component(input, target, anchor);
				current = true;
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				const input_changes = {};
				if (dirty[0] & /*customFields*/ 64) input_changes.id = /*fieldConfig*/ ctx[30].fieldName;
				if (dirty[0] & /*customFields*/ 64) input_changes.name = /*fieldConfig*/ ctx[30].fieldName;
				if (dirty[0] & /*customFields*/ 64) input_changes.type = /*fieldConfig*/ ctx[30].fieldType || 'text';
				if (dirty[0] & /*customFields*/ 64) input_changes.placeholder = /*fieldConfig*/ ctx[30].placeholder || '';
				if (dirty[0] & /*formValues, customFields*/ 2112) input_changes.value = /*formValues*/ ctx[11][/*fieldConfig*/ ctx[30].fieldName] || '';
				if (dirty[0] & /*isLoading*/ 256) input_changes.disabled = /*isLoading*/ ctx[8];
				if (dirty[0] & /*customFields*/ 64) input_changes.maxlength = /*fieldConfig*/ ctx[30].maxLength;
				if (dirty[0] & /*formErrors, customFields*/ 4160) input_changes.hasError = !!/*formErrors*/ ctx[12][/*fieldConfig*/ ctx[30].fieldName];
				input.$set(input_changes);
			},
			i(local) {
				if (current) return;
				transition_in(input.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(input.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(input, detaching);
			}
		};
	}

	// (161:8) {#if fieldConfig.fieldType === 'textarea'}
	function create_if_block_5$2(ctx) {
		let textarea;
		let textarea_id_value;
		let textarea_name_value;
		let textarea_placeholder_value;
		let textarea_maxlength_value;
		let mounted;
		let dispose;

		function textarea_input_handler() {
			/*textarea_input_handler*/ ctx[22].call(textarea, /*fieldConfig*/ ctx[30]);
		}

		function blur_handler() {
			return /*blur_handler*/ ctx[23](/*fieldConfig*/ ctx[30]);
		}

		return {
			c() {
				textarea = element("textarea");
				attr(textarea, "id", textarea_id_value = /*fieldConfig*/ ctx[30].fieldName);
				attr(textarea, "name", textarea_name_value = /*fieldConfig*/ ctx[30].fieldName);
				attr(textarea, "placeholder", textarea_placeholder_value = /*fieldConfig*/ ctx[30].placeholder || '');
				textarea.disabled = /*isLoading*/ ctx[8];
				attr(textarea, "maxlength", textarea_maxlength_value = /*fieldConfig*/ ctx[30].maxLength);
				attr(textarea, "class", "textarea-input svelte-t6s0pv");
				toggle_class(textarea, "error", /*formErrors*/ ctx[12][/*fieldConfig*/ ctx[30].fieldName]);
			},
			m(target, anchor) {
				insert(target, textarea, anchor);
				set_input_value(textarea, /*formValues*/ ctx[11][/*fieldConfig*/ ctx[30].fieldName]);

				if (!mounted) {
					dispose = [
						listen(textarea, "input", textarea_input_handler),
						listen(textarea, "blur", blur_handler)
					];

					mounted = true;
				}
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;

				if (dirty[0] & /*customFields*/ 64 && textarea_id_value !== (textarea_id_value = /*fieldConfig*/ ctx[30].fieldName)) {
					attr(textarea, "id", textarea_id_value);
				}

				if (dirty[0] & /*customFields*/ 64 && textarea_name_value !== (textarea_name_value = /*fieldConfig*/ ctx[30].fieldName)) {
					attr(textarea, "name", textarea_name_value);
				}

				if (dirty[0] & /*customFields*/ 64 && textarea_placeholder_value !== (textarea_placeholder_value = /*fieldConfig*/ ctx[30].placeholder || '')) {
					attr(textarea, "placeholder", textarea_placeholder_value);
				}

				if (dirty[0] & /*isLoading*/ 256) {
					textarea.disabled = /*isLoading*/ ctx[8];
				}

				if (dirty[0] & /*customFields*/ 64 && textarea_maxlength_value !== (textarea_maxlength_value = /*fieldConfig*/ ctx[30].maxLength)) {
					attr(textarea, "maxlength", textarea_maxlength_value);
				}

				if (dirty[0] & /*formValues, customFields*/ 2112) {
					set_input_value(textarea, /*formValues*/ ctx[11][/*fieldConfig*/ ctx[30].fieldName]);
				}

				if (dirty[0] & /*formErrors, customFields*/ 4160) {
					toggle_class(textarea, "error", /*formErrors*/ ctx[12][/*fieldConfig*/ ctx[30].fieldName]);
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(textarea);
				}

				mounted = false;
				run_all(dispose);
			}
		};
	}

	// (190:8) {#if formErrors[fieldConfig.fieldName]}
	function create_if_block_4$2(ctx) {
		let errormessage;
		let current;

		errormessage = new ErrorMessage({
				props: {
					error: /*formErrors*/ ctx[12][/*fieldConfig*/ ctx[30].fieldName]
				}
			});

		return {
			c() {
				create_component(errormessage.$$.fragment);
			},
			m(target, anchor) {
				mount_component(errormessage, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const errormessage_changes = {};
				if (dirty[0] & /*formErrors, customFields*/ 4160) errormessage_changes.error = /*formErrors*/ ctx[12][/*fieldConfig*/ ctx[30].fieldName];
				errormessage.$set(errormessage_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errormessage.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errormessage.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(errormessage, detaching);
			}
		};
	}

	// (155:4) {#each customFields as fieldConfig}
	function create_each_block$3(ctx) {
		let div;
		let label;
		let t0;
		let current_block_type_index;
		let if_block0;
		let t1;
		let current;

		label = new Label({
				props: {
					forInput: /*fieldConfig*/ ctx[30].fieldName,
					$$slots: { default: [create_default_slot$1] },
					$$scope: { ctx }
				}
			});

		const if_block_creators = [create_if_block_5$2, create_else_block_1];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*fieldConfig*/ ctx[30].fieldType === 'textarea') return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		let if_block1 = /*formErrors*/ ctx[12][/*fieldConfig*/ ctx[30].fieldName] && create_if_block_4$2(ctx);

		return {
			c() {
				div = element("div");
				create_component(label.$$.fragment);
				t0 = space();
				if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				attr(div, "class", "field-group svelte-t6s0pv");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(label, div, null);
				append(div, t0);
				if_blocks[current_block_type_index].m(div, null);
				append(div, t1);
				if (if_block1) if_block1.m(div, null);
				current = true;
			},
			p(ctx, dirty) {
				const label_changes = {};
				if (dirty[0] & /*customFields*/ 64) label_changes.forInput = /*fieldConfig*/ ctx[30].fieldName;

				if (dirty[0] & /*customFields*/ 64 | dirty[1] & /*$$scope*/ 4) {
					label_changes.$$scope = { dirty, ctx };
				}

				label.$set(label_changes);
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block0 = if_blocks[current_block_type_index];

					if (!if_block0) {
						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block0.c();
					} else {
						if_block0.p(ctx, dirty);
					}

					transition_in(if_block0, 1);
					if_block0.m(div, t1);
				}

				if (/*formErrors*/ ctx[12][/*fieldConfig*/ ctx[30].fieldName]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty[0] & /*formErrors, customFields*/ 4160) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_4$2(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div, null);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(label.$$.fragment, local);
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(label.$$.fragment, local);
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(label);
				if_blocks[current_block_type_index].d();
				if (if_block1) if_block1.d();
			}
		};
	}

	// (196:4) {#if submitError}
	function create_if_block_3$3(ctx) {
		let div;
		let errormessage;
		let current;

		errormessage = new ErrorMessage({
				props: { error: /*submitError*/ ctx[14] }
			});

		return {
			c() {
				div = element("div");
				create_component(errormessage.$$.fragment);
				attr(div, "class", "error-message svelte-t6s0pv");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(errormessage, div, null);
				current = true;
			},
			p(ctx, dirty) {
				const errormessage_changes = {};
				if (dirty[0] & /*submitError*/ 16384) errormessage_changes.error = /*submitError*/ ctx[14];
				errormessage.$set(errormessage_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errormessage.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errormessage.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(errormessage);
			}
		};
	}

	// (202:4) {#if submitSuccess && showSuccessInline}
	function create_if_block_2$3(ctx) {
		let div;
		let p;
		let t;

		return {
			c() {
				div = element("div");
				p = element("p");
				t = text(/*successMessage*/ ctx[3]);
				attr(p, "class", "success-text svelte-t6s0pv");
				attr(div, "class", "success-message svelte-t6s0pv");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, p);
				append(p, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*successMessage*/ 8) set_data(t, /*successMessage*/ ctx[3]);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (213:8) {:else}
	function create_else_block$1(ctx) {
		let t;

		return {
			c() {
				t = text(/*submitButtonText*/ ctx[4]);
			},
			m(target, anchor) {
				insert(target, t, anchor);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*submitButtonText*/ 16) set_data(t, /*submitButtonText*/ ctx[4]);
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(t);
				}
			}
		};
	}

	// (210:8) {#if isLoading}
	function create_if_block_1$4(ctx) {
		let spinner;
		let t0;
		let span;
		let t1;
		let current;
		spinner = new Spinner({});

		return {
			c() {
				create_component(spinner.$$.fragment);
				t0 = space();
				span = element("span");
				t1 = text(/*loadingText*/ ctx[2]);
			},
			m(target, anchor) {
				mount_component(spinner, target, anchor);
				insert(target, t0, anchor);
				insert(target, span, anchor);
				append(span, t1);
				current = true;
			},
			p(ctx, dirty) {
				if (!current || dirty[0] & /*loadingText*/ 4) set_data(t1, /*loadingText*/ ctx[2]);
			},
			i(local) {
				if (current) return;
				transition_in(spinner.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(spinner.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t0);
					detach(span);
				}

				destroy_component(spinner, detaching);
			}
		};
	}

	// (218:6) {#if onCancel}
	function create_if_block$4(ctx) {
		let button;
		let t;
		let mounted;
		let dispose;

		return {
			c() {
				button = element("button");
				t = text(/*cancelButtonText*/ ctx[5]);
				attr(button, "type", "button");
				button.disabled = /*isLoading*/ ctx[8];
				attr(button, "class", "cancel-button svelte-t6s0pv");
			},
			m(target, anchor) {
				insert(target, button, anchor);
				append(button, t);

				if (!mounted) {
					dispose = listen(button, "click", /*handleCancel*/ ctx[18]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*cancelButtonText*/ 32) set_data(t, /*cancelButtonText*/ ctx[5]);

				if (dirty[0] & /*isLoading*/ 256) {
					button.disabled = /*isLoading*/ ctx[8];
				}
			},
			d(detaching) {
				if (detaching) {
					detach(button);
				}

				mounted = false;
				dispose();
			}
		};
	}

	function create_fragment$6(ctx) {
		let div1;
		let t0;
		let t1;
		let t2;
		let form;
		let t3;
		let t4;
		let t5;
		let div0;
		let button;
		let current_block_type_index;
		let if_block5;
		let t6;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*title*/ ctx[0] && create_if_block_8(ctx);
		let if_block1 = /*description*/ ctx[1] && create_if_block_7(ctx);
		let if_block2 = /*selectedSubscription*/ ctx[9] && create_if_block_6$2(ctx);
		let each_value = ensure_array_like(/*customFields*/ ctx[6]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		let if_block3 = /*submitError*/ ctx[14] && create_if_block_3$3(ctx);
		let if_block4 = /*submitSuccess*/ ctx[13] && /*showSuccessInline*/ ctx[7] && create_if_block_2$3(ctx);
		const if_block_creators = [create_if_block_1$4, create_else_block$1];
		const if_blocks = [];

		function select_block_type_1(ctx, dirty) {
			if (/*isLoading*/ ctx[8]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_1(ctx);
		if_block5 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		let if_block6 = /*onCancel*/ ctx[10] && create_if_block$4(ctx);

		return {
			c() {
				div1 = element("div");
				if (if_block0) if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				t2 = space();
				form = element("form");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t3 = space();
				if (if_block3) if_block3.c();
				t4 = space();
				if (if_block4) if_block4.c();
				t5 = space();
				div0 = element("div");
				button = element("button");
				if_block5.c();
				t6 = space();
				if (if_block6) if_block6.c();
				attr(button, "type", "submit");
				button.disabled = /*isLoading*/ ctx[8];
				attr(button, "class", "submit-button svelte-t6s0pv");
				attr(div0, "class", "button-group svelte-t6s0pv");
				attr(form, "class", "custom-fields-form svelte-t6s0pv");
				attr(div1, "class", "subscription-custom-fields-update svelte-t6s0pv");
			},
			m(target, anchor) {
				insert(target, div1, anchor);
				if (if_block0) if_block0.m(div1, null);
				append(div1, t0);
				if (if_block1) if_block1.m(div1, null);
				append(div1, t1);
				if (if_block2) if_block2.m(div1, null);
				append(div1, t2);
				append(div1, form);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(form, null);
					}
				}

				append(form, t3);
				if (if_block3) if_block3.m(form, null);
				append(form, t4);
				if (if_block4) if_block4.m(form, null);
				append(form, t5);
				append(form, div0);
				append(div0, button);
				if_blocks[current_block_type_index].m(button, null);
				append(div0, t6);
				if (if_block6) if_block6.m(div0, null);
				current = true;

				if (!mounted) {
					dispose = listen(form, "submit", /*handleSubmit*/ ctx[17]);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (/*title*/ ctx[0]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_8(ctx);
						if_block0.c();
						if_block0.m(div1, t0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*description*/ ctx[1]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_7(ctx);
						if_block1.c();
						if_block1.m(div1, t1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (/*selectedSubscription*/ ctx[9]) {
					if (if_block2) {
						if_block2.p(ctx, dirty);
					} else {
						if_block2 = create_if_block_6$2(ctx);
						if_block2.c();
						if_block2.m(div1, t2);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}

				if (dirty[0] & /*formErrors, customFields, isLoading, formValues, handleFieldBlur, handleFieldChange*/ 104768) {
					each_value = ensure_array_like(/*customFields*/ ctx[6]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$3(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$3(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(form, t3);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (/*submitError*/ ctx[14]) {
					if (if_block3) {
						if_block3.p(ctx, dirty);

						if (dirty[0] & /*submitError*/ 16384) {
							transition_in(if_block3, 1);
						}
					} else {
						if_block3 = create_if_block_3$3(ctx);
						if_block3.c();
						transition_in(if_block3, 1);
						if_block3.m(form, t4);
					}
				} else if (if_block3) {
					group_outros();

					transition_out(if_block3, 1, 1, () => {
						if_block3 = null;
					});

					check_outros();
				}

				if (/*submitSuccess*/ ctx[13] && /*showSuccessInline*/ ctx[7]) {
					if (if_block4) {
						if_block4.p(ctx, dirty);
					} else {
						if_block4 = create_if_block_2$3(ctx);
						if_block4.c();
						if_block4.m(form, t5);
					}
				} else if (if_block4) {
					if_block4.d(1);
					if_block4 = null;
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block5 = if_blocks[current_block_type_index];

					if (!if_block5) {
						if_block5 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block5.c();
					} else {
						if_block5.p(ctx, dirty);
					}

					transition_in(if_block5, 1);
					if_block5.m(button, null);
				}

				if (!current || dirty[0] & /*isLoading*/ 256) {
					button.disabled = /*isLoading*/ ctx[8];
				}

				if (/*onCancel*/ ctx[10]) {
					if (if_block6) {
						if_block6.p(ctx, dirty);
					} else {
						if_block6 = create_if_block$4(ctx);
						if_block6.c();
						if_block6.m(div0, null);
					}
				} else if (if_block6) {
					if_block6.d(1);
					if_block6 = null;
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				transition_in(if_block3);
				transition_in(if_block5);
				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				transition_out(if_block3);
				transition_out(if_block5);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div1);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
				destroy_each(each_blocks, detaching);
				if (if_block3) if_block3.d();
				if (if_block4) if_block4.d();
				if_blocks[current_block_type_index].d();
				if (if_block6) if_block6.d();
				mounted = false;
				dispose();
			}
		};
	}

	function validateField(fieldConfig, value) {
		if (fieldConfig.required && (!value || value.trim() === '')) {
			return `${fieldConfig.label} is required`;
		}

		if (fieldConfig.maxLength && value.length > fieldConfig.maxLength) {
			return `${fieldConfig.label} must be ${fieldConfig.maxLength} characters or less`;
		}

		if (fieldConfig.validation?.pattern && value) {
			const regex = new RegExp(fieldConfig.validation.pattern);

			if (!regex.test(value)) {
				return fieldConfig.validation.message || `${fieldConfig.label} format is invalid`;
			}
		}

		return '';
	}

	const func = () => {
		
	};

	const func_1 = () => {
		
	};

	function instance$6($$self, $$props, $$invalidate) {
		let { title = 'Update Subscription Details' } = $$props;
		let { description = '' } = $$props;
		let { loadingText = 'Updating...' } = $$props;
		let { successMessage = 'Custom fields updated successfully' } = $$props;
		let { errorMessage = 'Failed to update custom fields' } = $$props;
		let { submitButtonText = 'Update Details' } = $$props;
		let { cancelButtonText = 'Cancel' } = $$props;
		let { customFields = [] } = $$props;
		let { validateOnBlur = true } = $$props;
		let { showSuccessInline = true } = $$props;
		let { isLoading = false } = $$props;
		let { selectedSubscription = null } = $$props;
		let { onSubmit } = $$props;
		let { onCancel = null } = $$props;
		const dispatch = createEventDispatcher();

		// Form state
		let formValues = {};

		let formErrors = {};
		let formTouched = {};
		let submitAttempted = false;
		let submitSuccess = false;
		let submitError = '';

		// eslint-disable-next-line no-inner-declarations
		function handleFieldChange(fieldName, value) {
			$$invalidate(11, formValues[fieldName] = value, formValues);

			if (validateOnBlur && (formTouched[fieldName] || submitAttempted)) {
				const fieldConfig = customFields.find(f => f.fieldName === fieldName);

				if (fieldConfig) {
					const error = validateField(fieldConfig, value);

					if (error) {
						$$invalidate(12, formErrors[fieldName] = error, formErrors);
					} else {
						delete formErrors[fieldName];
					}

					$$invalidate(12, formErrors = { ...formErrors });
				}
			}
		}

		// eslint-disable-next-line no-inner-declarations
		function handleFieldBlur(fieldName) {
			formTouched[fieldName] = true;

			if (validateOnBlur) {
				const fieldConfig = customFields.find(f => f.fieldName === fieldName);

				if (fieldConfig) {
					const error = validateField(fieldConfig, formValues[fieldName] || '');

					if (error) {
						$$invalidate(12, formErrors[fieldName] = error, formErrors);
					} else {
						delete formErrors[fieldName];
					}

					$$invalidate(12, formErrors = { ...formErrors });
				}
			}
		}

		// eslint-disable-next-line no-inner-declarations
		function validateForm() {
			let isValid = true;
			const newErrors = {};

			customFields.forEach(fieldConfig => {
				const value = formValues[fieldConfig.fieldName] || '';
				const error = validateField(fieldConfig, value);

				if (error) {
					newErrors[fieldConfig.fieldName] = error;
					isValid = false;
				}
			});

			$$invalidate(12, formErrors = newErrors);
			return isValid;
		}

		// eslint-disable-next-line no-inner-declarations
		async function handleSubmit(event) {
			event.preventDefault();
			submitAttempted = true;
			$$invalidate(13, submitSuccess = false);
			$$invalidate(14, submitError = '');

			if (!selectedSubscription?.externalId) {
				$$invalidate(14, submitError = 'No subscription selected');
				return;
			}

			if (!validateForm()) {
				return;
			}

			try {
				await onSubmit(formValues);
				$$invalidate(13, submitSuccess = true);

				if (showSuccessInline) {
					setTimeout(
						() => {
							$$invalidate(13, submitSuccess = false);
						},
						3000
					);
				}

				dispatch('success', { values: formValues });
			} catch(error) {
				console.error('Error updating custom fields:', error);
				$$invalidate(14, submitError = error?.message || errorMessage);
				dispatch('error', { error });
			}
		}

		// eslint-disable-next-line no-inner-declarations
		function handleCancel() {
			if (onCancel) {
				onCancel();
			} else {
				dispatch('cancel');
			}
		}

		function textarea_input_handler(fieldConfig) {
			formValues[fieldConfig.fieldName] = this.value;
			(($$invalidate(11, formValues), $$invalidate(9, selectedSubscription)), $$invalidate(6, customFields));
		}

		const blur_handler = fieldConfig => handleFieldBlur(fieldConfig.fieldName);
		const change_handler = (fieldConfig, e) => handleFieldChange(fieldConfig.fieldName, String(e.detail));
		const blur_handler_1 = fieldConfig => handleFieldBlur(fieldConfig.fieldName);

		$$self.$$set = $$props => {
			if ('title' in $$props) $$invalidate(0, title = $$props.title);
			if ('description' in $$props) $$invalidate(1, description = $$props.description);
			if ('loadingText' in $$props) $$invalidate(2, loadingText = $$props.loadingText);
			if ('successMessage' in $$props) $$invalidate(3, successMessage = $$props.successMessage);
			if ('errorMessage' in $$props) $$invalidate(19, errorMessage = $$props.errorMessage);
			if ('submitButtonText' in $$props) $$invalidate(4, submitButtonText = $$props.submitButtonText);
			if ('cancelButtonText' in $$props) $$invalidate(5, cancelButtonText = $$props.cancelButtonText);
			if ('customFields' in $$props) $$invalidate(6, customFields = $$props.customFields);
			if ('validateOnBlur' in $$props) $$invalidate(20, validateOnBlur = $$props.validateOnBlur);
			if ('showSuccessInline' in $$props) $$invalidate(7, showSuccessInline = $$props.showSuccessInline);
			if ('isLoading' in $$props) $$invalidate(8, isLoading = $$props.isLoading);
			if ('selectedSubscription' in $$props) $$invalidate(9, selectedSubscription = $$props.selectedSubscription);
			if ('onSubmit' in $$props) $$invalidate(21, onSubmit = $$props.onSubmit);
			if ('onCancel' in $$props) $$invalidate(10, onCancel = $$props.onCancel);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty[0] & /*selectedSubscription, formValues, customFields*/ 2624) {
				// Initialize form values with existing values on the subscription object (flattened)
				if (selectedSubscription && Object.keys(formValues).length === 0) {
					customFields.forEach(field => {
						$$invalidate(11, formValues[field.fieldName] = selectedSubscription[field.fieldName] ?? '', formValues);
					});
				}
			}
		};

		return [
			title,
			description,
			loadingText,
			successMessage,
			submitButtonText,
			cancelButtonText,
			customFields,
			showSuccessInline,
			isLoading,
			selectedSubscription,
			onCancel,
			formValues,
			formErrors,
			submitSuccess,
			submitError,
			handleFieldChange,
			handleFieldBlur,
			handleSubmit,
			handleCancel,
			errorMessage,
			validateOnBlur,
			onSubmit,
			textarea_input_handler,
			blur_handler,
			change_handler,
			blur_handler_1
		];
	}

	class SubscriptionCustomFieldsUpdate extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$6,
				create_fragment$6,
				safe_not_equal,
				{
					title: 0,
					description: 1,
					loadingText: 2,
					successMessage: 3,
					errorMessage: 19,
					submitButtonText: 4,
					cancelButtonText: 5,
					customFields: 6,
					validateOnBlur: 20,
					showSuccessInline: 7,
					isLoading: 8,
					selectedSubscription: 9,
					onSubmit: 21,
					onCancel: 10
				},
				null,
				[-1, -1]
			);
		}
	}

	const subscriptionCustomFieldsUpdateFactory = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.SUBSCRIPTION_CUSTOM_FIELDS_UPDATE,
	    create: (form, formState, formActions, elementConfig) => {
	        const selectedSubscription = formState.selectedSubscription;
	        async function handleSubmit(values) {
	            if (!selectedSubscription?.externalId) {
	                throw new Error('No subscription selected');
	            }
	            // Log data layer event for analytics using existing event pattern
	            logDataLayerEvent(form, 'zephr_form_button_press', {
	                sectionId: formState.currentSection.type,
	                buttonType: 'SUBMIT'
	            });
	            // Make API call to update subscription custom fields
	            const response = await fetch(`/zephr/subscriptions/${selectedSubscription.externalId}/custom-fields`, {
	                method: 'PATCH',
	                headers: {
	                    'Content-Type': 'application/json',
	                },
	                body: JSON.stringify({
	                    customFields: values
	                })
	            });
	            if (!response.ok) {
	                const errorData = await response.json().catch(() => ({}));
	                throw new Error(errorData.message || `HTTP ${response.status}: ${response.statusText}`);
	            }
	            const result = await response.json();
	            // Update form state with the updated subscription (extend with any additional data)
	            formActions.updateFormState({
	                selectedSubscription: {
	                    ...selectedSubscription,
	                    // Store custom fields in a way that doesn't conflict with the type
	                    ...result
	                }
	            });
	            return result;
	        }
	        function handleCancel() {
	            // Use existing form action to complete section or jump to previous part
	            formActions.jumpToPartStart('subscriptions');
	        }
	        return {
	            component: SubscriptionCustomFieldsUpdate,
	            props: {
	                title: elementConfig.title,
	                description: elementConfig.description,
	                loadingText: elementConfig.loadingText,
	                successMessage: elementConfig.successMessage,
	                errorMessage: elementConfig.errorMessage,
	                submitButtonText: elementConfig.submitButtonText,
	                cancelButtonText: elementConfig.cancelButtonText,
	                customFields: elementConfig.customFields || [],
	                validateOnBlur: elementConfig.validateOnBlur !== false,
	                showSuccessInline: elementConfig.showSuccessInline !== false,
	                isLoading: formState.isBusy,
	                selectedSubscription: selectedSubscription,
	                onSubmit: handleSubmit,
	                onCancel: handleCancel
	            }
	        };
	    }
	};

	/* src/components/elements/subscriptionCustomFieldsList/SubscriptionCustomFieldsList.svelte generated by Svelte v4.2.12 */

	function get_each_context$2(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[30] = list[i][0];
		child_ctx[31] = list[i][1];
		return child_ctx;
	}

	function get_each_context_1(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[34] = list[i];
		return child_ctx;
	}

	// (142:2) {#if formTitle}
	function create_if_block_6$1(ctx) {
		let h2;
		let t;

		return {
			c() {
				h2 = element("h2");
				t = text(/*formTitle*/ ctx[2]);
				attr(h2, "class", "form-title svelte-uox0m2");
			},
			m(target, anchor) {
				insert(target, h2, anchor);
				append(h2, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*formTitle*/ 4) set_data(t, /*formTitle*/ ctx[2]);
			},
			d(detaching) {
				if (detaching) {
					detach(h2);
				}
			}
		};
	}

	// (146:2) {#if formDescription}
	function create_if_block_5$1(ctx) {
		let p;
		let t;

		return {
			c() {
				p = element("p");
				t = text(/*formDescription*/ ctx[3]);
				attr(p, "class", "form-description svelte-uox0m2");
			},
			m(target, anchor) {
				insert(target, p, anchor);
				append(p, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*formDescription*/ 8) set_data(t, /*formDescription*/ ctx[3]);
			},
			d(detaching) {
				if (detaching) {
					detach(p);
				}
			}
		};
	}

	// (152:52) 
	function create_if_block_1$3(ctx) {
		let form;
		let t0;
		let t1;
		let t2;
		let mounted;
		let dispose;
		let each_value = ensure_array_like(/*activeFieldGroups*/ ctx[9]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
		}

		let if_block0 = /*successMessage*/ ctx[6] && create_if_block_4$1(ctx);
		let if_block1 = /*errorMessage*/ ctx[7] && create_if_block_3$2(ctx);
		let if_block2 = /*editableFieldNames*/ ctx[1].length > 0 && create_if_block_2$2(ctx);

		return {
			c() {
				form = element("form");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				t2 = space();
				if (if_block2) if_block2.c();
				attr(form, "class", "custom-fields-form svelte-uox0m2");
			},
			m(target, anchor) {
				insert(target, form, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(form, null);
					}
				}

				append(form, t0);
				if (if_block0) if_block0.m(form, null);
				append(form, t1);
				if (if_block1) if_block1.m(form, null);
				append(form, t2);
				if (if_block2) if_block2.m(form, null);

				if (!mounted) {
					dispose = listen(form, "submit", prevent_default(/*handleSubmit*/ ctx[13]));
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty[0] & /*activeFieldGroups, fieldValues, isFieldEditable, handleInputEvent*/ 21248) {
					each_value = ensure_array_like(/*activeFieldGroups*/ ctx[9]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$2(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$2(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(form, t0);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}

				if (/*successMessage*/ ctx[6]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_4$1(ctx);
						if_block0.c();
						if_block0.m(form, t1);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*errorMessage*/ ctx[7]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_3$2(ctx);
						if_block1.c();
						if_block1.m(form, t2);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (/*editableFieldNames*/ ctx[1].length > 0) {
					if (if_block2) {
						if_block2.p(ctx, dirty);
					} else {
						if_block2 = create_if_block_2$2(ctx);
						if_block2.c();
						if_block2.m(form, null);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(form);
				}

				destroy_each(each_blocks, detaching);
				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
				mounted = false;
				dispose();
			}
		};
	}

	// (150:2) {#if loading}
	function create_if_block$3(ctx) {
		let div;

		return {
			c() {
				div = element("div");
				div.textContent = "Loading custom fields...";
				attr(div, "class", "loading svelte-uox0m2");
			},
			m(target, anchor) {
				insert(target, div, anchor);
			},
			p: noop,
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (158:10) {#each group.fields as field}
	function create_each_block_1(ctx) {
		let div;
		let label;
		let t0_value = /*field*/ ctx[34].label + "";
		let t0;
		let label_for_value;
		let t1;
		let input;
		let input_id_value;
		let input_name_value;
		let input_value_value;
		let input_disabled_value;
		let mounted;
		let dispose;

		function input_handler(...args) {
			return /*input_handler*/ ctx[20](/*field*/ ctx[34], ...args);
		}

		return {
			c() {
				div = element("div");
				label = element("label");
				t0 = text(t0_value);
				t1 = space();
				input = element("input");
				attr(label, "for", label_for_value = /*field*/ ctx[34].name);
				attr(label, "class", "field-label svelte-uox0m2");
				attr(input, "id", input_id_value = /*field*/ ctx[34].name);
				attr(input, "name", input_name_value = /*field*/ ctx[34].name);
				attr(input, "type", "text");
				input.value = input_value_value = /*fieldValues*/ ctx[8][/*field*/ ctx[34].name];
				input.disabled = input_disabled_value = !/*isFieldEditable*/ ctx[12](/*field*/ ctx[34].name);
				attr(input, "class", "field-input svelte-uox0m2");
				attr(div, "class", "field-item svelte-uox0m2");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, label);
				append(label, t0);
				append(div, t1);
				append(div, input);

				if (!mounted) {
					dispose = listen(input, "input", input_handler);
					mounted = true;
				}
			},
			p(new_ctx, dirty) {
				ctx = new_ctx;
				if (dirty[0] & /*activeFieldGroups*/ 512 && t0_value !== (t0_value = /*field*/ ctx[34].label + "")) set_data(t0, t0_value);

				if (dirty[0] & /*activeFieldGroups*/ 512 && label_for_value !== (label_for_value = /*field*/ ctx[34].name)) {
					attr(label, "for", label_for_value);
				}

				if (dirty[0] & /*activeFieldGroups*/ 512 && input_id_value !== (input_id_value = /*field*/ ctx[34].name)) {
					attr(input, "id", input_id_value);
				}

				if (dirty[0] & /*activeFieldGroups*/ 512 && input_name_value !== (input_name_value = /*field*/ ctx[34].name)) {
					attr(input, "name", input_name_value);
				}

				if (dirty[0] & /*fieldValues, activeFieldGroups*/ 768 && input_value_value !== (input_value_value = /*fieldValues*/ ctx[8][/*field*/ ctx[34].name]) && input.value !== input_value_value) {
					input.value = input_value_value;
				}

				if (dirty[0] & /*activeFieldGroups*/ 512 && input_disabled_value !== (input_disabled_value = !/*isFieldEditable*/ ctx[12](/*field*/ ctx[34].name))) {
					input.disabled = input_disabled_value;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				mounted = false;
				dispose();
			}
		};
	}

	// (156:6) {#each activeFieldGroups as [_groupKey, group]}
	function create_each_block$2(ctx) {
		let div;
		let t;
		let each_value_1 = ensure_array_like(/*group*/ ctx[31].fields);
		let each_blocks = [];

		for (let i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
		}

		return {
			c() {
				div = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t = space();
				attr(div, "class", "simple-field-group svelte-uox0m2");
			},
			m(target, anchor) {
				insert(target, div, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div, null);
					}
				}

				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*activeFieldGroups, fieldValues, isFieldEditable, handleInputEvent*/ 21248) {
					each_value_1 = ensure_array_like(/*group*/ ctx[31].fields);
					let i;

					for (i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block_1(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(div, t);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value_1.length;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_each(each_blocks, detaching);
			}
		};
	}

	// (179:6) {#if successMessage}
	function create_if_block_4$1(ctx) {
		let div;
		let t0;
		let t1;

		return {
			c() {
				div = element("div");
				t0 = text("✓ ");
				t1 = text(/*successMessage*/ ctx[6]);
				attr(div, "class", "success-message svelte-uox0m2");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t0);
				append(div, t1);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*successMessage*/ 64) set_data(t1, /*successMessage*/ ctx[6]);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (185:6) {#if errorMessage}
	function create_if_block_3$2(ctx) {
		let div;
		let t0;
		let t1;

		return {
			c() {
				div = element("div");
				t0 = text("✗ ");
				t1 = text(/*errorMessage*/ ctx[7]);
				attr(div, "class", "error-message svelte-uox0m2");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t0);
				append(div, t1);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*errorMessage*/ 128) set_data(t1, /*errorMessage*/ ctx[7]);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (192:6) {#if editableFieldNames.length > 0}
	function create_if_block_2$2(ctx) {
		let div;
		let button;

		let t_value = (/*submitting*/ ctx[11]
		? 'Updating...'
		: /*loading*/ ctx[5]
			? 'Loading...'
			: /*submitButtonText*/ ctx[4]) + "";

		let t;
		let button_disabled_value;

		return {
			c() {
				div = element("div");
				button = element("button");
				t = text(t_value);
				attr(button, "type", "submit");
				attr(button, "class", "submit-button svelte-uox0m2");
				button.disabled = button_disabled_value = /*loading*/ ctx[5] || /*submitting*/ ctx[11] || !/*hasChanges*/ ctx[10];
				attr(div, "class", "form-actions svelte-uox0m2");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, button);
				append(button, t);
			},
			p(ctx, dirty) {
				if (dirty[0] & /*submitting, loading, submitButtonText*/ 2096 && t_value !== (t_value = (/*submitting*/ ctx[11]
				? 'Updating...'
				: /*loading*/ ctx[5]
					? 'Loading...'
					: /*submitButtonText*/ ctx[4]) + "")) set_data(t, t_value);

				if (dirty[0] & /*loading, submitting, hasChanges*/ 3104 && button_disabled_value !== (button_disabled_value = /*loading*/ ctx[5] || /*submitting*/ ctx[11] || !/*hasChanges*/ ctx[10])) {
					button.disabled = button_disabled_value;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	function create_fragment$5(ctx) {
		let div;
		let t0;
		let t1;
		let if_block0 = /*formTitle*/ ctx[2] && create_if_block_6$1(ctx);
		let if_block1 = /*formDescription*/ ctx[3] && create_if_block_5$1(ctx);

		function select_block_type(ctx, dirty) {
			if (/*loading*/ ctx[5]) return create_if_block$3;
			if (/*customFields*/ ctx[0] && /*customFields*/ ctx[0].length > 0) return create_if_block_1$3;
		}

		let current_block_type = select_block_type(ctx);
		let if_block2 = current_block_type && current_block_type(ctx);

		return {
			c() {
				div = element("div");
				if (if_block0) if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				attr(div, "class", "subscription-custom-fields-container svelte-uox0m2");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append(div, t0);
				if (if_block1) if_block1.m(div, null);
				append(div, t1);
				if (if_block2) if_block2.m(div, null);
			},
			p(ctx, dirty) {
				if (/*formTitle*/ ctx[2]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_6$1(ctx);
						if_block0.c();
						if_block0.m(div, t0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (/*formDescription*/ ctx[3]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_5$1(ctx);
						if_block1.c();
						if_block1.m(div, t1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if (if_block2) if_block2.d(1);
					if_block2 = current_block_type && current_block_type(ctx);

					if (if_block2) {
						if_block2.c();
						if_block2.m(div, null);
					}
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();

				if (if_block2) {
					if_block2.d();
				}
			}
		};
	}

	function instance$5($$self, $$props, $$invalidate) {
		let hasChanges;
		let changedFields;
		let fieldGroups;
		let activeFieldGroups;
		let { customFields } = $$props;
		let { editableFieldNames } = $$props;
		let { formTitle } = $$props;
		let { formDescription } = $$props;
		let { submitButtonText } = $$props;
		let { onUpdateCustomFields } = $$props;
		let { loading = false } = $$props;

		// New props for API call states
		let submitting = false;

		let successMessage = '';
		let errorMessage = '';
		let fieldValues = {};
		let originalFieldValues = {}; // Track original values to detect changes

		// Custom validation function that only validates sections with changes
		const validateChangedSections = () => {
			// Custom fields don't have validation requirements
			return [];
		};

		// Initialize/reset form values when component mounts or custom fields change
		let lastCustomFieldsLength = 0;

		// eslint-disable-next-line no-inner-declarations
		function initializeFormValues() {
			// Reset/initialize field values to original values
			$$invalidate(8, fieldValues = {});

			$$invalidate(16, originalFieldValues = {});

			customFields.forEach(field => {
				const originalValue = field.value || '';
				$$invalidate(8, fieldValues[field.name] = originalValue, fieldValues);
				$$invalidate(16, originalFieldValues[field.name] = originalValue, originalFieldValues);
			});

			// Clear any messages and states
			$$invalidate(6, successMessage = '');

			$$invalidate(7, errorMessage = '');
			$$invalidate(11, submitting = false);
		}

		// Check if a field is editable
		const isFieldEditable = fieldName => {
			return editableFieldNames.includes(fieldName);
		};

		const handleSubmit = async () => {
			// Validate only the sections that have changes
			const validationErrors = validateChangedSections();

			if (validationErrors.length > 0) {
				$$invalidate(7, errorMessage = validationErrors.join(', '));
				return;
			}

			$$invalidate(11, submitting = true);
			$$invalidate(6, successMessage = '');
			$$invalidate(7, errorMessage = '');

			try {
				// Only send the fields that have actually changed
				const changedFieldValues = {};

				changedFields.forEach(fieldName => {
					changedFieldValues[fieldName] = fieldValues[fieldName];
				});

				await onUpdateCustomFields(changedFieldValues);
				$$invalidate(6, successMessage = 'Successfully updated subscription details!');

				// Clear all input boxes after successful update
				Object.keys(fieldValues).forEach(fieldName => {
					$$invalidate(8, fieldValues[fieldName] = '', fieldValues);
					$$invalidate(16, originalFieldValues[fieldName] = '', originalFieldValues);
				});

				// Clear success message after 5 seconds
				setTimeout(
					() => {
						$$invalidate(6, successMessage = '');
					},
					5000
				);
			} catch(error) {
				$$invalidate(7, errorMessage = error.message || 'Failed to update subscription details. Please try again.');
			} finally {
				$$invalidate(11, submitting = false);
			}
		};

		const handleFieldChange = (fieldName, value) => {
			$$invalidate(8, fieldValues[fieldName] = value, fieldValues);
		};

		const handleInputEvent = (fieldName, event) => {
			handleFieldChange(fieldName, event.target.value);
		};

		const addressFieldNames = [
			'DeliveryAddressLine1__c',
			'DeliveryAddressLine2__c',
			'DeliveryCity__c',
			'DeliveryPostcode__c',
			'DeliveryZipcode__c',
			'DeliveryState__c',
			'DeliveryCountry__c'
		];

		addressFieldNames.some(name => isFieldEditable(name));
		addressFieldNames.some(name => fieldValues[name]);
		const input_handler = (field, e) => handleInputEvent(field.name, e);

		$$self.$$set = $$props => {
			if ('customFields' in $$props) $$invalidate(0, customFields = $$props.customFields);
			if ('editableFieldNames' in $$props) $$invalidate(1, editableFieldNames = $$props.editableFieldNames);
			if ('formTitle' in $$props) $$invalidate(2, formTitle = $$props.formTitle);
			if ('formDescription' in $$props) $$invalidate(3, formDescription = $$props.formDescription);
			if ('submitButtonText' in $$props) $$invalidate(4, submitButtonText = $$props.submitButtonText);
			if ('onUpdateCustomFields' in $$props) $$invalidate(15, onUpdateCustomFields = $$props.onUpdateCustomFields);
			if ('loading' in $$props) $$invalidate(5, loading = $$props.loading);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty[0] & /*fieldValues, originalFieldValues*/ 65792) {
				// Check if any field values have been modified
				$$invalidate(10, hasChanges = Object.keys(fieldValues).some(key => {
					const current = fieldValues[key];
					const original = originalFieldValues[key];

					// Handle array values (multiselect)
					if (Array.isArray(current) && Array.isArray(original)) {
						return JSON.stringify(current.sort()) !== JSON.stringify(original.sort());
					}

					// Handle regular values
					return current !== original;
				}));
			}

			if ($$self.$$.dirty[0] & /*fieldValues, originalFieldValues*/ 65792) {
				// Get the fields that have been changed (and thus the sections that should be validated)
				$$invalidate(19, changedFields = Object.keys(fieldValues).filter(key => {
					const current = fieldValues[key];
					const original = originalFieldValues[key];

					// Handle array values (multiselect)
					if (Array.isArray(current) && Array.isArray(original)) {
						return JSON.stringify(current.sort()) !== JSON.stringify(original.sort());
					}

					// Handle regular values
					return current !== original;
				}));
			}

			if ($$self.$$.dirty[0] & /*customFields*/ 1) {
				// Group fields by category - include all fields for display
				$$invalidate(18, fieldGroups = { all: { fields: customFields || [] } });
			}

			if ($$self.$$.dirty[0] & /*fieldGroups*/ 262144) {
				// Get only field groups that have fields
				$$invalidate(9, activeFieldGroups = Object.entries(fieldGroups).filter(([_key, group]) => group.fields.length > 0));
			}

			if ($$self.$$.dirty[0] & /*activeFieldGroups, changedFields*/ 524800) {
				// Get the sections that have changes and need validation
				activeFieldGroups.filter(([_groupKey, group]) => {
					return group.fields.some(field => changedFields.includes(field.name));
				});
			}

			if ($$self.$$.dirty[0] & /*hasChanges, successMessage, errorMessage*/ 1216) {
				// Clear messages when user starts making changes
				if (hasChanges && (successMessage || errorMessage)) {
					$$invalidate(6, successMessage = '');
					$$invalidate(7, errorMessage = '');
				}
			}

			if ($$self.$$.dirty[0] & /*customFields, lastCustomFieldsLength*/ 131073) {
				if (customFields && customFields.length !== lastCustomFieldsLength) {
					initializeFormValues();
					$$invalidate(17, lastCustomFieldsLength = customFields.length);
				}
			}
		};

		return [
			customFields,
			editableFieldNames,
			formTitle,
			formDescription,
			submitButtonText,
			loading,
			successMessage,
			errorMessage,
			fieldValues,
			activeFieldGroups,
			hasChanges,
			submitting,
			isFieldEditable,
			handleSubmit,
			handleInputEvent,
			onUpdateCustomFields,
			originalFieldValues,
			lastCustomFieldsLength,
			fieldGroups,
			changedFields,
			input_handler
		];
	}

	class SubscriptionCustomFieldsList extends SvelteComponent {
		constructor(options) {
			super();

			init(
				this,
				options,
				instance$5,
				create_fragment$5,
				safe_not_equal,
				{
					customFields: 0,
					editableFieldNames: 1,
					formTitle: 2,
					formDescription: 3,
					submitButtonText: 4,
					onUpdateCustomFields: 15,
					loading: 5
				},
				null,
				[-1, -1]
			);
		}
	}

	const subscriptionCustomFieldsListFactory = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.SUBSCRIPTION_CUSTOM_FIELDS_LIST,
	    create: (form, formState, formActions, elementConfig) => {
	        // Get the selected subscription's custom fields data
	        const selectedSubscription = formState.selectedSubscription || formState.existingSubscriptions?.[0];
	        // Create custom fields array from field definitions and subscription data
	        // Include all field definitions so both read-only and editable fields are available
	        const customFields = (elementConfig.customFieldDefinitions || []).map(fieldDef => ({
	            ...fieldDef,
	            value: selectedSubscription?.[fieldDef.name] || ''
	        }));
	        return {
	            component: SubscriptionCustomFieldsList,
	            props: {
	                customFields,
	                editableFieldNames: elementConfig.enabledCustomFields || [],
	                formTitle: elementConfig.formTitle || 'Update Subscription Details',
	                formDescription: elementConfig.formDescription || 'Update your subscription information below',
	                submitButtonText: elementConfig.submitButtonText || 'Update Details',
	                loading: formState.loadingSubscriptionCustomFields || false,
	                onBack: () => {
	                    // Navigate back to the main subscription list
	                    formActions.jumpToPartStart(partTypes.LIST_SUBSCRIPTIONS.type);
	                },
	                onUpdateCustomFields: async (fieldValues) => {
	                    // Check if we have a selected subscription with ID
	                    if (!selectedSubscription?.externalId) {
	                        throw new Error('No subscription selected for update');
	                    }
	                    // Check if we have accountId for ownership verification
	                    if (!selectedSubscription?.accountId) {
	                        throw new Error('Subscription account information is missing. Please try again.');
	                    }
	                    const subscriptionId = selectedSubscription.externalId;
	                    const accountId = selectedSubscription.accountId;
	                    // Set loading state
	                    formActions.updateFormState({
	                        loadingSubscriptionCustomFields: true
	                    });
	                    // Handle preview mode with mock API response
	                    if (form.environment?.previewMode) {
	                        // Simulate API delay
	                        await new Promise(resolve => setTimeout(resolve, 1000));
	                        // Update form state with the new values
	                        formActions.updateFormState({
	                            selectedSubscription: {
	                                ...selectedSubscription,
	                                ...fieldValues
	                            },
	                            loadingSubscriptionCustomFields: false
	                        });
	                        // Return mock success response
	                        return { success: true, message: 'Custom fields updated successfully (preview mode)' };
	                    }
	                    try {
	                        // Make real API call to update subscription custom fields
	                        const response = await fetch(`/zephr/subscriptions/${subscriptionId}/custom-fields`, {
	                            method: 'PATCH',
	                            headers: {
	                                'Content-Type': 'application/json',
	                            },
	                            body: JSON.stringify({
	                                accountId: accountId, // Required for backend ownership verification
	                                customFields: fieldValues
	                            })
	                        });
	                        if (!response.ok) {
	                            const errorData = await response.json().catch(() => ({}));
	                            throw new Error(errorData.message || `Failed to update subscription: ${response.status} ${response.statusText}`);
	                        }
	                        const result = await response.json();
	                        // Update form state with the new values
	                        formActions.updateFormState({
	                            selectedSubscription: {
	                                ...selectedSubscription,
	                                ...fieldValues
	                            },
	                            loadingSubscriptionCustomFields: false
	                        });
	                        // Return success - the component will handle showing success message
	                        return result;
	                    }
	                    catch (error) {
	                        console.error('Error updating subscription custom fields:', error);
	                        // Clear loading state on error
	                        formActions.updateFormState({
	                            loadingSubscriptionCustomFields: false
	                        });
	                        throw error; // Re-throw so component can handle it
	                    }
	                }
	            }
	        };
	    }
	};

	// TODO: This is a temporary list of countries that are accepted by Zuora.
	// We need to get this from the Contact metadata endpoint.
	const ZUORA_BILLING_COUNTRIES = [
	    "Afghanistan",
	    "Aland Islands",
	    "Albania",
	    "Algeria",
	    "American Samoa",
	    "Andorra",
	    "Angola",
	    "Anguilla",
	    "Antarctica",
	    "Antigua And Barbuda",
	    "Argentina",
	    "Armenia",
	    "Aruba",
	    "Australia",
	    "Austria",
	    "Azerbaijan",
	    "Bahamas",
	    "Bahrain",
	    "Bangladesh",
	    "Barbados",
	    "Belarus",
	    "Belgium",
	    "Belize",
	    "Benin",
	    "Bermuda",
	    "Bhutan",
	    "Bolivia",
	    "Bonaire, Saint Eustatius and Saba",
	    "Bosnia and Herzegovina",
	    "Botswana",
	    "Bouvet Island",
	    "Brazil",
	    "British Indian Ocean Territory",
	    "Brunei Darussalam",
	    "Bulgaria",
	    "Burkina Faso",
	    "Burundi",
	    "Cambodia",
	    "Cameroon",
	    "Canada",
	    "Cape Verde",
	    "Cayman Islands",
	    "Central African Republic",
	    "Chad",
	    "Chile",
	    "China",
	    "Christmas Island",
	    "Cocos (Keeling) Islands",
	    "Colombia",
	    "Comoros",
	    "Congo",
	    "Congo, the Democratic Republic of the",
	    "Cook Islands",
	    "Costa Rica",
	    "Cote d'Ivoire",
	    "Croatia",
	    "Cuba",
	    "Curacao",
	    "Cyprus",
	    "Czech Republic",
	    "Denmark",
	    "Djibouti",
	    "Dominica",
	    "Dominican Republic",
	    "Ecuador",
	    "Egypt",
	    "El Salvador",
	    "Equatorial Guinea",
	    "Eritrea",
	    "Estonia",
	    "Ethiopia",
	    "Falkland Islands (Malvinas)",
	    "Faroe Islands",
	    "Fiji",
	    "Finland",
	    "France",
	    "French Guiana",
	    "French Polynesia",
	    "French Southern Territories",
	    "Gabon",
	    "Gambia",
	    "Georgia",
	    "Germany",
	    "Ghana",
	    "Gibraltar",
	    "Greece",
	    "Greenland",
	    "Grenada",
	    "Guadeloupe",
	    "Guam",
	    "Guatemala",
	    "Guernsey",
	    "Guinea",
	    "Guinea-Bissau",
	    "Guyana",
	    "Haiti",
	    "Heard Island and McDonald Islands",
	    "Holy See (Vatican City State)",
	    "Honduras",
	    "Hong Kong",
	    "Hungary",
	    "Iceland",
	    "India",
	    "Indonesia",
	    "Iran, Islamic Republic of",
	    "Iraq",
	    "Ireland",
	    "Isle of Man",
	    "Israel",
	    "Italy",
	    "Jamaica",
	    "Japan",
	    "Jersey",
	    "Jordan",
	    "Kazakhstan",
	    "Kenya",
	    "Kiribati",
	    "Korea, Democratic People's Republic of",
	    "Korea, Republic of",
	    "Kosovo",
	    "Kuwait",
	    "Kyrgyzstan",
	    "Lao People's Democratic Republic",
	    "Latvia",
	    "Lebanon",
	    "Lesotho",
	    "Liberia",
	    "Libyan Arab Jamahiriya",
	    "Liechtenstein",
	    "Lithuania",
	    "Luxembourg",
	    "Macao",
	    "Macedonia, the former Yugoslav Republic of",
	    "Madagascar",
	    "Malawi",
	    "Malaysia",
	    "Maldives",
	    "Mali",
	    "Malta",
	    "Marshall Islands",
	    "Martinique",
	    "Mauritania",
	    "Mauritius",
	    "Mayotte",
	    "Mexico",
	    "Micronesia, Federated States of",
	    "Moldova, Republic of",
	    "Monaco",
	    "Mongolia",
	    "Montenegro",
	    "Montserrat",
	    "Morocco",
	    "Mozambique",
	    "Myanmar",
	    "Namibia",
	    "Nauru",
	    "Nepal",
	    "Netherlands",
	    "Netherlands Antilles",
	    "New Caledonia",
	    "New Zealand",
	    "Nicaragua",
	    "Niger",
	    "Nigeria",
	    "Niue",
	    "Norfolk Island",
	    "Northern Mariana Islands",
	    "Norway",
	    "Oman",
	    "Pakistan",
	    "Palau",
	    "Palestinian Territory, Occupied",
	    "Panama",
	    "Papua New Guinea",
	    "Paraguay",
	    "Peru",
	    "Philippines",
	    "Pitcairn",
	    "Poland",
	    "Portugal",
	    "Puerto Rico",
	    "Qatar",
	    "Reunion",
	    "Romania",
	    "Russian Federation",
	    "Rwanda",
	    "Saint Barthelemy",
	    "Saint Helena",
	    "Saint Kitts and Nevis",
	    "Saint Lucia",
	    "Saint Martin (French part)",
	    "Saint Pierre and Miquelon",
	    "Saint Vincent and the Grenadines",
	    "Samoa",
	    "San Marino",
	    "Sao Tome and Principe",
	    "Saudi Arabia",
	    "Senegal",
	    "Serbia",
	    "Seychelles",
	    "Sierra Leone",
	    "Singapore",
	    "Sint Maarten",
	    "Slovakia",
	    "Slovenia",
	    "Solomon Islands",
	    "Somalia",
	    "South Africa",
	    "South Georgia and the South Sandwich Islands",
	    "South Sudan",
	    "Spain",
	    "Sri Lanka",
	    "Sudan",
	    "Suriname",
	    "Svalbard and Jan Mayen",
	    "Swaziland",
	    "Sweden",
	    "Switzerland",
	    "Syrian Arab Republic",
	    "Taiwan",
	    "Tajikistan",
	    "Tanzania, United Republic of",
	    "Thailand",
	    "Timor-Leste",
	    "Togo",
	    "Tokelau",
	    "Tonga",
	    "Trinidad and Tobago",
	    "Tunisia",
	    "Turkey",
	    "Turkmenistan",
	    "Turks and Caicos Islands",
	    "Tuvalu",
	    "Uganda",
	    "Ukraine",
	    "United Arab Emirates",
	    "United Kingdom",
	    "United States",
	    "United States Minor Outlying Islands",
	    "Uruguay",
	    "Uzbekistan",
	    "Vanuatu",
	    "Venezuela",
	    "Viet Nam",
	    "Virgin Islands, British",
	    "Virgin Islands, U.S.",
	    "Wallis and Futuna",
	    "Western Sahara",
	    "Yemen",
	    "Zambia",
	    "Zimbabwe"
	];

	/* src/components/elements/billToContact/BillToContact.svelte generated by Svelte v4.2.12 */

	function get_each_context$1(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[17] = list[i];
		return child_ctx;
	}

	// (63:6) {#each ZUORA_BILLING_COUNTRIES as country}
	function create_each_block$1(ctx) {
		let option;
		let t0;
		let t1;
		let option_selected_value;

		return {
			c() {
				option = element("option");
				t0 = text(/*country*/ ctx[17]);
				t1 = space();
				option.__value = /*country*/ ctx[17];
				set_input_value(option, option.__value);
				option.selected = option_selected_value = /*billToContact*/ ctx[0].country === /*country*/ ctx[17];
			},
			m(target, anchor) {
				insert(target, option, anchor);
				append(option, t0);
				append(option, t1);
			},
			p(ctx, dirty) {
				if (dirty & /*billToContact*/ 1 && option_selected_value !== (option_selected_value = /*billToContact*/ ctx[0].country === /*country*/ ctx[17])) {
					option.selected = option_selected_value;
				}
			},
			d(detaching) {
				if (detaching) {
					detach(option);
				}
			}
		};
	}

	// (83:4) {#if errors["address1"]}
	function create_if_block_6(ctx) {
		let div;
		let t_value = /*errors*/ ctx[1]["address1"] + "";
		let t;

		return {
			c() {
				div = element("div");
				t = text(t_value);
				attr(div, "class", "error-text svelte-z564ap");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty & /*errors*/ 2 && t_value !== (t_value = /*errors*/ ctx[1]["address1"] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (97:4) {#if errors["address2"]}
	function create_if_block_5(ctx) {
		let div;
		let t_value = /*errors*/ ctx[1]["address2"] + "";
		let t;

		return {
			c() {
				div = element("div");
				t = text(t_value);
				attr(div, "class", "error-text svelte-z564ap");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty & /*errors*/ 2 && t_value !== (t_value = /*errors*/ ctx[1]["address2"] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (111:4) {#if errors["city"]}
	function create_if_block_4(ctx) {
		let div;
		let t_value = /*errors*/ ctx[1]["city"] + "";
		let t;

		return {
			c() {
				div = element("div");
				t = text(t_value);
				attr(div, "class", "error-text svelte-z564ap");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty & /*errors*/ 2 && t_value !== (t_value = /*errors*/ ctx[1]["city"] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (125:4) {#if errors["state"]}
	function create_if_block_3$1(ctx) {
		let div;
		let t_value = /*errors*/ ctx[1]["state"] + "";
		let t;

		return {
			c() {
				div = element("div");
				t = text(t_value);
				attr(div, "class", "error-text svelte-z564ap");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty & /*errors*/ 2 && t_value !== (t_value = /*errors*/ ctx[1]["state"] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (139:4) {#if errors["zipCode"]}
	function create_if_block_2$1(ctx) {
		let div;
		let t_value = /*errors*/ ctx[1]["zipCode"] + "";
		let t;

		return {
			c() {
				div = element("div");
				t = text(t_value);
				attr(div, "class", "error-text svelte-z564ap");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty & /*errors*/ 2 && t_value !== (t_value = /*errors*/ ctx[1]["zipCode"] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (153:4) {#if errors["county"]}
	function create_if_block_1$2(ctx) {
		let div;
		let t_value = /*errors*/ ctx[1]["county"] + "";
		let t;

		return {
			c() {
				div = element("div");
				t = text(t_value);
				attr(div, "class", "error-text svelte-z564ap");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty & /*errors*/ 2 && t_value !== (t_value = /*errors*/ ctx[1]["county"] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (167:4) {#if errors["taxRegion"]}
	function create_if_block$2(ctx) {
		let div;
		let t_value = /*errors*/ ctx[1]["taxRegion"] + "";
		let t;

		return {
			c() {
				div = element("div");
				t = text(t_value);
				attr(div, "class", "error-text svelte-z564ap");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, t);
			},
			p(ctx, dirty) {
				if (dirty & /*errors*/ 2 && t_value !== (t_value = /*errors*/ ctx[1]["taxRegion"] + "")) set_data(t, t_value);
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	function create_fragment$4(ctx) {
		let div8;
		let div0;
		let label0;
		let t1;
		let select;
		let option;
		let select_value_value;
		let t3;
		let div1;
		let label1;
		let t5;
		let input0;
		let t6;
		let t7;
		let div2;
		let label2;
		let t9;
		let input1;
		let t10;
		let t11;
		let div3;
		let label3;
		let t13;
		let input2;
		let t14;
		let t15;
		let div4;
		let label4;
		let t17;
		let input3;
		let t18;
		let t19;
		let div5;
		let label5;
		let t21;
		let input4;
		let t22;
		let t23;
		let div6;
		let label6;
		let t25;
		let input5;
		let t26;
		let t27;
		let div7;
		let label7;
		let t29;
		let input6;
		let t30;
		let mounted;
		let dispose;
		let each_value = ensure_array_like(ZUORA_BILLING_COUNTRIES);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
		}

		let if_block0 = /*errors*/ ctx[1]["address1"] && create_if_block_6(ctx);
		let if_block1 = /*errors*/ ctx[1]["address2"] && create_if_block_5(ctx);
		let if_block2 = /*errors*/ ctx[1]["city"] && create_if_block_4(ctx);
		let if_block3 = /*errors*/ ctx[1]["state"] && create_if_block_3$1(ctx);
		let if_block4 = /*errors*/ ctx[1]["zipCode"] && create_if_block_2$1(ctx);
		let if_block5 = /*errors*/ ctx[1]["county"] && create_if_block_1$2(ctx);
		let if_block6 = /*errors*/ ctx[1]["taxRegion"] && create_if_block$2(ctx);

		return {
			c() {
				div8 = element("div");
				div0 = element("div");
				label0 = element("label");
				label0.textContent = "Country";
				t1 = space();
				select = element("select");
				option = element("option");
				option.textContent = "Select a Country";

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t3 = space();
				div1 = element("div");
				label1 = element("label");
				label1.textContent = "Address 1";
				t5 = space();
				input0 = element("input");
				t6 = space();
				if (if_block0) if_block0.c();
				t7 = space();
				div2 = element("div");
				label2 = element("label");
				label2.textContent = "Address 2";
				t9 = space();
				input1 = element("input");
				t10 = space();
				if (if_block1) if_block1.c();
				t11 = space();
				div3 = element("div");
				label3 = element("label");
				label3.textContent = "City";
				t13 = space();
				input2 = element("input");
				t14 = space();
				if (if_block2) if_block2.c();
				t15 = space();
				div4 = element("div");
				label4 = element("label");
				label4.textContent = "State/Province";
				t17 = space();
				input3 = element("input");
				t18 = space();
				if (if_block3) if_block3.c();
				t19 = space();
				div5 = element("div");
				label5 = element("label");
				label5.textContent = "Postal Code";
				t21 = space();
				input4 = element("input");
				t22 = space();
				if (if_block4) if_block4.c();
				t23 = space();
				div6 = element("div");
				label6 = element("label");
				label6.textContent = "County";
				t25 = space();
				input5 = element("input");
				t26 = space();
				if (if_block5) if_block5.c();
				t27 = space();
				div7 = element("div");
				label7 = element("label");
				label7.textContent = "Tax Region";
				t29 = space();
				input6 = element("input");
				t30 = space();
				if (if_block6) if_block6.c();
				attr(label0, "for", "address1");
				attr(label0, "class", "svelte-z564ap");
				option.disabled = true;
				option.__value = "";
				set_input_value(option, option.__value);
				attr(select, "name", "country");
				attr(select, "class", "zephr-form-input zephr-form-input-select svelte-z564ap");
				toggle_class(select, "unselected", !/*billToContact*/ ctx[0].country);
				attr(div0, "class", "field svelte-z564ap");
				attr(label1, "for", "address1");
				attr(label1, "class", "svelte-z564ap");
				attr(input0, "id", "address1");
				attr(input0, "type", "text");
				input0.required = true;
				attr(input0, "class", "svelte-z564ap");
				toggle_class(input0, "error", !!/*errors*/ ctx[1]["address1"]);
				attr(div1, "class", "field svelte-z564ap");
				attr(label2, "for", "address2");
				attr(label2, "class", "svelte-z564ap");
				attr(input1, "id", "address2");
				attr(input1, "type", "text");
				input1.required = true;
				attr(input1, "class", "svelte-z564ap");
				toggle_class(input1, "error", !!/*errors*/ ctx[1]["address2"]);
				attr(div2, "class", "field svelte-z564ap");
				attr(label3, "for", "city");
				attr(label3, "class", "svelte-z564ap");
				attr(input2, "id", "city");
				attr(input2, "type", "text");
				input2.required = true;
				attr(input2, "class", "svelte-z564ap");
				toggle_class(input2, "error", !!/*errors*/ ctx[1]["city"]);
				attr(div3, "class", "field svelte-z564ap");
				attr(label4, "for", "state");
				attr(label4, "class", "svelte-z564ap");
				attr(input3, "id", "state");
				attr(input3, "type", "text");
				input3.required = true;
				attr(input3, "class", "svelte-z564ap");
				toggle_class(input3, "error", !!/*errors*/ ctx[1]["state"]);
				attr(div4, "class", "field svelte-z564ap");
				attr(label5, "for", "zipCode");
				attr(label5, "class", "svelte-z564ap");
				attr(input4, "id", "zipCode");
				attr(input4, "type", "text");
				input4.required = true;
				attr(input4, "class", "svelte-z564ap");
				toggle_class(input4, "error", !!/*errors*/ ctx[1]["zipCode"]);
				attr(div5, "class", "field svelte-z564ap");
				attr(label6, "for", "county");
				attr(label6, "class", "svelte-z564ap");
				attr(input5, "id", "county");
				attr(input5, "type", "text");
				input5.required = true;
				attr(input5, "class", "svelte-z564ap");
				toggle_class(input5, "error", !!/*errors*/ ctx[1]["county"]);
				attr(div6, "class", "field svelte-z564ap");
				attr(label7, "for", "taxRegion");
				attr(label7, "class", "svelte-z564ap");
				attr(input6, "id", "taxRegion");
				attr(input6, "type", "text");
				input6.required = true;
				attr(input6, "class", "svelte-z564ap");
				toggle_class(input6, "error", !!/*errors*/ ctx[1]["taxRegion"]);
				attr(div7, "class", "field svelte-z564ap");
				attr(div8, "class", "bill-to-contact-section svelte-z564ap");
			},
			m(target, anchor) {
				insert(target, div8, anchor);
				append(div8, div0);
				append(div0, label0);
				append(div0, t1);
				append(div0, select);
				append(select, option);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(select, null);
					}
				}

				select_option(select, /*billToContact*/ ctx[0].country ?? "");
				append(div8, t3);
				append(div8, div1);
				append(div1, label1);
				append(div1, t5);
				append(div1, input0);
				set_input_value(input0, /*billToContact*/ ctx[0].address1);
				append(div1, t6);
				if (if_block0) if_block0.m(div1, null);
				append(div8, t7);
				append(div8, div2);
				append(div2, label2);
				append(div2, t9);
				append(div2, input1);
				set_input_value(input1, /*billToContact*/ ctx[0].address2);
				append(div2, t10);
				if (if_block1) if_block1.m(div2, null);
				append(div8, t11);
				append(div8, div3);
				append(div3, label3);
				append(div3, t13);
				append(div3, input2);
				set_input_value(input2, /*billToContact*/ ctx[0].city);
				append(div3, t14);
				if (if_block2) if_block2.m(div3, null);
				append(div8, t15);
				append(div8, div4);
				append(div4, label4);
				append(div4, t17);
				append(div4, input3);
				set_input_value(input3, /*billToContact*/ ctx[0].state);
				append(div4, t18);
				if (if_block3) if_block3.m(div4, null);
				append(div8, t19);
				append(div8, div5);
				append(div5, label5);
				append(div5, t21);
				append(div5, input4);
				set_input_value(input4, /*billToContact*/ ctx[0].zipCode);
				append(div5, t22);
				if (if_block4) if_block4.m(div5, null);
				append(div8, t23);
				append(div8, div6);
				append(div6, label6);
				append(div6, t25);
				append(div6, input5);
				set_input_value(input5, /*billToContact*/ ctx[0].county);
				append(div6, t26);
				if (if_block5) if_block5.m(div6, null);
				append(div8, t27);
				append(div8, div7);
				append(div7, label7);
				append(div7, t29);
				append(div7, input6);
				set_input_value(input6, /*billToContact*/ ctx[0].taxRegion);
				append(div7, t30);
				if (if_block6) if_block6.m(div7, null);

				if (!mounted) {
					dispose = [
						listen(select, "change", /*onCountrySelect*/ ctx[3]),
						listen(input0, "input", /*input0_input_handler*/ ctx[6]),
						listen(input0, "input", /*updateSuspendResumeSubscription*/ ctx[2]),
						listen(input1, "input", /*input1_input_handler*/ ctx[7]),
						listen(input1, "input", /*updateSuspendResumeSubscription*/ ctx[2]),
						listen(input2, "input", /*input2_input_handler*/ ctx[8]),
						listen(input2, "input", /*updateSuspendResumeSubscription*/ ctx[2]),
						listen(input3, "input", /*input3_input_handler*/ ctx[9]),
						listen(input3, "input", /*updateSuspendResumeSubscription*/ ctx[2]),
						listen(input4, "input", /*input4_input_handler*/ ctx[10]),
						listen(input4, "input", /*updateSuspendResumeSubscription*/ ctx[2]),
						listen(input5, "input", /*input5_input_handler*/ ctx[11]),
						listen(input5, "input", /*updateSuspendResumeSubscription*/ ctx[2]),
						listen(input6, "input", /*input6_input_handler*/ ctx[12]),
						listen(input6, "input", /*updateSuspendResumeSubscription*/ ctx[2])
					];

					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (dirty & /*billToContact*/ 1) {
					each_value = ensure_array_like(ZUORA_BILLING_COUNTRIES);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$1(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$1(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(select, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}

				if (dirty & /*billToContact*/ 1 && select_value_value !== (select_value_value = /*billToContact*/ ctx[0].country ?? "")) {
					select_option(select, /*billToContact*/ ctx[0].country ?? "");
				}

				if (dirty & /*billToContact*/ 1) {
					toggle_class(select, "unselected", !/*billToContact*/ ctx[0].country);
				}

				if (dirty & /*billToContact*/ 1 && input0.value !== /*billToContact*/ ctx[0].address1) {
					set_input_value(input0, /*billToContact*/ ctx[0].address1);
				}

				if (dirty & /*errors*/ 2) {
					toggle_class(input0, "error", !!/*errors*/ ctx[1]["address1"]);
				}

				if (/*errors*/ ctx[1]["address1"]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_6(ctx);
						if_block0.c();
						if_block0.m(div1, null);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (dirty & /*billToContact*/ 1 && input1.value !== /*billToContact*/ ctx[0].address2) {
					set_input_value(input1, /*billToContact*/ ctx[0].address2);
				}

				if (dirty & /*errors*/ 2) {
					toggle_class(input1, "error", !!/*errors*/ ctx[1]["address2"]);
				}

				if (/*errors*/ ctx[1]["address2"]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_5(ctx);
						if_block1.c();
						if_block1.m(div2, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (dirty & /*billToContact*/ 1 && input2.value !== /*billToContact*/ ctx[0].city) {
					set_input_value(input2, /*billToContact*/ ctx[0].city);
				}

				if (dirty & /*errors*/ 2) {
					toggle_class(input2, "error", !!/*errors*/ ctx[1]["city"]);
				}

				if (/*errors*/ ctx[1]["city"]) {
					if (if_block2) {
						if_block2.p(ctx, dirty);
					} else {
						if_block2 = create_if_block_4(ctx);
						if_block2.c();
						if_block2.m(div3, null);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}

				if (dirty & /*billToContact*/ 1 && input3.value !== /*billToContact*/ ctx[0].state) {
					set_input_value(input3, /*billToContact*/ ctx[0].state);
				}

				if (dirty & /*errors*/ 2) {
					toggle_class(input3, "error", !!/*errors*/ ctx[1]["state"]);
				}

				if (/*errors*/ ctx[1]["state"]) {
					if (if_block3) {
						if_block3.p(ctx, dirty);
					} else {
						if_block3 = create_if_block_3$1(ctx);
						if_block3.c();
						if_block3.m(div4, null);
					}
				} else if (if_block3) {
					if_block3.d(1);
					if_block3 = null;
				}

				if (dirty & /*billToContact*/ 1 && input4.value !== /*billToContact*/ ctx[0].zipCode) {
					set_input_value(input4, /*billToContact*/ ctx[0].zipCode);
				}

				if (dirty & /*errors*/ 2) {
					toggle_class(input4, "error", !!/*errors*/ ctx[1]["zipCode"]);
				}

				if (/*errors*/ ctx[1]["zipCode"]) {
					if (if_block4) {
						if_block4.p(ctx, dirty);
					} else {
						if_block4 = create_if_block_2$1(ctx);
						if_block4.c();
						if_block4.m(div5, null);
					}
				} else if (if_block4) {
					if_block4.d(1);
					if_block4 = null;
				}

				if (dirty & /*billToContact*/ 1 && input5.value !== /*billToContact*/ ctx[0].county) {
					set_input_value(input5, /*billToContact*/ ctx[0].county);
				}

				if (dirty & /*errors*/ 2) {
					toggle_class(input5, "error", !!/*errors*/ ctx[1]["county"]);
				}

				if (/*errors*/ ctx[1]["county"]) {
					if (if_block5) {
						if_block5.p(ctx, dirty);
					} else {
						if_block5 = create_if_block_1$2(ctx);
						if_block5.c();
						if_block5.m(div6, null);
					}
				} else if (if_block5) {
					if_block5.d(1);
					if_block5 = null;
				}

				if (dirty & /*billToContact*/ 1 && input6.value !== /*billToContact*/ ctx[0].taxRegion) {
					set_input_value(input6, /*billToContact*/ ctx[0].taxRegion);
				}

				if (dirty & /*errors*/ 2) {
					toggle_class(input6, "error", !!/*errors*/ ctx[1]["taxRegion"]);
				}

				if (/*errors*/ ctx[1]["taxRegion"]) {
					if (if_block6) {
						if_block6.p(ctx, dirty);
					} else {
						if_block6 = create_if_block$2(ctx);
						if_block6.c();
						if_block6.m(div7, null);
					}
				} else if (if_block6) {
					if_block6.d(1);
					if_block6 = null;
				}
			},
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(div8);
				}

				destroy_each(each_blocks, detaching);
				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
				if (if_block3) if_block3.d();
				if (if_block4) if_block4.d();
				if (if_block5) if_block5.d();
				if (if_block6) if_block6.d();
				mounted = false;
				run_all(dispose);
			}
		};
	}

	function instance$4($$self, $$props, $$invalidate) {
		let { formState } = $$props;
		let { formActions } = $$props;
		const dispatch = createEventDispatcher();
		let billToContact = {};
		const sourceContact = formState.selectedSubscription?.billToContact || {};

		const fieldsToExtract = [
			'country',
			'address1',
			'address2',
			'city',
			'state',
			'zipCode',
			'county',
			'taxRegion'
		];

		for (const field of fieldsToExtract) {
			if (sourceContact[field] != null) {
				billToContact[field] = sourceContact[field];
			}
		}

		let errors = {};

		// Update form state when input changes
		const updateSuspendResumeSubscription = () => {
			formActions.updateFormState({ billToContact });
			validateForm();
		};

		const onCountrySelect = e => {
			$$invalidate(0, billToContact.country = e.target.value, billToContact);
			updateSuspendResumeSubscription();
		};

		const validateForm = () => {
			// Reset errors
			$$invalidate(1, errors = {});

			if (!!billToContact.address1 && billToContact.address1.length > 255) {
				$$invalidate(1, errors["address1"] = "Address 1 should be 255 characters or less", errors);
			}

			if (!!billToContact.address2 && billToContact.address2.length > 255) {
				$$invalidate(1, errors["address2"] = "Address 2 should be 255 characters or less", errors);
			}

			if (!!billToContact.city && billToContact.city.length > 40) {
				$$invalidate(1, errors["city"] = "City should be 40 characters or less", errors);
			}

			if (!!billToContact.county && billToContact.county.length > 32) {
				$$invalidate(1, errors["county"] = "County should be 32 characters or less", errors);
			}

			if (!!billToContact.zipCode && billToContact.zipCode.length > 20) {
				$$invalidate(1, errors["zipCode"] = "Postal code should be 20 characters or less", errors);
			}

			// Dispatch event for form validity
			const isValid = Object.keys(errors).length === 0;

			dispatch("validity", { isValid });
		};

		function input0_input_handler() {
			billToContact.address1 = this.value;
			$$invalidate(0, billToContact);
		}

		function input1_input_handler() {
			billToContact.address2 = this.value;
			$$invalidate(0, billToContact);
		}

		function input2_input_handler() {
			billToContact.city = this.value;
			$$invalidate(0, billToContact);
		}

		function input3_input_handler() {
			billToContact.state = this.value;
			$$invalidate(0, billToContact);
		}

		function input4_input_handler() {
			billToContact.zipCode = this.value;
			$$invalidate(0, billToContact);
		}

		function input5_input_handler() {
			billToContact.county = this.value;
			$$invalidate(0, billToContact);
		}

		function input6_input_handler() {
			billToContact.taxRegion = this.value;
			$$invalidate(0, billToContact);
		}

		$$self.$$set = $$props => {
			if ('formState' in $$props) $$invalidate(4, formState = $$props.formState);
			if ('formActions' in $$props) $$invalidate(5, formActions = $$props.formActions);
		};

		return [
			billToContact,
			errors,
			updateSuspendResumeSubscription,
			onCountrySelect,
			formState,
			formActions,
			input0_input_handler,
			input1_input_handler,
			input2_input_handler,
			input3_input_handler,
			input4_input_handler,
			input5_input_handler,
			input6_input_handler
		];
	}

	class BillToContact extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$4, create_fragment$4, safe_not_equal, { formState: 4, formActions: 5 });
		}
	}

	const billToContactFactory = {
	    matches: (sectionElement) => sectionElement.type === elementTypes.BILL_TO_CONTACT,
	    create: (form, formState, formActions) => {
	        return {
	            component: BillToContact,
	            props: {
	                form,
	                formState,
	                formActions,
	            }
	        };
	    }
	};

	const elementFactories = [
	    factory$s,
	    factory$r,
	    factory$q,
	    factory$p,
	    factory$o,
	    factory$n,
	    factory$m,
	    factory$l,
	    paymentAutoRenewToggleFactory,
	    factory$k,
	    factory$j,
	    factory$i,
	    factory$h,
	    factory$g,
	    factory$f,
	    factory$e,
	    factory$d,
	    factory$c,
	    factory$b,
	    factory$a,
	    factory$9,
	    factory$8,
	    factory$7,
	    factory$6,
	    factory$5,
	    subscriptionSelectFactory,
	    subscriptionsListFactory,
	    pastSubscriptionsLinkFactory,
	    changePaymentMethodButtonFactory,
	    eventLinkFactory,
	    factory$4,
	    factory$3,
	    readOnlyUserAttributeFactory,
	    deviceSessionsFactory,
	    deviceSessionsSignOutAll,
	    billingHistoryFactory,
	    factory$2,
	    factory$1,
	    recipientNameFactory,
	    recipientEmailFactory,
	    recipientAddressFactory,
	    recipientMessageFactory,
	    factory,
	    giftSubscriptionsListFactory,
	    giftToggleFactory,
	    giftFutureDateToggleFactory,
	    giftFutureDateInputFactory,
	    suspendResumeSubscriptionFactory,
	    subscriptionCustomFieldsUpdateFactory,
	    subscriptionCustomFieldsListFactory,
	    billToContactFactory,
	];

	/* src/components/ElementResolver.svelte generated by Svelte v4.2.12 */

	function create_if_block$1(ctx) {
		let switch_instance;
		let t;
		let if_block_anchor;
		let current;

		const switch_instance_spread_levels = [
			/*enrichPropsWithServerError*/ ctx[4](/*element*/ ctx[2].props, /*formState*/ ctx[0], /*sectionElement*/ ctx[1])
		];

		var switch_value = /*element*/ ctx[2].component;

		function switch_props(ctx, dirty) {
			let switch_instance_props = {};

			for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
				switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
			}

			if (dirty !== undefined && dirty & /*enrichPropsWithServerError, element, formState, sectionElement*/ 23) {
				switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
					get_spread_object(/*enrichPropsWithServerError*/ ctx[4](/*element*/ ctx[2].props, /*formState*/ ctx[0], /*sectionElement*/ ctx[1]))
				]));
			}

			return { props: switch_instance_props };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		}

		let if_block = /*element*/ ctx[2].isValid === false && /*formState*/ ctx[0].showFieldErrors && create_if_block_1$1(ctx);

		return {
			c() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				t = space();
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert(target, t, anchor);
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				if (dirty & /*element*/ 4 && switch_value !== (switch_value = /*element*/ ctx[2].component)) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, t.parentNode, t);
					} else {
						switch_instance = null;
					}
				} else if (switch_value) {
					const switch_instance_changes = (dirty & /*enrichPropsWithServerError, element, formState, sectionElement*/ 23)
					? get_spread_update(switch_instance_spread_levels, [
							get_spread_object(/*enrichPropsWithServerError*/ ctx[4](/*element*/ ctx[2].props, /*formState*/ ctx[0], /*sectionElement*/ ctx[1]))
						])
					: {};

					switch_instance.$set(switch_instance_changes);
				}

				if (/*element*/ ctx[2].isValid === false && /*formState*/ ctx[0].showFieldErrors) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*element, formState*/ 5) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_1$1(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				transition_in(if_block);
				current = true;
			},
			o(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(if_block_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (61:2) {#if element.isValid === false && formState.showFieldErrors}
	function create_if_block_1$1(ctx) {
		let errormessage;
		let current;

		errormessage = new ErrorMessage({
				props: {
					error: "Field is invalid",
					isPaymentForm: /*isPaymentForm*/ ctx[3]
				}
			});

		return {
			c() {
				create_component(errormessage.$$.fragment);
			},
			m(target, anchor) {
				mount_component(errormessage, target, anchor);
				current = true;
			},
			p: noop,
			i(local) {
				if (current) return;
				transition_in(errormessage.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errormessage.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(errormessage, detaching);
			}
		};
	}

	function create_fragment$3(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*element*/ ctx[2] && create_if_block$1(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, [dirty]) {
				if (/*element*/ ctx[2]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*element*/ 4) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$1(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};
	}

	function instance$3($$self, $$props, $$invalidate) {
		let element;
		let { form } = $$props;
		let { formActions } = $$props;
		let isPaymentForm = form.formType === "PAYMENT";
		let { formState } = $$props;
		let { sectionElement } = $$props;

		const enrichPropsWithServerError = (props, _formState, _sectionElement) => {
			const serverErrorForElementValue = serverErrorForElement(_sectionElement.type, _formState);
			const error = ServerErrors[serverErrorForElementValue];

			if (error) {
				// send message to app saying payment form has errored
				const formErrorMessage = {
					error: ServerError[serverErrorForElementValue],
					errorMessage: resolveErrorLanguagePackKey(form, serverErrorForElementValue),
					success: false,
					formSlug: form.id
				};

				const formEventPayload = JSON.stringify(formErrorMessage);

				// handle ios message
				window?.webkit?.messageHandlers?.messageHandler?.postMessage(formEventPayload);

				// handle android message
				window?.AndroidFormEventListener?.processFormEvent(formEventPayload);
			}

			return error
			? {
					...element.props,
					error: element.props.error ?? (error.useDymamicMessage
					? _formState.dynamicServerErrorMessage
					: resolveErrorLanguagePackKey(form, serverErrorForElementValue))
				}
			: props;
		};

		const buildElement = (_formState, _sectionElement) => {
			if (_sectionElement.config?.enabled === false || _sectionElement.hidden === true) {
				return null;
			}

			const factory = elementFactories.find(f => f.matches(_sectionElement, form, _formState.currentPart, _formState.currentSection));

			if (!factory) {
				throw `Unknown element ${JSON.stringify(_sectionElement)}`;
			}

			const element = factory.create(form, _formState, formActions, _sectionElement.config);
			updateElementValidity(element, _formState, _sectionElement, formActions);
			return element;
		};

		$$self.$$set = $$props => {
			if ('form' in $$props) $$invalidate(5, form = $$props.form);
			if ('formActions' in $$props) $$invalidate(6, formActions = $$props.formActions);
			if ('formState' in $$props) $$invalidate(0, formState = $$props.formState);
			if ('sectionElement' in $$props) $$invalidate(1, sectionElement = $$props.sectionElement);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*formState, sectionElement*/ 3) {
				$$invalidate(2, element = buildElement(formState, sectionElement));
			}
		};

		return [
			formState,
			sectionElement,
			element,
			isPaymentForm,
			enrichPropsWithServerError,
			form,
			formActions
		];
	}

	class ElementResolver extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance$3, create_fragment$3, safe_not_equal, {
				form: 5,
				formActions: 6,
				formState: 0,
				sectionElement: 1
			});
		}
	}

	const extractDefaultUserAttributes = (form) => form.parts
	    .flatMap((p) => p.sections)
	    .flatMap((s) => s.elements)
	    .filter((e) => e.type === elementTypes.USER_ATTRIBUTE)
	    .map(e => e.config)
	    .reduce((attributes, config) => {
	    const schemafield = form.organisationConfiguration.schemaFields.find(s => s.slug === config.slug);
	    if (schemafield) {
	        return {
	            ...attributes,
	            [config.slug]: (config.defaultValue || (schemafield["select-options"]?.find(o => o.default)?.value)) ?? undefined
	        };
	    }
	    else {
	        return {
	            ...attributes
	        };
	    }
	}, {});

	/**
	 * Sort all items in the Form by their order properties
	 */
	const sortForm = (form) => ({
	    ...form,
	    parts: form.parts
	        .sort((a, b) => partTypeFor(a.type).order - partTypeFor(b.type).order)
	        .map((p) => ({
	        ...p,
	        sections: p.sections
	            .sort((a, b) => a.order - b.order)
	            .map((s) => ({
	            ...s,
	            elements: s.elements.sort((a, b) => a.order - b.order),
	        })),
	    }))
	});

	const addFormProcessorsToWindow = () => {
	    if (!window.Blaize) {
	        window.Blaize = {
	            formPreProcessors: {},
	            formPostProcessors: {},
	            registerFormPreProcessor: function (formSlug, processor) {
	                if (!window.Blaize.formPreProcessors[formSlug])
	                    window.Blaize.formPreProcessors[formSlug] = [];
	                if (typeof processor === "function") {
	                    window.Blaize.formPreProcessors[formSlug].push(processor);
	                }
	            },
	            registerFormPostProcessor: function (formSlug, processor) {
	                if (!window.Blaize.formPostProcessors[formSlug])
	                    window.Blaize.formPostProcessors[formSlug] = [];
	                if (typeof processor === "function") {
	                    window.Blaize.formPostProcessors[formSlug].push(processor);
	                }
	            },
	            preProcessFormData: function (formSlug, formData) {
	                if (window.Blaize.formPreProcessors[formSlug] ||
	                    window.Blaize.formPreProcessors["*"]) {
	                    const processors = [];
	                    if (window.Blaize.formPreProcessors["*"]) {
	                        window.Blaize.formPreProcessors["*"].forEach(function (processor) {
	                            processors.push(processor);
	                        });
	                    }
	                    if (window.Blaize.formPreProcessors[formSlug]) {
	                        window.Blaize.formPreProcessors[formSlug].forEach(function (processor) {
	                            processors.push(processor);
	                        });
	                    }
	                    processors.forEach(function (processor) {
	                        const processedFormData = processor(formData);
	                        if (processedFormData != undefined) {
	                            formData = processedFormData;
	                        }
	                    });
	                }
	                return formData;
	            },
	            postProcessFormData: function (formSlug, formData, response) {
	                if (window.Blaize.formPostProcessors[formSlug] ||
	                    window.Blaize.formPostProcessors["*"]) {
	                    const processors = [];
	                    if (window.Blaize.formPostProcessors["*"]) {
	                        window.Blaize.formPostProcessors["*"].forEach(function (processor) {
	                            processors.push(processor);
	                        });
	                    }
	                    if (window.Blaize.formPostProcessors[formSlug]) {
	                        window.Blaize.formPostProcessors[formSlug].forEach(function (processor) {
	                            processors.push(processor);
	                        });
	                    }
	                    processors.forEach(function (processor) {
	                        processor(formData, response);
	                    });
	                }
	            },
	        };
	    }
	};

	/* src/components/FormViewedDetect.svelte generated by Svelte v4.2.12 */

	function create_fragment$2(ctx) {
		let div;
		let current;
		const default_slot_template = /*#slots*/ ctx[3].default;
		const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

		return {
			c() {
				div = element("div");
				if (default_slot) default_slot.c();
			},
			m(target, anchor) {
				insert(target, div, anchor);

				if (default_slot) {
					default_slot.m(div, null);
				}

				/*div_binding*/ ctx[4](div);
				current = true;
			},
			p(ctx, [dirty]) {
				if (default_slot) {
					if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
						update_slot_base(
							default_slot,
							default_slot_template,
							ctx,
							/*$$scope*/ ctx[2],
							!current
							? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
							: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
							null
						);
					}
				}
			},
			i(local) {
				if (current) return;
				transition_in(default_slot, local);
				current = true;
			},
			o(local) {
				transition_out(default_slot, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (default_slot) default_slot.d(detaching);
				/*div_binding*/ ctx[4](null);
			}
		};
	}

	function instance$2($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		let { form } = $$props;
		let intersecting = false;
		let element;
		let observer;
		const dispatch = createEventDispatcher();

		onMount(() => {
			if (typeof IntersectionObserver !== 'undefined') {
				observer = new IntersectionObserver(entries => {
						const entry = entries[0];
						intersecting = entry?.isIntersecting;
						dispatch('observe', entry);

						if (intersecting && form) {
							logDataLayerEvent(form, 'zephr_form_view', null);
							observer.unobserve(element);
						}
					},
				{ threshold: 0.75 });

				if (element) {
					observer.observe(element);
				}
			}

			return () => {
				if (observer) {
					observer.disconnect();
				}
			};
		});

		function div_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				element = $$value;
				$$invalidate(0, element);
			});
		}

		$$self.$$set = $$props => {
			if ('form' in $$props) $$invalidate(1, form = $$props.form);
			if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
		};

		return [element, form, $$scope, slots, div_binding];
	}

	class FormViewedDetect extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$2, create_fragment$2, safe_not_equal, { form: 1 });
		}
	}

	const checkForRegisteredUser = async (formActions) => {
	    if (!document.cookie?.includes("blaize_session")) {
	        formActions.updateFormState({
	            userSession: false,
	        });
	        return false;
	    }
	    let response;
	    try {
	        response = await request('blaize/account', { method: "GET" }, formActions);
	    }
	    catch (err) {
	        console.error(err);
	    }
	    if (response?.ok) {
	        const responseJson = await response.json();
	        formActions.updateFormState({
	            userExists: true,
	            emailIsContact: false,
	            emailAddress: responseJson.identifiers?.email_address,
	            userSession: true,
	            loginRegistrationComplete: true
	        });
	    }
	    else {
	        formActions.updateFormState({
	            userSession: false,
	        });
	    }
	    return response?.ok;
	};

	/* src/components/FormRoot.svelte generated by Svelte v4.2.12 */

	function get_each_context(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[21] = list[i];
		return child_ctx;
	}

	// (204:2) {#if formCanBeManuallyClosed}
	function create_if_block_3(ctx) {
		let div;
		let button;
		let fa;
		let current;
		let mounted;
		let dispose;
		fa = new Fa({ props: { icon: faTimesCircle } });

		return {
			c() {
				div = element("div");
				button = element("button");
				create_component(fa.$$.fragment);
				attr(button, "type", "button");
				attr(button, "class", "close-button svelte-j7lu48");
				attr(div, "class", "close-button-container svelte-j7lu48");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				append(div, button);
				mount_component(fa, button, null);
				current = true;

				if (!mounted) {
					dispose = listen(button, "click", /*closeForm*/ ctx[8]);
					mounted = true;
				}
			},
			p: noop,
			i(local) {
				if (current) return;
				transition_in(fa.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(fa.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(fa);
				mounted = false;
				dispose();
			}
		};
	}

	// (217:2) {:else}
	function create_else_block(ctx) {
		let formvieweddetect;
		let t;
		let if_block_anchor;
		let current;

		formvieweddetect = new FormViewedDetect({
				props: {
					form: /*form*/ ctx[5],
					$$slots: { default: [create_default_slot] },
					$$scope: { ctx }
				}
			});

		let if_block = /*topLevelError*/ ctx[3] && create_if_block_2(ctx);

		return {
			c() {
				create_component(formvieweddetect.$$.fragment);
				t = space();
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m(target, anchor) {
				mount_component(formvieweddetect, target, anchor);
				insert(target, t, anchor);
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const formvieweddetect_changes = {};

				if (dirty & /*$$scope, isFullWidth, formState*/ 16777221) {
					formvieweddetect_changes.$$scope = { dirty, ctx };
				}

				formvieweddetect.$set(formvieweddetect_changes);

				if (/*topLevelError*/ ctx[3]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*topLevelError*/ 8) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_2(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i(local) {
				if (current) return;
				transition_in(formvieweddetect.$$.fragment, local);
				transition_in(if_block);
				current = true;
			},
			o(local) {
				transition_out(formvieweddetect.$$.fragment, local);
				transition_out(if_block);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(t);
					detach(if_block_anchor);
				}

				destroy_component(formvieweddetect, detaching);
				if (if_block) if_block.d(detaching);
			}
		};
	}

	// (213:69) 
	function create_if_block_1(ctx) {
		let div;
		let spinner;
		let current;
		spinner = new Spinner({});

		return {
			c() {
				div = element("div");
				create_component(spinner.$$.fragment);
				attr(div, "class", "loading-placeholder svelte-j7lu48");
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(spinner, div, null);
				current = true;
			},
			p: noop,
			i(local) {
				if (current) return;
				transition_in(spinner.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(spinner.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(spinner);
			}
		};
	}

	// (211:2) {#if formHasCrashed}
	function create_if_block(ctx) {
		let div;

		return {
			c() {
				div = element("div");
				div.textContent = `${resolveErrorLanguagePackKey(/*form*/ ctx[5], ServerError.UNKNOWN)}`;
			},
			m(target, anchor) {
				insert(target, div, anchor);
			},
			p: noop,
			i: noop,
			o: noop,
			d(detaching) {
				if (detaching) {
					detach(div);
				}
			}
		};
	}

	// (224:8) {#each form.sectionFlow.extraElements.concat(formState.currentSection.elements || []) as element}
	function create_each_block(ctx) {
		let elementresolver;
		let current;

		elementresolver = new ElementResolver({
				props: {
					form: /*form*/ ctx[5],
					formState: /*formState*/ ctx[0],
					formActions: /*formActions*/ ctx[7],
					sectionElement: /*element*/ ctx[21]
				}
			});

		return {
			c() {
				create_component(elementresolver.$$.fragment);
			},
			m(target, anchor) {
				mount_component(elementresolver, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const elementresolver_changes = {};
				if (dirty & /*formState*/ 1) elementresolver_changes.formState = /*formState*/ ctx[0];
				if (dirty & /*formState*/ 1) elementresolver_changes.sectionElement = /*element*/ ctx[21];
				elementresolver.$set(elementresolver_changes);
			},
			i(local) {
				if (current) return;
				transition_in(elementresolver.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(elementresolver.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(elementresolver, detaching);
			}
		};
	}

	// (218:4) <FormViewedDetect form={form}>
	function create_default_slot(ctx) {
		let form_1;
		let current;
		let mounted;
		let dispose;
		let each_value = ensure_array_like(/*form*/ ctx[5].sectionFlow.extraElements.concat(/*formState*/ ctx[0].currentSection.elements || []));
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		return {
			c() {
				form_1 = element("form");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr(form_1, "class", "zephr-form-content svelte-j7lu48");
				toggle_class(form_1, "zephr-payment-options-content", /*isFullWidth*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, form_1, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(form_1, null);
					}
				}

				current = true;

				if (!mounted) {
					dispose = listen(form_1, "submit", submit_handler);
					mounted = true;
				}
			},
			p(ctx, dirty) {
				if (dirty & /*form, formState, formActions*/ 161) {
					each_value = ensure_array_like(/*form*/ ctx[5].sectionFlow.extraElements.concat(/*formState*/ ctx[0].currentSection.elements || []));
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(form_1, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (!current || dirty & /*isFullWidth*/ 4) {
					toggle_class(form_1, "zephr-payment-options-content", /*isFullWidth*/ ctx[2]);
				}
			},
			i(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(form_1);
				}

				destroy_each(each_blocks, detaching);
				mounted = false;
				dispose();
			}
		};
	}

	// (234:4) {#if topLevelError}
	function create_if_block_2(ctx) {
		let errormessage;
		let current;

		errormessage = new ErrorMessage({
				props: {
					error: resolveErrorLanguagePackKey(/*form*/ ctx[5], /*topLevelError*/ ctx[3]),
					isPaymentForm: /*isPaymentForm*/ ctx[6]
				}
			});

		return {
			c() {
				create_component(errormessage.$$.fragment);
			},
			m(target, anchor) {
				mount_component(errormessage, target, anchor);
				current = true;
			},
			p(ctx, dirty) {
				const errormessage_changes = {};
				if (dirty & /*topLevelError*/ 8) errormessage_changes.error = resolveErrorLanguagePackKey(/*form*/ ctx[5], /*topLevelError*/ ctx[3]);
				errormessage.$set(errormessage_changes);
			},
			i(local) {
				if (current) return;
				transition_in(errormessage.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(errormessage.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				destroy_component(errormessage, detaching);
			}
		};
	}

	function create_fragment$1(ctx) {
		let div;
		let t;
		let current_block_type_index;
		let if_block1;
		let accordion_action;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*formCanBeManuallyClosed*/ ctx[9] && create_if_block_3(ctx);
		const if_block_creators = [create_if_block, create_if_block_1, create_else_block];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*form*/ ctx[5].formType === "GIFT_REDEMPTION" && !/*isSessionChecked*/ ctx[1]) return 1;
			return 2;
		}

		current_block_type_index = select_block_type(ctx);
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				div = element("div");
				if (if_block0) if_block0.c();
				t = space();
				if_block1.c();
				toggle_class(div, "zephr-form-max-width", !/*isFullWidth*/ ctx[2]);
				toggle_class(div, "zephr-payment-form-max-width", !/*isFullWidth*/ ctx[2]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append(div, t);
				if_blocks[current_block_type_index].m(div, null);
				current = true;

				if (!mounted) {
					dispose = action_destroyer(accordion_action = accordion.call(null, div, /*formIsOpen*/ ctx[4]));
					mounted = true;
				}
			},
			p(ctx, [dirty]) {
				if (/*formCanBeManuallyClosed*/ ctx[9]) if_block0.p(ctx, dirty);
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					} else {
						if_block1.p(ctx, dirty);
					}

					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}

				if (accordion_action && is_function(accordion_action.update) && dirty & /*formIsOpen*/ 16) accordion_action.update.call(null, /*formIsOpen*/ ctx[4]);

				if (!current || dirty & /*isFullWidth*/ 4) {
					toggle_class(div, "zephr-form-max-width", !/*isFullWidth*/ ctx[2]);
				}

				if (!current || dirty & /*isFullWidth*/ 4) {
					toggle_class(div, "zephr-payment-form-max-width", !/*isFullWidth*/ ctx[2]);
				}
			},
			i(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				if (if_block0) if_block0.d();
				if_blocks[current_block_type_index].d();
				mounted = false;
				dispose();
			}
		};
	}
	const defaultBusyKey = "default";
	const submit_handler = e => e?.preventDefault();

	function instance$1($$self, $$props, $$invalidate) {
		let formIsOpen;
		let topLevelError;
		let isFullWidth;
		onMount(addFormProcessorsToWindow);
		let { formConfiguration } = $$props;
		let form = sortForm(formConfiguration);

		if (form.environment.debugLogging) {
			console.log(form);
		}

		// variable
		let isPaymentForm = form.formType === "PAYMENT";

		let requestCountByKey = {};
		let isSessionChecked = false;

		const previewSection = form.environment.previewMode && form.environment.previewInitialState
		? findSectionByAddress(form.environment.previewInitialState, form)
		: null;

		let formState = Object.freeze({
			currentPart: previewSection?.part ?? form.parts[0],
			currentSection: previewSection?.section ?? form.parts[0].sections[0],
			paymentOption: null,
			paymentOptionPrices: null,
			emailAddress: "",
			createPassword: "",
			password: "",
			confirmCreatePassword: "",
			accountMembershipCode: "",
			passwordIsValid: false,
			elementValidity: [],
			canAttemptSectionCompletion: true,
			showFieldErrors: false,
			loginRegistrationComplete: false,
			serverErrors: [],
			isBusy: false,
			isBusyByKey: [],
			formCannotBeActioned: false,
			forgotPassword: false,
			promoCode: "",
			addons: [],
			discountedPlanPrices: [],
			paymentProviderFormLoaded: false,
			paymentProviderError: null,
			paymentFormComplete: false,
			paymentProviderVendorFields: null,
			verificationCode: "",
			userAttributes: extractDefaultUserAttributes(form),
			socialSignin: false,
			paymentProcessed: false,
			invitationEmail: "",
			invitationSent: false,
			validChangeFromPlans: [],
			taxCalculations: {},
			billingAddress: { country: null, postalCode: null },
			formPrerequisiteLoaded: !form.sectionFlow.formRequiresPrerequisiteLoading(form),
			dynamicOfferResult: null,
			originalDynamicOfferResult: null,
			giftCode: new URLSearchParams(window.location.search).get('giftCode') || '',
			giftRecipient: {
				name: '',
				email: '',
				customMessage: '',
				recipientAddress: {
					addressLine1: '',
					addressLine2: '',
					city: '',
					state: '',
					country: '',
					postalCode: ''
				}
			}
		});

		// actions
		const updateFormState = update => {
			$$invalidate(0, formState = Object.freeze({ ...formState, ...update }));
			form.environment.debugLogging && console.log(formState);
			form.environment.onStateChanged(update, formState);
			return formState;
		};

		const _attemptCompleteSection = () => {
			void attemptCompleteSection(form, formState, formActions);
		};

		const _completeSection = () => {
			void completeSection(form, formState, formActions);
		};

		const jumpToPartStart = partType => {
			void jumpToPart(partType, form, formActions);
		};

		const _jumpToSection = sectionType => {
			void jumpToSection(sectionType, form, formActions);
		};

		const onEvent = formEvent => {
			if (form.environment.previewMode) {
				return;
			}

			void form.sectionFlow.eventHandlers[formEvent]?.(form, formState, formActions);
		};

		const modifyRequestCount = (by, busyKey) => {
			const key = busyKey ?? defaultBusyKey;

			if (requestCountByKey[key] === undefined) {
				requestCountByKey[key] = 0;
			}

			requestCountByKey[key] += by;

			if (requestCountByKey[key] < 0) {
				throw "Negative request count";
			}

			const isBusy = Object.values(requestCountByKey).some(v => v > 0);

			if (isBusy !== formState.isBusy) {
				updateFormState({ isBusy });
			}

			const isBusyByKey = requestCountByKey[key] > 0;

			if (isBusyByKey !== formState.isBusyByKey[key]) {
				updateFormState({
					isBusyByKey: {
						...formState.isBusyByKey,
						[key]: isBusyByKey
					}
				});
			}
		};

		const formActions = {
			updateFormState,
			attemptCompleteSection: _attemptCompleteSection,
			completeSection: _completeSection,
			jumpToPartStart,
			jumpToSection: _jumpToSection,
			onEvent,
			incrementRequestCount: (busyKey = null) => modifyRequestCount(+1, busyKey),
			decrementRequestCount: (busyKey = null) => modifyRequestCount(-1, busyKey),
			getFormState: () => formState,
			apiUrlBase: form.environment.apiUrlBase
		};

		// Preview
		if (form.environment.previewMode) {
			form.environment.previewBundle?.setupPreviewMode(form, formActions);
		}

		// When the form first loads, check if this is a currently-registered user
		onMount(async () => {
			if (form.formType === "GIFT_REDEMPTION") {
				// Check user session before triggering form start
				await checkForRegisteredUser(formActions);

				$$invalidate(1, isSessionChecked = true);
			}

			formActions.onEvent(FormEvent.FORM_START);
			logDataLayerEvent(form, 'zephr_form_render', null);
		});

		let formManuallyClosed = false;
		const closeForm = () => $$invalidate(11, formManuallyClosed = true);
		const formCanBeManuallyClosed = form.sectionFlow.canDismissFormManually(form) && form.formType !== 'CHANGE_SUBSCRIPTION';

		$$self.$$set = $$props => {
			if ('formConfiguration' in $$props) $$invalidate(10, formConfiguration = $$props.formConfiguration);
		};

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*formState*/ 1) {
				{
					const canAttemptSectionCompletion = form.sectionFlow.canAttemptSectionCompletion(form, formState);

					if (canAttemptSectionCompletion != formState.canAttemptSectionCompletion) {
						updateFormState({ canAttemptSectionCompletion });
					}
				}
			}

			if ($$self.$$.dirty & /*formManuallyClosed, formState*/ 2049) {
				$$invalidate(4, formIsOpen = !formManuallyClosed && formState.formPrerequisiteLoaded && !formState.formCannotBeActioned);
			}

			if ($$self.$$.dirty & /*formState*/ 1) {
				// Unshown errors
				$$invalidate(3, topLevelError = formState.serverErrors[0] && (formState.currentSection.elements || []).filter(e => serverErrorForElement(e.type, formState)).length === 0
				? formState.serverErrors[0]
				: null);
			}

			if ($$self.$$.dirty & /*formState*/ 1) {
				$$invalidate(2, isFullWidth = [...Object.values(sectionTypes)].find(s => s.type === formState.currentSection.type)?.fullWidth);
			}
		};

		return [
			formState,
			isSessionChecked,
			isFullWidth,
			topLevelError,
			formIsOpen,
			form,
			isPaymentForm,
			formActions,
			closeForm,
			formCanBeManuallyClosed,
			formConfiguration,
			formManuallyClosed
		];
	}

	class FormRoot extends SvelteComponent {
		constructor(options) {
			super();
			init(this, options, instance$1, create_fragment$1, safe_not_equal, { formConfiguration: 10 });
		}
	}

	const defaultCssVariables = {
	    "--zephr-button-borderRadius": "9",
	    "--zephr-button-borderWidth": "0",
	    "--zephr-button-fontSize": "16",
	    "--zephr-button-fontWeight": "normal",
	    "--zephr-button-height": "50",
	    "--zephr-color-accent-main": "#dcf1fb",
	    "--zephr-color-accent-tinted": "#81cdf1",
	    "--zephr-color-action-main": "#006edb",
	    "--zephr-color-action-tinted": "#0f87ff",
	    "--zephr-color-background-main": "#fff",
	    "--zephr-color-background-tinted": "#ccc",
	    "--zephr-color-text-main": "#000",
	    "--zephr-color-text-tinted": "#333",
	    "--zephr-color-warning-main": "#d90b00",
	    "--zephr-color-warning-tinted": "#ff190d",
	    "--zephr-input-borderColor": "#333",
	    "--zephr-input-borderRadius": "5",
	    "--zephr-input-borderWidth": "1",
	    "--zephr-input-height": "50",
	    "--zephr-typography-title-fallbackFont": "sans-serif",
	    "--zephr-typography-title-font": "Roboto",
	    "--zephr-typography-body-fallbackFont": "sans-serif",
	    "--zephr-typography-body-font": "Roboto",
	};
	/* eslint-disable @typescript-eslint/restrict-template-expressions */
	const convertSiteStylesToCssVariables = (siteStyles) => {
	    const styles = {};
	    const convertToCssVariables = (styleGuide, variablePrefix) => {
	        if (styleGuide !== null && typeof styleGuide == "object") {
	            Object.entries(styleGuide).forEach(([key, value]) => {
	                convertToCssVariables(value, variablePrefix.concat(`${variablePrefix ? "-" : ""}${key}`));
	            });
	        }
	        else {
	            styles[`--zephr-${variablePrefix}`] = styleGuide;
	        }
	    };
	    convertToCssVariables(siteStyles, "");
	    return Object.entries({ ...defaultCssVariables, ...styles })
	        .map(([key, value]) => `${key}: ${value}`)
	        .join(';\n');
	};

	function formTypeClass(formType) {
	    switch (formType) {
	        case FormType.CHANGE_SUBSCRIPTION:
	        case FormType.PAYMENT:
	        case FormType.GIFT_SUBSCRIPTION:
	            return "zephr-payment-form";
	        case FormType.REGISTRATION:
	        case FormType.COMPLETE_REGISTRATION:
	        case FormType.GIFT_REDEMPTION:
	            return "zephr-registration-form";
	        case FormType.CONTACT:
	            return "zephr-contact-form";
	        case FormType.DATA_CAPTURE:
	            return "zephr-data-capture-form";
	        default:
	            return "";
	    }
	}

	const userAttributesValuesForPart = (partType, form, formState) => form.parts.find(p => p.type === partType)
	    .sections.flatMap(s => s.elements)
	    .filter(e => e.type === elementTypes.USER_ATTRIBUTE)
	    .map(e => e.config)
	    .reduce((current, elementConfig) => {
	    if (formState.userAttributes) {
	        return ({
	            ...current,
	            [elementConfig.slug]: formState.userAttributes[elementConfig.slug]
	        });
	    }
	    else {
	        return ({
	            ...current
	        });
	    }
	}, {});

	const mapToServerError = (responseCode, responseMessage, formState) => {
	    if (responseCode === 401) {
	        if (responseMessage.indexOf("verification is required") > -1) {
	            return ServerError.EMAIL_VERIFICATION_REQUIRED;
	        }
	        if (responseMessage.indexOf("session must be authenticated") > -1) {
	            return ServerError.NO_AUTHENTICATED_SESSION;
	        }
	        if (formState.verificationCode) {
	            return ServerError.VERIFICATION_CODE_OR_PASSWORD_INCORRECT;
	        }
	        return ServerError.LOGIN_FAILED;
	    }
	    if (responseCode === 402 && responseMessage?.includes('this domain is not supported.')) {
	        return ServerError.BLOCKED_EMAIL_DOMAIN;
	    }
	    if (responseCode === 409) {
	        return ServerError.USER_ALREADY_EXISTS;
	    }
	    if (responseCode === 400 && responseMessage?.includes("The provided password is not strong enough")) {
	        return ServerError.PASSWORD_NOT_STRONG_ENOUGH;
	    }
	    if (responseCode === 404 && responseMessage?.includes("account")) {
	        return ServerError.ACCOUNT_NOT_FOUND;
	    }
	    if (responseCode === 404)
	        return ServerError.USER_DOES_NOT_EXIST;
	    if (responseCode === 429 && responseMessage?.includes("sessions limit reached")) {
	        return ServerError.TOO_MANY_SESSIONS;
	    }
	    if (responseCode === 429)
	        return ServerError.NO_ACCOUNT_ACCESS;
	    if (formState.socialSignin)
	        return ServerError.SOCIAL_SIGNIN_REGISTRATION_LOGIN_ERROR;
	    if (responseCode === 403 && responseMessage?.includes("Contact creation not enabled")) {
	        return ServerError.CONTACT_CREATION_NOT_ENABLED;
	    }
	    return ServerError.UNKNOWN_LOGIN_REGISTER_ERROR;
	};

	const logConversion = (conversion, form, formActions) => {
	    if (!form.organisationConfiguration.ruleAnalyticsEnabled) {
	        return;
	    }
	    void request('zephr/public/rule-outcomes/v1/conversions', {
	        method: 'POST',
	        bodyObject: {
	            "conversion": conversion,
	            "ruleId": form.ruleId,
	            "outcomeId": form.outcomeId
	        }
	    }, formActions);
	};

	const logConversionAfterRegistration = (form, formActions) => logConversion("REGISTERED", form, formActions);

	const PATH_PARAM_NAME = "sharing_id";
	/**
	 * Extract a sharing ID from the page URL.
	 */
	const getProductSharingInvite = () => {
	    try {
	        const sharingId = new URLSearchParams(window.location.search).get(PATH_PARAM_NAME);
	        return sharingId ? { product_sharing_id: sharingId } : null;
	    }
	    catch {
	        // If there is any browser compatibility issue, ignore it
	        return null;
	    }
	};
	const removeSharingInviteFromUrl = (url) => {
	    try {
	        const r = new URL(url);
	        if (!r.searchParams.has(PATH_PARAM_NAME)) {
	            return url;
	        }
	        r.searchParams.delete(PATH_PARAM_NAME);
	        return r.href;
	    }
	    catch {
	        // If there is any browser compatibility issue, ignore it
	        return url;
	    }
	};

	const toLoginPayload = (formState) => ({
	    identifiers: { email_address: formState.emailAddress },
	    validators: {
	        password: formState.password || undefined,
	        email_otp: formState.verificationCode || undefined,
	        token_exchange: formState.socialSigninToken || undefined
	    }
	});
	const preprocessorIdentity$2 = (slug, t) => t;
	const toRegistrationPayload = (form, formState) => {
	    const autoAppliedAttributes = formConfigAs(form).autoApplyAttributes ?? {};
	    const preprocessor = window.Blaize?.preProcessFormData ?? preprocessorIdentity$2;
	    const attributes = userAttributesValuesForPart(partTypes.ACCOUNT_VERIFICATION.type, form, formState);
	    const attributesWithAutoApplied = {
	        ...attributes,
	        ...autoAppliedAttributes
	    };
	    const productSharingData = getProductSharingInvite();
	    return preprocessor(form.id, {
	        identifiers: { email_address: formState.emailAddress },
	        validators: {
	            password: formState.createPassword || undefined,
	            email_otp: formState.verificationCode || undefined,
	            token_exchange: formState.socialSigninToken || undefined
	        },
	        attributes: Object.keys(attributesWithAutoApplied).length ? attributesWithAutoApplied : undefined,
	        account_membership_code: formState.accountMembershipCode || undefined,
	        ...(productSharingData ?? {})
	    });
	};
	const register = async (form, formState, formActions) => {
	    const payload = toRegistrationPayload(form, formState);
	    const response = await request('blaize/register', {
	        method: "POST",
	        bodyObject: payload
	    }, formActions);
	    return processResponse$2(payload, response, form, formState, formActions);
	};
	const login = async (form, formState, formActions) => {
	    const payload = toLoginPayload(formState);
	    const response = await request('blaize/login', {
	        method: "POST",
	        bodyObject: payload
	    }, formActions);
	    return processResponse$2(null, response, form, formState, formActions);
	};
	const processResponse$2 = async (registrationPayload, response, form, formState, formActions) => {
	    registrationPayload ?
	        logDataLayerEvent(form, 'zephr_form_register', {
	            success: response?.ok
	        }) :
	        logDataLayerEvent(form, 'zephr_form_login', {
	            success: response?.ok
	        });
	    if (!response?.ok) {
	        if (formState.verificationCode) {
	            formActions.updateFormState({
	                verificationCodeValid: false
	            });
	        }
	        const responseMessage = (await response.json())?.message;
	        const serverError = mapToServerError(response.status, responseMessage, formState);
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[serverError],
	        });
	        if (serverError === ServerError.PASSWORD_NOT_STRONG_ENOUGH) {
	            formActions.updateFormState({
	                dynamicServerErrorMessage: responseMessage,
	            });
	        }
	        formActions.updateFormState({
	            serverErrors: [serverError]
	        });
	        if (ServerErrors[serverError].jumpToPart) {
	            formActions.jumpToPartStart(ServerErrors[serverError].jumpToPart);
	        }
	        return Promise.resolve();
	    }
	    if (!formState.userExists) {
	        logConversionAfterRegistration(form, formActions);
	    }
	    return response.json()
	        .then(async (json) => {
	        const cookieInResponse = json.cookie?.includes("blaize_session");
	        if (cookieInResponse) {
	            document.cookie = json.cookie;
	        }
	        else {
	            if (!form.sectionFlow.canPartiallyRegister) {
	                console.warn("No cookie returned from login/register endpoint - most likely incorrect form configuration.");
	                formActions.updateFormState({
	                    serverErrors: [ServerError.NO_COOKIE_FROM_LOGIN_REGISTER_ERROR],
	                });
	                return Promise.resolve();
	            }
	        }
	        registrationPayload && window.Blaize?.postProcessFormData && window.Blaize.postProcessFormData(form.id, registrationPayload, json);
	        if (formState.verificationCode && formState.currentSection.elements.some(e => e.type === elementTypes.VERIFICATION_CODE)) {
	            formActions.updateFormState({
	                verificationCodeValid: true
	            });
	            await waitAfterCode(form);
	        }
	        formActions.updateFormState({
	            loginRegistrationComplete: true
	        });
	        return formActions.onEvent(FormEvent.LOGIN_REGISTRATION_COMPLETE);
	    });
	};

	/**
	 * Submit user attributes in sections that are not part of registration.
	 */
	const submitUserAttributesForPart = async (partType, form, formState, formActions) => {
	    const attributes = userAttributesValuesForPart(partType, form, formState);
	    if (Object.keys(attributes).length === 0) {
	        return Promise.resolve();
	    }
	    const response = await request('blaize/profile', {
	        method: "PATCH",
	        bodyObject: attributes
	    }, formActions);
	    if (!response.ok) {
	        formActions.updateFormState({
	            serverErrors: [ServerError.INVALID_USER_ATTRIBUTES]
	        });
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[ServerError.INVALID_USER_ATTRIBUTES],
	        });
	        throw `Error submitting user attributes ${JSON.stringify(response)}`;
	    }
	    return Promise.resolve();
	};

	const CHANGE_SUBSCRIPTION_DEFAULT_CONVERSION_NAME = "CHANGE_SUBSCRIPTION";
	const logConversionAfterPurchase = (form, formActions) => logConversion(formConfigAs(form).changeSubscriptionMode
	    ? (formConfigAs(form).changeSubscriptionConversionName ?? CHANGE_SUBSCRIPTION_DEFAULT_CONVERSION_NAME)
	    : "CUSTOMER", form, formActions);

	// Unique ID creation requires a high quality random # generator. In the browser we therefore
	// require the crypto API and do not support built-in fallback to lower quality random number
	// generators (like Math.random()).
	let getRandomValues;
	const rnds8 = new Uint8Array(16);
	function rng() {
	  // lazy load so that environments that need to polyfill have a chance to do so
	  if (!getRandomValues) {
	    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
	    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

	    if (!getRandomValues) {
	      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
	    }
	  }

	  return getRandomValues(rnds8);
	}

	/**
	 * Convert array of 16 byte values to UUID string format of the form:
	 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
	 */

	const byteToHex = [];

	for (let i = 0; i < 256; ++i) {
	  byteToHex.push((i + 0x100).toString(16).slice(1));
	}

	function unsafeStringify(arr, offset = 0) {
	  // Note: Be careful editing this code!  It's been tuned for performance
	  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
	  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
	}

	const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
	var native = {
	  randomUUID
	};

	function v4(options, buf, offset) {
	  if (native.randomUUID && !buf && !options) {
	    return native.randomUUID();
	  }

	  options = options || {};
	  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

	  rnds[6] = rnds[6] & 0x0f | 0x40;
	  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

	  if (buf) {
	    offset = offset || 0;

	    for (let i = 0; i < 16; ++i) {
	      buf[offset + i] = rnds[i];
	    }

	    return buf;
	  }

	  return unsafeStringify(rnds);
	}

	const pay = (form, formState, formActions) => submitUserAttributesForPart(partTypes.PAYMENT.type, form, formState, formActions)
	    .then(() => {
	    const completer = formState.mobilePaymentService == null
	        ? paymentProviderFor(form.organisationConfiguration.paymentProvider).completer
	        : mobilePaymentServiceFor(form.organisationConfiguration.paymentProvider).completer;
	    return completer(form, formState, formActions)
	        .then(() => {
	        const postFormSubmitMessage = {
	            error: null,
	            errorMessage: "",
	            success: true,
	            formSlug: form.id
	        };
	        const formEventPayload = JSON.stringify(postFormSubmitMessage);
	        // handle ios message
	        window?.webkit?.messageHandlers?.messageHandler?.postMessage(formEventPayload);
	        // handle android message
	        window?.AndroidFormEventListener?.processFormEvent(formEventPayload);
	        logConversionAfterPurchase(form, formActions);
	        formActions.updateFormState({
	            paymentProcessed: true
	        });
	        logDataLayerEvent(form, 'zephr_form_purchase', {
	            productId: formState.paymentOption.productId,
	            planId: formState.paymentOption.slug,
	            price: formState.paymentOptionPrices?.totalPrice
	        });
	        logDataLayerEvent(form, 'purchase', {
	            ecommerce: {
	                transaction_id: v4(),
	                value: formState.paymentOptionPrices?.totalPrice,
	                tax: formState.paymentOptionPrices?.taxPrice,
	                currency: getRelevantCurrency(form, formState),
	                coupon: formState.promoCode,
	                items: [{
	                        item_id: formState.paymentOption.slug,
	                        item_name: formState.paymentOption.productId,
	                        price: formState.paymentOptionPrices?.totalPrice,
	                        quantity: 1
	                    }]
	            }
	        });
	        if (formState.convertCancelSubscriptionToAcceptOffer) {
	            logDataLayerEvent(form, 'zephr_form_subscription_cancel_accept_offer', {
	                canceledProductId: formState.selectedSubscription.productId,
	                acceptedProductId: formState.paymentOption.productId,
	                productLabel: formState.paymentOption.label,
	                currency: formState.paymentOption.currencyCode,
	                amount: formState.paymentOptionPrices?.totalPrice
	            });
	        }
	        formActions.jumpToPartStart(partTypes.SUCCESS.type);
	        if (formConfigAs(form).changeSubscriptionMode) {
	            const changingFromSubscription = formState
	                .validChangeFromPlans
	                .find(plan => formState.paymentOption.slug === plan.planSlug && formState.paymentOption.productId === plan.productId)
	                .changesFromSubscription;
	            logDataLayerEvent(form, 'zephr_form_subscription_change', {
	                fromProductId: changingFromSubscription.productId,
	                fromProductAmount: changingFromSubscription.amount,
	                toProductId: formState.paymentOption.productId,
	                toProductAmount: formState.paymentOptionPrices.netPriceFormattedString,
	            });
	        }
	    }).catch(err => {
	        const serverError = formState.mobilePaymentService == null
	            ? ServerError.PAYMENT_PROCESSING_ERROR
	            : ServerError.MOBILE_PAYMENT_PROCESSING_ERROR;
	        console.error("Error completing payment", err);
	        logDataLayerEvent(form, 'zephr_form_payment_failure', {
	            reason: err
	        });
	        formActions.updateFormState({
	            mobilePaymentService: null,
	            serverErrors: [serverError]
	        });
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[serverError],
	        });
	    });
	});

	const calculateChangeSubscriptionProrate = async (form, formState, formActions) => {
	    if (!formConfigAs(form).changeSubscriptionMode) {
	        return;
	    }
	    formActions.updateFormState({
	        changeSubscriptionProrate: null
	    });
	    const prorateCalculator = paymentProviderFor(form.organisationConfiguration.paymentProvider)
	        .changeSubscriptionProrateCalculator;
	    if (!prorateCalculator) {
	        return;
	    }
	    const prorate = await prorateCalculator(form, formState, formActions);
	    formActions.updateFormState({
	        changeSubscriptionProrate: prorate
	    });
	};

	const getSubscriptionParam = (url) => {
	    const urlObj = new URL(url);
	    return urlObj.searchParams.get("subscription");
	};

	const getChangeFromPlans = (subscriptions, form) => {
	    return subscriptions.length === 0 ? [] :
	        formConfigAs(form).paymentOptions.map(paymentOption => {
	            const mapping = (formConfigAs(form).changeSubscriptionPlanMappings ?? [])
	                .find(mapping => mapping.toPlan.planSlug === paymentOption.slug
	                && mapping.toPlan.productId === paymentOption.productId);
	            if (!mapping) {
	                return;
	            }
	            const validSubscriptions = subscriptions.filter(subscription => 
	            // Ignore if subscription is for the destination payment option
	            !(subscription.planId === paymentOption.slug && subscription.productId === paymentOption.productId)
	                &&
	                    (
	                    // Ignore if subscription plan is not in 'fromPlans', unless allowing any plan
	                    mapping.fromAnyPlan ||
	                        mapping.fromPlans.some(fromPlan => ((!subscription.multiphasePlan && fromPlan.planSlug === subscription.planId) ||
	                            subscriptionMatchesMultiphasePlan(fromPlan, subscription))
	                            && fromPlan.productId === subscription.productId)));
	            if (validSubscriptions.length === 0) {
	                return;
	            }
	            if (validSubscriptions.length > 1) {
	                console.log("Found multiple valid subscriptions to move to payment option, selecting the first", paymentOption);
	            }
	            return {
	                planSlug: paymentOption.slug,
	                productId: paymentOption.productId,
	                changesFromSubscription: subscriptions[0],
	            };
	        }).filter(Boolean);
	};
	const subscriptionMatchesMultiphasePlan = (fromPlan, subscription) => {
	    if (!subscription.multiphasePlan) {
	        return false;
	    }
	    const planSlug = fromPlan.planSlug;
	    const multiphasePlan = subscription.multiphasePlanMappings?.[planSlug];
	    if (!multiphasePlan) {
	        return false;
	    }
	    return multiphasePlan.phases.some(phase => phase.planId === subscription.planId);
	};
	const loadExistingSubscriptions$1 = async (form, formState, formActions, hasDynamicOfferAttached, validPlansRequired) => {
	    const subscriptionLoader = paymentProviderFor(form.organisationConfiguration.paymentProvider).existingSubscriptionLoader;
	    if (!subscriptionLoader) {
	        console.error(`Existing subscription loader not configured for ${form.organisationConfiguration.paymentProvider}`);
	        formActions.updateFormState({
	            formCannotBeActioned: true
	        });
	        return;
	    }
	    let subscriptions;
	    try {
	        subscriptions = await subscriptionLoader(form, formState, formActions, true);
	    }
	    catch (err) {
	        console.error("Unable to load subscriptions", err);
	        formActions.updateFormState({
	            formCannotBeActioned: true
	        });
	        return;
	    }
	    const subscriptionQueryParamId = getSubscriptionParam(window.location.href);
	    if (subscriptionQueryParamId) {
	        const subscriptionMatched = subscriptions.filter(sub => sub.externalId === subscriptionQueryParamId);
	        if (subscriptionMatched.length && getChangeFromPlans(subscriptionMatched, form).length) {
	            subscriptions = subscriptionMatched;
	        }
	    }
	    if (hasDynamicOfferAttached) {
	        filterDynamicOfferChangeFromPlans(subscriptions, formState, formActions);
	        return;
	    }
	    const changeFromPlans = getChangeFromPlans(subscriptions, form);
	    const selectionMode = formConfigAs(form).subscriptionSelectionMode;
	    if (subscriptions.length === 0) {
	        console.warn("Not showing form as user has no active subscriptions");
	    }
	    else if (changeFromPlans.length === 0 && !selectionMode && validPlansRequired) {
	        console.warn("Not showing form as no payment options can be actioned with the user's current subscriptions");
	    }
	    if (selectionMode) {
	        subscriptions = subscriptions.map(subscription => {
	            if (formConfigAs(form).changeSubscriptionPlanMappings.some(m => m.fromAnyPlan || m.fromPlans.some(fromPlan => ((!subscription.multiphasePlan && fromPlan.planSlug === subscription.planId) ||
	                subscriptionMatchesMultiphasePlan(fromPlan, subscription))
	                && fromPlan.productId === subscription.productId))) {
	                subscription.cannotBeChanged = false;
	            }
	            else {
	                subscription.cannotBeChanged = true;
	            }
	            return subscription;
	        });
	    }
	    formActions.updateFormState({
	        existingSubscriptions: subscriptions,
	        formCannotBeActioned: changeFromPlans.length === 0 && !selectionMode && validPlansRequired,
	        validChangeFromPlans: changeFromPlans,
	        formPrerequisiteLoaded: true,
	    });
	    return subscriptions;
	};
	const filterDynamicOfferChangeFromPlans = (subscriptions, formState, formActions) => {
	    if (subscriptions.length === 0) {
	        console.log("No subscriptions available.");
	        formActions.updateFormState({
	            existingSubscriptions: [],
	            formCannotBeActioned: true,
	            validChangeFromPlans: [],
	            formPrerequisiteLoaded: true,
	        });
	        return;
	    }
	    const dynamicOffer = formState.dynamicOfferResult;
	    if (!dynamicOffer) {
	        console.log("No dynamic offer result available.");
	    }
	    // Filter payment plans from dynamic offers that the user is not already subscribed to and matches the currency of existing subscriptions.
	    const changeFromPlans = dynamicOffer?.products?.flatMap(product => product.paymentPlans.filter(plan => {
	        const isSubscribed = subscriptions.some(sub => sub.planId === plan.planId && sub.productId === product.id);
	        const currencyMatch = subscriptions.every(sub => plan.charges.every(charge => charge.prices?.some(price => price.currency === sub.currency)));
	        return !isSubscribed && currencyMatch;
	    }).map(plan => ({
	        planSlug: plan.planId,
	        productId: product.id,
	        changesFromSubscription: subscriptions.find(sub => plan.charges.every(charge => charge.prices?.some(price => price.currency === sub.currency)))
	    })).filter(plan => {
	        const hasChangesFromSubscription = !!plan.changesFromSubscription;
	        return hasChangesFromSubscription;
	    })) ?? [];
	    formActions.updateFormState({
	        existingSubscriptions: subscriptions,
	        formCannotBeActioned: changeFromPlans.length === 0,
	        validChangeFromPlans: changeFromPlans,
	        formPrerequisiteLoaded: true,
	    });
	};

	/**
	 * Map of possible movements through the form sections.
	 */
	let checkForRegisteredUserResolve;
	const checkForRegisteredUserPromise = new Promise(function (resolve) {
	    checkForRegisteredUserResolve = resolve;
	});
	const formStartAction$a = async (form, _, formActions) => {
	    const hasDynamicOfferAttached = !!formConfigAs(form).dynamicOffer?.id
	        || !!formConfigAs(form).dynamicOfferPreview;
	    if (hasDynamicOfferAttached) {
	        await getDynamicOffer(form, formActions).catch((e) => { console.error('Error loading Dynamic Offer', e); });
	    }
	    return checkForRegisteredUser(formActions)
	        .then(async (alreadyRegistered) => {
	        checkForRegisteredUserResolve(checkForRegisteredUserResolve);
	        if (formConfigAs(form).changeSubscriptionMode) {
	            formActions.updateFormState({ formCannotBeActioned: !alreadyRegistered });
	            await loadExistingSubscriptions$1(form, formActions.getFormState(), formActions, hasDynamicOfferAttached, true);
	            const subscriptionQueryParam = getSubscriptionParam(window.location.href);
	            if (subscriptionQueryParam && formActions.getFormState().existingSubscriptions.length === 1) {
	                formActions.jumpToPartStart(partTypes.PLAN_SELECT.type);
	            }
	        }
	    });
	};
	const onPlanSelectComplete$2 = (form, formState, formActions) => 
	// After plan select, wait to see if the user is already logged in
	checkForRegisteredUserPromise
	    .then(async () => {
	    const state = formActions.getFormState();
	    if (state.userSession || state.loginRegistrationComplete) {
	        const updatedState = await getProductAddons(form, state, formActions);
	        void calculatePrices(form, updatedState, formActions)
	            .then(formState => logDataLayerEvents(form, formState));
	        void calculateChangeSubscriptionProrate(form, updatedState, formActions);
	        formActions.jumpToPartStart(partTypes.PAYMENT.type);
	    }
	    else {
	        void calculatePrices(form, formState, formActions)
	            .then(formState => logDataLayerEvents(form, formState));
	        void calculateChangeSubscriptionProrate(form, formState, formActions);
	        formActions.jumpToPartStart(partTypes.ACCOUNT_VERIFICATION.type);
	    }
	});
	const logDataLayerEvents = (form, formState) => {
	    // don't trigger data layer events for other form types that override this flow (i.e. gift subscription form)
	    if (form.organisationConfiguration.trackFormDataLayerEvents && form.formType == FormType.PAYMENT) {
	        const paymentOption = formState.paymentOption;
	        // await calculatePrices(form, formActions.getFormState(), formActions);
	        const paymentOptionPrice = formState.paymentOptionPrices?.totalPrice;
	        logDataLayerEvent(form, 'zephr_form_payment_option_selected', {
	            productId: paymentOption.productId,
	            planId: paymentOption.slug,
	            price: paymentOptionPrice,
	        });
	        logDataLayerEvent(form, 'select_item', {
	            ecommerce: {
	                items: [{
	                        item_id: paymentOption.slug,
	                        item_name: paymentOption.productId,
	                        price: paymentOptionPrice,
	                        quantity: 1
	                    }]
	            }
	        });
	        logDataLayerEvent(form, 'add_to_cart', {
	            ecommerce: {
	                currency: formConfigAs(form).formCurrency ?? paymentOption?.currencyCode,
	                value: paymentOptionPrice,
	                items: [{
	                        item_id: paymentOption.slug,
	                        item_name: paymentOption.productId,
	                        price: paymentOptionPrice,
	                        quantity: 1
	                    }]
	            }
	        });
	    }
	};
	const onAccountVerificationComplete$1 = (form, formState, formActions) => (formState.userExists ? login : register)(form, formState, formActions);
	const onSuccessComplete$1 = (form, formState, formActions) => submitUserAttributesForPart(partTypes.SUCCESS.type, form, formState, formActions)
	    .then(() => {
	    window.location.reload();
	});
	const onLoginRegister = (form, _, formActions) => getProductAddons(form, formActions.getFormState(), formActions)
	    .then(() => calculatePrices(form, formActions.getFormState(), formActions))
	    .then(() => formActions.jumpToPartStart(partTypes.PAYMENT.type));
	const onSubscriptionSelectComplete$4 = (form, formState, formActions) => {
	    const changeFromPlans = getChangeFromPlans([formState.selectedSubscription], form);
	    formActions.updateFormState({
	        existingSubscriptions: [formState.selectedSubscription],
	        formCannotBeActioned: changeFromPlans.length === 0,
	        validChangeFromPlans: changeFromPlans,
	        formPrerequisiteLoaded: true,
	    });
	    formActions.jumpToPartStart(partTypes.PLAN_SELECT.type);
	};
	const eventHandlers$b = {
	    [FormEvent.FORM_START]: formStartAction$a,
	    [FormEvent.LOGIN_REGISTRATION_COMPLETE]: onLoginRegister,
	    [FormEvent.SECTION_EMAIL_COMPLETE]: onEmailEntered,
	    [FormEvent.SECTION_PASSWORD_RESET_COMPLETE]: resetPassword,
	    [FormEvent.SECTION_FORGOT_PASSWORD_COMPLETE]: verifiyPasswordResetCode,
	    [FormEvent.PART_PLAN_SELECT_COMPLETE]: onPlanSelectComplete$2,
	    [FormEvent.PART_ACCOUNT_VERIFICATION_COMPLETE]: onAccountVerificationComplete$1,
	    [FormEvent.PART_PAYMENT_COMPLETE]: pay,
	    [FormEvent.PART_SUCCESS_COMPLETE]: onSuccessComplete$1,
	    [FormEvent.SELECT_SUBSCRIPTION_COMPLETE]: onSubscriptionSelectComplete$4,
	};
	const sectionVisibilities$9 = [
	    {
	        type: sectionTypes.EMAIL.type,
	        isDisplayedInProgressBar: true,
	        isVisible: (form) => !formConfigAs(form).changeSubscriptionMode
	    },
	    {
	        type: sectionTypes.LOGIN_PASSWORD.type,
	        isDisplayedInProgressBar: false,
	        isVisible: (form, formState) => formConfigAs(form).usePassword && formState.userExists && !formState.socialSignin
	    },
	    {
	        type: sectionTypes.PASSWORD_SETUP.type,
	        isDisplayedInProgressBar: false,
	        isVisible: (form, formState) => formConfigAs(form).usePassword && !formState.userExists && !formState.socialSignin
	    },
	    {
	        type: sectionTypes.SUCCESS.type,
	        isDisplayedInProgressBar: false,
	        isVisible: () => true
	    },
	    {
	        type: sectionTypes.PASSWORD_RESET.type,
	        isDisplayedInProgressBar: false,
	        isVisible: (form, formState) => formConfigAs(form).usePassword && formState.forgotPassword
	    },
	    {
	        type: sectionTypes.FORGOT_PASSWORD.type,
	        isDisplayedInProgressBar: false,
	        isVisible: (form, formState) => formConfigAs(form).usePassword && formState.forgotPassword
	    },
	    {
	        type: sectionTypes.VERIFICATION_CODE_LOGIN.type,
	        isDisplayedInProgressBar: false,
	        isVisible: (form, formState) => (formState.userExists && (formConfigAs(form).useVerificationCodes || formState.socialSignin)) ?? false
	    },
	    {
	        type: sectionTypes.VERIFICATION_CODE_REGISTRATION.type,
	        isDisplayedInProgressBar: false,
	        isVisible: (form, formState) => (!formState.userExists && (formConfigAs(form).useVerificationCodes || formState.emailIsContact)) ?? false
	    },
	    {
	        type: sectionTypes.REGISTRATION_CUSTOM.type,
	        isDisplayedInProgressBar: true,
	        isVisible: (form, formState) => !formState.userExists
	    }
	];
	const canAttemptSectionCompletion$a = (form, formState) => {
	    const providerConfig = paymentProviderFor(form.organisationConfiguration.paymentProvider);
	    return !formState.elementValidity.filter(e => e.partType === formState.currentPart.type &&
	        e.sectionType === formState.currentSection.type &&
	        e.sectionOrder === formState.currentSection.order)
	        .filter(e => !(e.elementType === elementTypes.PAYMENT
	        && providerConfig.canAttemptIncompletePaymentFormSubmission
	        && formState.paymentProviderFormLoaded))
	        .some(e => !e.isValid);
	};
	const canDismissFormManually = (form) => formConfigAs(form).changeSubscriptionMode;
	const formRequiresPrerequisiteLoading = (form) => formConfigAs(form).changeSubscriptionMode;
	const extraElements$2 = [
	    {
	        type: elementTypes.PAYMENT_PRE_LOADER,
	        order: -1,
	    },
	];
	const sectionFlow$9 = {
	    extraElements: extraElements$2,
	    sectionVisibilities: sectionVisibilities$9,
	    eventHandlers: eventHandlers$b,
	    canAttemptSectionCompletion: canAttemptSectionCompletion$a,
	    canDismissFormManually,
	    formRequiresPrerequisiteLoading
	};

	/**
	 * Map of possible movements through the form sections for reg forms.
	 */
	const onAccountVerificationComplete = (form, formState, formActions) => (formState.userExists ? login : register)(form, formState, formActions);
	const onLoginRegisterComplete$1 = async (form, formState, formActions) => {
	    const config = formConfigAs(form);
	    const isPasswordless = getFormIsPasswordless(form);
	    if (!formState.userExists && (isPasswordless || (form.organisationConfiguration.requireEmailVerfication && !config.useVerificationCodes && !formState.socialSignin))) {
	        await sendLink(form, 'register', formState.emailAddress, formActions);
	        await jumpToSection(sectionTypes.EMAIL_VERIFIED.type, form, formActions);
	        return Promise.resolve();
	    }
	    if (config.showSuccessOnFormCompletion && !formState.userExists) {
	        await jumpToSection(sectionTypes.SUCCESS.type, form, formActions);
	    }
	    else {
	        window.location.href = removeSharingInviteFromUrl(window.location.href);
	        if (window.flowpoint) {
	            window.flowpoint.track("Registration/Login Form Submitted");
	        }
	    }
	    return Promise.resolve();
	};
	const onSuccessComplete = () => {
	    window.location.href = removeSharingInviteFromUrl(window.location.href);
	    if (window.flowpoint) {
	        window.flowpoint.track("Registration/Login Form Submitted");
	    }
	    return Promise.resolve();
	};
	const eventHandlers$a = {
	    [FormEvent.LOGIN_REGISTRATION_COMPLETE]: onLoginRegisterComplete$1,
	    [FormEvent.SECTION_EMAIL_COMPLETE]: onEmailEntered,
	    [FormEvent.SECTION_PASSWORD_RESET_COMPLETE]: resetPassword,
	    [FormEvent.SECTION_FORGOT_PASSWORD_COMPLETE]: verifiyPasswordResetCode,
	    [FormEvent.PART_ACCOUNT_VERIFICATION_COMPLETE]: onAccountVerificationComplete,
	    [FormEvent.PART_SUCCESS_COMPLETE]: onSuccessComplete,
	};
	const sectionVisibilities$8 = [
	    {
	        type: sectionTypes.EMAIL.type,
	        isDisplayedInProgressBar: true,
	        isVisible: () => true
	    },
	    {
	        type: sectionTypes.LOGIN_PASSWORD.type,
	        isDisplayedInProgressBar: true,
	        isVisible: (form, formState) => formConfigAs(form).usePassword && formState.userExists && !formState.socialSignin
	    },
	    {
	        type: sectionTypes.PASSWORD_SETUP.type,
	        isDisplayedInProgressBar: true,
	        isVisible: (form, formState) => formConfigAs(form).usePassword && !formState.userExists && !formState.socialSignin
	    },
	    {
	        type: sectionTypes.PASSWORD_RESET.type,
	        isDisplayedInProgressBar: false,
	        isVisible: (form, formState) => formConfigAs(form).usePassword && formState.forgotPassword
	    },
	    {
	        type: sectionTypes.FORGOT_PASSWORD.type,
	        isDisplayedInProgressBar: false,
	        isVisible: (form, formState) => formConfigAs(form).usePassword && formState.forgotPassword
	    },
	    {
	        type: sectionTypes.VERIFICATION_CODE_LOGIN.type,
	        isDisplayedInProgressBar: false,
	        isVisible: (form, formState) => (formState.userExists && (formConfigAs(form).useVerificationCodes || formState.socialSignin)) ?? false
	    },
	    {
	        type: sectionTypes.VERIFICATION_CODE_REGISTRATION.type,
	        isDisplayedInProgressBar: false,
	        isVisible: (form, formState) => (!formState.userExists && (formConfigAs(form).useVerificationCodes || formState.emailIsContact)) ?? false
	    },
	    {
	        type: sectionTypes.REGISTRATION_CUSTOM.type,
	        isDisplayedInProgressBar: true,
	        isVisible: (_, formState) => !formState.userExists
	    },
	    {
	        type: sectionTypes.SUCCESS.type,
	        isDisplayedInProgressBar: false,
	        isVisible: () => true
	    },
	    {
	        type: sectionTypes.EMAIL_VERIFIED.type,
	        isDisplayedInProgressBar: false,
	        isVisible: (form) => form.organisationConfiguration.requireEmailVerfication && !(formConfigAs(form).useVerificationCodes)
	    },
	    {
	        type: sectionTypes.PASSWORDLESS_VIA_LOGIN_LINK.type,
	        isDisplayedInProgressBar: false,
	        isVisible: (form, formState) => formState.userExists && getFormIsPasswordless(form)
	    }
	];
	const canAttemptSectionCompletion$9 = (_, formState) => {
	    return !formState.elementValidity.filter(e => e.partType === formState.currentPart.type &&
	        e.sectionType === formState.currentSection.type &&
	        e.sectionOrder === formState.currentSection.order)
	        .some(e => !e.isValid);
	};
	const sectionFlow$8 = {
	    extraElements: [],
	    eventHandlers: eventHandlers$a,
	    sectionVisibilities: sectionVisibilities$8,
	    canAttemptSectionCompletion: canAttemptSectionCompletion$9,
	    canDismissFormManually: () => false,
	    formRequiresPrerequisiteLoading: () => false,
	    canPartiallyRegister: true
	};

	const processResponse$1 = async (payload, response, form, formState, formActions) => {
	    const json = await response.json();
	    if (response?.ok) {
	        logConversion('CONTACT', form, formActions);
	        window.Blaize?.postProcessFormData && window.Blaize.postProcessFormData(form.id, payload, json);
	        return Promise.resolve(true);
	    }
	    // Handle errors
	    const serverError = mapToServerError(response.status, json?.message, formState);
	    formActions.updateFormState({
	        serverErrors: [serverError]
	    });
	    logDataLayerEvent(form, 'zephr_form_error', {
	        error: ServerError[serverError],
	    });
	    if (ServerErrors[serverError].jumpToPart) {
	        formActions.jumpToPartStart(ServerErrors[serverError].jumpToPart);
	    }
	    return Promise.resolve(false);
	};
	const preprocessorIdentity$1 = (_, t) => t;
	const toContactCreeatePayload = (form, formState) => {
	    const autoAppliedAttributes = formConfigAs(form).autoApplyAttributes ?? {};
	    const preprocessor = window.Blaize?.preProcessFormData ?? preprocessorIdentity$1;
	    const attributes = userAttributesValuesForPart(partTypes.CONTACT_VERIFICATION.type, form, formState);
	    const attributesWithAutoApplied = {
	        ...attributes,
	        ...autoAppliedAttributes
	    };
	    return preprocessor(form.id, {
	        identifiers: { email_address: formState.emailAddress },
	        attributes: Object.keys(attributesWithAutoApplied).length ? attributesWithAutoApplied : undefined,
	    });
	};
	const registerContact = async (form, formState, formActions) => {
	    const payload = toContactCreeatePayload(form, formState);
	    const response = await request('zephr/createContact', {
	        method: "POST",
	        bodyObject: payload
	    }, formActions);
	    return processResponse$1(payload, response, form, formState, formActions);
	};

	/**
	 * Map of possible movements through the form sections for contact forms.
	 */
	const formStartAction$9 = async (_, __, formActions) => {
	    await checkForRegisteredUser(formActions);
	};
	// handle submit of email on first step or after additional attributes preferences provided
	const onContactVerificationComplete = async (form, formState, formActions) => {
	    const config = formConfigAs(form);
	    try {
	        await registerContact(form, formState, formActions);
	        if (config.showSuccessOnFormCompletion) {
	            await jumpToPart(partTypes.SUCCESS.type, form, formActions);
	        }
	        else {
	            window.location.reload();
	        }
	    }
	    catch (error) {
	        console.error(error);
	        await jumpToSection(sectionTypes.EMAIL.type, form, formActions);
	    }
	};
	const eventHandlers$9 = {
	    [FormEvent.FORM_START]: formStartAction$9,
	    [FormEvent.PART_CONTACT_VERIFICATION_COMPLETE]: onContactVerificationComplete,
	};
	const sectionVisibilities$7 = [
	    {
	        type: sectionTypes.EMAIL.type,
	        isDisplayedInProgressBar: false,
	        isVisible: () => true,
	    },
	    {
	        type: sectionTypes.REGISTRATION_CUSTOM.type,
	        isDisplayedInProgressBar: false,
	        isVisible: (_, formState) => !formState.userExists,
	    },
	];
	const canAttemptSectionCompletion$8 = (_, formState) => {
	    return !formState.elementValidity
	        .filter((e) => e.partType === formState.currentPart.type &&
	        e.sectionType === formState.currentSection.type &&
	        e.sectionOrder === formState.currentSection.order)
	        .some((e) => !e.isValid);
	};
	const sectionFlow$7 = {
	    extraElements: [],
	    eventHandlers: eventHandlers$9,
	    sectionVisibilities: sectionVisibilities$7,
	    canAttemptSectionCompletion: canAttemptSectionCompletion$8,
	    canDismissFormManually: () => false,
	    formRequiresPrerequisiteLoading: () => false,
	};

	const processResponse = async (payload, response, attributes, form, formState, formActions) => {
	    if (response?.ok) {
	        if (form.formType == FormType.UPDATE_PROFILE) {
	            logDataLayerEvent(form, 'zephr_form_profile_update', {
	                success: response?.ok,
	                ...Object.entries(attributes).reduce((acc, [key, value]) => ({ ...acc, [`attr_${key}`]: value }), {})
	            });
	        }
	        if (form.formType == FormType.DATA_CAPTURE) {
	            logConversion('Data Captured', form, formActions);
	            logDataLayerEvent(form, 'zephr_form_data_capture', {
	                success: response?.ok,
	                ...Object.entries(attributes).reduce((acc, [key, value]) => ({ ...acc, [`attr_${key}`]: value }), {})
	            });
	        }
	        if (form.formType == FormType.COMPLETE_REGISTRATION) {
	            logConversion('Completed Registration', form, formActions);
	            logDataLayerEvent(form, 'zephr_form_complete_registration', {
	                success: response?.ok,
	                ...Object.entries(attributes).reduce((acc, [key, value]) => ({ ...acc, [`attr_${key}`]: value }), {})
	            });
	        }
	        const json = await response.json();
	        payload && window.Blaize?.postProcessFormData && window.Blaize.postProcessFormData(form.id, payload, json);
	        return Promise.resolve(true);
	    }
	    const responseMessage = (await response.json())?.message;
	    const serverError = mapToServerError(response.status, responseMessage, formState);
	    formActions.updateFormState({
	        serverErrors: [serverError]
	    });
	    logDataLayerEvent(form, 'zephr_form_error', {
	        error: ServerError[serverError],
	    });
	    return Promise.resolve(false);
	};
	const preprocessorIdentity = (_, t) => t;
	const toUpdateUserPayload = (form, formState, partType) => {
	    const preprocessor = window.Blaize?.preProcessFormData ?? preprocessorIdentity;
	    const attributes = userAttributesValuesForPart(partType, form, formState);
	    const autoAppliedAttributes = formConfigAs(form).autoApplyAttributes ?? {};
	    return preprocessor(form.id, {
	        ...attributes,
	        ...autoAppliedAttributes,
	        ...(formState.createPassword && { 'blaize-validator': formState.createPassword }),
	    });
	};
	const updateUser = async (form, formState, formActions, partType) => {
	    const payload = toUpdateUserPayload(form, formState, partType);
	    if (formState.fireCancelationReasonEvent) {
	        formActions.updateFormState({
	            cancelationReasonAttributes: payload
	        });
	    }
	    const response = await request('blaize/profile', {
	        method: "PATCH",
	        bodyObject: payload
	    }, formActions);
	    const attributes = userAttributesValuesForPart(partType, form, formState);
	    return processResponse(payload, response, attributes, form, formState, formActions);
	};

	const formStartAction$8 = async (form, formState, formActions) => {
	    const hideIfSet = form.parts
	        .map(e => e.sections)
	        .reduce((acc, curr) => {
	        const attrToHide = curr.map(e => e.elements
	            .filter(e => e.type == "user_attribute" && e.config?.hideIfSet)
	            .map(e => e.config?.slug)
	            .filter(slug => slug != null));
	        return acc.concat(attrToHide);
	    }, [])
	        .flat();
	    const toRemove = [];
	    try {
	        const response = await request('blaize/profile', { method: "GET" }, formActions);
	        if (response?.ok) {
	            const responseJson = await response.json();
	            formConfigAs(form).autoApplyAttributes &&
	                Object.keys(formConfigAs(form).autoApplyAttributes).forEach(a => {
	                    if (Object.prototype.hasOwnProperty.call(responseJson, a)) {
	                        delete responseJson[a];
	                    }
	                });
	            hideIfSet.forEach(a => {
	                if (Object.prototype.hasOwnProperty.call(responseJson, a)) {
	                    toRemove.push(a);
	                }
	            });
	            if (toRemove.length == Object.keys(formState.userAttributes).length && form.formType != FormType.COMPLETE_REGISTRATION) {
	                console.warn("Not showing form as user has no attributes to update");
	            }
	            else {
	                formActions.updateFormState({
	                    formPrerequisiteLoaded: true,
	                    hideIfSetAttributes: toRemove,
	                    userAttributes: { ...responseJson },
	                });
	            }
	        }
	    }
	    catch (err) {
	        console.error(err);
	    }
	};
	const onUpdateProfileComplete = async (form, formState, formActions) => {
	    const config = formConfigAs(form);
	    try {
	        await updateUser(form, formState, formActions, partTypes.PROFILE_UPDATE.type)
	            .then(async (success) => {
	            if (success && config.showSuccessOnFormCompletion) {
	                await jumpToPart(partTypes.SUCCESS.type, form, formActions);
	            }
	            else if (success) {
	                window.location.reload();
	            }
	        });
	    }
	    catch (error) {
	        console.error(error);
	    }
	};
	const eventHandlers$8 = {
	    [FormEvent.FORM_START]: formStartAction$8,
	    [FormEvent.PART_PROFILE_UPDATE_COMPLETE]: onUpdateProfileComplete,
	};
	const sectionVisibilities$6 = [];
	const canAttemptSectionCompletion$7 = (_, formState) => {
	    return !formState.elementValidity
	        .filter((e) => e.partType === formState.currentPart.type &&
	        e.sectionType === formState.currentSection.type &&
	        e.sectionOrder === formState.currentSection.order)
	        .some((e) => !e.isValid);
	};
	const sectionFlow$6 = {
	    extraElements: [],
	    eventHandlers: eventHandlers$8,
	    sectionVisibilities: sectionVisibilities$6,
	    canAttemptSectionCompletion: canAttemptSectionCompletion$7,
	    canDismissFormManually: () => false,
	    formRequiresPrerequisiteLoading: () => true,
	};

	const startUpdateEmailFlow = async (form, formState, formActions) => {
	    try {
	        const updateEmailWithoutPassword = !formState.password;
	        const payload = {
	            current_identifiers: {
	                email_address: formState.readOnlyEmail,
	            },
	            new_identifiers: {
	                email_address: formState.emailAddress,
	            },
	            ...(updateEmailWithoutPassword ? {} : {
	                validators: {
	                    password: formState.password,
	                },
	            }),
	        };
	        const response = await request(updateEmailWithoutPassword ? 'blaize/users/update-email' : 'zephr/users/update-email', {
	            method: 'POST',
	            bodyObject: payload,
	        }, formActions);
	        logDataLayerEvent(form, 'zephr_form_email_update_code_sent', {
	            success: response?.ok
	        });
	        if (!response.ok) {
	            formActions.updateFormState({
	                serverErrors: [ServerError.UNKNOWN],
	            });
	            logDataLayerEvent(form, 'zephr_form_error', {
	                error: ServerError[ServerError.UNKNOWN],
	            });
	            return false;
	        }
	        return true;
	    }
	    catch (err) {
	        formActions.updateFormState({
	            serverErrors: [ServerError.UNKNOWN],
	        });
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[ServerError.UNKNOWN],
	        });
	        return false;
	    }
	};
	const endEmailUpdateFlow = async (form, formState, formActions) => {
	    formActions.incrementRequestCount();
	    formActions.updateFormState({
	        verificationCodeValid: undefined
	    });
	    const response = await request(`zephr/users/update-email/${formState.verificationCode}`, {
	        method: "POST",
	        bodyObject: {
	            current_identifiers: {
	                email_address: formState.readOnlyEmail,
	            },
	        }
	    }, formActions);
	    logDataLayerEvent(form, 'zephr_form_password_reset_code_validate', {
	        success: response?.ok
	    });
	    if (!response.ok) {
	        formActions.updateFormState({
	            serverErrors: [ServerError.VERIFICATION_CODE_INCORRECT]
	        });
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[ServerError.VERIFICATION_CODE_INCORRECT],
	        });
	        formActions.decrementRequestCount();
	        return false;
	    }
	    await waitAfterCode(form);
	    formActions.decrementRequestCount();
	    return true;
	};

	const startPasswordUpdateFlow = async (form, formState, formActions) => {
	    try {
	        const payload = {
	            current_validators: {
	                password: formState.currentPassword,
	            },
	            new_validators: {
	                password: formState.createPassword,
	            },
	        };
	        const response = await request('zephr/users/change-password', {
	            method: 'POST',
	            bodyObject: payload,
	        }, formActions);
	        logDataLayerEvent(form, 'zephr_form_password_update_code_sent', {
	            success: response?.ok
	        });
	        if (!response.ok) {
	            formActions.updateFormState({
	                serverErrors: [ServerError.UNKNOWN],
	            });
	            return false;
	        }
	        return true;
	    }
	    catch (err) {
	        formActions.updateFormState({
	            serverErrors: [ServerError.UNKNOWN],
	        });
	        return false;
	    }
	};
	const endPasswordUpdateFlow = async (form, formState, formActions) => {
	    formActions.incrementRequestCount();
	    formActions.updateFormState({
	        verificationCodeValid: undefined
	    });
	    const response = await request(`zephr/users/change-password/${formState.verificationCode}`, {
	        method: "GET",
	    }, formActions);
	    logDataLayerEvent(form, 'zephr_form_password_update_code_validate', {
	        success: response?.ok
	    });
	    if (!response.ok) {
	        formActions.updateFormState({
	            serverErrors: [ServerError.VERIFICATION_CODE_INCORRECT]
	        });
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[ServerError.VERIFICATION_CODE_INCORRECT],
	        });
	        formActions.decrementRequestCount();
	        return false;
	    }
	    await waitAfterCode(form);
	    formActions.decrementRequestCount();
	    return true;
	};

	const formStartAction$7 = async (_, __, formActions) => {
	    formActions.incrementRequestCount();
	    try {
	        await Promise.all([fetchProfile(formActions), fetchEmail(formActions)]);
	    }
	    finally {
	        formActions.decrementRequestCount();
	    }
	};
	const startEmailUpdate = async (form, formState, formActions) => {
	    const success = await startUpdateEmailFlow(form, formState, formActions);
	    if (success) {
	        await jumpToPart(partTypes.EMAIL_UPDATE_OTP.type, form, formActions);
	    }
	};
	const endEmailUpdate = async (form, formState, formActions) => {
	    const success = await endEmailUpdateFlow(form, formState, formActions);
	    if (success) {
	        await reset(form, formState, formActions, true);
	    }
	};
	const startPasswordUpdate = async (form, formState, formActions) => {
	    const success = await startPasswordUpdateFlow(form, formState, formActions);
	    if (success) {
	        await jumpToPart(partTypes.PASSWORD_UPDATE_OTP.type, form, formActions);
	    }
	};
	const endPasswordUpdate = async (form, formState, formActions) => {
	    const success = await endPasswordUpdateFlow(form, formState, formActions);
	    if (success) {
	        await reset(form, formState, formActions, true);
	    }
	};
	const onUpdateAttributes$1 = async (form, formState, formActions) => {
	    const submitSuccess = await updateUser(form, formState, formActions, partTypes.ATTRIBUTES_UPDATE.type);
	    if (submitSuccess) {
	        await reset(form, formState, formActions, true);
	    }
	};
	const goBack$3 = async (form, formState, formActions) => reset(form, formState, formActions, false);
	const jumpToUserAttributeUpdate = async (form, _, formActions) => {
	    await jumpToPart(partTypes.ATTRIBUTES_UPDATE.type, form, formActions);
	};
	const reset = async (form, formState, formActions, wait) => {
	    formActions.updateFormState({
	        emailAddress: null,
	        password: null,
	        createPassword: null,
	        passwordIsValid: null,
	        verificationCode: null,
	        currentPassword: null,
	        serverErrors: [],
	    });
	    if (wait) {
	        await formStartAction$7(form, formState, formActions);
	    }
	    else {
	        void formStartAction$7(form, formState, formActions);
	    }
	    await jumpToPart(partTypes.PROFILE_UPDATE.type, form, formActions);
	};
	const fetchProfile = async (formActions) => {
	    try {
	        const response = await request('blaize/profile', { method: "GET" }, formActions);
	        const json = await response.json();
	        formActions.updateFormState({
	            readOnlyAttributeValues: json,
	        });
	    }
	    catch (err) {
	        console.error("Unable to load user profile", err);
	    }
	};
	const fetchEmail = async (formActions) => {
	    try {
	        const response = await request('blaize/account', { method: "GET" }, formActions);
	        const email = (await response.json())?.identifiers.email_address;
	        formActions.updateFormState({
	            readOnlyEmail: email
	        });
	    }
	    catch (err) {
	        console.error("Unable to load user email", err);
	    }
	};
	const eventHandlers$7 = {
	    [FormEvent.FORM_START]: formStartAction$7,
	    [FormEvent.GO_BACK]: goBack$3,
	    [FormEvent.UPDATE]: jumpToUserAttributeUpdate,
	    [FormEvent.PART_EMAIL_UPDATE_COMPLETE]: startEmailUpdate,
	    [FormEvent.VERIFY_EMAIL_UPDATE_OTP]: endEmailUpdate,
	    [FormEvent.PART_PASSWORD_UPDATE_COMPLETE]: startPasswordUpdate,
	    [FormEvent.VERIFY_PASSWORD_UPDATE_OTP]: endPasswordUpdate,
	    [FormEvent.PART_ATTRIBUTES_UPDATE_COMPLETE]: onUpdateAttributes$1,
	};
	const canAttemptSectionCompletion$6 = (_, formState) => {
	    return !formState.elementValidity
	        .filter((e) => e.partType === formState.currentPart.type &&
	        e.sectionType === formState.currentSection.type &&
	        e.sectionOrder === formState.currentSection.order)
	        .some((e) => !e.isValid);
	};
	const sectionFlow$5 = {
	    extraElements: [],
	    eventHandlers: eventHandlers$7,
	    sectionVisibilities: [],
	    canAttemptSectionCompletion: canAttemptSectionCompletion$6,
	    canDismissFormManually: () => false,
	    formRequiresPrerequisiteLoading: () => false,
	};

	const loadExistingSubscriptions = async (form, formState, formActions, activeOnly) => {
	    const provider = form.organisationConfiguration.paymentProvider;
	    const loader = paymentProviderFor(provider)?.existingSubscriptionLoader;
	    if (!loader) {
	        console.error(`❌ [loadExistingSubscriptions] Existing subscription loader not configured for ${provider}`);
	        return [];
	    }
	    const existingSubscriptions = loader ? await loader(form, formState, formActions, activeOnly) : [];
	    formActions.updateFormState({
	        existingSubscriptions
	    });
	    return existingSubscriptions;
	};

	const formStartAction$6 = async (form, formState, formActions) => {
	    const hasDynamicOfferAttached = !!formConfigAs(form).dynamicOffer?.id;
	    if (hasDynamicOfferAttached) {
	        await getDynamicOffer(form, formActions).catch((e) => { console.error('Error loading Dynamic Offer', e); });
	        formState = formActions.getFormState();
	    }
	    const existingSubscriptions = formConfigAs(form).hasSaveOffer ?
	        await loadExistingSubscriptions$1(form, formState, formActions, hasDynamicOfferAttached, false) : await loadExistingSubscriptions(form, formState, formActions, true);
	    const subscriptionQueryParam = getSubscriptionParam(window.location.href);
	    if (!subscriptionQueryParam) {
	        return;
	    }
	    const queryParamSubscription = existingSubscriptions.find(subscription => subscription.externalId === subscriptionQueryParam);
	    if (queryParamSubscription) {
	        formActions.updateFormState({
	            selectedSubscription: queryParamSubscription,
	            isExternalReferrer: true,
	        });
	        formActions.completeSection();
	    }
	};
	const cancel = async (form, formActions) => {
	    const formState = formActions.getFormState();
	    try {
	        const response = await request(`zephr/subscriptions/${formState.selectedSubscription.externalId}`, {
	            method: 'DELETE',
	        }, formActions);
	        if (response.ok) {
	            if (formState.fireCancelationReasonEvent) {
	                logDataLayerEvent(form, 'zephr_form_subscription_cancel_reason', {
	                    productId: formState.selectedSubscription.productId,
	                    ...Object.entries(formState.cancelationReasonAttributes).reduce((acc, [key, value]) => ({ ...acc, [`attr_${key}`]: value }), {})
	                });
	            }
	            logDataLayerEvent(form, 'zephr_form_subscription_cancel', {
	                productId: formState.selectedSubscription.productId,
	                productLabel: formState.selectedSubscription.productLabel,
	                currency: formState.selectedSubscription.currency,
	                amount: formState.selectedSubscription.amount,
	            });
	            if (form.parts.some(e => e.type == partTypes.CANCEL_SUCCESS.type)) {
	                formActions.jumpToPartStart(partTypes.CANCEL_SUCCESS.type);
	            }
	            else {
	                formActions.jumpToPartStart(partTypes.SUCCESS.type);
	            }
	        }
	        else {
	            formActions.updateFormState({
	                serverErrors: [ServerError.UNKNOWN],
	            });
	            logDataLayerEvent(form, 'zephr_form_error', {
	                error: ServerError[ServerError.UNKNOWN],
	            });
	        }
	    }
	    catch (error) {
	        console.error("Error occurred while cancelling subscription.", error);
	        formActions.updateFormState({
	            serverErrors: [ServerError.UNKNOWN],
	        });
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[ServerError.UNKNOWN],
	        });
	    }
	};
	const onSubscriptionSelectComplete$3 = async (form, formState, formActions) => {
	    if (formConfigAs(form).hasCancelReason) {
	        formActions.updateFormState({
	            fireCancelationReasonEvent: true,
	            cancelFlowSubscriptionSelectedId: formState.selectedSubscription.externalId,
	        });
	        formActions.jumpToPartStart(partTypes.ATTRIBUTES_UPDATE.type);
	    }
	    else if (formState.validChangeFromPlans.length === 0) {
	        await cancel(form, formActions);
	    }
	    else if (formConfigAs(form).hasSaveOffer) {
	        formActions.updateFormState({
	            cancelFlowSubscriptionSelectedId: formState.selectedSubscription.externalId,
	        });
	        formActions.jumpToPartStart(partTypes.PLAN_SELECT.type);
	    }
	    else {
	        await cancel(form, formActions);
	    }
	};
	const onPlanSelectComplete$1 = async (form, formState, formActions) => {
	    if (formState.confirmCancel) {
	        await cancel(form, formActions);
	    }
	    else {
	        const state = formActions.getFormState();
	        const updatedState = await getProductAddons(form, state, formActions);
	        void calculatePrices(form, updatedState, formActions);
	        void calculateChangeSubscriptionProrate(form, updatedState, formActions);
	        formActions.updateFormState({
	            convertCancelSubscriptionToAcceptOffer: true,
	        });
	        formActions.jumpToPartStart(partTypes.PAYMENT.type);
	    }
	};
	const onUpdateAttributes = async (form, formState, formActions) => {
	    const submitSuccess = await updateUser(form, formState, formActions, partTypes.ATTRIBUTES_UPDATE.type);
	    if (!submitSuccess) {
	        return;
	    }
	    if (formState.validChangeFromPlans.length === 0) {
	        await cancel(form, formActions);
	    }
	    else if (formConfigAs(form).hasSaveOffer) {
	        formActions.jumpToPartStart(partTypes.PLAN_SELECT.type);
	    }
	    else {
	        await cancel(form, formActions);
	    }
	};
	const goBack$2 = async (_, __, formActions) => {
	    formActions.jumpToPartStart(partTypes.SELECT_SUBSCRIPTION.type);
	    return Promise.resolve();
	};
	const eventHandlers$6 = {
	    [FormEvent.FORM_START]: formStartAction$6,
	    [FormEvent.SELECT_SUBSCRIPTION_COMPLETE]: onSubscriptionSelectComplete$3,
	    [FormEvent.GO_BACK]: goBack$2,
	    [FormEvent.PART_PLAN_SELECT_COMPLETE]: onPlanSelectComplete$1,
	    [FormEvent.PART_PAYMENT_COMPLETE]: pay,
	    [FormEvent.PART_ATTRIBUTES_UPDATE_COMPLETE]: onUpdateAttributes,
	};
	const extraElements$1 = [
	    {
	        type: elementTypes.PAYMENT_PRE_LOADER,
	        order: -1,
	    },
	];
	const cancelSubscriptionSectionFlow = {
	    extraElements: extraElements$1,
	    eventHandlers: eventHandlers$6,
	    sectionVisibilities: [],
	    canAttemptSectionCompletion: () => true,
	    canDismissFormManually: () => false,
	    formRequiresPrerequisiteLoading: () => false,
	};

	const goBack$1 = async (_, __, formActions) => {
	    formActions.jumpToPartStart(partTypes.LIST_GIFT_SUBSCRIPTIONS_SENT.type);
	    return Promise.resolve();
	};
	const changePayment$1 = async (form, formState, formActions) => {
	    const completer = paymentProviderFor(form.organisationConfiguration.paymentProvider).changePaymentCompleter;
	    await completer(form, formState, formActions)
	        .then(() => {
	        formActions.updateFormState({
	            paymentProviderFormBusy: false
	        });
	        formActions.jumpToPartStart(partTypes.SUCCESS.type);
	        logDataLayerEvent(form, 'zephr_form_payment_method_changed', null);
	    }).catch(err => {
	        const serverError = formState.mobilePaymentService == null
	            ? ServerError.PAYMENT_PROCESSING_ERROR
	            : ServerError.MOBILE_PAYMENT_PROCESSING_ERROR;
	        console.error("Error completing payment change", err);
	        formActions.updateFormState({
	            mobilePaymentService: null,
	            paymentProviderFormBusy: false,
	            serverErrors: [serverError]
	        });
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[serverError],
	        });
	    });
	};
	const onSubscriptionSelectComplete$2 = (form, formState, formActions) => {
	    const changeFromPlans = getChangeFromPlans([formState.selectedSubscription], form);
	    formActions.updateFormState({
	        existingSubscriptions: [formState.selectedSubscription],
	        formCannotBeActioned: changeFromPlans.length === 0,
	        validChangeFromPlans: changeFromPlans,
	        formPrerequisiteLoaded: true,
	    });
	    formActions.jumpToPartStart(partTypes.PLAN_SELECT.type);
	};
	const formStartAction$5 = async (form, formState, formActions) => {
	    // Set loading state to true first, before making any API calls
	    formActions.updateFormState({
	        loadingGiftSubscriptions: true
	    });
	    try {
	        await loadGiftSubscriptions(form, formState, formActions);
	    }
	    catch (error) {
	        console.error("Error loading gift subscriptions", error);
	        formActions.updateFormState({
	            serverErrors: [ServerError.PAYMENT_PROCESSING_ERROR]
	        });
	    }
	    finally {
	        // Always set loading to false when done, regardless of success or failure
	        formActions.updateFormState({
	            loadingGiftSubscriptions: false
	        });
	    }
	};
	const loadGiftSubscriptions = async (form, formState, formActions) => {
	    try {
	        const response = await request("zephr/public/gifts/v1/gifts", {
	            method: "GET"
	        }, formActions, null, true);
	        if (response.ok) {
	            const json = await response.json();
	            const rawGiftSubscriptions = json || [];
	            // Map API response fields from camelCase to snake_case to match our interfaces
	            const giftSubscriptions = rawGiftSubscriptions
	                .filter(gift => gift.subscriptionDetails)
	                .map(gift => ({
	                gift_code: gift.giftCode,
	                subscription_number: gift.subscriptionNumber,
	                status: gift.status,
	                is_purchaser: gift.isPurchaser,
	                is_recipient: gift.isRecipient,
	                error_reason: gift.errorReason,
	                host: gift.host,
	                externalId: gift.subscriptionDetails?.id,
	                recipientFirstName: gift.subscriptionDetails.soldToContact?.firstName,
	                recipientLastName: gift.subscriptionDetails.soldToContact?.lastName,
	                subscriptionStartDate: gift.subscriptionDetails.subscriptionStartDate,
	                subscriptionEndDate: gift.subscriptionDetails.termEndDate,
	                subscriptionType: gift.subscriptionDetails.ratePlans[0]?.productName,
	            }));
	            formActions.updateFormState({
	                giftSubscriptions: giftSubscriptions,
	                formPrerequisiteLoaded: true
	            });
	        }
	        else {
	            formActions.updateFormState({
	                serverErrors: [ServerError.PAYMENT_PROCESSING_ERROR]
	            });
	        }
	    }
	    catch (error) {
	        formActions.updateFormState({
	            serverErrors: [ServerError.PAYMENT_PROCESSING_ERROR]
	        });
	    }
	};
	// NB: If you change these event handlers, you must also consider updating the event handlers in listSubscriptionsSectionFlow.ts
	({
	    [FormEvent.FORM_START]: formStartAction$5,
	    [FormEvent.GO_BACK]: goBack$1,
	    [FormEvent.PART_CHANGE_PAYMENT_COMPLETE]: changePayment$1,
	    [FormEvent.SELECT_SUBSCRIPTION_COMPLETE]: onSubscriptionSelectComplete$2,
	});

	const formStartAction$4 = async (form, formState, formActions) => {
	    const hasGifts = form.formType === FormType.LIST_GIFT_SUBSCRIPTIONS_SENT
	        || (form.formType === FormType.LIST_SUBSCRIPTIONS && form.organisationConfiguration.paymentProvider.includes('zuora-billing'));
	    // Load gift subscriptions if applicable (for sent gifts or regular subscriptions that need to show received gifts)
	    if (hasGifts) {
	        // Set loading state to true first
	        formActions.updateFormState({
	            loadingGiftSubscriptions: true
	        });
	        // Get the mock data outside the try block so it's accessible in the catch block
	        let allGiftSubscriptionsData = [];
	        // For preview mode, we can skip the API call and use the mock data directly
	        if (form.environment?.previewMode) {
	            allGiftSubscriptionsData = [
	                // Received gift (current user is recipient)
	                {
	                    gift_code: "GIFT-PREVIEW-1",
	                    subscription_number: "gift-sub-preview-1",
	                    status: "REDEEMED",
	                    is_purchaser: false,
	                    is_recipient: true,
	                    amount: "GBP 99/year",
	                    currency: "GBP",
	                    currentTermPeriodType: "Year",
	                    tenant_id: "organization_tenant_id",
	                    purchaser_user_id: "user_sender_12345",
	                    recipient_user_id: "user_current",
	                    recipient_email: "current.user@example.com",
	                    recipientFirstName: "John",
	                    recipientLastName: "Smith",
	                    message: "Enjoy your premium gift subscription!",
	                    subscriptionType: "Premium Digital",
	                    subscriptionStartDate: "January 1, 2025",
	                    subscriptionEndDate: "January 1, 2026",
	                    error_reason: null,
	                    host: "example.com",
	                    recipient_zuora_account_id: "account_123"
	                },
	                // Sent gift (current user is purchaser)
	                {
	                    gift_code: "GIFT-PREVIEW-2",
	                    subscription_number: "gift-sub-preview-2",
	                    status: "REDEEMED",
	                    is_purchaser: true,
	                    is_recipient: false,
	                    amount: "GBP 50/year",
	                    currency: "GBP",
	                    currentTermPeriodType: "Year",
	                    tenant_id: "organization_tenant_id",
	                    purchaser_user_id: "user_current",
	                    recipient_user_id: "user_recipient_12345",
	                    recipient_email: "recipient@example.com",
	                    recipientFirstName: "Jane",
	                    recipientLastName: "Doe",
	                    message: "Here's your gift subscription!",
	                    subscriptionType: "Basic Digital",
	                    subscriptionStartDate: "February 15, 2025",
	                    subscriptionEndDate: "February 15, 2026",
	                    error_reason: null,
	                    host: "example.com",
	                    recipient_zuora_account_id: "account_456"
	                },
	                // Pending gift (not yet redeemed)
	                {
	                    gift_code: "GIFT-PREVIEW-3",
	                    subscription_number: "gift-sub-preview-3",
	                    status: "PENDING",
	                    is_purchaser: true,
	                    is_recipient: false,
	                    amount: "GBP 50/year",
	                    currency: "GBP",
	                    currentTermPeriodType: "Year",
	                    tenant_id: "organization_tenant_id",
	                    purchaser_user_id: "user_current",
	                    recipient_user_id: null,
	                    recipient_email: "pending@example.com",
	                    recipientFirstName: "",
	                    recipientLastName: "",
	                    message: "A gift subscription for you!",
	                    subscriptionType: "Basic Digital",
	                    subscriptionStartDate: "March 1, 2025",
	                    subscriptionEndDate: "March 1, 2026",
	                    error_reason: null,
	                    host: "example.com",
	                    recipient_zuora_account_id: null
	                }
	            ];
	            formActions.updateFormState({
	                giftSubscriptions: allGiftSubscriptionsData,
	                formPrerequisiteLoaded: true,
	                loadingGiftSubscriptions: false
	            });
	        }
	        else {
	            try {
	                formActions.updateFormState({
	                    loadingSubscriptions: true
	                });
	                // loads in subscriptions and gift data
	                await loadGiftSubscriptions(form, formState, formActions);
	                formActions.updateFormState({
	                    formPrerequisiteLoaded: true,
	                    loadingGiftSubscriptions: false
	                });
	            }
	            catch (error) {
	                console.error('❌ [LIST_SUBSCRIPTIONS] Error loading gift subscriptions:', error);
	                formActions.updateFormState({
	                    formPrerequisiteLoaded: true,
	                    serverErrors: [
	                        ServerError.UNKNOWN
	                    ]
	                });
	            }
	        }
	        formActions.updateFormState({
	            loadingGiftSubscriptions: false,
	            loadingSubscriptions: false
	        });
	    }
	    // Load regular subscriptions for the standard list view
	    try {
	        formActions.updateFormState({
	            loadingSubscriptions: true
	        });
	        await loadExistingSubscriptions(form, formState, formActions, false);
	    }
	    catch (error) {
	        console.error("❌ [LIST_SUBSCRIPTIONS] Error loading subscriptions", error);
	        formActions.updateFormState({
	            serverErrors: [ServerError.PAYMENT_PROCESSING_ERROR],
	        });
	    }
	    finally {
	        formActions.updateFormState({
	            loadingSubscriptions: false,
	            loadingGiftSubscriptions: false,
	        });
	    }
	};
	const goBack = async (_, __, formActions) => {
	    formActions.jumpToPartStart(partTypes.LIST_SUBSCRIPTIONS.type);
	    return Promise.resolve();
	};
	const changePayment = async (form, formState, formActions) => {
	    const completer = paymentProviderFor(form.organisationConfiguration.paymentProvider).changePaymentCompleter;
	    await completer(form, formState, formActions)
	        .then(() => {
	        formActions.updateFormState({
	            paymentProviderFormBusy: false
	        });
	        formActions.jumpToPartStart(partTypes.SUCCESS.type);
	        logDataLayerEvent(form, 'zephr_form_payment_method_changed', null);
	    }).catch(err => {
	        const serverError = formState.mobilePaymentService == null
	            ? ServerError.PAYMENT_PROCESSING_ERROR
	            : ServerError.MOBILE_PAYMENT_PROCESSING_ERROR;
	        console.error("Error completing payment change", err);
	        formActions.updateFormState({
	            mobilePaymentService: null,
	            paymentProviderFormBusy: false,
	            serverErrors: [serverError]
	        });
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[serverError],
	        });
	    });
	};
	// NB: If you change these event handlers, you must also consider updating the event handlers in giftSubscriptionsListSectionFlow.ts
	const eventHandlers$5 = {
	    [FormEvent.FORM_START]: formStartAction$4,
	    [FormEvent.GO_BACK]: goBack,
	    [FormEvent.PART_CHANGE_PAYMENT_COMPLETE]: changePayment,
	};
	const sectionVisibilities$5 = [];
	const canAttemptSectionCompletion$5 = (_, formState) => {
	    return !formState.elementValidity
	        .filter((e) => e.partType === formState.currentPart.type &&
	        e.sectionType === formState.currentSection.type &&
	        e.sectionOrder === formState.currentSection.order)
	        .some((e) => !e.isValid);
	};
	const extraElements = [
	    {
	        type: elementTypes.PAYMENT_PRE_LOADER,
	        order: -1,
	    },
	];
	const listSubscriptionsSectionFlow = {
	    extraElements,
	    eventHandlers: eventHandlers$5,
	    sectionVisibilities: sectionVisibilities$5,
	    canAttemptSectionCompletion: canAttemptSectionCompletion$5,
	    canDismissFormManually: () => false,
	    formRequiresPrerequisiteLoading: () => false,
	};

	const formStartAction$3 = async (form, formState, formActions) => {
	    const existingSubscriptions = await loadExistingSubscriptions(form, formState, formActions, true);
	    const subscriptionQueryParam = getSubscriptionParam(window.location.href);
	    if (!subscriptionQueryParam) {
	        return;
	    }
	    const queryParamSubscription = existingSubscriptions.find(subscription => subscription.externalId === subscriptionQueryParam);
	    if (queryParamSubscription) {
	        formActions.updateFormState({
	            selectedSubscription: queryParamSubscription,
	            isExternalReferrer: true,
	        });
	        formActions.completeSection();
	    }
	};
	const onSubscriptionSelectComplete$1 = (form, formState, formActions) => {
	    formActions.updateFormState({
	        suspendResumeFlowSubscriptionSelectedId: formState.selectedSubscription.externalId,
	    });
	    formActions.jumpToPartStart(partTypes.SUSPEND_RESUME_SUBSCRIPTION.type);
	};
	const suspendResumeSubscriptionComplete = async (form, formState, formActions) => {
	    try {
	        const response = await request(`zephr/subscriptions/${formState.selectedSubscription.externalId}/manage`, {
	            method: 'POST',
	            bodyObject: {
	                vendor_fields: {
	                    order: JSON.stringify({
	                        subscription: {
	                            orderActions: [
	                                {
	                                    type: 'Suspend',
	                                    suspend: {
	                                        suspendPolicy: 'SpecificDate',
	                                        suspendSpecificDate: formState.suspendResumeSubscription.suspensionDate,
	                                    }
	                                },
	                                {
	                                    type: 'Resume',
	                                    resume: {
	                                        resumePolicy: 'SpecificDate',
	                                        resumeSpecificDate: formState.suspendResumeSubscription.resumeDate,
	                                        extendsTerm: true,
	                                    }
	                                }
	                            ]
	                        }
	                    })
	                }
	            }
	        }, formActions);
	        if (response.ok) {
	            logDataLayerEvent(form, 'zephr_form_subscription_suspend', {
	                productId: formState.selectedSubscription.productId,
	                productLabel: formState.selectedSubscription.productLabel,
	                currency: formState.selectedSubscription.currency,
	                amount: formState.selectedSubscription.amount,
	            });
	            formActions.jumpToPartStart(partTypes.SUCCESS.type);
	        }
	        else {
	            formActions.updateFormState({
	                serverErrors: [ServerError.UNKNOWN],
	            });
	            logDataLayerEvent(form, 'zephr_form_error', {
	                error: ServerError[ServerError.UNKNOWN],
	            });
	        }
	    }
	    catch (error) {
	        console.error("Error occurred while suspending subscription.", error);
	        formActions.updateFormState({
	            serverErrors: [ServerError.UNKNOWN],
	        });
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[ServerError.UNKNOWN],
	        });
	    }
	};
	const eventHandlers$4 = {
	    [FormEvent.FORM_START]: formStartAction$3,
	    [FormEvent.SELECT_SUBSCRIPTION_COMPLETE]: onSubscriptionSelectComplete$1,
	    [FormEvent.SUSPEND_RESUME_SUBSCRIPTION_COMPLETE]: suspendResumeSubscriptionComplete,
	};
	const sectionVisibilities$4 = [];
	const canAttemptSectionCompletion$4 = (_, formState) => {
	    return !formState.elementValidity
	        .filter((e) => e.partType === formState.currentPart.type &&
	        e.sectionType === formState.currentSection.type &&
	        e.sectionOrder === formState.currentSection.order)
	        .some((e) => !e.isValid);
	};
	const sectionFlow$4 = {
	    extraElements: [],
	    eventHandlers: eventHandlers$4,
	    sectionVisibilities: sectionVisibilities$4,
	    canAttemptSectionCompletion: canAttemptSectionCompletion$4,
	    canDismissFormManually: () => false,
	    formRequiresPrerequisiteLoading: () => false,
	};

	const formStartAction$2 = async (form, formState, formActions) => {
	    await loadDeviceSessions(form, formState, formActions);
	};
	const eventHandlers$3 = {
	    [FormEvent.FORM_START]: formStartAction$2,
	};
	const sectionVisibilities$3 = [];
	const canAttemptSectionCompletion$3 = (_, formState) => {
	    return !formState.elementValidity
	        .filter((e) => e.partType === formState.currentPart.type &&
	        e.sectionType === formState.currentSection.type &&
	        e.sectionOrder === formState.currentSection.order)
	        .some((e) => !e.isValid);
	};
	const sectionFlow$3 = {
	    extraElements: [],
	    eventHandlers: eventHandlers$3,
	    sectionVisibilities: sectionVisibilities$3,
	    canAttemptSectionCompletion: canAttemptSectionCompletion$3,
	    canDismissFormManually: () => false,
	    formRequiresPrerequisiteLoading: () => false,
	};

	/**
	 * Map of possible movements through the form sections for gift subscription forms.
	 */
	// Handle the completion of the recipient details section
	const onGiftRecipientComplete = async (form, formState, formActions) => {
	    // Check if user is logged in using existing session state
	    if (formState.loginRegistrationComplete) {
	        // If logged in, jump directly to payment section
	        await jumpToPart(partTypes.PAYMENT.type, form, formActions);
	    }
	    else {
	        // If not logged in, continue with normal flow to account verification
	        await jumpToSection(sectionTypes.EMAIL.type, form, formActions);
	    }
	};
	// Modified pay service for gift subscription
	const payWithGiftInfo = async (form, formState, formActions) => {
	    try {
	        // Add gift recipient info to the payment metadata
	        const giftRecipient = formState.giftRecipient;
	        if (!giftRecipient) {
	            throw new Error("Gift recipient information is missing");
	        }
	        // Call the standard payment flow - the gift-specific logic is handled in zuoraService.ts
	        // which will make the actual API call to create the gift subscription
	        return await pay(form, formState, formActions);
	    }
	    catch (error) {
	        console.error("Error in gift subscription payment:", error);
	        // Use the language pack for error message
	        const errorMessage = resolveLanguagePackKeyTyped(form, 'forms.errors.unknown-payment-error', "Payment failed");
	        // Display the error message
	        formActions.updateFormState({
	            dynamicServerErrorMessage: errorMessage
	        });
	        throw error;
	    }
	};
	// Customize the payment flow's PART_PLAN_SELECT_COMPLETE handler to add our gift recipient step
	const onPlanSelectComplete = async (form, formState, formActions) => {
	    // Check gift form mode FIRST, before calling payment flow handler
	    if (formState.isGiftForm) {
	        // If gift mode is enabled, check if recipient details are valid before jumping
	        const recipientDetailsElementTypes = [
	            'recipient_name',
	            'recipient_email',
	            'recipient_address',
	            'recipient_message'
	        ];
	        // Check if all recipient details elements are valid
	        const recipientDetailsValid = recipientDetailsElementTypes.every(elementType => {
	            const elementValidity = formState.elementValidity.find(e => e.elementType === elementType &&
	                e.sectionType === 'recipient_details');
	            return elementValidity ? elementValidity.isValid : false;
	        });
	        // Calculate prices first (from payment form flow)
	        await sectionFlow$9.eventHandlers[FormEvent.PART_PLAN_SELECT_COMPLETE](form, formState, formActions);
	        // Then navigate to recipient details if they are not valid
	        if (!recipientDetailsValid) {
	            await jumpToSection('recipient_details', form, formActions);
	        }
	        // If recipient details are valid, the payment handler already navigated correctly
	    }
	    else {
	        // If gift mode is disabled, just run the standard payment flow
	        await sectionFlow$9.eventHandlers[FormEvent.PART_PLAN_SELECT_COMPLETE](form, formState, formActions);
	    }
	};
	// Starting with the payment form handlers, override only what we need
	const eventHandlers$2 = {
	    ...sectionFlow$9.eventHandlers,
	    [FormEvent.FORM_START]: async (form, formState, formActions) => {
	        // Execute the standard payment form start handler
	        await sectionFlow$9.eventHandlers[FormEvent.FORM_START](form, formState, formActions);
	        // Check if the form has any gift toggle elements
	        const hasGiftToggleElements = form.parts
	            .flatMap(part => part.sections)
	            .flatMap(section => section.elements)
	            .some(element => element.type === elementTypes.GIFT_TOGGLE);
	        // Initialize the gift form state based on whether gift toggle elements are present
	        // If no gift toggle elements are found, assume this is a dedicated gift form (isGiftForm = true)
	        // If gift toggle elements are present, default to regular subscription mode (isGiftForm = false)
	        formActions.updateFormState({
	            isGiftForm: !hasGiftToggleElements, // true if no toggles (dedicated gift form), false if toggles exist
	            giftRecipient: {
	                firstName: '',
	                lastName: '',
	                email: '',
	                recipientAddress: {
	                    addressLine1: '',
	                    addressLine2: '',
	                    city: '',
	                    state: '',
	                    country: '',
	                    postalCode: ''
	                },
	                customMessage: '',
	                futureDeliveryEnabled: false,
	                futureDeliveryDate: ''
	            }
	        });
	    },
	    // Override plan select to redirect to gift recipient conditionally
	    [FormEvent.PART_PLAN_SELECT_COMPLETE]: onPlanSelectComplete,
	    // Add gift recipient handler
	    [FormEvent.PART_GIFT_RECIPIENT_COMPLETE]: onGiftRecipientComplete,
	    // Override payment complete to include gift logic
	    [FormEvent.PART_PAYMENT_COMPLETE]: payWithGiftInfo,
	};
	// Add our new section visibility for recipient details
	const sectionVisibilities$2 = [
	    ...sectionFlow$9.sectionVisibilities,
	    {
	        type: sectionTypes.RECIPIENT_DETAILS.type,
	        isDisplayedInProgressBar: true,
	        isVisible: (form, formState) => {
	            // Only show recipient details section if gift form mode is enabled
	            return formState.isGiftForm === true;
	        }
	    }
	];
	const canAttemptSectionCompletion$2 = (form, formState) => {
	    return !formState.elementValidity
	        .filter((e) => e.partType === formState.currentPart.type &&
	        e.sectionType === formState.currentSection.type &&
	        e.sectionOrder === formState.currentSection.order)
	        .some((e) => !e.isValid);
	};
	// Inherit other properties from payment flow
	const sectionFlow$2 = {
	    extraElements: sectionFlow$9.extraElements,
	    sectionVisibilities: sectionVisibilities$2,
	    eventHandlers: eventHandlers$2,
	    canAttemptSectionCompletion: canAttemptSectionCompletion$2,
	    canDismissFormManually: sectionFlow$9.canDismissFormManually,
	    formRequiresPrerequisiteLoading: sectionFlow$9.formRequiresPrerequisiteLoading,
	    canPartiallyRegister: true
	};

	const validateGiftCode = async (form, formState, formActions) => {
	    const giftCode = formState.giftCode;
	    try {
	        // First check locally if gift code is valid length
	        if (!giftCode || giftCode.length !== 16) {
	            formActions.updateFormState({
	                giftCodeError: resolveLanguagePackKeyTyped(form, 'forms.errors.gift-code-invalid-length', 'Gift code must be 16 characters long')
	            });
	            return false;
	        }
	        formActions.incrementRequestCount();
	        const response = await request('zephr/public/gifts/v1/redeem', {
	            method: 'POST',
	            bodyObject: {
	                giftCode: giftCode,
	            },
	        }, formActions);
	        // Log event for gift redemption attempt
	        logDataLayerEvent(form, 'zephr_form_gift_redeem', {
	            success: response.ok,
	        });
	        if (!response.ok) {
	            formActions.updateFormState({
	                serverErrors: [ServerError.GIFT_CODE_INVALID],
	                giftCodeError: resolveLanguagePackKeyTyped(form, 'forms.errors.gift-code-invalid', 'The gift code you entered is invalid'),
	            });
	            formActions.decrementRequestCount();
	            return false;
	        }
	        formActions.decrementRequestCount();
	        await jumpToSection(sectionTypes.GIFT_REDEEMED.type, form, formActions);
	        return true;
	    }
	    catch (error) {
	        formActions.updateFormState({
	            serverErrors: [ServerError.GIFT_CODE_SERVER_ERROR],
	            giftCodeError: resolveLanguagePackKeyTyped(form, 'forms.errors.gift-code-server-error', 'An error occurred processing your gift code'),
	        });
	        formActions.decrementRequestCount();
	        return false;
	    }
	};

	const GIFT_REDEMPTION_PART = "gift_redemption";
	const onGiftRedemptionComplete = async (form, formState, formActions) => {
	    await validateGiftCode(form, formState, formActions);
	};
	const formStartAction$1 = async (form, formState, formActions) => {
	    // If user session is already set, we don't need to check again
	    if (formState.userSession) {
	        // Skip registration and go straight to gift redemption if user is logged in
	        const giftRedemptionPart = form.parts.find(part => part.type === "gift_redemption");
	        if (giftRedemptionPart) {
	            formActions.updateFormState({
	                currentPart: giftRedemptionPart,
	                currentSection: giftRedemptionPart.sections[0],
	                userSession: true,
	                loginRegistrationComplete: true
	            });
	        }
	        return;
	    }
	    // Otherwise check for user session
	    const userSession = await checkForRegisteredUser(formActions);
	    if (userSession) {
	        // Skip registration and go straight to gift redemption if user is logged in
	        const giftRedemptionPart = form.parts.find(part => part.type === "gift_redemption");
	        if (giftRedemptionPart) {
	            formActions.updateFormState({
	                currentPart: giftRedemptionPart,
	                currentSection: giftRedemptionPart.sections[0],
	                userSession: true,
	                loginRegistrationComplete: true
	            });
	        }
	    }
	};
	const onLoginRegisterComplete = async (form, formState, formActions) => {
	    // Instead of reloading page or showing success, go straight to gift redemption
	    await jumpToPart(GIFT_REDEMPTION_PART, form, formActions);
	    return Promise.resolve();
	};
	const canAttemptSectionCompletion$1 = (form, formState) => {
	    // Check if we're in the gift redemption section and enforce validation
	    if (formState.currentSection.type === sectionTypes.GIFT_REDEMPTION.type) {
	        const giftCodeElement = formState.elementValidity.find(e => e.elementType === elementTypes.GIFT_CODE &&
	            e.sectionType === formState.currentSection.type);
	        if (giftCodeElement && !giftCodeElement.isValid) {
	            return false;
	        }
	        if (formState.giftCode?.length !== 16) {
	            return false;
	        }
	    }
	    // For other sections, use the default registration flow validation
	    return sectionFlow$8.canAttemptSectionCompletion(form, formState);
	};
	const eventHandlers$1 = {
	    ...sectionFlow$8.eventHandlers,
	    [FormEvent.FORM_START]: formStartAction$1,
	    [FormEvent.GIFT_REDEMPTION_COMPLETE]: onGiftRedemptionComplete,
	    [FormEvent.LOGIN_REGISTRATION_COMPLETE]: onLoginRegisterComplete, // Override the registration flow handler
	};
	// Add gift redemption specific section visibilities while inheriting registration ones
	const sectionVisibilities$1 = [
	    {
	        type: sectionTypes.EMAIL.type,
	        isDisplayedInProgressBar: true,
	        isVisible: (form, formState) => !formState.userSession
	    },
	    {
	        type: sectionTypes.LOGIN_PASSWORD.type,
	        isDisplayedInProgressBar: true,
	        isVisible: (form, formState) => !formState.userSession &&
	            formConfigAs(form).usePassword &&
	            formState.userExists &&
	            !formState.socialSignin
	    },
	    {
	        type: sectionTypes.PASSWORD_SETUP.type,
	        isDisplayedInProgressBar: true,
	        isVisible: (form, formState) => !formState.userSession &&
	            formConfigAs(form).usePassword &&
	            !formState.userExists &&
	            !formState.socialSignin
	    },
	    {
	        type: sectionTypes.PASSWORD_RESET.type,
	        isDisplayedInProgressBar: false,
	        isVisible: (form, formState) => !formState.userSession &&
	            formConfigAs(form).usePassword &&
	            formState.forgotPassword
	    },
	    {
	        type: sectionTypes.FORGOT_PASSWORD.type,
	        isDisplayedInProgressBar: false,
	        isVisible: (form, formState) => !formState.userSession &&
	            formConfigAs(form).usePassword &&
	            formState.forgotPassword
	    },
	    {
	        type: sectionTypes.GIFT_REDEMPTION.type,
	        isDisplayedInProgressBar: true,
	        isVisible: (form, formState) => {
	            // Show after registration is complete or if user is logged in
	            return formState.loginRegistrationComplete || formState.userSession;
	        }
	    },
	    {
	        type: sectionTypes.GIFT_REDEEMED.type,
	        isDisplayedInProgressBar: false,
	        isVisible: () => true
	    }
	];
	const sectionFlow$1 = {
	    ...sectionFlow$8,
	    eventHandlers: eventHandlers$1,
	    sectionVisibilities: sectionVisibilities$1,
	    canAttemptSectionCompletion: canAttemptSectionCompletion$1,
	    canDismissFormManually: () => false,
	    formRequiresPrerequisiteLoading: () => false,
	    canPartiallyRegister: true
	};

	const formStartAction = async (form, formState, formActions) => {
	    const existingSubscriptions = await loadExistingSubscriptions(form, formState, formActions, true);
	    const subscriptionQueryParam = getSubscriptionParam(window.location.href);
	    if (!subscriptionQueryParam) {
	        return;
	    }
	    const queryParamSubscription = existingSubscriptions.find(subscription => subscription.externalId === subscriptionQueryParam);
	    if (queryParamSubscription) {
	        formActions.updateFormState({
	            selectedSubscription: queryParamSubscription,
	            isExternalReferrer: true,
	        });
	        formActions.completeSection();
	    }
	};
	const onSubscriptionSelectComplete = (form, formState, formActions) => {
	    formActions.jumpToPartStart(partTypes.BILL_TO_CONTACT.type);
	};
	const onBillToContactComplete = async (form, formState, formActions) => {
	    try {
	        const response = await request(`zephr/accounts/${formState.selectedSubscription.accountId}/update`, {
	            method: 'PATCH',
	            bodyObject: {
	                vendor_fields: {
	                    account: JSON.stringify({
	                        billToContact: formState.billToContact
	                    })
	                }
	            }
	        }, formActions);
	        if (response.ok) {
	            logDataLayerEvent(form, 'zephr_form_bill_to_contact_change', {
	                accountId: formState.selectedSubscription.accountId,
	                billToContact: formState.billToContact
	            });
	            formActions.jumpToPartStart(partTypes.SUCCESS.type);
	        }
	        else {
	            formActions.updateFormState({
	                serverErrors: [ServerError.UNKNOWN],
	            });
	            logDataLayerEvent(form, 'zephr_form_error', {
	                error: ServerError[ServerError.UNKNOWN],
	            });
	        }
	    }
	    catch (error) {
	        console.error("Error occurred while updating bill to contact address.", error);
	        formActions.updateFormState({
	            serverErrors: [ServerError.UNKNOWN],
	        });
	        logDataLayerEvent(form, 'zephr_form_error', {
	            error: ServerError[ServerError.UNKNOWN],
	        });
	    }
	};
	const eventHandlers = {
	    [FormEvent.FORM_START]: formStartAction,
	    [FormEvent.SELECT_SUBSCRIPTION_COMPLETE]: onSubscriptionSelectComplete,
	    [FormEvent.BILL_TO_CONTACT_COMPLETE]: onBillToContactComplete,
	};
	const sectionVisibilities = [];
	const canAttemptSectionCompletion = (_, formState) => {
	    return !formState.elementValidity
	        .filter((e) => e.partType === formState.currentPart.type &&
	        e.sectionType === formState.currentSection.type &&
	        e.sectionOrder === formState.currentSection.order)
	        .some((e) => !e.isValid);
	};
	const sectionFlow = {
	    extraElements: [],
	    eventHandlers,
	    sectionVisibilities,
	    canAttemptSectionCompletion,
	    canDismissFormManually: () => false,
	    formRequiresPrerequisiteLoading: () => false,
	};

	const sectionFlows = {
	    [FormType.PAYMENT]: sectionFlow$9,
	    [FormType.CHANGE_SUBSCRIPTION]: sectionFlow$9,
	    [FormType.REGISTRATION]: sectionFlow$8,
	    [FormType.CONTACT]: sectionFlow$7,
	    [FormType.DATA_CAPTURE]: sectionFlow$6,
	    [FormType.COMPLETE_REGISTRATION]: sectionFlow$6,
	    [FormType.UPDATE_PROFILE]: sectionFlow$5,
	    [FormType.CANCEL_SUBSCRIPTION]: cancelSubscriptionSectionFlow,
	    [FormType.LIST_SUBSCRIPTIONS]: listSubscriptionsSectionFlow,
	    [FormType.LIST_GIFT_SUBSCRIPTIONS_SENT]: listSubscriptionsSectionFlow,
	    [FormType.DEVICES]: sectionFlow$3,
	    [FormType.GIFT_SUBSCRIPTION]: sectionFlow$2,
	    [FormType.GIFT_REDEMPTION]: sectionFlow$1,
	    [FormType.SUSPEND_RESUME_SUBSCRIPTION]: sectionFlow$4,
	    [FormType.BILL_TO_CONTACT]: sectionFlow,
	    [FormType.EMPTY]: {
	        extraElements: [],
	        sectionVisibilities: [],
	        eventHandlers: {},
	        canAttemptSectionCompletion: () => true,
	        canDismissFormManually: () => false,
	        formRequiresPrerequisiteLoading: () => false,
	    }
	};
	const sectionFlowFor = (formType) => {
	    const flow = sectionFlows[formType];
	    if (!flow) {
	        throw `No flow for form type ${formType}`;
	    }
	    return flow;
	};

	const baselineCssVariablesTimestamp = Date.parse("2024-04-19T00:00:00Z");
	const baselineCssVariables = {
	    "--zf-container-color": "unset",
	    "--zf-container-bgColor": "#fff",
	    "--zf-container-borderRadius": "0",
	    "--zf-input-bgColor": "#fff",
	    "--zf-payment-options-border": "1px solid #000",
	    "--zf-payment-options-color": "#000",
	    "--zf-payment-options-bgColor": "#fff",
	    "--zf-payment-summary-border": "1px solid #000",
	    "--zf-payment-summary-borderRadius": "0",
	    "--zf-payment-summary-color": "unset",
	    "--zf-payment-summary-bgColor": "transparent",
	};
	const appendCssVariables = (cssVariablesStyle, additionalCssVariables) => {
	    const additionalCssVariablesStyle = Object.entries(additionalCssVariables)
	        .map(([key, value]) => `${key}: ${value}`)
	        .join(';\n');
	    return `${cssVariablesStyle};\n${additionalCssVariablesStyle}`;
	};
	const addBackwardsCompatibilityCssVariables = (cssVariablesStyle, formConfigTimestamp) => (formConfigTimestamp || 0) < baselineCssVariablesTimestamp
	    ? appendCssVariables(cssVariablesStyle, baselineCssVariables)
	    : cssVariablesStyle;

	/* src/FormApp.svelte generated by Svelte v4.2.12 */

	function create_fragment(ctx) {
		let div;
		let formroot;
		let div_class_value;
		let current;

		formroot = new FormRoot({
				props: {
					formConfiguration: /*formConfiguration*/ ctx[2]
				}
			});

		return {
			c() {
				div = element("div");
				create_component(formroot.$$.fragment);
				attr(div, "id", /*formConfiguration*/ ctx[2].formId);
				attr(div, "class", div_class_value = "" + (null_to_empty(`zephr-form ${formTypeClass(/*formType*/ ctx[0])}`) + " svelte-789zog"));
				attr(div, "style", /*cssVariables*/ ctx[1]);
			},
			m(target, anchor) {
				insert(target, div, anchor);
				mount_component(formroot, div, null);
				current = true;
			},
			p(ctx, [dirty]) {
				if (!current || dirty & /*formType*/ 1 && div_class_value !== (div_class_value = "" + (null_to_empty(`zephr-form ${formTypeClass(/*formType*/ ctx[0])}`) + " svelte-789zog"))) {
					attr(div, "class", div_class_value);
				}
			},
			i(local) {
				if (current) return;
				transition_in(formroot.$$.fragment, local);
				current = true;
			},
			o(local) {
				transition_out(formroot.$$.fragment, local);
				current = false;
			},
			d(detaching) {
				if (detaching) {
					detach(div);
				}

				destroy_component(formroot);
			}
		};
	}

	function instance($$self, $$props, $$invalidate) {
		const defaultEnvironment = {
			apiUrlBase: "",
			onStateChanged: () => {
				
			},
			debugLogging: false,
			reduceDelays: false,
			previewMode: false
		};

		let { formType } = $$props;
		let { formConfig } = $$props;
		let { formTypeConfig } = $$props;
		let { organisationConfig } = $$props;
		let { environment = {} } = $$props;

		const mergedEnvironment = {
			...defaultEnvironment,
			...environment,
			...(formConfig?._spikeApiUrl)
			? { apiUrlBase: formConfig._spikeApiUrl }
			: {}
		};

		// Styles
		const styleGuideObj = JSON.parse(organisationConfig.siteStyles ?? "{}");

		const cssVariables = addBackwardsCompatibilityCssVariables(convertSiteStylesToCssVariables(styleGuideObj), formConfig.timestamp);

		// Section flow
		const sectionFlow = sectionFlowFor(formType);

		// Language pack resolving
		const formConfigResolved = resolveLanguagePackKeys(formConfig.languagePack, formConfig);

		const typeConfigResolved = resolveLanguagePackKeys(formConfig.languagePack, formTypeConfig);
		const orgConfigResolved = resolveLanguagePackKeys(formConfig.languagePack, organisationConfig);
		const uniqueKey = randomId();
		const isPaymentForm = formType === FormType.PAYMENT;

		const formConfiguration = {
			environment: mergedEnvironment,
			formType,
			...formConfigResolved,
			organisationConfiguration: orgConfigResolved,
			typeConfiguration: typeConfigResolved,
			sectionFlow,
			uniqueKey,
			formId: isPaymentForm
			? "zephr-payment-form-root"
			: `zephr-form-root-${uniqueKey}`
		};

		$$self.$$set = $$props => {
			if ('formType' in $$props) $$invalidate(0, formType = $$props.formType);
			if ('formConfig' in $$props) $$invalidate(3, formConfig = $$props.formConfig);
			if ('formTypeConfig' in $$props) $$invalidate(4, formTypeConfig = $$props.formTypeConfig);
			if ('organisationConfig' in $$props) $$invalidate(5, organisationConfig = $$props.organisationConfig);
			if ('environment' in $$props) $$invalidate(6, environment = $$props.environment);
		};

		return [
			formType,
			cssVariables,
			formConfiguration,
			formConfig,
			formTypeConfig,
			organisationConfig,
			environment
		];
	}

	class FormApp extends SvelteComponent {
		constructor(options) {
			super();

			init(this, options, instance, create_fragment, safe_not_equal, {
				formType: 0,
				formConfig: 3,
				formTypeConfig: 4,
				organisationConfig: 5,
				environment: 6
			});
		}
	}

	// TODO Parameter version translation
	// TODO remove circular deps
	const currentPropsVersion = "main:1";
	const translateFormProps = (propsVersion, props) => {
	    if (propsVersion === currentPropsVersion) {
	        return props;
	    }
	    // Knowledge of other prop versions goes here once some backwards-incompatible changes
	    // have been made to the props schema.
	    throw `Unknown props version ${propsVersion}`;
	};
	const renderForm = (container, props) => {
	    const target = (typeof container === 'string' || container instanceof String)
	        ? document.getElementById(container)
	        : container;
	    return new FormApp({ target, props });
	};
	// Public API entrypoint
	if (window.Zephr == null) {
	    window.Zephr = {};
	}
	window.Zephr.renderForm = renderForm;
	window.Zephr.translateFormProps = translateFormProps;

})();
//# sourceMappingURL=bundle.js.map
</script><script data-cmp-ab="2">
                            var element = document.currentScript;
                            while(!(element.classList && element.classList.contains('zephr-form-container'))){
                                element = element.previousSibling;
                            }
                            window.Zephr.renderForm(element, window.Zephr.translateFormProps("main:1", {"formType":"PAYMENT","formConfig":{"parts":[{"type":"plan-select","label":"Plan Select","sections":[{"type":"plan_select","label":"Plan Select","order":0,"tab":"plans","elements":[{"type":"template_component","id":"117f8e9e-b3fa-4670-988a-e1e90db9e0f2","config":{"templateId":"modaltest:24","templateValues":{"plan-description-6":null,"plan-group-specific-description":"$1 for 14 days, then $4/week (billed annually at $199) or $6.25/week (billed every 4 weeks at $24.99). Plans renew automatically. Cancel anytime during your 14-day trial to avoid full-plan charges.","plan-group-name":"Start for $1 – Select a Plan","plan-description-1":"Unlimited access to TheWrap","plan-description-2":"Data insights & deep-dive features","plan-description-3":"Weekly PRO newsletters","plan-description-4":"Exclusive videos & analysis","plan-description-5":"Invite-only member events","terms-and-conditions":null,"login-link":"https://www.thewrap.com/login"}}}]}]},{"type":"account-verification","label":"Account Verification","sections":[{"type":"email","order":1,"label":"Account Verification","elements":[{"type":"payment_summary","order":0,"config":{"title":"WrapPRO Subscription","total":"TOTAL","prorateLabel":"","prorateDisclaimer":"Today's payment may vary.","taxLabel":"Tax"},"id":"1b761c3b-60bf-457e-aeb4-90a86c2980b8","hidden":false},{"type":"email_address","order":1,"config":{"label":"Email","placeholder":"name@provider.com","disabled":false},"id":"a8a328f9-4fc2-4dd6-a26b-7307ed65318e","hidden":false},{"type":"button","order":2,"config":{"text":"Continue"},"id":"a214da55-ec4e-4e6c-bd07-9db09cfa87f4","hidden":false},{"type":"divider","order":3,"config":{"text":"OR USE","showLine":true,"show":false},"id":"79de35d6-1b89-497c-bb68-1c252197a9ad","hidden":false},{"type":"social_sign_in","order":4,"config":{"Google":true,"Facebook":true,"labelText":"Continue with","Apple":true},"id":"d2cabb57-f2f4-4299-8a09-78933ccfa158","hidden":false},{"type":"text","order":5,"id":"1bf188fb-736f-49ea-a0e6-49e71f434f07","config":{"text":"<h6 class=\"p1\">$1 today. After 14 days, your selected plan begins. Annual plan renews at $199/year. Monthly plan renews at $24.99/month. Cancel anytime during your trial to avoid charges.</h6>","centerText":true},"hidden":false},{"type":"text","order":6,"config":{"text":"<div style=\"font-size: 8px; color: #888888; line-height: 1.4; text-align: left;\">This offer does not apply to renewals or future subscription years. By accessing or using TheWrap (&ldquo;WrapPRO,&rdquo; &ldquo;we,&rdquo; or &ldquo;us&rdquo;), including thewrap.com and any affiliated websites (collectively, the &ldquo;Website&rdquo;), or any content, products, or services offered through the Website (the &ldquo;Services&rdquo;), you agree to these Terms of Service (&ldquo;Terms&rdquo;). If you do not agree, you may not use the Website or Services. Your use is also subject to our Privacy Policy which can be reviewed at http://www.thewrap.com/members/privacy-policy. The Services are available only to individuals aged 13 or older.</div>"},"id":"fcf80c0e-79cc-4398-a0eb-30efb9e29a9a","hidden":false}],"tab":"email"},{"type":"verification_code_registration","order":2,"label":"Registration via Verification Code","elements":[{"type":"progress_bar","order":1,"config":{"enabled":false,"hidden":true},"id":"4737007b-d28c-4cde-8719-52052498c682"},{"type":"payment_summary","order":2,"config":{"title":"WrapPRO Subscription","total":"TOTAL","prorateLabel":"","prorateDisclaimer":"Today's payment may vary.","taxLabel":"Tax"},"id":"4298d8c1-41fe-4e65-a634-97c12e348cac"},{"type":"text","order":3,"config":{"text":"A message with a code has been sent to"},"id":"20ec4532-9851-471c-8980-f6eddef16ed3"},{"type":"email_address","order":4,"config":{"label":"Email","placeholder":"name@provider.com","disabled":true},"id":"eacecc40-8587-4de0-b461-a842a3432cd0"},{"type":"text","order":5,"config":{"text":"Enter the code in the box below."},"id":"ddff5055-f428-458a-8496-eb2cf0de95bf"},{"type":"otp_code","order":6,"config":{"label":"Code","placeholder":"e.g. 350271","resendText":"Didn't get a code?","message":"Resent!"},"id":"0820e4fc-f755-4af6-8036-9a1ab4ff1030"}],"tab":"reg"},{"type":"password_setup","order":3,"label":"Password Setup","elements":[{"type":"progress_bar","order":0,"config":{"enabled":false,"hidden":true},"id":"8f5f56c8-116a-43f3-99dd-13fb82c5b8ab","hidden":false},{"type":"payment_summary","order":1,"config":{"title":"WrapPRO Subscription","total":"TOTAL","prorateLabel":"","prorateDisclaimer":"Today's payment may vary.","taxLabel":"Tax"},"id":"32d43a98-2d80-495b-aad0-b38ccbce0434","hidden":false},{"type":"text","order":2,"config":{"text":"Create an account"},"id":"f90e32c7-5e7c-4243-a158-f90d8e2751e3","hidden":false},{"type":"email_address","order":3,"config":{"label":"Email","placeholder":"name@provider.com","disabled":true},"id":"6c2f679e-dc67-4b80-a2b4-6c2e87f5374c","hidden":false},{"type":"password","order":4,"config":{"password":"Password","placeholder":"","show":"Show","hide":"Hide","passValidatorEnabled":true,"confirm":"Confirm Password","confirmPlaceholder":""},"id":"fb2f321d-b780-4eaf-b00c-5b1ec9800abf","hidden":false},{"type":"button","order":5,"config":{"isSubmit":false,"text":"Continue"},"id":"688f9d94-d9cb-4e53-9234-690cd6843348","hidden":false},{"type":"text","order":6,"id":"177cbc3a-963f-47c6-8e4e-06790092e8ae","config":{"text":"<h6 class=\"p1\">$1 today. After 14 days, your selected plan begins. Annual plan renews at $199/year. Monthly plan renews at $24.99/month. Cancel anytime during your trial to avoid charges.</h6>","centerText":true},"hidden":false},{"type":"text","order":7,"config":{"text":"<div style=\"font-size: 10px; color: #666666; line-height: 1.4; text-align: left;\">\nThis offer does not apply to renewals or future subscription years. By accessing or using TheWrap (“WrapPRO,” “we,” or “us”), including thewrap.com and any affiliated websites (collectively, the “Website”), or any content, products, or services offered through the Website (the “Services”), you agree to these Terms of Service (“Terms”). If you do not agree, you may not use the Website or Services. Your use is also subject to our Privacy Policy which can be reviewed at http://www.thewrap.com/members/privacy-policy. The Services are available only to individuals aged 13 or older.</div>\n"},"id":"2f8d9329-12f9-4407-9c8a-049fe4284ebf","hidden":false}],"tab":"reg"},{"type":"verification_code_login","order":4,"label":"Passwordless Login via Login Code","elements":[{"type":"progress_bar","order":1,"config":{"enabled":false,"hidden":true},"id":"4db862c8-6135-4f79-be52-f9c48ab32480"},{"type":"payment_summary","order":2,"config":{"title":"WrapPRO Subscription","total":"TOTAL","prorateLabel":"","prorateDisclaimer":"Today's payment may vary.","taxLabel":"Tax"},"id":"13544490-36ed-4e34-9b02-e44c8b6d216f"},{"type":"text","order":3,"config":{"text":"A message with a code has been sent to"},"id":"94945519-a0b1-482c-9e4b-043dd935f3d1"},{"type":"email_address","order":4,"config":{"label":"Email","placeholder":"name@provider.com","disabled":true},"id":"72e7a041-1b11-480f-bf6e-b8694beb2fde"},{"type":"text","order":5,"config":{"text":"Enter the code in the box below."},"id":"92c2466c-01e5-464e-9232-79749b961cf2"},{"type":"otp_code","order":6,"config":{"label":"Code","placeholder":"e.g. 350271","resendText":"Didn't get a code?","message":"Resent!"},"id":"43278308-b87f-4a9f-8158-528d0b92b590"}],"tab":"login"},{"type":"login_password","order":5,"label":"Login with Password","elements":[{"type":"progress_bar","order":0,"config":{"enabled":false,"hidden":true},"id":"9cce4b11-7e9a-46f7-b862-dc8e4f94e5e2","hidden":false},{"type":"payment_summary","order":1,"config":{"title":"WrapPRO Subscription","total":"TOTAL","prorateLabel":"","prorateDisclaimer":"Today's payment may vary.","taxLabel":"Tax"},"id":"f11ff659-bee7-45ef-838c-6095efbc2e63","hidden":false},{"type":"email_address","order":2,"config":{"label":"Email","placeholder":"name@provider.com","disabled":true},"id":"4c38a54d-2f5b-472a-b199-633a20ffdc5b","hidden":false},{"type":"password","order":3,"config":{"isLogin":true,"password":"Password","placeholder":"","show":"Show","hide":"Hide"},"id":"ac1ccebe-73ad-4a70-b507-27b2fddaa362","hidden":false},{"type":"link","order":4,"config":{"label":"Reset Password Link","text":"Forgot Password?"},"id":"818a632a-10c6-4ad8-b47d-ad0c8cd3a8a3","hidden":false},{"type":"button","order":5,"config":{"isSubmit":true,"text":"Submit"},"id":"f65620f3-4d00-4abd-b52e-ffc480642e3f","hidden":false},{"type":"text","order":6,"id":"2885290f-e52c-4a70-860e-03f6599d8347","config":{"text":"<p class=\"p1\">Billed annually at $52 for first year, then $199 thereafter. Renews yearly. Cancel anytime.</p>","centerText":true},"hidden":false}],"tab":"login"},{"type":"forgot_password","order":6,"label":"Forgot Password","elements":[{"type":"text","order":1,"config":{"text":"Reset your password"},"id":"e8d4dba2-8341-4a15-abf2-cb2639266db9"},{"type":"text","order":2,"config":{"text":"A message with the code was sent to..."},"id":"7cd92ca5-9dd1-4ce8-b1c9-09565e3b8a93"},{"type":"email_address","order":3,"config":{"label":"Email","placeholder":"name@provider.com","disabled":true},"id":"a47dc890-2d3b-4ff7-a1d8-b87ab458225f"},{"type":"text","order":4,"config":{"text":"Enter the code in the box below."},"id":"67ca0066-6cb9-44e6-85d5-944cd3c6dbc8"},{"type":"otp_code","order":5,"config":{"label":"Code","placeholder":"e.g. 350271","resendText":"Didn't get a code?","message":"Resent!"},"id":"3c3c2d14-6deb-4a29-aff8-1882832fb619"},{"type":"divider","order":6,"config":{"text":"OR USE","showLine":true,"show":true},"id":"f14a6e57-2b27-4b4c-bb7b-8987b1fc9392"},{"type":"button","order":7,"config":{"isSubmit":false,"isLogin":true,"text":"Login"},"id":"3e674246-b1a7-4e9b-8dd9-b354314e8954"}],"tab":"login"},{"type":"reset_password","order":7,"label":"Reset Password","elements":[{"type":"text","order":1,"config":{"text":"Reset your password"},"id":"a39ea0f1-ea8d-4e52-8b60-3a1178eca2ea"},{"type":"email_address","order":2,"config":{"label":"Email","disabled":true},"id":"945bf54f-27b6-4dc6-ab8f-bb71b6ce72f2"},{"type":"password","order":3,"config":{"password":"Password","placeholder":"","show":"Show","hide":"Hide","passValidatorEnabled":true,"confirm":"Confirm Password","confirmPlaceholder":""},"id":"bce27689-1a46-48bb-ae8d-1f91ade56f9f"},{"type":"button","order":4,"config":{"isSubmit":true,"text":"Submit"},"id":"df228f20-3552-42f3-86e6-79ced270b243"}],"tab":"login"}]},{"type":"payment","sections":[{"type":"payment_details","order":1,"label":"Payment Details","elements":[{"type":"progress_bar","order":0,"config":{"enabled":false,"hidden":true},"hidden":false,"id":"14b97e3f-dd31-4997-995b-dabefd738bf0"},{"type":"payment_summary","order":1,"config":{"title":"WrapPRO Subscription","total":"TOTAL","prorateLabel":"","prorateDisclaimer":"Today's payment may vary.","taxLabel":"Tax"},"hidden":false,"id":"d0ffb2f4-7ca6-4290-b36c-ffe3cc2ae85a"},{"type":"user_attribute","order":2,"config":{"slug":"first-name","label":"First Name","inputType":"TEXT","required":true},"hidden":false,"id":"7de35c08-d812-454d-88b1-999b44faa452"},{"type":"user_attribute","order":3,"config":{"slug":"last-name","label":"Last Name","inputType":"TEXT","required":true},"hidden":false,"id":"624e0ba2-515e-429e-9213-123d00d964c0"},{"type":"payment","order":4,"config":{},"hidden":false,"id":"55eea59f-ee64-4a63-9034-c095fd8daa11"},{"type":"mobile_payment","order":5,"config":{"enabled":true,"showActivateTip":false},"hidden":false,"id":"f03d5faa-97c8-4175-9708-400166a3bc5e"},{"type":"button","order":6,"config":{"text":"Confirm and process payment"},"hidden":false,"id":"60d445b8-c1c3-489f-84d5-312cdb83a17c"},{"type":"text","order":7,"id":"b4e933f7-98e2-46fe-9cb2-5406e0d72d15","config":{"text":"<h6 class=\"p1\">$1 today. After 14 days, your selected plan begins. Annual plan renews at $199/year. Monthly plan renews at $24.99/month. Cancel anytime during your trial to avoid charges.</h6>","centerText":true},"hidden":false}],"tab":"pay"}]},{"type":"success","sections":[{"type":"success","order":1,"label":"Successful Payment","elements":[{"type":"text","order":1,"config":{"text":"<h2>Payment processed successfully!</h2>\n<p>Welcome to WrapPRO! Please check your email for confirmation details.</p>"},"id":"ab2ceeb2-d491-4789-914f-d14725100840"},{"type":"payment_summary","order":2,"config":{"title":"WrapPRO Subscription","total":"TOTAL","prorateLabel":"","prorateDisclaimer":"Today's payment may vary.","taxLabel":"Tax"},"id":"f799fc08-40c9-40d5-9b57-ec8271184fd0"},{"type":"button","order":3,"config":{"text":"Continue reading"},"id":"9a337f43-a0bd-42e5-aee8-eba604577cce"},{"id":"03aef8fa-e9db-49f1-af2e-cf28207a1fb9","order":3,"type":"invitation","config":{"title":"<<<forms.payment.invitation-title|Invite people to your sharable plan>>>","description":"<<<forms.payment.invitation-description|You can invite people by entering their email>>>","label":"<<<forms.payment.invitation-label|Email Address>>>","btnText":"<<<forms.payment.invitation-button|Send Invite>>>","linkSentText":"<<<forms.payment.invitation-link-sent|Invite sent!>>>"}}],"tab":"pay"}]}],"timestamp":1767289424909,"id":"U-NyOoWL","outcomeId":"graph/1#2,graph/1#3,graph/1#5,graph/2#1,graph/2#76,graph/2#49,graph/2#30,graph/2#47,graph/2#61,graph/2#64,subrule/3#1,subrule/3#2,subrule/3#6,transformation/9","ruleId":"H-article-test-432","resolvedComponentTemplates":[{"id":"modaltest:24","css":".zephr-radio-payment-options-page {\n  --zephr-radio-payment-options-page-line-color: var(--zephr-color-text-main);\n  --zephr-radio-payment-options-page-line-font-size: 18px;\n\n  --zephr-radio-payment-options-page-title-font-size: 24px;\n  --zephr-radio-payment-options-page-title-text-align: center;\n\n  --zephr-radio-payment-options-page-wrapper-background: var(--zephr-color-background-main);\n  --zephr-radio-payment-options-page-wrapper-border: 1px solid var(--zephr-color-background-tinted);\n  --zephr-radio-payment-options-page-wrapper-border-radius: 5px;\n\n  --zephr-radio-payment-option-price-color: var(--zephr-color-text-main);\n  --zephr-radio-payment-option-price-font-size: 16px;\n\n  --zephr-radio-payment-options-description-color: var(--zephr-color-text-main);\n  --zephr-radio-payment-options-description-font-size: 12px;\n\n  --zephr-radio-payment-option-price-description-color: var(--zephr-color-text-main);\n  --zephr-radio-payment-option-price-description-font-size: 12px;\n\n  --zephr-radio-payment-options-button-background: var(--zephr-color-action-main);\n  --zephr-radio-payment-options-button-color: var(--zephr-color-background-main);\n  --zephr-radio-payment-options-button-hover-background: var(--zephr-color-action-tinted);\n  --zephr-radio-payment-options-button-hover-color: var(--zephr-color-action-tinted);\n  --zephr-radio-payment-options-button-font-size: 12px;\n  --zephr-radio-payment-options-button-width: 100%;\n  --zephr-radio-payment-options-button-height: calc(var(--zephr-button-height) * 1px);\n\n  --zephr-radio-plan-group-description-color: var(--zephr-color-text-tinted);\n  --zephr-radio-plan-group-description-font-size: 10px;\n  --zephr-radio-plan-group-description-max-width: 492px;\n\n  --zephr-radio-plan-group-terms-color: var(--zephr-color-text-tinted);\n  --zephr-radio-plan-group-terms-text-align: center;\n  --zephr-radio-plan-group-terms-font-size: 12px;\n\n  --zephr-radio-payment-options-page-link-color: #2E6CD4;\n  --zephr-radio-payment-options-page-link-font-size: 12px;\n}\n\n  .zephr-radio-payment-options-page {\n    display: flex;\n    flex-direction: column;\n    gap: 32px;\n    font-family: var(--zephr-typography-body-font),  var(--zephr-typography-body-fallbackFont);\n  }\n  .zephr-radio-payment-options-page-line {\n    text-align: center;\n    color: var(--zephr-radio-payment-options-page-line-color);\n  }\n  .zephr-radio-payment-options-page-line h2 {\n    font-size: var(--zephr-radio-payment-options-page-line-font-size);\n    font-weight: 400;\n    margin: 0px;\n  }\n  .zephr-radio-payment-options-page-title {\n    font-size: var(--zephr-radio-payment-options-page-title-font-size);\n    font-weight: 400;\n    margin: 0px;\n    color: var(--zephr-color-text-main);\n    text-align: var(--zephr-radio-payment-options-page-title-text-align);\n    font-style: normal;\n    font-weight: 400;\n    line-height: 100%;\n  }\n  .zephr-radio-payment-options-page-wrapper {\n    display: flex;\n    padding: 30px;\n    flex-direction: column;\n    align-items: center;\n    gap: 32px;\n    border-radius: var(--zephr-radio-payment-options-page-wrapper-border-radius);\n    border: var(--zephr-radio-payment-options-page-wrapper-border);\n    background: var(--zephr-radio-payment-options-page-wrapper-background);\n    align-self: center;\n  }\n\n  .zephr-radio-payment-options-wrapper {\n    display: flex;\n    justify-content: center;\n    align-items: flex-start;\n    gap: 20px;\n  }\n  .zephr-radio-payment-options-selector-wrapper {\n    display: flex;\n    flex-direction: column;\n    align-items: flex-start;\n    gap: 24px;\n  }\n  .zephr-radio-payment-options-description-wrapper {\n    display: flex;\n    flex-direction: column;\n    align-items: flex-start;\n    gap: 16px;\n  }\n  .zephr-radio-payment-option-wrapper {\n    display: flex;\n    justify-content: center;\n    align-items: flex-start;\n    gap: 8px;\n  }\n  .zephr-radio-payment-option-description-wrapper {\n    display: flex;\n    flex-direction: column;\n    align-items: flex-start;\n    gap: 8px;\n    max-width: 220px;\n  }\n  .zephr-radio-payment-option-title {\n    color: var(--zephr-color-text-main);\n    font-size: 18px;\n    font-style: normal;\n    font-weight: 510;\n    line-height: 100%;\n  }\n  .zephr-radio-payment-option-price {\n    color: var(--zephr-radio-payment-option-price-color);\n    font-family: SF Pro;\n    font-size: var(--zephr-radio-payment-option-price-font-size);\n    font-style: normal;\n    font-weight: 400;\n    line-height: 100%;\n  }\n  .zephr-radio-payment-option-price-description {\n    color: var(--zephr-radio-payment-option-price-description-color);\n    font-size: var(--zephr-radio-payment-option-price-description-font-size);\n    font-style: normal;\n    font-weight: 400;\n    line-height: 100%;\n  }\n  .zephr-radio-payment-options-description-line {\n    display: flex;\n    max-width: 220px;\n    align-items: flex-start;\n    gap: 8px;\n  }\n  .zephr-payment-option-description-icon {\n    stroke-width: 2px;\n    stroke: var(--zephr-color-action-main);\n  }\n  .zephr-radio-payment-options-description {\n    color: var(--zephr-radio-payment-options-description-color);\n    font-size: var(--zephr-radio-payment-options-description-font-size);\n    font-style: normal;\n    font-weight: 400;\n    line-height: 100%;\n    padding-right: 8px;\n  }\n  .zephr-radio-payment-options-button {\n    max-width: 492px;\n    padding: 10px 28px;\n    background: var(--zephr-radio-payment-options-button-background);\n    border-radius: calc(var(--zephr-input-borderRadius) * 1px);\n    border-style: solid;\n    border-width: calc(var(--zephr-button-borderWidth) * 1px);\n    border-color: var(--zephr-color-action-tinted);\n    font-size: var(--zephr-radio-payment-options-button-font-size);\n    font-style: normal;\n    font-weight: 510;\n    text-align: center;\n    color: var(--zephr-radio-payment-options-button-color);\n    cursor: pointer;\n    width: var(--zephr-radio-payment-options-button-width);\n    height: var(--zephr-radio-payment-options-button-height);\n    font-family: var(--zephr-typography-body-font),\n      var(--zephr-typography-body-fallbackFont);\n  }\n  .zephr-radio-payment-options-button:hover {\n    background-color: var(--zephr-radio-payment-options-button-hover-background);\n    border-color: var(--zephr-radio-payment-options-button-hover-color);\n  }\n  .zephr-radio-plan-group-description {\n    color: var(--zephr-radio-plan-group-description-color);\n    font-size: var(--zephr-radio-plan-group-description-font-size);\n    text-align: center;\n    font-style: normal;\n    font-weight: 400;\n    line-height: 138.3%;\n    max-width: var(--zephr-radio-plan-group-description-max-width);\n  }\n  .zephr-radio-plan-group-terms {\n    color: var(--zephr-radio-plan-group-terms-color);\n    text-align: var(--zephr-radio-plan-group-terms-text-align);\n    font-size: var(--zephr-radio-plan-group-terms-font-size);\n    font-style: normal;\n    font-weight: 400;\n    line-height: 100%;\n  }\n  .zephr-radio-payment-options-page-footer {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    gap: 16px;\n  }\n  .zephr-radio-payment-options-page-login-line {\n    display: flex;\n    justify-content: center;\n    align-items: flex-start;\n    gap: 4px;\n  }\n  .zephr-radio-payment-options-page-link {\n    color: var(--zephr-radio-payment-options-page-link-color);\n    font-size: var(--zephr-radio-payment-options-page-link-font-size);\n    font-style: normal;\n    font-weight: 400;\n    line-height: 100%;\n  }\n  /* NYT-style Welcome Offer visual treatment */\n.zephr-welcome-offer-header {\n  text-align: center;\n  margin-bottom: -12px;\n  margin-top: 8px;\n}\n\n.zephr-welcome-offer-header .label {\n  font-size: 14px;\n  font-weight: 600;\n  letter-spacing: 0.5px;\n  text-transform: uppercase;\n  color: #333333;\n}\n\n.zephr-welcome-offer-header .price-line {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  gap: 8px;\n  font-family: Georgia, serif;\n  font-size: 28px;\n  font-weight: 600;\n  margin-top: 4px;\n  color: #1A1A1A;\n}\n\n.zephr-welcome-offer-header .old-price {\n  text-decoration: line-through;\n  color: #999999;\n  font-size: 22px;\n  font-weight: 400;\n}\n.zephr-welcome-offer-header .price-line {\n  margin-bottom: 10px;  /* adjust to taste: 8px, 12px, 16px */\n}\n.zephr-welcome-offer-header s {\n  color: #888;        /* light gray */\n  text-decoration-color: #888;  /* ensure the line is gray too */\n}\n/* Header wrapper */\n.zephr-welcome-offer-header {\n  text-align: center;\n  margin: 0 auto 2px auto;\n}\n\n/* Top line: \"Cyber Sale – Save 75%\" (3x bigger & with red 'Save 75%') */\n.zephr-welcome-offer-header .cyber-line {\n  font-size: 1.1rem;          /* ~3x typical body text */\n  font-weight: 600;\n  line-height: 1;\n}\n\n/* Make just \"Save 75%\" red */\n.zephr-welcome-offer-header .savings-red {\n  color: #88;             /* your brand red */\n}\n\n/* $1/week – 3x bigger */\n.zephr-welcome-offer-header .price-line .new-price {\n        color: #c20000 !important;\n  display: inline-block;\n  margin-top: 3px;\n  font-size: 3.2rem;          /* ~3x original */\n  font-weight: 700;\n}\n\n/* Subline: NOW $199 (strike) $52 for 12 months */\n.zephr-welcome-offer-header .subline {\n  margin-top: 4px;\n  font-size: 1.1rem;\n  font-weight: 500;\n}\n\n/* Optional: gray old price */\n.zephr-welcome-offer-header .subline s {\n  color: #999999;\n  text-decoration-color: #999999;\n  margin: 0 2px;\n}\n.zephr-radio-payment-option-price-description {\n  color: var(--zephr-radio-payment-option-price-description-color);\n  font-size: var(--zephr-radio-payment-option-price-description-font-size);\n  font-style: italic; /* ← change this */\n  font-weight: 400;\n  line-height: 100%;\n}\n.zephr-radio-payment-option-price-description {\n  font-style: italic;\n  opacity: 0.85;\n}\n\n.zephr-welcome-offer-header \n.zephr-radio-payment-option-price {\n  font-style: italic;\n  font-weight: 400;\n}\n\n.zephr-radio-payment-option-price {\n  font-style: normal;\n}\n/* FIX: restore native radio rendering in test/live where global CSS resets inputs */\n.zephr-radio-payment-options-page input[type=\"radio\"]{\n  -webkit-appearance: radio !important;\n  appearance: auto !important;\n\n  /* override common “hide input” patterns */\n  display: inline-block !important;\n  opacity: 1 !important;\n  visibility: visible !important;\n  position: static !important;\n  clip: auto !important;\n  clip-path: none !important;\n\n  /* ensure it has a box to render */\n  width: 16px !important;\n  height: 16px !important;\n  margin-right: 10px !important;\n}\n\n/* Optional: keeps alignment clean if your label is flex/inline */\n.zephr-radio-payment-options-page .zephr-radio-payment-options-page-option,\n.zephr-radio-payment-options-page label{\n  align-items: flex-start;\n}\n/* Enlarge entire footer line: \"Already a subscriber? Login\" */\n.zephr-radio-payment-options-page-login-line {\n  font-size: 16px;        /* increase whole line */\n  line-height: 1.4;\n}\n\n/* Ensure the Login link inherits the same size */\n.zephr-radio-payment-options-page-login-line\n  .zephr-radio-payment-options-page-link {\n  font-size: inherit;\n}\n/* Make the entire \"Already a subscriber? Login\" line bigger */\n.zephr-radio-payment-options-page .zephr-radio-payment-options-page-login-line{\n  font-size: 23px !important;\n  line-height: 1.4 !important;\n}\n\n/* Force the non-link text to match (covers span/p/div wrappers) */\n.zephr-radio-payment-options-page .zephr-radio-payment-options-page-login-line span,\n.zephr-radio-payment-options-page .zephr-radio-payment-options-page-login-line p,\n.zephr-radio-payment-options-page .zephr-radio-payment-options-page-login-line div{\n  font-size: 23px !important;\n  line-height: 1.4 !important;\n}\n\n/* Keep link aligned + same size */\n.zephr-radio-payment-options-page .zephr-radio-payment-options-page-login-line\n  .zephr-radio-payment-options-page-link{\n  font-size: 23px !important;\n}","html":"<div class=\"zephr-radio-payment-options-page\">\n\n  <div class=\"zephr-welcome-offer-header\">\n    <div class=\"label cyber-line\">\n      ALL ACCESS – <span class=\"savings-red\">14 Day Trial </span>\n    </div>\n\n    <div class=\"price-line\">\n      <span class=\"new-price\">Try for $1</span>\n    </div>\n\n    <div class=\"label subline\">\n    \n    </div>\n  </div>\n\n  {{#page-title}}\n    <div class=\"zephr-radio-payment-options-page-line\">\n      <h2>{{.}}</h2>\n    </div>\n  {{/page-title}}\n\n  <div class=\"zephr-radio-payment-options-page\">\n  {{#page-title}}\n      <div class=\"zephr-radio-payment-options-page-line\">\n          <h2>{{.}}</h2>\n      </div>\n  {{/page-title}}\n  <div class=\"zephr-radio-payment-options-page-wrapper\">\n    {{#plan-group-name}}\n      <h2 class=\"zephr-radio-payment-options-page-title\">{{.}}</h2>\n    {{/plan-group-name}}\n    <div class=\"zephr-radio-payment-options-wrapper\">\n      <div class=\"zephr-radio-payment-options-selector-wrapper\">\n      {{#paymentOptions}}\n        <div class=\"zephr-radio-payment-option-wrapper\">\n          {{#selected}}\n          <input type=\"radio\" id=\"{{slug}}\" name=\"radio-payment-option\" checked value=\"{{slug}}\"/>\n          {{/selected}}\n          {{^selected}}\n          <input type=\"radio\" id=\"{{slug}}\" name=\"radio-payment-option\" value=\"{{slug}}\"\n          onchange=\"{{zephrForm.ref}}.setState({ selectedOption: '{{slug}}' });\"/>\n          {{/selected}}\n          <div class=\"zephr-radio-payment-option-description-wrapper\">\n            <label for=\"{{slug}}\" class=\"zephr-radio-payment-option-title\">{{plan-name}}</label>\n            {{#plan-price}}\n              <span class=\"zephr-radio-payment-option-price\">{{.}}</span>\n            {{/plan-price}}\n            {{#plan-price-description}}\n              <span class=\"zephr-radio-payment-option-price-description\">{{.}}</span>\n            {{/plan-price-description}}\n          </div>\n        </div>\n      {{/paymentOptions}}\n      </div>\n      <div class=\"zephr-radio-payment-options-description-wrapper\">\n      {{#plan-description-1}}\n        <div class=\"zephr-radio-payment-options-description-line\">\n          <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"10\" viewBox=\"0 0 12 10\" fill=\"none\">\n            <path class=\"zephr-payment-option-description-icon\" d=\"M1 4.85738L4.09524 7.95261L11 1.04785\"/>\n          </svg>\n          <span class=\"zephr-radio-payment-options-description\">{{.}}</span>\n        </div>\n      {{/plan-description-1}}\n      {{#plan-description-2}}\n        <div class=\"zephr-radio-payment-options-description-line\">\n          <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"10\" viewBox=\"0 0 12 10\" fill=\"none\">\n            <path class=\"zephr-payment-option-description-icon\" d=\"M1 4.85738L4.09524 7.95261L11 1.04785\"/>\n          </svg>\n          <span class=\"zephr-radio-payment-options-description\">{{.}}</span>\n        </div>\n      {{/plan-description-2}}\n      {{#plan-description-3}}\n        <div class=\"zephr-radio-payment-options-description-line\">\n          <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"10\" viewBox=\"0 0 12 10\" fill=\"none\">\n            <path class=\"zephr-payment-option-description-icon\" d=\"M1 4.85738L4.09524 7.95261L11 1.04785\"/>\n          </svg>\n          <span class=\"zephr-radio-payment-options-description\">{{.}}</span>\n        </div>\n      {{/plan-description-3}}\n      {{#plan-description-4}}\n        <div class=\"zephr-radio-payment-options-description-line\">\n          <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"10\" viewBox=\"0 0 12 10\" fill=\"none\">\n            <path class=\"zephr-payment-option-description-icon\" d=\"M1 4.85738L4.09524 7.95261L11 1.04785\"/>\n          </svg>\n          <span class=\"zephr-radio-payment-options-description\">{{.}}</span>\n        </div>\n      {{/plan-description-4}}\n      {{#plan-description-5}}\n        <div class=\"zephr-radio-payment-options-description-line\">\n          <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"10\" viewBox=\"0 0 12 10\" fill=\"none\">\n            <path class=\"zephr-payment-option-description-icon\" d=\"M1 4.85738L4.09524 7.95261L11 1.04785\"/>\n          </svg>\n          <span class=\"zephr-radio-payment-options-description\">{{.}}</span>\n        </div>\n      {{/plan-description-5}}\n      {{#plan-description-6}}\n        <div class=\"zephr-radio-payment-options-description-line\">\n          <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"10\" viewBox=\"0 0 12 10\" fill=\"none\">\n            <path class=\"zephr-payment-option-description-icon\" d=\"M1 4.85738L4.09524 7.95261L11 1.04785\"/>\n          </svg>\n          <span class=\"zephr-radio-payment-options-description\">{{.}}</span>\n        </div>\n      {{/plan-description-6}}\n      </div>\n    </div>\n  {{#selectedOption}}\n    <button\n    class=\"zephr-radio-payment-options-button\"\n    onClick=\"{{zephrForm.ref}}.selectPaymentOption('{{productId}}', '{{slug}}');\"\n    >\n      {{select-button-text}}\n    </button>\n  {{/selectedOption}}\n  {{#plan-group-specific-description}}\n    <span class=\"zephr-radio-plan-group-description\">{{.}}</span>\n  {{/plan-group-specific-description}}\n  </div>\n  <div class=\"zephr-radio-payment-options-page-footer\">\n    {{#terms-and-conditions}}\n    <div class=\"zephr-radio-payment-options-page-line\">\n        <span class=\"zephr-radio-plan-group-terms\">{{.}}</span>\n    </div>\n    {{/terms-and-conditions}}\n    <div class=\"zephr-radio-payment-options-page-login-line\">\n        {{#login-suggestion-text}}\n        <span class=\"zephr-radio-plan-group-terms\">{{.}}</span>\n        {{/login-suggestion-text}}\n        {{#login-link-text}}\n        <a class=\"zephr-radio-payment-options-page-link\" href={{login-link}}><span>{{.}}</span><a>\n        {{/login-link-text}}\n    </div>\n  </div>\n  </div>\n","preRenderScript":"\n  const context = {\n    scope: {\n      selectedOption: scope.zephrForm.paymentOptions\n      .filter(o => o.slug === state?.selectedOption)[0] || scope.zephrForm.paymentOptions[0],\n      paymentOptions: scope.zephrForm.paymentOptions.map(p => ({\n        ...p,\n        selected: p.slug === (state?.selectedOption || scope.zephrForm.paymentOptions[0].slug)\n      }))\n    },\n  };\n  return context;\n","templateVariables":[{"key":"plan-group-name","defaultValue":"","paymentOptionLevel":false},{"key":"plan-description-1","defaultValue":"Unlimited access to member-exclusive content","paymentOptionLevel":false},{"key":"plan-description-2","defaultValue":"Industry analyses and in-depth features","paymentOptionLevel":false},{"key":"plan-description-3","defaultValue":"PRO Newsletters","paymentOptionLevel":false},{"key":"plan-description-4","defaultValue":"Exclusive video content","paymentOptionLevel":false},{"key":"plan-description-5","defaultValue":"Access to members-only events","paymentOptionLevel":false},{"key":"plan-description-6","defaultValue":"TheWrap's premium glossy print magazine","paymentOptionLevel":false},{"key":"plan-group-specific-description","defaultValue":"Billed as $4 for the first month, then $8.65/month for the remainder of your first year. Renews  at $19.99/month thereafter.","paymentOptionLevel":false},{"key":"terms-and-conditions","defaultValue":"No commitment. You can cancel anytime.","paymentOptionLevel":false},{"key":"login-suggestion-text","defaultValue":"Already a subscriber?","paymentOptionLevel":false},{"key":"login-link-text","defaultValue":"Login","paymentOptionLevel":false},{"key":"login-link","defaultValue":"#","paymentOptionLevel":false},{"key":"select-button-text","defaultValue":"Continue with card","paymentOptionLevel":true},{"key":"plan-name","defaultValue":"Welcome Offer","paymentOptionLevel":true},{"key":"plan-price","defaultValue":" ","paymentOptionLevel":true}]}],"languagePack":{"entries":{"forms.billing.history.date":"Date","forms.billing.history.every":"every","forms.billing.history.period":"Period","forms.billing.history.subtotal":"Subtotal","forms.billing.history.total":"Total","forms.buttons.back-button":"Back","forms.common.account-code.label":"Have an account registration code? Enter it here","forms.common.account-code.placeholder":"e.g. ACCOUNT001","forms.common.additional-section":"Additional Section","forms.common.continue":"Continue","forms.common.current-password":"Current Password","forms.common.divider-text":"or use","forms.common.email":"Email","forms.common.email-edit":"Edit","forms.common.email-placeholder":"Your email address","forms.common.otp.code-sent-to":"A message with a code has been sent to","forms.common.otp.enter-code":"Enter the code in the box below.","forms.common.otp.forgot-password":"Forgot Password?","forms.common.otp.forgot-password-code-sent":"Code sent!","forms.common.otp.label":"Code","forms.common.otp.placeholder":"e.g. 350271","forms.common.otp.resend":"Didn't get a code?","forms.common.otp.resent":"Resent!","forms.common.password":"Password","forms.common.password-confirm":"Confirm Password","forms.common.password-confirm-placeholder":"confirm password...","forms.common.password-hide":"Hide","forms.common.password-placeholder":"password...","forms.common.password-show":"Show","forms.common.password-validator.length":"Must include at least 8 characters","forms.common.password-validator.match":"Passwords match","forms.common.password-validator.number":"Must include a number character","forms.common.password-validator.symbol":"Must include a supported symbol","forms.common.password-validator.uppercase":"Must include an uppercase letter","forms.common.social-sign-in-label":"Continue with","forms.common.submit":"Submit","forms.common.update":"Update","forms.complete-registration-form.default-intro-text":"Set up your password","forms.complete-registration-form.default-success-message":"Thank you for updating your profile.","forms.contact-form.default-intro-text-1":"Stay in touch","forms.contact-form.default-intro-text-2":"Subscribe to our newsletter today","forms.contact-form.default-success-message":"Thank you for submitting your contact information.","forms.data-capture-form.default-intro-text":"Tell us more about you!","forms.data-capture-form.default-success-message":"Thank you for updating your profile.","forms.devices.current-device-label":"Current Device","forms.devices.login-time-label":"Login Time","forms.devices.no-session-message":"No Device sessions recorded","forms.devices.sign-out-button":"Sign Out","forms.devices.sign-out-of-other-devices-button":"Sign Out of Other Devices","forms.devices.your-devices-label":"Your Devices","forms.errors.company-account-not-found":"Account not found","forms.errors.contact-creation-disabled":"This operation is not possible at the moment, please try again later","forms.errors.email-domain-blocked":"Please use a different email address, this domain is not supported","forms.errors.email-taken":"This email address is already registered. Please log in to continue","forms.errors.email-verification-required":"Email verification is required","forms.errors.future-delivery-date-invalid":"Please select a valid future date","forms.errors.future-delivery-date-required":"Please select a future delivery date","forms.errors.future-delivery-date-too-early":"Delivery date must be at least 24 hours in the future","forms.errors.invitation-failed-duplicate-email":"An invite has already been created for this email","forms.errors.invitation-failed-invalid-email":"Invalid email address","forms.errors.invitation-failed-limit-reached":"You have reached the sharing limit for this product","forms.errors.invitation-failed-no-product-access":"You do not currently have access to this product","forms.errors.login-failed":"The email address or password you entered is incorrect","forms.errors.no-authenticated-session":"Please login to update your profile","forms.errors.otp-incorrect":"The code you entered is incorrect","forms.errors.otp-or-password-incorrect":"The password or code you entered is incorrect","forms.errors.otp-send-failed":"Unable to send a verification code. Please try again later","forms.errors.password-reset-failed":"Unable to reset your password. Please try again later","forms.errors.password-reset-link-send-failed":"Unable to send a password reset link. Please try again later","forms.errors.promo-code-expired":"Promo code expired","forms.errors.promo-code-invalid":"Invalid promo code","forms.errors.promo-code-invalid-for-payment-option":"Promo code cannot be applied to selected option","forms.errors.session-limit-reached":"You have reached the session limit. Please log out from another device to access this content","forms.errors.too-many-requests":"To gain login access, please contact your administrator","forms.errors.unknown-error":"Something went wrong. Please try again later","forms.errors.unknown-payment-error":"Something went wrong when processing your payment. Please try again later","forms.errors.user-attribute-invalid":"Invalid user attribute","forms.errors.user-not-found":"User not found","forms.gift-subscription.enable-future-delivery-toggle-description":"Schedule this gift subscription to start on a specific date","forms.gift-subscription.enable-future-delivery-toggle-label":"Schedule for future date","forms.gift-subscription.future-delivery-date-description":"Choose when the gift subscription should start","forms.gift-subscription.future-delivery-date-label":"Start date","forms.gift-subscription.future-delivery-date-placeholder":"Select start date","forms.list-subscriptions.billing-history-link":"Billing history","forms.list-subscriptions.billing-history-text":"To see previous invoices visit","forms.list-subscriptions.cancel-subscription-text":"Cancel subscription","forms.list-subscriptions.change-default-payment-method-button":"Change Default Payment Method","forms.list-subscriptions.change-payment-method-button":"Change Payment Method","forms.list-subscriptions.change-payment-success-text":"Payment successfully changed","forms.list-subscriptions.change-subscription-text":"Change subscription","forms.list-subscriptions.custom-fields-section-description":"Update your subscription information below","forms.list-subscriptions.custom-fields-section-title":"Update Subscription Details","forms.list-subscriptions.custom-fields-submit-button-text":"Update Details","forms.list-subscriptions.delivery-address-line-1-label":"Delivery Address Line 1","forms.list-subscriptions.delivery-address-line-1-placeholder":"Enter delivery address line 1","forms.list-subscriptions.delivery-address-line-2-label":"Delivery Address Line 2","forms.list-subscriptions.delivery-address-line-2-placeholder":"Enter delivery address line 2","forms.list-subscriptions.delivery-city-label":"Delivery City","forms.list-subscriptions.delivery-city-placeholder":"Enter delivery city","forms.list-subscriptions.delivery-country-label":"Delivery Country","forms.list-subscriptions.delivery-country-placeholder":"Enter delivery country","forms.list-subscriptions.delivery-information-description":"Manage your delivery address and preferences","forms.list-subscriptions.delivery-information-title":"Delivery Information","forms.list-subscriptions.delivery-postcode-label":"Delivery Postcode","forms.list-subscriptions.delivery-postcode-placeholder":"Enter delivery postcode","forms.list-subscriptions.next-payment-date":"Next payment date","forms.list-subscriptions.no-subscriptions-message":"You don't have any subscriptions","forms.list-subscriptions.subscription-rate-label":"Subscription rate","forms.list-subscriptions.suspend-resume-subscription-text":"Suspend/Resume subscription","forms.list-subscriptions.view-past-subscriptions-link":"View past subscriptions","forms.payment.account-verification-section":"Account Verification","forms.payment.invitation-button":"Send Invite","forms.payment.invitation-description":"You can invite people by entering their email","forms.payment.invitation-label":"Email Address","forms.payment.invitation-link-sent":"Invite sent!","forms.payment.invitation-title":"Invite people to your sharable plan","forms.payment.login":"Login","forms.payment.login-link":"Login","forms.payment.login-link-message":"Already a registered user?","forms.payment.password-setup-text":"Create an account","forms.payment.payment-button":"Confirm and process payment","forms.payment.payment-option-select-button":"Select Plan","forms.payment.payment-section":"Payment Details","forms.payment.payment-summary-disclaimer":"Today's payment may vary","forms.payment.payment-summary-prorate":"DUE TODAY","forms.payment.payment-summary-tax":"Tax","forms.payment.payment-summary-title":"Subscription","forms.payment.payment-summary-total":"TOTAL","forms.payment.plan-select-section":"Plan Select","forms.payment.promo-code-button":"Verify","forms.payment.promo-code-placeholder":"Promo code","forms.payment.promo-code-text":"Have a promo code?","forms.payment.reset-password-text":"Reset your password","forms.payment.success-button":"Continue Reading","forms.payment.success-message":"Payment processed successfully","forms.registration.account-verification-section":"Account Verification","forms.registration.default-intro-text":"You've reached the limit of free articles","forms.registration.email-verification-required-message":"A link has been sent to you. Please check your Email.","forms.registration.login":"Login","forms.registration.login-link-text":"A login link has been sent to","forms.registration.password-setup-section":"Password Setup","forms.registration.password-setup-text":"Create an account","forms.registration.resend-login-link":"Didn't get a link?","forms.registration.resend-login-link-resent":"Resent!","forms.registration.reset":"Reset!","forms.registration.reset-password-text":"Reset your password","forms.registration.success-button":"Continue Reading","forms.registration.success-message":"You have signed up successfully!","forms.subscription-cancel.back-button":"Back","forms.subscription-cancel.back-cancellation-button":"Back","forms.subscription-cancel.cancel-button":"Cancel Subscription","forms.subscription-cancel.confirm-text":"Are you sure you want to cancel?","forms.subscription-cancel.continue-cancel-button":"Continue Cancellation","forms.subscription-cancel.intro-text":"Select a subscription to cancel","forms.subscription-cancel.offer-text":"<h2>We are sorry to see you go</h2>Here is a special offer just for you.","forms.subscription-cancel.payment-option-select-button":"Accept Offer","forms.subscription-cancel.reason-text":"<h2>We would like to hear your feedback</h2>We'd appreciate it if you could to take a moment to let us know why you are cancelling.","forms.subscription-cancel.success-text":"Your subscription has been cancelled","forms.subscription-select.amount-label":"Amount:","forms.subscription-select.intro-text":"Select a subscription to upgrade","forms.subscription-select.next-billing-date-label":"Next billing date:","forms.subscription-select.no-change-plan-mapping-message":"No upgrade options are available for this subscription","forms.subscription-select.no-subscriptions-message":"No subscriptions available","forms.subscription-select.select-button":"Select","forms.suspend-resume-subscription.back-button":"Back to Home","forms.suspend-resume-subscription.intro-text":"Select a subscription to suspend or resume","forms.suspend-resume-subscription.resume-date-label":"Resume date:","forms.suspend-resume-subscription.success-text":"Your subscription has been suspended","forms.suspend-resume-subscription.suspension-date-label":"Suspension date:","forms.update-profile.update-email-title":"<h2>Update Email Address</h2>","forms.update-profile.update-password-title":"<h2>Update Password</h2>","forms.update-profile.your-profile":"Your Profile","forms.update-profile.your-profile-title":"<h2>Your Profile</h2>","hidden.example-key":"Hello world","hidden.form-preview.locale":"en-US","hidden.forms-preview.example-payment-option-description":"Example Payment Option","hidden.forms-preview.example-payment-option-label":"Example Offer","interstitial-page.password-reset.new-password":"New password:","interstitial-page.password-reset.password-mismatch-error":"You did not enter the same password twice","interstitial-page.password-reset.repeat-password":"Repeat password:","interstitial-page.password-reset.reset-button":"Reset","interstitial-page.password-reset.return-home-link":"Go back to the site","interstitial-page.password-reset.success-message":"Your password has been reset successfully!","interstitial-page.password-reset.title":"Change your password","interstitial-page.password-reset.unknown-error":"Something went wrong! Please try again later.","interstitial-page.passwordless-login.title":"Welcome","interstitial-page.update-email.enter-password":"Please enter your current password to complete the email update request.","interstitial-page.update-email.incorrect-password-error":"Incorrect password.","interstitial-page.update-email.password":"Password:","interstitial-page.update-email.return-home-link":"Go back to the site","interstitial-page.update-email.submit-button":"Update","interstitial-page.update-email.title":"Changing your email","interstitial-page.update-email.unknown-error":"Something went wrong! Please try again later.","interstitial-page.update-email-passwordless.message":"Please check the inbox of your new email for further instructions.","interstitial-page.update-email-passwordless.title":"Changing your email","interstitial-page.update-email-passwordless-success.message":"You have successfully changed your email address.","interstitial-page.update-email-passwordless-success.title":"Changing your email","interstitial-page.update-email-success.message":"Your email has been updated successfully!","pages.account-management.account-select-dropdown":"Select account","pages.account-management.delete-link":"Delete","pages.account-management.delete-modal-body":"Are you sure you want to delete this user?","pages.account-management.delete-modal-button":"Yes Delete","pages.account-management.delete-modal-title":"You are about to delete user","pages.account-management.delete-success-modal-body":"has been successfully deleted.","pages.account-management.delete-success-modal-title":"User Deleted","pages.account-management.errors.already-exists":"already exists","pages.account-management.errors.delete-fail":"Failed to delete","pages.account-management.errors.invite-fail":"Could not invite user","pages.account-management.invite-button-text":"Invite a User","pages.account-management.invite-modal-cancel-button":"Cancel","pages.account-management.invite-modal-confirm-button":"Invite User","pages.account-management.invite-modal-email-label":"Email Address","pages.account-management.invite-modal-email-placeholder":"Enter Email Address","pages.account-management.invite-modal-title":"Invite User","pages.account-management.invite-success-modal-body":"An invite has been sent to","pages.account-management.no-users":"No users found","pages.account-management.owner":"Owner","pages.account-management.search-button-text":"Search","pages.account-management.search-placeholder-text":"Search for a user","pages.account-management.success-modal-button":"Close","pages.account-management.title":"Manage Your Users","pages.cancel.back-to-subscriptions":"Back to Subscriptions","pages.cancel.cancel-subscription":"Cancel Subscription","pages.cancel.cancelled":"Cancelled","pages.cancel.continue-subscription":"Continue Subscription","pages.cancel.days-left":"DAYS LEFT:","pages.cancel.plan-frequency":"Frequency","pages.cancel.plan-name":"Name","pages.cancel.plan-next-billing":"Next Billing","pages.cancel.plan-period":"Period","pages.cancel.plan-price":"Price","pages.cancel.plan-type":"Type","pages.cancel.select-plans":"Select the plans you wish to cancel","pages.cancel.status-active":"Active","pages.cancel.status-cancelled":"Cancelled","pages.cancel.status-draft":"Draft","pages.cancel.status-expired":"Expired","pages.cancel.status-pending-acceptance":"Pending Acceptance","pages.cancel.status-pending-activation":"Pending Activation","pages.cancel.status-suspended":"Suspended","pages.cancel.status-unknown":"Unknown","pages.cancel.subscription-ends-on":"Subscription ends on","pages.cancel.subscription-will-end-on":"Your subscription will end on","pages.cancel.success":"You've cancelled your subscription","pages.cancel.until-cancelled":"Until Cancelled","pages.common.collapsible-content-text":"See details","pages.common.confirmation-modal-cancel-button":"Cancel","pages.common.confirmation-modal-confirm-button":"Confirm","pages.common.confirmation-primary-error-message":"Something went wrong!","pages.common.confirmation-secondary-error-message":"Try again later.","pages.common.date-time-format-locale":"en-US","pages.common.input-errors-invalid-email":"Please enter a valid email","pages.common.input-errors-invalid-url":"Please enter a valid URL","pages.common.input-errors-missing-value":"Please enter a value","pages.common.loading":"Loading...","pages.common.no-access-back-link":"Go Back","pages.common.no-access-body":"Sorry, you are not allowed to access this page. Click the button to go back.","pages.common.no-access-title":"No access.","pages.common.password-hide":"Hide","pages.common.password-show":"Show","pages.login-reg.already-registered-sign-in":"Already registered? Sign in","pages.login-reg.cancel":"Cancel","pages.login-reg.complete-registration-button":"Complete Registration","pages.login-reg.continue-with-apple":"Continue with Apple","pages.login-reg.continue-with-facebook":"Continue with Facebook","pages.login-reg.continue-with-google":"Continue with Google","pages.login-reg.continue-with-linkedin":"Continue with Linkedin","pages.login-reg.continue-with-microsoft":"Continue with Microsoft","pages.login-reg.continue-with-open-id-connect":"Continue with Open ID Connect","pages.login-reg.continue-with-twitter":"Continue with X","pages.login-reg.create-account":"Create an account","pages.login-reg.email-me-login-link":"Email me login link","pages.login-reg.email-me-reset-code":"Email me reset code","pages.login-reg.email-placeholder":"Email Address","pages.login-reg.enter-account-reg-code-here":"Enter an account registration code here","pages.login-reg.errors.contact-admin":"Please contact the administrator","pages.login-reg.errors.email-already-taken":"Email already taken","pages.login-reg.errors.email-verification-required":"Email verification is required","pages.login-reg.errors.password-incorrect":"The password you entered is incorrect","pages.login-reg.errors.password-not-strong-enough":"Password is not strong enough","pages.login-reg.errors.seat-capacity":"Your registration request couldn't be completed due to account seat capacity issue.","pages.login-reg.errors.something-went-wrong":"Something went wrong!","pages.login-reg.errors.to-gain-access-contact-admin":"To gain login access, please contact your administrator","pages.login-reg.errors.try-again-later":"Please try again later.","pages.login-reg.errors.user-not-found":"User not found","pages.login-reg.errors.username-already-taken":"Username already taken","pages.login-reg.forgotten-password":"Forgotten Password?","pages.login-reg.logging-in":"Logging in...","pages.login-reg.login-button":"Login","pages.login-reg.login-to-account":"Login to your account","pages.login-reg.or":"Or","pages.login-reg.password-placeholder":"Password","pages.login-reg.password-requirement":"Password must be a minimum of 8 characters and contain uppercase and lowercase, numbers and at least 1 special character.","pages.login-reg.register-button":"Register","pages.login-reg.register-for-account":"Register for an account","pages.login-reg.reset-your-password":"Reset your password","pages.login-reg.wait":"Please wait...","pages.pref-center.devices.current-device":"Current Device","pages.pref-center.devices.error-loading":"There was an error getting the device list","pages.pref-center.devices.sign-in-time":"Login date and time:","pages.pref-center.devices.sign-out":"Sign out","pages.pref-center.devices.sign-out-all":"Sign out of all other devices","pages.pref-center.devices.sign-out-all-success":"All other devices are now signed out","pages.pref-center.devices.sign-out-fail":"Signing out failed","pages.pref-center.devices.sign-out-success":"is now signed out.","pages.pref-center.devices.title":"Your Devices","pages.pref-center.devices.unknown-device":"Unknown","pages.pref-center.email-update-passwordless-message":"A link has been sent to your current email. Please check your inbox.","pages.pref-center.email-update-passwordless-title":"Check Your Inbox","pages.pref-center.general-error":"Something went wrong - please try again later","pages.pref-center.profile.attributes-select-list-placeholder":"Select One","pages.pref-center.profile.attributes-update-save":"Save","pages.pref-center.profile.attributes-update-title":"Your profile","pages.pref-center.profile.email":"Email Address","pages.pref-center.profile.email-update-email-label":"New Email","pages.pref-center.profile.email-update-email-placeholder":"Enter Email","pages.pref-center.profile.email-update-password-label":"Your Password","pages.pref-center.profile.email-update-password-placeholder":"Enter password","pages.pref-center.profile.email-update-save":"Save","pages.pref-center.profile.email-update-step-2-title":"Update Email Address","pages.pref-center.profile.email-update-title":"Update Email Address","pages.pref-center.profile.errors.change-email-error":"Sorry but your email address has not been changed. Please try again.","pages.pref-center.profile.errors.change-password-error":"Sorry but we were unable to reset your password. Please try again.","pages.pref-center.profile.errors.email-already-taken-error":"This email address is already taken.","pages.pref-center.profile.errors.incorrect-code":"Entered code is incorrect","pages.pref-center.profile.errors.incorrect-password":"The password you entered is incorrect","pages.pref-center.profile.errors.password-validation-error":"Password is not strong enough","pages.pref-center.profile.errors.unsuccessful":"Unsuccessful","pages.pref-center.profile.errors.update-profile-error":"Sorry but we were unable to update your profile. Please try again.","pages.pref-center.profile.password":"Password","pages.pref-center.profile.password-update-current-password-label":"Current Password","pages.pref-center.profile.password-update-current-password-placeholder":"Enter your password","pages.pref-center.profile.password-update-new-password-label":"New Password","pages.pref-center.profile.password-update-new-password-placeholder":"Enter a password","pages.pref-center.profile.password-update-save":"Continue","pages.pref-center.profile.password-update-step-2-title":"Reset your password","pages.pref-center.profile.password-update-title":"Update Password","pages.pref-center.profile.title":"Your Profile","pages.pref-center.profile.update":"Update","pages.pref-center.profile.update-email-successful":"Your email address has been changed.","pages.pref-center.profile.update-password-successful":"Your password has been reset.","pages.pref-center.profile.update-profile-successful":"Your profile has been updated.","pages.pref-center.profile.update-return-text":"Return to Personal Information","pages.pref-center.profile.update-step-2-code-label":"Code","pages.pref-center.profile.update-step-2-code-placeholder":"e.g. 350271","pages.pref-center.profile.update-step-2-enter-code":"Enter the code in the box below.","pages.pref-center.profile.update-step-2-message-sent":"A message with a code has been sent to email address:","pages.pref-center.profile.update-step-2-new-code-modal-body":"Would you like to send a new verification code to","pages.pref-center.profile.update-step-2-new-code-modal-button":"Resend Code","pages.pref-center.profile.update-step-2-new-code-modal-title":"Get a new verification code","pages.pref-center.profile.update-step-2-resend-code-link-text":"Didn't get a code?","pages.pref-center.profile.update-step-2-save":"Submit","pages.pref-center.profile.update-successful":"Success","pages.pref-center.share-product.modal-body":"You can invite people by entering their email. Available seats:","pages.pref-center.share-product.modal-email-label":"Email Address","pages.pref-center.share-product.modal-email-placeholder":"Enter Email Address","pages.pref-center.share-product.modal-send-button-text":"Send Invite","pages.pref-center.share-product.modal-title":"Invite people to your sharable subscription","pages.pref-center.shared-members.done-button":"Done","pages.pref-center.shared-members.invite-button-text":"Invite new members","pages.pref-center.shared-members.manage-shared-members-title":"Manage shared members","pages.pref-center.shared-members.no-members":"This product is not currently shared with anyone.","pages.pref-center.shared-members.seats-used":"seats used","pages.pref-center.shared-members.status-active":"Active","pages.pref-center.shared-members.status-inactive":"Inactive","pages.pref-center.shared-members.status-pending":"Pending","pages.pref-center.shared-members.table-header-date":"Date Shared","pages.pref-center.shared-members.table-header-email":"Email Address","pages.pref-center.shared-members.table-header-status":"Status","pages.pref-center.shared-members.table-remove-member":"Remove member","pages.pref-center.shared-members.title":"Shared Members","pages.pref-center.shared-products.errors.existing-invite-error":"An invite has already been created for this email","pages.pref-center.shared-products.errors.invalid-email-error":"Invalid email address","pages.pref-center.shared-products.errors.limit-reached-error":"You have reached the sharing limit for this product","pages.pref-center.shared-products.errors.no-access-error":"You do not currently have access to this product","pages.pref-center.shared-products.leave-product-body":"Are you sure you want to leave this shared product?","pages.pref-center.shared-products.leave-product-title":"Leave Product","pages.pref-center.shared-products.no-subscriptions":"You do not currently have any products shared with you.","pages.pref-center.shared-products.remove-invite-body":"Are you sure you want to remove this pending invite from your subscription?","pages.pref-center.shared-products.remove-invite-title":"Remove Invite","pages.pref-center.shared-products.remove-member-body":"Are you sure you want to remove this user from your subscription?","pages.pref-center.shared-products.remove-member-title":"Remove Member","pages.pref-center.shared-products.remove-subscription":"Leave shared subscription","pages.pref-center.shared-products.shared-by":"Shared by","pages.pref-center.subscriptions.billing-history-link":"Billing History.","pages.pref-center.subscriptions.billing-history-table-canceled":"Subscription canceled","pages.pref-center.subscriptions.billing-history-table-header-date":"Date","pages.pref-center.subscriptions.billing-history-table-header-period":"Subscription Period","pages.pref-center.subscriptions.billing-history-table-header-subtotal":"Subtotal","pages.pref-center.subscriptions.billing-history-table-header-total":"Total","pages.pref-center.subscriptions.billing-history-title":"Billing History","pages.pref-center.subscriptions.cancel-subscription-confirm-modal-body":"Your subscription has been canceled.","pages.pref-center.subscriptions.cancel-subscription-confirm-modal-button":"Close","pages.pref-center.subscriptions.cancel-subscription-confirm-modal-title":"Subscription canceled","pages.pref-center.subscriptions.cancel-subscription-modal-body":"Are you sure you want to cancel the subscription","pages.pref-center.subscriptions.cancel-subscription-modal-button":"Cancel Subscription","pages.pref-center.subscriptions.cancel-subscription-modal-title":"Cancel your subscription","pages.pref-center.subscriptions.cancel-subscription-title":"Cancel your subscription","pages.pref-center.subscriptions.canceled-date":"Canceled on","pages.pref-center.subscriptions.change-multi-subscription-screen-active-subscription":"active","pages.pref-center.subscriptions.change-multi-subscription-screen-best-value":"best value","pages.pref-center.subscriptions.change-multi-subscription-screen-cancel-subscriptions-confirm-modal-body":"Your subscriptions have been canceled.","pages.pref-center.subscriptions.change-multi-subscription-screen-cancel-subscriptions-confirm-modal-title":"Subscriptions canceled","pages.pref-center.subscriptions.change-multi-subscription-screen-cancel-subscriptions-modal-title":"Cancel your subscriptions","pages.pref-center.subscriptions.change-multi-subscription-screen-cancel-subscriptions-text":"Cancel Subscriptions","pages.pref-center.subscriptions.change-multi-subscription-screen-current-subscription":"current subscription","pages.pref-center.subscriptions.change-multi-subscription-screen-current-subscriptions-title":"Current Subscriptions","pages.pref-center.subscriptions.change-multi-subscription-screen-edit-subscription-text":"Edit","pages.pref-center.subscriptions.change-multi-subscription-screen-new-subscriptions-title":"New Subscriptions","pages.pref-center.subscriptions.change-multi-subscription-screen-review-button":"Review Changes","pages.pref-center.subscriptions.change-multi-subscription-screen-title":"Manage Subscriptions","pages.pref-center.subscriptions.change-payment-method-description":"Adjust how you pay for the product.","pages.pref-center.subscriptions.change-payment-method-screen-description":"This credit card will be used as the payment method for the following subscription:","pages.pref-center.subscriptions.change-payment-method-screen-save-button":"Save","pages.pref-center.subscriptions.change-payment-method-screen-title":"Enter Payment Detail","pages.pref-center.subscriptions.change-payment-method-title":"Change payment method","pages.pref-center.subscriptions.change-single-subscription-screen-add-new":"Add a new card","pages.pref-center.subscriptions.change-single-subscription-screen-best-value":"Best Value","pages.pref-center.subscriptions.change-single-subscription-screen-confirm-button":"CONFIRM & PROCESS PAYMENT","pages.pref-center.subscriptions.change-single-subscription-screen-current-subscription-title":"Current Subscription","pages.pref-center.subscriptions.change-single-subscription-screen-existing-payment":"Use existing payment method","pages.pref-center.subscriptions.change-single-subscription-screen-new-subscription-description":"Change your current subscription for another.","pages.pref-center.subscriptions.change-single-subscription-screen-new-subscription-title":"Change Subscription","pages.pref-center.subscriptions.change-single-subscription-screen-payment-method-selection":"Payment Method","pages.pref-center.subscriptions.change-single-subscription-screen-review-button":"Review Changes","pages.pref-center.subscriptions.change-single-subscription-screen-select-plan":"Select Plan","pages.pref-center.subscriptions.change-single-subscription-screen-selected-plan":"Selected Plan","pages.pref-center.subscriptions.change-single-subscription-screen-title":"Manage Subscription","pages.pref-center.subscriptions.change-single-subscription-title":"Change your subscription","pages.pref-center.subscriptions.change-subscription-description":"Adjust what products you have access to.","pages.pref-center.subscriptions.change-subscriptions-title":"Change your subscriptions","pages.pref-center.subscriptions.invoices-text":"To see previous invoices visit","pages.pref-center.subscriptions.manage-single-subscription-title":"Manage Subscription","pages.pref-center.subscriptions.manage-subscriptions-title":"Manage Subscriptions","pages.pref-center.subscriptions.next-payment-title":"Next payment date","pages.pref-center.subscriptions.no-subscriptions":"You don't have any subscriptions.","pages.pref-center.subscriptions.one-off-expiry-date":"Expiry Date","pages.pref-center.subscriptions.one-off-price-title":"Price","pages.pref-center.subscriptions.payment-information-title":"Payment Information","pages.pref-center.subscriptions.payment-processing-text":"(payment processing)","pages.pref-center.subscriptions.product-canceled":"Product canceled","pages.pref-center.subscriptions.return-to-subscription-text":"Return to Subscription","pages.pref-center.subscriptions.return-to-subscriptions-text":"Return to Subscriptions","pages.pref-center.subscriptions.subscription-rate-title":"Subscription rate","pages.pref-center.subscriptions.update-success":"Update success"}}},"formTypeConfig":{"paymentOptions":[{"slug":"ZXXm3P","productId":"wrappro-digital-print","price":1,"currencyCode":"USD","type":"MULTI_PHASED","highlightedText":"","selectButtonText":"<<<forms.payment.payment-option-select-button|Select Plan>>>","description":"<div id=\"zephr-payment-option-description\">\n<h2 style=\"font-weight: 400;\">WrapPRO Digital + Print</h2>\n<p style=\"color: #262626; font-weight: 400; font-size: 16px;\">\nWrapPro Digital + Print\n</p>\n<h3 style=\"font-weight: 400;\">$1.00 USD</h3>\n</div>\n","label":"$1 Trial + Annual","fieldOrder":1,"disclaimerMessage":"","templateValues":{"plan-name":"Annual (Most Popular)","plan-price":"$3.83/week (billed annually)"},"descriptionMode":"VISUAL","paymentProvider":"stripe","discounts":[],"virtualEnvironment":"live","product_sharing_limit":0},{"slug":"MXQT8U","productId":"wrappro-digital-monthly","price":1,"currencyCode":"USD","type":"MULTI_PHASED","highlightedText":"","selectButtonText":"<<<forms.payment.payment-option-select-button|Select Plan>>>","description":"<div id=\"zephr-payment-option-description\">\n<h2 style=\"font-weight: 400;\">WrapPRO Digital (Monthly)</h2>\n<p style=\"color: #262626; font-weight: 400; font-size: 16px;\">\nWrapPro Digital + Print\n</p>\n<h3 style=\"font-weight: 400;\">$1.00 USD</h3>\n</div>\n","label":"$1 Trial + Monthly","fieldOrder":2,"disclaimerMessage":"","templateValues":{"plan-name":"Monthly","plan-price":"$6.25/week (billed monthly)"},"descriptionMode":"VISUAL","paymentProvider":"stripe","discounts":[],"virtualEnvironment":"live","product_sharing_limit":0}],"loginLinkConfig":{"enabled":true,"alreadyRegText":"Already a registered user?","loginText":"Login","url":"/login"},"allowAccountRegistration":false,"formCurrency":"","paymentProviderFormConfig":{"usePaymentElement":false,"subscriptionMetadata":{"offer_type\t":"welcome_offer","signup_month\t":"{{now.format(\"YYYY-MM\")}}","referrer_url":"{{user.referrer}}","plan_name":"{{selectedPlan.name}}","plan_slug":"{{selectedPlan.slug}}"}},"stagingPaymentProviderFormConfig":{},"hideConfirmPasswordOnRegForm":false,"changeSubscriptionPlanMappings":[],"changeSubscriptionMode":false,"promoCodeConfig":{"promoCodeAllowed":true,"promoCodeText":"Have a promo code?","promoCodeButtonText":"Verify","promoCodePlaceholder":"Add your promo code here"},"usePassword":true,"useVerificationCodes":false,"invitationEnabled":false,"invitationMetadata":{"url":"https://www.thewrap.com/join-pro/","mapping":[]},"autoApplyAttributes":{},"dynamicOffer":null,"requestCountry":"US","requestState":"Illinois","requestCity":"Chicago","requestZipCode":"60602"},"organisationConfig":{"schemaFields":[{"slug":"account_subscription","visibility":"PUBLIC","label":"Subscription Status","required":false,"public-description":"","validation-expression":null,"input-type":"text","select-options":null,"range-start":0,"range-end":100,"range-step":5},{"slug":"address-1","visibility":"PUBLIC","label":"Address 1","required":false,"public-description":"Address 1","validation-expression":null,"input-type":"text","select-options":null,"range-start":null,"range-end":null,"range-step":null},{"slug":"address-2","visibility":"PUBLIC","label":"Address 2","required":false,"public-description":"Address 2","validation-expression":null,"input-type":"text","select-options":null,"range-start":null,"range-end":null,"range-step":null},{"slug":"awards-season","visibility":"PUBLIC","label":"Awards Season","required":false,"public-description":"","validation-expression":null,"input-type":"checkbox","select-options":null,"range-start":null,"range-end":null,"range-step":null},{"slug":"city","visibility":"PUBLIC","label":"City","required":false,"public-description":"","validation-expression":null,"input-type":"text","select-options":null,"range-start":null,"range-end":null,"range-step":null},{"slug":"company","visibility":"PUBLIC","label":"Company","required":false,"public-description":"","validation-expression":null,"input-type":"text","select-options":null,"range-start":null,"range-end":null,"range-step":null},{"slug":"country","visibility":"PUBLIC","label":"Country","required":false,"public-description":"","validation-expression":null,"input-type":"text","select-options":null,"range-start":0,"range-end":100,"range-step":5},{"slug":"first-name","visibility":"PUBLIC","label":"First Name","required":false,"public-description":"","validation-expression":null,"input-type":"text","select-options":null,"range-start":null,"range-end":null,"range-step":null},{"slug":"first-take","visibility":"PUBLIC","label":"First Take","required":false,"public-description":"","validation-expression":null,"input-type":"checkbox","select-options":null,"range-start":0,"range-end":100,"range-step":5},{"slug":"gender","visibility":"PUBLIC","label":"Gender","required":false,"public-description":"gender","validation-expression":null,"input-type":"text","select-options":null,"range-start":0,"range-end":100,"range-step":5},{"slug":"geocountry","visibility":"PUBLIC","label":"GeoCountry","required":false,"public-description":"","validation-expression":null,"input-type":"text","select-options":null,"range-start":null,"range-end":null,"range-step":null},{"slug":"geostate","visibility":"PUBLIC","label":"GeoState","required":false,"public-description":"","validation-expression":null,"input-type":"text","select-options":null,"range-start":null,"range-end":null,"range-step":null},{"slug":"job","visibility":"PUBLIC","label":"Job Title","required":false,"public-description":"","validation-expression":null,"input-type":"text","select-options":null,"range-start":0,"range-end":100,"range-step":5},{"slug":"last-name","visibility":"PUBLIC","label":"Last Name","required":false,"public-description":"","validation-expression":null,"input-type":"text","select-options":null,"range-start":null,"range-end":null,"range-step":null},{"slug":"news-highlights","visibility":"PUBLIC","label":"Breaking News","required":false,"public-description":"","validation-expression":null,"input-type":"checkbox","select-options":null,"range-start":0,"range-end":100,"range-step":5},{"slug":"photo","visibility":"PUBLIC","label":"Photo","required":false,"public-description":"","validation-expression":null,"input-type":"url","select-options":null,"range-start":0,"range-end":100,"range-step":5},{"slug":"product","visibility":"PUBLIC","label":"Product","required":false,"public-description":"Product","validation-expression":null,"input-type":"text","select-options":null,"range-start":null,"range-end":null,"range-step":null},{"slug":"province","visibility":"PUBLIC","label":"Province","required":false,"public-description":"","validation-expression":null,"input-type":"text","select-options":null,"range-start":null,"range-end":null,"range-step":null},{"slug":"screenings-events","visibility":"PUBLIC","label":"Screenings & Events","required":false,"public-description":"","validation-expression":null,"input-type":"checkbox","select-options":null,"range-start":null,"range-end":null,"range-step":null},{"slug":"state","visibility":"PUBLIC","label":"US State","required":false,"public-description":"","validation-expression":null,"input-type":"select","select-options":[{"label":"AL","value":"AL","default":false},{"label":"AK","value":"AK","default":false},{"label":"AZ","value":"AZ","default":false},{"label":"AR","value":"AR","default":false},{"label":"CA","value":"CA","default":false},{"label":"CO","value":"CO","default":false},{"label":"CT","value":"CT","default":false},{"label":"DE","value":"DE","default":false},{"label":"DC","value":"DC","default":false},{"label":"FL","value":"FL","default":false},{"label":"GA","value":"GA","default":false},{"label":"HI","value":"HI","default":false},{"label":"ID","value":"ID","default":false},{"label":"IL","value":"IL","default":false},{"label":"IN","value":"IN","default":false},{"label":"IA","value":"IA","default":false},{"label":"KS","value":"KS","default":false},{"label":"KY","value":"KY","default":false},{"label":"LA","value":"LA","default":false},{"label":"ME","value":"ME","default":false},{"label":"MD","value":"MD","default":false},{"label":"MA","value":"MA","default":false},{"label":"MI","value":"MI","default":false},{"label":"MN","value":"MN","default":false},{"label":"MS","value":"MS","default":false},{"label":"MO","value":"MO","default":false},{"label":"MT","value":"MT","default":false},{"label":"NE","value":"NE","default":false},{"label":"NV","value":"NV","default":false},{"label":"NH","value":"NH","default":false},{"label":"NJ","value":"NJ","default":false},{"label":"NM","value":"NM","default":false},{"label":"NY","value":"NY","default":false},{"label":"NC","value":"NC","default":false},{"label":"ND","value":"ND","default":false},{"label":"OH","value":"OH","default":false},{"label":"OK","value":"OK","default":false},{"label":"OR","value":"OR","default":false},{"label":"PA","value":"PA","default":false},{"label":"PR","value":"PR","default":false},{"label":"RI","value":"RI","default":false},{"label":"SC","value":"SC","default":false},{"label":"SD","value":"SD","default":false},{"label":"TN","value":"TN","default":false},{"label":"TX","value":"TX","default":false},{"label":"UT","value":"UT","default":false},{"label":"VT","value":"VT","default":false},{"label":"VI","value":"VI","default":false},{"label":"VA","value":"VA","default":false},{"label":"WA","value":"WA","default":false},{"label":"WV","value":"WV","default":false},{"label":"WI","value":"WI","default":false},{"label":"WY","value":"WY","default":false}],"range-start":0,"range-end":100,"range-step":5},{"slug":"the-weekender","visibility":"PUBLIC","label":"The Weekender","required":false,"public-description":"","validation-expression":null,"input-type":"checkbox","select-options":null,"range-start":null,"range-end":null,"range-step":null},{"slug":"tv-watch-list","visibility":"PUBLIC","label":"TV Watch List","required":false,"public-description":"","validation-expression":null,"input-type":"checkbox","select-options":null,"range-start":null,"range-end":null,"range-step":null},{"slug":"wrapwomen","visibility":"PUBLIC","label":"WrapWomen","required":false,"public-description":"","validation-expression":null,"input-type":"checkbox","select-options":null,"range-start":null,"range-end":null,"range-step":null},{"slug":"zipcode","visibility":"PUBLIC","label":"Zipcode","required":false,"public-description":"","validation-expression":null,"input-type":"text","select-options":null,"range-start":null,"range-end":null,"range-step":null}],"siteStyles":"{\"color\":{\"text\":{\"main\":\"#000000\",\"tinted\":\"#333333\"},\"background\":{\"main\":\"#FFFFFF\",\"tinted\":\"#b3b3b3\"},\"accent\":{\"main\":\"#dcdfe4\",\"tinted\":\"#bfc4ce\"},\"action\":{\"main\":\"#da0a0a\",\"tinted\":\"#f52222\"},\"warning\":{\"main\":\"#D90B00\",\"tinted\":\"#ff190d\"}},\"typography\":{\"title\":{\"font\":\"IvyPresto Text\",\"fallbackFont\":\"serif\"},\"body\":{\"font\":\"Libre Franklin\",\"fallbackFont\":\"sans-serif\"}},\"button\":{\"fontWeight\":\"normal\",\"fontSize\":\"16\",\"borderWidth\":\"0\",\"borderRadius\":\"0\",\"height\":\"50\"},\"input\":{\"borderColor\":\"#333333\",\"borderWidth\":\"1\",\"borderRadius\":\"0\",\"height\":\"50\"}}","twoFactorEmailAuthenticationEnabled":false,"requireEmailVerfication":false,"hideConfirmPasswordOnRegForm":false,"passwordStrengthRequirements":{"minLength":8,"requireUppercase":true,"requireNumbers":true,"requireSpecialCharacters":false},"ruleAnalyticsEnabled":true,"paymentProvider":"stripe","braintreeSandboxEnv":true,"braintreeMobilePaymentConfig":null,"stripeMobilePaymentConfig":"{\"apple\":{\"countryCode\":\"US\"},\"google\":{\"countryCode\":\"US\"}}","stripeAutomaticTaxEnabled":false,"dataLayerName":"dataLayer","trackFormDataLayerEvents":true}})); 
                        </script><footer class="entry-footer container container--entry-content">
					<div class="entry-footer__inner">
								<form class="wp-block-newsletter-builder-signup-form" data-component="newsletter-builder-signup">
		<div class="wp-block-newsletter-builder-signup-form__header container container--entry-content">
			
			<div>
				<h2>Sign Up to Breaking News.</h2>
				<div class="wp-block-newsletter-builder-signup-form__subheader">Daily updates of the most vital industry news in Hollywood.</div>
			</div>
			<div>
				<label for="newsletter-builder-email-67">
					Email <span>(required)</span>					<input type="email" id="newsletter-builder-email-67" name="newsletter-builder-email" placeholder="Enter your email address" class="wp-block-newsletter-builder-signup-form__email-input">
				</label>
				<div class="wp-block-newsletter-builder-signup-form__disclaimer">
					By clicking Sign Up, you agree to receive emails from TheWrap. You can unsubscribe at any time				</div>

				<div class="g-recaptcha" data-sitekey="6LfrehcpAAAAAL6o0kJfxk5Fr4WhO3ktYWPR7-u1">
				</div>

				<div class="wp-block-button is-style-subscribe">
					<button class="wp-block-button__link wp-element-button">
						Sign Up Now					</button>
				</div>

				<div class="wp-block-newsletter-builder-signup-form__response"></div>
			</div>
		</div>
		<input type="hidden" name="newsletter-builder-hidden" value="c7c9ca930e16890adfeefcdc9930a542">	</form>
	
						
					</div>
				</footer>

				<div class="wp-block-the-wrap-connatix--below-article wp-block-the-wrap-connatix">
	<div id="the-wrapconnatix68" class="wp-block-the-wrap-connatix__player-container" data-matchmedia="(max-width: 767px)" data-scrolldepth="500" data-initialized="true">
	</div>
</div>


				
			</div>

			<aside class="sidebar-area wp-block-template-part"><div class="yad-dsk-box-ad-a wp-block-the-wrap-ad"></div>
	
	<div class="yad-mob-box-ad-d wp-block-the-wrap-ad"></div>


	
		
				
					<div class="wp-block-the-wrap-connatix--right-rail wp-block-the-wrap-connatix">
	<div id="the-wrapconnatix69" class="wp-block-the-wrap-connatix__player-container" data-matchmedia="(min-width: 768px)" data-scrolldepth="500" data-initialized="true">
	</div>
</div>

				
		
	



	
		
	


<div class="wp-block-the-wrap-taboola">
	<div id="taboola-right-rail-thumbnails"></div>
	<script>
		if (window.matchMedia("(min-width: 768px)").matches) {
			if (!Array.isArray(window._taboola)) {
				window._taboola = [];
				window._taboola.push({"article":"auto","url":"https://www.thewrap.com/juliet-broadway-review-max-martin-jukebox-musical/"});
			}
			window._taboola.push({"mode":"alternating-thumbnails-r","container":"taboola-right-rail-thumbnails","placement":"Right Rail Thumbnails","target_type":"mix"});
		}
	</script>
</div>


<div class="yad-dsk-box-ad-b wp-block-the-wrap-ad"></div>
</aside>
		</div>

		<aside class="container container--site">
	<div data-hx-trigger="revealed" data-hx-get="https://www.thewrap.com/dispatch/lazy-render-block/" data-hx-swap="outerHTML" data-hx-vals="{&quot;jwt&quot;:&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJibGsiOiI8IS0tIHdwOnRoZS13cmFwL3F1ZXJ5IHtcIm5hbWVcIjpcImFydGljbGUtdHJlbmRpbmdcIn0gLS0-XG5cdFx0PCEtLSB3cDp0aGUtd3JhcC9zZWN0aW9uLWhlYWRpbmcge1wiY2xhc3NOYW1lXCI6XCJpcy1zdHlsZS1taW5pbWFsLXRvLWJsb2NrXCJ9IC0tPlxuXHRcdFx0PCEtLSB3cDp0aGUtd3JhcC9xdWVyeS1oZWFkaW5nIC8tLT5cblx0XHQ8IS0tIC93cDp0aGUtd3JhcC9zZWN0aW9uLWhlYWRpbmcgLS0-XG5cblx0XHQ8IS0tIHdwOnBvc3QtdGVtcGxhdGUge1wiY2xhc3NOYW1lXCI6XCJ3cC1ibG9jay1wb3N0LXRlbXBsYXRlXFx1MDAyZFxcdTAwMmRncmlkLTQtY29sXCJ9IC0tPlxuXHRcdFx0PGRpdiBjbGFzcz1cInBvc3QtaXRlbS0tZm91ci1hY3Jvc3NcIj5cblx0XHRcdFx0PCEtLSB3cDpwb3N0LXRpdGxlIHtcImlzTGlua1wiOnRydWUsXCJsZXZlbFwiOjN9IC8tLT5cblxuXHRcdFx0XHQ8IS0tIHdwOnRlbXBsYXRlLXBhcnQge1wic2x1Z1wiOlwicG9zdC1pdGVtLW1ldGFcIixcImNsYXNzTmFtZVwiOlwicG9zdC10ZW1wbGF0ZV9fbWV0YS13cmFwcGVyXCIsXCJ0aGVtZVwiOlwidGhlLXdyYXBcIn0gLy0tPlxuXG5cdFx0XHRcdDwhLS0gd3A6dGVtcGxhdGUtcGFydCB7XCJzbHVnXCI6XCJwb3N0LWl0ZW0tZXllYnJvd1wiLFwiY2xhc3NOYW1lXCI6XCJwb3N0LWl0ZW1fX2V5ZWJyb3ctd3JhcHBlclwiLFwidGhlbWVcIjpcInRoZS13cmFwXCJ9IC8tLT5cblxuXHRcdFx0XHQ8IS0tIHdwOnBvc3QtZmVhdHVyZWQtaW1hZ2Uge1wiaXNMaW5rXCI6dHJ1ZSxcInNpemVTbHVnXCI6XCJ0aGUtd3JhcC10aGVtZS0zMjB4MTgwLWNjXCJ9IC0tPlxuXHRcdFx0XHRcdDwhLS0gd3A6dGhlLXdyYXAvcHJvLWJhZGdlIHtcImNsYXNzTmFtZVwiOlwiaGFzLWltYWdlLXBsYWNlbWVudFwifSAvLS0-XG5cdFx0XHRcdDwhLS0gL3dwOnBvc3QtZmVhdHVyZWQtaW1hZ2UgLS0-XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8IS0tIC93cDpwb3N0LXRlbXBsYXRlIC0tPlxuXHQ8IS0tIC93cDp0aGUtd3JhcC9xdWVyeSAtLT4iLCJjdHgiOnsicG9zdElkIjo3MTcyMTU0fX0.bV9Mn6dgY-uDkD0GXsiVHsns_is7vzFMLD-ot56DqeM&quot;}" data-hx-select=".lazy-render-response" class="lazy-render-placeholder" aria-hidden="true">
	<div class="lazy-render-placeholder__the-wrap-query"><div class="lazy-render-placeholder__the-wrap-section-heading"><div class="lazy-render-placeholder__the-wrap-query-heading"></div></div><div class="lazy-render-placeholder__core-post-template"><ul role="list"><li><div class="lazy-render-placeholder__core-post-title"></div><div class="lazy-render-placeholder__core-template-part"></div><div class="lazy-render-placeholder__core-template-part"></div><div class="lazy-render-placeholder__core-post-featured-image"><div class="lazy-render-placeholder__the-wrap-pro-badge"></div></div></li><li><div class="lazy-render-placeholder__core-post-title"></div><div class="lazy-render-placeholder__core-template-part"></div><div class="lazy-render-placeholder__core-template-part"></div><div class="lazy-render-placeholder__core-post-featured-image"><div class="lazy-render-placeholder__the-wrap-pro-badge"></div></div></li><li><div class="lazy-render-placeholder__core-post-title"></div><div class="lazy-render-placeholder__core-template-part"></div><div class="lazy-render-placeholder__core-template-part"></div><div class="lazy-render-placeholder__core-post-featured-image"><div class="lazy-render-placeholder__the-wrap-pro-badge"></div></div></li><li><div class="lazy-render-placeholder__core-post-title"></div><div class="lazy-render-placeholder__core-template-part"></div><div class="lazy-render-placeholder__core-template-part"></div><div class="lazy-render-placeholder__core-post-featured-image"><div class="lazy-render-placeholder__the-wrap-pro-badge"></div></div></li></ul></div></div>
</div>
</aside>

		<div class="container container--content has-global-padding">
	
	<h2 class="wp-block-heading screen-reader-text">Comments</h2>
	

	
</div>
	</div>

	<div class="container container--entry-content container--taboola has-global-padding wp-block-the-wrap-taboola">
	<div id="taboola-below-article-thumbnails"></div>
	<script>
		if (window.matchMedia("(min-width: 0px)").matches) {
			if (!Array.isArray(window._taboola)) {
				window._taboola = [];
				window._taboola.push({"article":"auto","url":"https://www.thewrap.com/juliet-broadway-review-max-martin-jukebox-musical/"});
			}
			window._taboola.push({"mode":"thumbnails-a","container":"taboola-below-article-thumbnails","placement":"Below Article Thumbnails","target_type":"mix"});
		}
	</script>
</div>

</article>

</main>
		</div><!-- #primary -->
	</div><!-- #content -->

	<footer id="colophon" class="site-footer container container--site" data-component="site-footer">
		<div class="site-footer__inner">
			<div class="site-footer__cover wp-block-the-wrap-footer-image">
		<h2 class="screen-reader-only">Latest Magazine Issue</h2>
	
		<a href="https://view.flipdocs.com/?ID=10004691_483412">
	
	<img width="240" height="300" src="https://i0.wp.com/www.thewrap.com/wp-content/uploads/2025/12/121125_COVER-_IR_5x4a.jpg?fit=240%2C300&amp;quality=89&amp;ssl=1" class="attachment-medium size-medium" alt="View magazine issue" decoding="async" loading="lazy" srcset="https://i0.wp.com/www.thewrap.com/wp-content/uploads/2025/12/121125_COVER-_IR_5x4a.jpg?w=1200&amp;quality=89&amp;ssl=1 1200w, https://i0.wp.com/www.thewrap.com/wp-content/uploads/2025/12/121125_COVER-_IR_5x4a.jpg?resize=240%2C300&amp;quality=89&amp;ssl=1 240w, https://i0.wp.com/www.thewrap.com/wp-content/uploads/2025/12/121125_COVER-_IR_5x4a.jpg?resize=819%2C1024&amp;quality=89&amp;ssl=1 819w, https://i0.wp.com/www.thewrap.com/wp-content/uploads/2025/12/121125_COVER-_IR_5x4a.jpg?resize=768%2C960&amp;quality=89&amp;ssl=1 768w, https://i0.wp.com/www.thewrap.com/wp-content/uploads/2025/12/121125_COVER-_IR_5x4a.jpg?resize=990%2C1238&amp;quality=89&amp;ssl=1 990w" sizes="auto, (max-width: 240px) 100vw, 240px" data-portal-copyright="TheWrap" data-has-syndication-rights="1">
		</a>
	</div>

			<div class="site-footer__menus">
				<nav aria-label="TheWrap" class="site-footer__navigation wp-block-the-wrap-footer-menu">
	<h2 id="footer1-nav-heading" class="footer-menu__heading">
		<button id="footer1-nav-toggle" aria-controls="footer1-nav-container" class="footer-menu__toggle">
			TheWrap							<span class="footer-menu__toggle-icon">
					<svg aria-hidden="true" focusable="false" width="14" height="9"><use href="#am-symbol-chevron-down"></use></svg>				</span>
					</button>
	</h2>

	<div id="footer1-nav-container" role="region" class="footer-menu__menu">
		<ul role="list" id="menu-thewrap" class="footer1-menu"><li id="menu-item-5725563" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-5725563 menu__item footer1-menu__item"><a href="https://www.thewrap.com/about-us/" id="menu-link-70" class="menu__link footer1-menu__link">About Us</a></li>
<li id="menu-item-5725564" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-5725564 menu__item footer1-menu__item"><a href="https://www.thewrap.com/advertise-us/" id="menu-link-71" class="menu__link footer1-menu__link">Advertise</a></li>
<li id="menu-item-5725565" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-5725565 menu__item footer1-menu__item"><a href="https://www.thewrap.com/contact/" id="menu-link-72" class="menu__link footer1-menu__link">Contact</a></li>
<li id="menu-item-5725566" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-5725566 menu__item footer1-menu__item"><a href="https://www.thewrap.com/jobs/" id="menu-link-73" class="menu__link footer1-menu__link">Careers</a></li>
<li id="menu-item-5725567" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-5725567 menu__item footer1-menu__item"><a href="https://www.thewrap.com/masthead/" id="menu-link-74" class="menu__link footer1-menu__link">Masthead</a></li>
<li id="menu-item-5786172" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-5786172 menu__item footer1-menu__item"><a href="https://www.thewrap.com/newsletters/" id="menu-link-75" class="menu__link footer1-menu__link">Newsletters</a></li>
<li id="menu-item-7551824" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-7551824 menu__item footer1-menu__item"><a href="https://www.thewrap.com/the-wrapbook-art-of-cinema-issue-3/" id="menu-link-76" class="menu__link footer1-menu__link">WrapBook</a></li>
</ul>	</div>
</nav>

				<nav aria-label="Wrap Pro" class="site-footer__navigation wp-block-the-wrap-footer-menu">
	<h2 id="footer2-nav-heading" class="footer-menu__heading">
		<button id="footer2-nav-toggle" aria-controls="footer2-nav-container" class="footer-menu__toggle">
			Wrap Pro							<span class="footer-menu__toggle-icon">
					<svg aria-hidden="true" focusable="false" width="14" height="9"><use href="#am-symbol-chevron-down"></use></svg>				</span>
					</button>
	</h2>

	<div id="footer2-nav-container" role="region" class="footer-menu__menu">
		<ul role="list" id="menu-wrap-pro" class="footer2-menu"><li id="menu-item-7386589" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-7386589 menu__item footer2-menu__item"><a href="https://www.thewrap.com/join-pro/" id="menu-link-77" class="menu__link footer2-menu__link">Subscribe</a></li>
<li id="menu-item-5725572" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-5725572 menu__item footer2-menu__item"><a href="https://www.thewrap.com/join-pro/" id="menu-link-78" class="menu__link footer2-menu__link">Team Plan</a></li>
<li id="menu-item-5725573" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-5725573 menu__item footer2-menu__item"><a href="https://www.thewrap.com/join-pro/" title="Learn more about becoming a member" id="menu-link-79" class="menu__link footer2-menu__link">Learn More</a></li>
</ul>	</div>
</nav>

				<nav aria-label="Legal" class="site-footer__navigation wp-block-the-wrap-footer-menu">
	<h2 id="footer3-nav-heading" class="footer-menu__heading">
		<button id="footer3-nav-toggle" aria-controls="footer3-nav-container" class="footer-menu__toggle">
			Legal							<span class="footer-menu__toggle-icon">
					<svg aria-hidden="true" focusable="false" width="14" height="9"><use href="#am-symbol-chevron-down"></use></svg>				</span>
					</button>
	</h2>

	<div id="footer3-nav-container" role="region" class="footer-menu__menu">
		<ul role="list" id="menu-legal" class="footer3-menu"><li id="menu-item-5725577" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-5725577 menu__item footer3-menu__item"><a href="https://www.thewrap.com/terms-of-service-wrappro/" id="menu-link-80" class="menu__link footer3-menu__link">Terms of Service</a></li>
<li id="menu-item-5725578" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-5725578 menu__item footer3-menu__item"><a href="https://www.thewrap.com/privacy-policy/" id="menu-link-81" class="menu__link footer3-menu__link">Privacy Policy</a></li>
<li id="menu-item-5725579" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-5725579 menu__item footer3-menu__item"><a href="https://youradchoices.com/" id="menu-link-82" class="menu__link footer3-menu__link">AdChoices</a></li>
</ul>	</div>
</nav>

				<nav aria-label="Wrap Magazine" class="site-footer__navigation wp-block-the-wrap-footer-menu">
	<h2 id="footer4-nav-heading" class="footer-menu__heading">
		<button id="footer4-nav-toggle" aria-controls="footer4-nav-container" class="footer-menu__toggle">
			Wrap Magazine							<span class="footer-menu__toggle-icon">
					<svg aria-hidden="true" focusable="false" width="14" height="9"><use href="#am-symbol-chevron-down"></use></svg>				</span>
					</button>
	</h2>

	<div id="footer4-nav-container" role="region" class="footer-menu__menu">
		<ul role="list" id="menu-wrap-magazine" class="footer4-menu"><li id="menu-item-5778611" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-5778611 menu__item footer4-menu__item"><a href="https://www.thewrap.com/canneswrap-magazines/" id="menu-link-83" class="menu__link footer4-menu__link">Cannes</a></li>
<li id="menu-item-5778612" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-5778612 menu__item footer4-menu__item"><a href="https://www.thewrap.com/collegewrap-magazines/" id="menu-link-84" class="menu__link footer4-menu__link">College</a></li>
<li id="menu-item-5778613" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-5778613 menu__item footer4-menu__item"><a href="https://www.thewrap.com/emmywrap-magazines/" id="menu-link-85" class="menu__link footer4-menu__link">Emmys</a></li>
<li id="menu-item-5778614" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-5778614 menu__item footer4-menu__item"><a href="https://www.thewrap.com/oscarwrap/" id="menu-link-86" class="menu__link footer4-menu__link">Oscars</a></li>
<li id="menu-item-5725575" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-5725575 menu__item footer4-menu__item"><a href="https://www.thewrap.com/advertise-us/" id="menu-link-87" class="menu__link footer4-menu__link">Advertise With Us</a></li>
</ul>	</div>
</nav>

			</div>
			<div class="site-footer__social-profiles wp-block-template-part"><nav id="socials-navigation" aria-label="Social Media" class="social-profiles">
	<h2 class="screen-reader-text">Follow Us</h2>

	<ul role="list" class="social-profiles__social-accounts">
		<li><a href="https://www.facebook.com/thewrap" class="wp-block-the-wrap-social-profile">
	<span class="screen-reader-text">Visit The Wrap on facebook</span>
	<svg aria-hidden="true" focusable="false" width="18.42" height="32"><use href="#am-symbol-facebook"></use></svg></a>
</li>
		<li><a href="https://www.twitter.com/thewrap" class="wp-block-the-wrap-social-profile">
	<span class="screen-reader-text">Visit The Wrap on twitter</span>
	<svg aria-hidden="true" focusable="false" width="29.62" height="25"><use href="#am-symbol-twitter"></use></svg></a>
</li>
		<li><a href="https://www.instagram.com/thewrap" class="wp-block-the-wrap-social-profile">
	<span class="screen-reader-text">Visit The Wrap on instagram</span>
	<svg aria-hidden="true" focusable="false" width="31.03" height="32"><use href="#am-symbol-instagram"></use></svg></a>
</li>
		<li><a href="https://www.youtube.com/thewrap" class="wp-block-the-wrap-social-profile">
	<span class="screen-reader-text">Visit The Wrap on youtube</span>
	<svg aria-hidden="true" focusable="false" width="32" height="23"><use href="#am-symbol-youtube"></use></svg></a>
</li>
	</ul>
</nav>
</div>
		</div>
		<div class="site-footer__copyright wp-block-the-wrap-copyright">
	© Copyright 2026 TheWrap</div>

	</footer>
</div><!-- #page -->


	
		
			

			
					<div class="yad-mob-banner-ad-a wp-block-the-wrap-ad"></div>
</div>
<script type="speculationrules">
{"prefetch":[{"source":"document","where":{"and":[{"href_matches":"\/*"},{"not":{"href_matches":["\/wp-*.php","\/wp-admin\/*","\/wp-content\/uploads\/*","\/wp-content\/*","\/wp-content\/plugins\/*","\/wp-content\/themes\/the-wrap\/*","\/*\\?(.+)"]}},{"not":{"selector_matches":"a[rel~=\"nofollow\"]"}},{"not":{"selector_matches":".no-prefetch, .no-prefetch a"}}]},"eagerness":"conservative"}]}
</script>
<script src="https://www.google.com/recaptcha/api.js?ver=6.8" id="recaptcha-js" async="" data-wp-strategy="async"></script>
<script src="https://www.thewrap.com/wp-content/plugins/the-wrap/build/taboola-loader/index.js?ver=6e3bf6b1e0103986e25d" id="the-wrap-taboola-loader-js"></script>
<script id="wp-block-template-skip-link-js-after">
	( function() {
		var skipLinkTarget = document.querySelector( 'main' ),
			sibling,
			skipLinkTargetID,
			skipLink;

		// Early exit if a skip-link target can't be located.
		if ( ! skipLinkTarget ) {
			return;
		}

		/*
		 * Get the site wrapper.
		 * The skip-link will be injected in the beginning of it.
		 */
		sibling = document.querySelector( '.wp-site-blocks' );

		// Early exit if the root element was not found.
		if ( ! sibling ) {
			return;
		}

		// Get the skip-link target's ID, and generate one if it doesn't exist.
		skipLinkTargetID = skipLinkTarget.id;
		if ( ! skipLinkTargetID ) {
			skipLinkTargetID = 'wp--skip-link--target';
			skipLinkTarget.id = skipLinkTargetID;
		}

		// Create the skip link.
		skipLink = document.createElement( 'a' );
		skipLink.classList.add( 'skip-link', 'screen-reader-text' );
		skipLink.id = 'wp-skip-link';
		skipLink.href = '#' + skipLinkTargetID;
		skipLink.innerText = 'Skip to content';

		// Inject the skip link.
		sibling.parentElement.insertBefore( skipLink, sibling );
	}() );
	
</script>
<script src="https://www.thewrap.com/wp-includes/js/dist/hooks.min.js?ver=4d63a3d491d11ffd8ac6" id="wp-hooks-js"></script>
<script src="https://www.thewrap.com/wp-includes/js/dist/i18n.min.js?ver=5e580eb46a90c2b997e6" id="wp-i18n-js"></script>
<script id="wp-i18n-js-after">
wp.i18n.setLocaleData( { 'text direction\u0004ltr': [ 'ltr' ] } );
</script>
<script src="https://www.thewrap.com/wp-includes/js/dist/vendor/wp-polyfill.min.js?ver=3.15.0" id="wp-polyfill-js"></script>
<script src="https://www.thewrap.com/wp-includes/js/dist/url.min.js?ver=6bf93e90403a1eec6501" id="wp-url-js"></script>
<script src="https://www.thewrap.com/wp-includes/js/dist/api-fetch.min.js?ver=3623a576c78df404ff20" id="wp-api-fetch-js"></script>
<script id="wp-api-fetch-js-after">
wp.apiFetch.use( wp.apiFetch.createRootURLMiddleware( "https://www.thewrap.com/wp-json/" ) );
wp.apiFetch.nonceMiddleware = wp.apiFetch.createNonceMiddleware( "b3b5f80261" );
wp.apiFetch.use( wp.apiFetch.nonceMiddleware );
wp.apiFetch.use( wp.apiFetch.mediaUploadMiddleware );
wp.apiFetch.nonceEndpoint = "https://www.thewrap.com/wp-admin/admin-ajax.php?action=rest-nonce";
</script>
<script src="https://www.thewrap.com/wp-content/plugins/the-wrap/build/global/index.js?ver=d765a5530a1044a5c897" id="the-wrap-plugin-global-js-js"></script>
<script src="https://cdn.sophi.io/assets/demeter/1/stable/3599730833.js?ver=1.0" id="the-wrap-sophi-js" data-wp-strategy="async"></script>
<script id="the-wrap-sophi-js-after">
			// Determine session type based on existing cookies.
			let thewrap_user_session_type = "anonymous";
			if (
				document.cookie.split("; ").find((row) => row.startsWith("thewrap_registered_user"))?.split("=")[1] === "true"
				|| typeof document.cookie.split("; ").find((row) => row.startsWith("blaize_prev_anon_session")) !== "undefined"
				) {
				thewrap_user_session_type = "registered";
			}

			// Establish a container for decision data.
			let thewrap_sophi_decision_data = {};

			demeter("getDecision", {
				args: { visitor: thewrap_user_session_type },
				onSuccess: (sophiDecision) => {
					if (typeof sophiDecision.outcome.wallVisibility === "string" && sophiDecision.outcome.wallVisibility === "never") {
						thewrap_sophi_decision_data = {
							wallVisibility: "never",
							wallType: "none"
						}
					} else if (typeof sophiDecision.outcome.wallVisibility === "string" && typeof sophiDecision.outcome.wallType === "string") {
						thewrap_sophi_decision_data = {
							wallVisibility: sophiDecision.outcome.wallVisibility,
							wallType: sophiDecision.outcome.wallType
						}
					}
					if (typeof sophiDecision.experiment.experimentId === "string" && typeof sophiDecision.experiment.assignedGroup === "string") {
						thewrap_sophi_decision_data.sophiExperiment = sophiDecision.experiment.experimentId;
						thewrap_sophi_decision_data.sophiGroup      = sophiDecision.experiment.assignedGroup;
					}
				},
				onError: (error) => {
					console.error("Sophi Error:", error);
				}
			});
			
</script>
<script src="https://www.thewrap.com/wp-content/themes/the-wrap/client/build/js/global.bundle.min.js?ver=19e008cf102573392fd2" id="the-wrap-global-js"></script>
<script src="https://www.thewrap.com/wp-content/themes/the-wrap/client/build/js/article.bundle.min.js?ver=abd8678a08ecee2de838" id="the-wrap-article-js"></script>


<iframe marginwidth="0" marginheight="0" scrolling="no" frameborder="0" id="1c68d0ce1a84e6" width="0" height="0" src="about:blank" name="__pb_locator__" style="display: none; height: 0px; width: 0px; border: 0px;"></iframe><iframe name="__uspapiLocator" style="display: none;"></iframe><img width="0" height="0" src="//ams-pageview-public.s3.amazonaws.com/1x1-pixel.png?id=d8d824b66aa3" alt="." style="height: 0px; width: 0px; border: 0px; display: none;"><script class="ntv-script" type="text/javascript">ntv.Util.appendImage('https://ads.us.e-planning.net/uspd/1/c3fd10e01305b693?ruidm=1&du=https%3A%2F%2Fjadserve.postrelease.com%2Fsuid%2F102014%2F%3Fvk%3D%24UID%0A',0);ntv.Util.appendImage('https://sync.inmobi.com/oRTB?gdpr_consent=null&gdpr=0&redirect=https%3A%2F%2Fjadserve.postrelease.com%2Fdmp%2F102000%3Fvk%3D%7BID5UID%7D%26gdpr_consent%3Dnull%26gdpr%3D0',0);ntv.Util.appendImage('https://match.adsrvr.org/track/cmf/generic?ttd_pid=qg0stl0&ttd_tpi=1&gdpr=0&gdpr_consent=null',0);ntv.Util.appendImage('https://pixel-sync.sitescout.com/dmp/pixelSync?nid=106&gdpr=0&gdpr_consent=null&us_privacy=1---',0);ntv.Util.appendImage('https://x.bidswitch.net/sync?ssp=nativo&gdpr=0&gdpr_consent=null&us_privacy=1---&user_id=fb7e0cad-a32d-4aba-8756-e9565ac5388e&expires=365',0);ntv.Util.appendImage('https://image8.pubmatic.com/AdServer/ImgSync?p=156500&gdpr=%7bGDPR_APPLIES_MACRO%7d&gdpr_consent=%7bGDPR_CONSENT_MACRO%7d&pu=https%3A%2F%2Fimage4.pubmatic.com%2FAdServer%2FSPug%3Fp%3D156500%26pmc%3DPM_PMC%26pr%3Dhttps%253A%252F%252Fjadserve.postrelease.com%252Fsuid%252F1043%253Fvk%253D%2523PMUID',0);ntv.Util.appendImage('https://ib.adnxs.com/setuid?entity=16383&code=fb7e0cad-a32d-4aba-8756-e9565ac5388e&gdpr=0&gdpr_consent=null',0);ntv.Util.appendImage('https://ib.adnxs.com/getuid?https://jadserve.postrelease.com/suid/1019?vk=$UID',0);ntv.Util.appendImage('https://bttrack.com/pixel/cookiesync?source=3b452dcb-0cd7-47c7-b4d7-167ed732230d&secure=1&gdpr=0/gdpr_consent=',0);</script><script class="ntv-script" type="text/javascript">prdom.query('body').append('<iframe src="https://cs-server-s2s.yellowblue.io/sync-iframe?gdpr=0&gdpr_consent=null&us_privacy=1---&gpp={GPP}&gpp_sid=&redirect=https%3A%2F%2Fjadserve.postrelease.com%2Fsuid%2F102017%3Fvk%3D%7BpartnerId%7D" style="height:0 !important; width:0 !important; visibility:hidden; display:none"></iframe>');</script><script type="text/javascript">ntv.PostRelease.trackFirstPartyCookie('fb7e0cad-a32d-4aba-8756-e9565ac5388e');</script><iframe src="https://cs-server-s2s.yellowblue.io/sync-iframe?gdpr=0&amp;gdpr_consent=null&amp;us_privacy=1---&amp;gpp={GPP}&amp;gpp_sid=&amp;redirect=https%3A%2F%2Fjadserve.postrelease.com%2Fsuid%2F102017%3Fvk%3D%7BpartnerId%7D" style="height:0 !important; width:0 !important; visibility:hidden; display:none"></iframe><img src="https://sync.intentiq.com/profiles_engine/ProfilesEngineServlet?at=20&amp;mi=10&amp;secure=1&amp;dpi=456059511&amp;iiqidtype=2&amp;iiqpcid=6a348c7a-1e21-4de9-b319-85b98b33665c&amp;iiqpciddate=1770020809064&amp;tsrnd=139_1770020809064&amp;vrref=&amp;jsver=5.082" width="1" height="1"><div><script src="//cd.connatix.com/connatix.player.js?cid=8759484e-bb96-415e-9d33-167af5d155f0" async="1" type="text/javascript"></script><script src="//cds.connatix.com/p/153045906/elLoader.js" async="1" type="text/javascript"></script><script src="//cds.connatix.com/p/153045906/connatix.player.js?cid=8759484e-bb96-415e-9d33-167af5d155f0" crossorigin="anonymous" async="1" type="text/javascript"></script></div><div></div><div></div><div><img src="https://sync.1rx.io/usersync2/rmpssp?gdpr=0&amp;gdpr_consent=&amp;sub=typeaholdings" style="display:none;"><img src="https://ssc-cms.33across.com/ps/?ri=0015a00002hdV5tAAE&amp;ru=https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D11580%26puid%3D33XUSERID33X" style="display:none;"><img src="https://us-u.openx.net/w/1.0/cm?gdpr=0&amp;gdpr_consent=&amp;id=58ceaaf5-c766-4c17-869a-d76e43401714&amp;r=https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D11563%26id%3D" style="display:none;"><img src="https://x.bidswitch.net/check_uuid/https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Faid%3D11603%26gdpr%3D%5BGDPR%5D%26gdpr_consent%3D%5BUSER_CONSENT%5D%26uid%3D$%7BBSW_UUID%7D" style="display:none;"><iframe src="https://secure-assets.rubiconproject.com/utils/xapi/multi-sync.html?endpoint=us-east&amp;p=rise_engage" style="display:none;"></iframe><img src="https://rtb.mfadsrvr.com/sync?gdpr=0&amp;gdpr_consent=&amp;redir=https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D11611%26uid%3D%24%7BUUID%7D&amp;ssp=rise" style="display:none;"><img src="https://cs.admanmedia.com/77bb8e39d66271fda1db01d45766b9d9.gif?puid=%5BUID%5D&amp;redir=https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D11559%26id%3D%5BUID%5D%26gdpr%3D%5BGDPR%5D%26gdpr_consent%3D%5BUSER_CONSENT%5D" style="display:none;"><iframe src="https://ap.lijit.com/pixel?gdpr=0&amp;gdpr_consent=&amp;redir=https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D11607%26uid%3D%24UID" style="display:none;"></iframe><img src="https://eb2.3lift.com/getuid?cmp_cs=&amp;gdpr=0&amp;redir=https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D11602%26rid%3D-UNuOlrckp_s%26id%3D%24UID" style="display:none;"><iframe src="https://cpm.vistarsagency.com/user-sync?pub_point=253416&amp;r=https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D11619%26id%3D%26gdpr%3D%5BGDPR%5D%26gdpr_consent%3D%5BUSER_CONSENT%5D" style="display:none;"></iframe><iframe src="https://measureadv.com/userIframe?gdpr=0&amp;gdpr_consent=&amp;p=2&amp;redirect=https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D11586%26id%3D%7BUID%7D&amp;usp_consent=1---" style="display:none;"></iframe><img src="https://secure.adnxs.com/getuid?https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D11596%26id%3D%24UID&amp;gdpr=0&amp;gdpr_consent=" style="display:none;"><img src="https://image8.pubmatic.com/AdServer/ImgSync?gdpr=0&amp;gdpr=0&amp;gdpr_consent=&amp;gdpr_consent=&amp;p=160295&amp;pu=https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D11576%26id%3D%23PMUID" style="display:none;"><img src="https://creativecdn.com/cm-notify?pi=rise" style="display:none;"><img src="https://cm.adform.net/cookie?redirect_url=https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D11606%26gdpr%3D%5BGDPR%5D%26gdpr_consent%3D%5BUSER_CONSENT%5D%26uid%3D%24UID" style="display:none;"><img src="https://bh.contextweb.com/bh/rtset?ev=1&amp;gdpr=0&amp;gdpr_consent=&amp;pid=562615&amp;rurl=https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D11592%26uid%3D%25%25VGUID%25%25&amp;us_privacy=1---" style="display:none;"><img src="https://user-sync.fwmrm.net/ad/u?cr=https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D11601%26id%3D%23%7Buser.id%7D&amp;mode=echo" style="display:none;"><img src="https://prebid-match.dotomi.com/match/bounce/current?gdpr=0&amp;gdpr_consent=&amp;networkId=72582&amp;rurl=https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D11617%26uid%3D&amp;us_privacy=1---&amp;version=1" style="display:none;"><iframe src="https://onetag-sys.com/usync/?gdpr=0&amp;gdpr_consent=&amp;redir=https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D11581%26uid%3D%24%7BUSER_TOKEN%7D&amp;us_privacy=1---" style="display:none;"></iframe><img src="https://sync.go.sonobi.com/us?consent_string=&amp;gdpr=0&amp;loc=https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D115667%26uid%3D%5BUID%5D" style="display:none;"><img src="https://ssp-sync.criteo.com/user-sync/redirect?gdpr=0&amp;gdpr_consent=&amp;profile=342&amp;redir=https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D11614%26id%3D%24%7BCRITEO_USER_ID%7D" style="display:none;"><img src="https://ads.yieldmo.com/pbsync?gdpr=0&amp;gdpr_consent=&amp;is=rise&amp;redirectUri=https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D11584%26uid%3D%24UID&amp;us_privacy=" style="display:none;"><img src="https://csync.loopme.me/?gdpr=0&amp;gdpr_consent=&amp;pubid=11362&amp;redirect=https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D11571%26id%3D%7Bdevice_id%7D" style="display:none;"><img src="https://jadserve.postrelease.com/suid/102050?gdpr=0&amp;gdpr_consent=&amp;ntv_r=https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D11618%26id%3DNTV_USER_ID" style="display:none;"><img src="https://ssbsync-global.smartadserver.com/api/sync?callerId=5&amp;gdpr=0&amp;gdpr_consent=&amp;redirectUri=https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D11600%26uid%3D%5Bssb_sync_pid%5D&amp;us_privacy=1---" style="display:none;"><iframe src="https://rtb.gumgum.com/usync/16112?gdpr=0&amp;gdpr_consent=&amp;r=https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D11616%26id%3D" style="display:none;"></iframe><iframe src="https://ssp.disqus.com/redirectuser?gdpr=0&amp;gdpr_consent=%5BGDPR_CONSENT%5D&amp;gpp=%5BGPP%5D&amp;gpp_sid=%5BGPP_SID%5D&amp;r=https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D11612%26id%3D%24UID&amp;sid=716&amp;us_privacy=1---" style="display:none;"></iframe><img src="https://s.ad.smaato.net/c/?adExInit=rise&amp;gdpr=0&amp;gdpr_consent=&amp;redir=https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D11574%26id%3D%24UID" style="display:none;"><img src="https://hbx.media.net/cksync.php?bidder=medianet&amp;cs=1&amp;gdpr=0&amp;gdpr_consent=&amp;gpp=%5BGPP%5D&amp;gpp_sid=%5BGPP_SID%5D&amp;ovsid=%7B%7BAPID%7D%7D&amp;redirect=https%3A%2F%2Fcs-server-s2s.yellowblue.io%2Fcs%3Ffwrd%3D1%26aid%3D11585%26id%3D%3Cvsid%3E&amp;type=pbs&amp;us_privacy=1---" style="display:none;"><img src="https://match.sharethrough.com/universal/v1?gdpr=0&amp;gdpr_consent=&amp;supply_id=5926d422" style="display:none;"><img src="https://jadserve.postrelease.com/suid/102017?vk=-UNuOlrckp_s" style="display:none;"></div></body></html>