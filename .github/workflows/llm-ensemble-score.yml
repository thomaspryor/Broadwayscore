name: LLM Ensemble Score Reviews

on:
  # Manual trigger with options
  workflow_dispatch:
    inputs:
      show:
        description: 'Show slug to process (leave empty for all)'
        required: false
        default: ''
      limit:
        description: 'Max reviews to process (leave empty for no limit)'
        required: false
        default: ''
      run_calibration:
        description: 'Run calibration after scoring'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      run_validation:
        description: 'Run aggregator validation after scoring'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      dry_run:
        description: 'Dry run (no file changes)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      needs_rescore:
        description: 'Only rescore reviews flagged with needsRescore=true'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      outdated:
        description: 'Re-score reviews with promptVersion older than current PROMPT_VERSION'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      rescore:
        description: 'Re-score all reviews (even already scored ones)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      chain:
        description: 'Auto-trigger next batch if unscored reviews remain'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      remaining_batches:
        description: 'Max remaining batches for chaining (decrements each run)'
        required: false
        default: '0'
      shard:
        description: 'Shard index for parallel runs (0-based)'
        required: false
        default: ''
      total_shards:
        description: 'Total number of parallel shards'
        required: false
        default: ''

env:
  ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
  OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
  GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
  OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}

jobs:
  ensemble-score:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build CLI arguments
        id: build-args
        run: |
          ARGS="--ensemble"

          # Show filter
          if [ -n "${{ github.event.inputs.show }}" ]; then
            ARGS="$ARGS --show=${{ github.event.inputs.show }}"
          else
            ARGS="$ARGS --all"
          fi

          # Limit
          if [ -n "${{ github.event.inputs.limit }}" ]; then
            ARGS="$ARGS --limit=${{ github.event.inputs.limit }}"
          fi

          # Calibration
          if [ "${{ github.event.inputs.run_calibration }}" == "true" ]; then
            ARGS="$ARGS --calibrate"
          fi

          # Validation
          if [ "${{ github.event.inputs.run_validation }}" == "true" ]; then
            ARGS="$ARGS --validate"
          fi

          # Dry run
          if [ "${{ github.event.inputs.dry_run }}" == "true" ]; then
            ARGS="$ARGS --dry-run"
          fi

          # Needs rescore (only reviews flagged for rescoring)
          if [ "${{ github.event.inputs.needs_rescore }}" == "true" ]; then
            ARGS="$ARGS --needs-rescore"
          fi

          # Outdated (rescore reviews with old prompt versions)
          if [ "${{ github.event.inputs.outdated }}" == "true" ]; then
            ARGS="$ARGS --outdated"
          fi

          # Rescore all (even already scored)
          if [ "${{ github.event.inputs.rescore }}" == "true" ]; then
            ARGS="$ARGS --rescore"
          fi

          # Sharding for parallel runs
          if [ -n "${{ github.event.inputs.shard }}" ] && [ -n "${{ github.event.inputs.total_shards }}" ]; then
            ARGS="$ARGS --shard=${{ github.event.inputs.shard }} --total-shards=${{ github.event.inputs.total_shards }}"
          fi

          # Always verbose in CI
          ARGS="$ARGS --verbose"

          echo "args=$ARGS" >> $GITHUB_OUTPUT

      - name: Configure git for checkpoints
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Run ensemble scoring pipeline
        run: |
          npx ts-node --project scripts/tsconfig.json scripts/llm-scoring/index.ts ${{ steps.build-args.outputs.args }}

      - name: Check for changes
        id: check-changes
        if: ${{ github.event.inputs.dry_run != 'true' }}
        run: |
          git add -A
          if git diff --staged --quiet; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            git diff --staged --stat
          fi

      - name: Check for large files
        if: ${{ steps.check-changes.outputs.has_changes == 'true' }}
        uses: ./.github/actions/check-file-sizes

      - name: Commit and push changes
        if: ${{ steps.check-changes.outputs.has_changes == 'true' }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Build commit message
          SHOW_MSG=""
          if [ -n "${{ github.event.inputs.show }}" ]; then
            SHOW_MSG=" for ${{ github.event.inputs.show }}"
          fi

          git commit -m "feat: Ensemble LLM score reviews${SHOW_MSG}

          Models: Claude Sonnet + GPT-4o + Gemini 2.0 Flash (v5)
          Triggered by: @${{ github.actor }}

          Co-Authored-By: Claude <noreply@anthropic.com>"

          # Robust push with retry and conflict resolution
          MAX_RETRIES=5
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Push attempt $i of $MAX_RETRIES..."

            # Fetch latest
            git fetch origin ${{ github.ref_name }}

            # Try rebase first
            if git rebase origin/${{ github.ref_name }}; then
              echo "Rebase successful"
            else
              echo "Rebase had conflicts, attempting auto-resolution..."
              # Resolve modify/delete conflicts: if remote deleted a file, accept the deletion
              # (the file was likely a cleaned-up duplicate; our score updates don't matter for it)
              CONFLICTED=$(git diff --name-only --diff-filter=U 2>/dev/null || true)
              if [ -n "$CONFLICTED" ]; then
                echo "Resolving conflicts by accepting deletions:"
                echo "$CONFLICTED"
                echo "$CONFLICTED" | while read -r f; do
                  git rm --force "$f" 2>/dev/null || git checkout --theirs "$f" && git add "$f" 2>/dev/null || true
                done
                if git rebase --continue 2>/dev/null; then
                  echo "Rebase completed after conflict resolution"
                else
                  echo "Rebase still failing, trying merge..."
                  git rebase --abort 2>/dev/null || true

                  # Reset to our commit and try merge
                  git reset --hard HEAD
                  git fetch origin ${{ github.ref_name }}
                  if git merge origin/${{ github.ref_name }} -X ours --no-edit 2>/dev/null; then
                    echo "Merge successful"
                  else
                    # Resolve any remaining modify/delete conflicts
                    MERGE_CONFLICTS=$(git diff --name-only --diff-filter=U 2>/dev/null || true)
                    if [ -n "$MERGE_CONFLICTS" ]; then
                      echo "Resolving merge conflicts:"
                      echo "$MERGE_CONFLICTS" | while read -r f; do
                        git rm --force "$f" 2>/dev/null || git checkout --theirs "$f" && git add "$f" 2>/dev/null || true
                      done
                      git commit --no-edit 2>/dev/null || true
                    else
                      echo "Merge failed with non-file conflicts, will retry..."
                      git merge --abort 2>/dev/null || true
                      sleep $((i * 2))
                      continue
                    fi
                  fi
                fi
              else
                echo "No conflicted files found, aborting rebase..."
                git rebase --abort 2>/dev/null || true
                sleep $((i * 2))
                continue
              fi
            fi

            # Try to push
            if git push origin HEAD:${{ github.ref_name }}; then
              echo "Push successful!"
              exit 0
            else
              echo "Push failed, will retry..."
              sleep $((i * 2))
            fi
          done

          echo "All push attempts failed"
          exit 1

      - name: Count remaining unscored reviews
        if: ${{ github.event.inputs.chain == 'true' && github.event.inputs.dry_run != 'true' }}
        id: count-remaining
        run: |
          # Count review files without llmScore (excluding invalid/wrongProduction)
          REMAINING=$(node -e "
            const fs = require('fs'), path = require('path');
            const base = 'data/review-texts';
            const dirs = fs.readdirSync(base).filter(d => { try { return fs.statSync(path.join(base,d)).isDirectory(); } catch(e) { return false; } });
            let n = 0;
            dirs.forEach(d => {
              fs.readdirSync(path.join(base,d)).filter(f => f.endsWith('.json') && f !== 'failed-fetches.json').forEach(f => {
                try {
                  const r = JSON.parse(fs.readFileSync(path.join(base,d,f),'utf8'));
                  if (!r.llmScore && !r.wrongShow && !r.wrongProduction && r.contentTier !== 'invalid') n++;
                } catch(e) {}
              });
            });
            console.log(n);
          ")
          echo "remaining=$REMAINING" >> $GITHUB_OUTPUT
          echo "Unscored reviews remaining: $REMAINING"

      - name: Chain next batch
        if: ${{ github.event.inputs.chain == 'true' && steps.count-remaining.outputs.remaining > 10 }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BATCHES_LEFT=${{ github.event.inputs.remaining_batches }}
          if [ "$BATCHES_LEFT" -le 0 ] 2>/dev/null; then
            echo "No remaining batches. Stopping chain."
            exit 0
          fi
          NEXT_BATCHES=$((BATCHES_LEFT - 1))
          LIMIT="${{ github.event.inputs.limit }}"
          LIMIT="${LIMIT:-400}"
          SHARD="${{ github.event.inputs.shard }}"
          TOTAL_SHARDS="${{ github.event.inputs.total_shards }}"
          echo "Triggering next batch (${NEXT_BATCHES} remaining after this)..."
          echo "Reviews still unscored: ${{ steps.count-remaining.outputs.remaining }}"

          CHAIN_ARGS="-f limit=$LIMIT -f chain=true -f remaining_batches=$NEXT_BATCHES -f run_calibration=false -f run_validation=false"
          if [ -n "$SHARD" ] && [ -n "$TOTAL_SHARDS" ]; then
            CHAIN_ARGS="$CHAIN_ARGS -f shard=$SHARD -f total_shards=$TOTAL_SHARDS"
          fi

          gh workflow run "LLM Ensemble Score Reviews" $CHAIN_ARGS
          echo "Next batch dispatched."
