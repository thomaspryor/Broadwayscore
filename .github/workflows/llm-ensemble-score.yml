name: LLM Ensemble Score Reviews

on:
  # Manual trigger with options
  workflow_dispatch:
    inputs:
      show:
        description: 'Show slug to process (leave empty for all)'
        required: false
        default: ''
      limit:
        description: 'Max reviews to process (leave empty for no limit)'
        required: false
        default: ''
      run_calibration:
        description: 'Run calibration after scoring'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      run_validation:
        description: 'Run aggregator validation after scoring'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      dry_run:
        description: 'Dry run (no file changes)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      needs_rescore:
        description: 'Only rescore reviews flagged with needsRescore=true'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      outdated:
        description: 'Re-score reviews with promptVersion older than current PROMPT_VERSION'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      rescore:
        description: 'Re-score all reviews (even already scored ones)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

env:
  ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
  OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
  GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}

jobs:
  ensemble-score:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build CLI arguments
        id: build-args
        run: |
          ARGS="--ensemble"

          # Show filter
          if [ -n "${{ github.event.inputs.show }}" ]; then
            ARGS="$ARGS --show=${{ github.event.inputs.show }}"
          else
            ARGS="$ARGS --all"
          fi

          # Limit
          if [ -n "${{ github.event.inputs.limit }}" ]; then
            ARGS="$ARGS --limit=${{ github.event.inputs.limit }}"
          fi

          # Calibration
          if [ "${{ github.event.inputs.run_calibration }}" == "true" ]; then
            ARGS="$ARGS --calibrate"
          fi

          # Validation
          if [ "${{ github.event.inputs.run_validation }}" == "true" ]; then
            ARGS="$ARGS --validate"
          fi

          # Dry run
          if [ "${{ github.event.inputs.dry_run }}" == "true" ]; then
            ARGS="$ARGS --dry-run"
          fi

          # Needs rescore (only reviews flagged for rescoring)
          if [ "${{ github.event.inputs.needs_rescore }}" == "true" ]; then
            ARGS="$ARGS --needs-rescore"
          fi

          # Outdated (rescore reviews with old prompt versions)
          if [ "${{ github.event.inputs.outdated }}" == "true" ]; then
            ARGS="$ARGS --outdated"
          fi

          # Rescore all (even already scored)
          if [ "${{ github.event.inputs.rescore }}" == "true" ]; then
            ARGS="$ARGS --rescore"
          fi

          # Always verbose in CI
          ARGS="$ARGS --verbose"

          echo "args=$ARGS" >> $GITHUB_OUTPUT

      - name: Run ensemble scoring pipeline
        run: |
          npx ts-node --project scripts/tsconfig.json scripts/llm-scoring/index.ts ${{ steps.build-args.outputs.args }}

      - name: Check for changes
        id: check-changes
        if: ${{ github.event.inputs.dry_run != 'true' }}
        run: |
          git add -A
          if git diff --staged --quiet; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            git diff --staged --stat
          fi

      - name: Commit and push changes
        if: ${{ steps.check-changes.outputs.has_changes == 'true' }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Build commit message
          SHOW_MSG=""
          if [ -n "${{ github.event.inputs.show }}" ]; then
            SHOW_MSG=" for ${{ github.event.inputs.show }}"
          fi

          git commit -m "feat: Ensemble LLM score reviews${SHOW_MSG}

          Models: Claude Sonnet + GPT-4o + Gemini 2.0 Flash (v5)
          Triggered by: @${{ github.actor }}

          Co-Authored-By: Claude <noreply@anthropic.com>"

          # Robust push with retry and conflict resolution
          MAX_RETRIES=5
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Push attempt $i of $MAX_RETRIES..."

            # Fetch latest
            git fetch origin ${{ github.ref_name }}

            # Try rebase first
            if git rebase origin/${{ github.ref_name }}; then
              echo "Rebase successful"
            else
              echo "Rebase had conflicts, attempting auto-resolution..."
              # Resolve modify/delete conflicts: if remote deleted a file, accept the deletion
              # (the file was likely a cleaned-up duplicate; our score updates don't matter for it)
              CONFLICTED=$(git diff --name-only --diff-filter=U 2>/dev/null || true)
              if [ -n "$CONFLICTED" ]; then
                echo "Resolving conflicts by accepting deletions:"
                echo "$CONFLICTED"
                echo "$CONFLICTED" | while read -r f; do
                  git rm --force "$f" 2>/dev/null || git checkout --theirs "$f" && git add "$f" 2>/dev/null || true
                done
                if git rebase --continue 2>/dev/null; then
                  echo "Rebase completed after conflict resolution"
                else
                  echo "Rebase still failing, trying merge..."
                  git rebase --abort 2>/dev/null || true

                  # Reset to our commit and try merge
                  git reset --hard HEAD
                  git fetch origin ${{ github.ref_name }}
                  if git merge origin/${{ github.ref_name }} -X ours --no-edit 2>/dev/null; then
                    echo "Merge successful"
                  else
                    # Resolve any remaining modify/delete conflicts
                    MERGE_CONFLICTS=$(git diff --name-only --diff-filter=U 2>/dev/null || true)
                    if [ -n "$MERGE_CONFLICTS" ]; then
                      echo "Resolving merge conflicts:"
                      echo "$MERGE_CONFLICTS" | while read -r f; do
                        git rm --force "$f" 2>/dev/null || git checkout --theirs "$f" && git add "$f" 2>/dev/null || true
                      done
                      git commit --no-edit 2>/dev/null || true
                    else
                      echo "Merge failed with non-file conflicts, will retry..."
                      git merge --abort 2>/dev/null || true
                      sleep $((i * 2))
                      continue
                    fi
                  fi
                fi
              else
                echo "No conflicted files found, aborting rebase..."
                git rebase --abort 2>/dev/null || true
                sleep $((i * 2))
                continue
              fi
            fi

            # Try to push
            if git push origin HEAD:${{ github.ref_name }}; then
              echo "Push successful!"
              exit 0
            else
              echo "Push failed, will retry..."
              sleep $((i * 2))
            fi
          done

          echo "All push attempts failed"
          exit 1
